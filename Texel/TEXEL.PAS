{*************************************
 *     T E X E L  Version 2.00r0     *
 * Copyright ½1994-97 by Thomas Much *
 *************************************
 *   Thomas Much, Gerwigstraže 46,   *
 * 76131 Karlsruhe, (0721) 62 28 41  *
 *        Thomas Much @ KA2          *
 * Thomas.Much@stud.uni-karlsruhe.de *
 * http://www.uni-karlsruhe.de/~uk48 *
 *************************************
 *  erstellt am:         05.10.1994  *
 *  letztes Update am:   01.12.1997  *
 *************************************}

{       | deutsch   | englisch          | franz”sisch
	------|-----------|-------------------|------------------
  Beta  | BETA      | BETA ENGLISH      | BETA FRENCH
  Final |           | ENGLISH           | FRENCH
  Demo  | BETA DEMO | BETA DEMO ENGLISH | BETA DEMO FRENCH  }

{$B+,D-,G-,I-,L-,N-,P-,Q-,R-,S-,T-,V-,X+,Z-}

{$M 182272}

program Texel;

uses

	Strings,Dos,Tos,Gem,Objects,OTypes,OProcs,
	OWindows,ODialogs,OValidat,ODB,OStdWnds;

const

	TEXELVER          =   $0200;
	TEXELDATE         = '01.12.1997';
	RELEASE           =       0;
	EXPIRE            = (18 shl 25) + (2 shl 21);
	EXPIRESTR         = '31.01.98';
	TEXELWINDCLASS    = 'TexelCalcWindow';
	BLOCKWINDCLASS    = 'BlockChangeDialog';
	TEXELEXTENSION    =   'txl';
	TEXELSCRIPTEXT    =   'tsc';
	TEXELMAGIC        =  'TEXL';
	TEXELNAME         = 'Texel';
	TEXELWINDPREFIX   = TEXELNAME+' - ';
	TEXELFILE         = 'texel';
	TEXELAPPNAME      = TEXELFILE+'.app';
	TEXELINF          = TEXELFILE+'.inf';
	TEXELUSRVAL       = TEXELFILE+'usr.val';
	TEXELUSRFRM       = TEXELFILE+'usr.frm';
	TEXELUSRDAT       = TEXELFILE+'usr.dat';
	TEXELSOUND        = TEXELFILE+'.cla';
	TEXELHISTORY      = TEXELFILE+'.his';
	TEXELPATHS        = TEXELFILE+'.pth';
	TEXELPALETTE      = TEXELFILE+'.pal';
	TEXELPRNSET       = TEXELFILE+'.prs';
	TEXELWORK         = TEXELFILE+'.wrk';
	GUIDES            = '*:\';
	GEMJING           = 'gemjing.prg';
	{$IFDEF FRENCH}
	TEXELFRM          = TEXELFILE+'_f.frm';
	TEXELDAT          = TEXELFILE+'_f.dat';
	TEXELVAL          = TEXELFILE+'_f.val';
	TEXELRSC          = TEXELFILE+'_f.rsc';
	TEXELRSC2         = TEXELFILE+'2_f.rsc';
	TEXELHELP         = TEXELFILE+'_f.hyp';
	TEXELHELPREF      = TEXELFILE+'_f.hyp'; { ... }
	TEXELDATAPATH     = 'Fichiers\';
	TEXELSCRIPTPATH   = 'Scripts\';
	{$ELSE}
	{$IFDEF ENGLISH}
	TEXELFRM          = TEXELFILE+'_e.frm';
	TEXELDAT          = TEXELFILE+'_e.dat';
	TEXELVAL          = TEXELFILE+'_e.val';
	TEXELRSC          = TEXELFILE+'_e.rsc';
	TEXELRSC2         = TEXELFILE+'2_e.rsc';
	TEXELHELP         = TEXELFILE+'_e.hyp';
	TEXELHELPREF      = TEXELFILE+'_e.hyp'; { ... }
	TEXELDATAPATH     = 'Data\';
	TEXELSCRIPTPATH   = 'Scripts\';
	{$ELSE}
	TEXELFRM          = TEXELFILE+'.frm';
	TEXELDAT          = TEXELFILE+'.dat';
	TEXELVAL          = TEXELFILE+'.val';
	TEXELRSC          = TEXELFILE+'.rsc';
	TEXELRSC2         = TEXELFILE+'2.rsc';
	TEXELHELP         = TEXELFILE+'.hyp';
	TEXELHELPREF      = TEXELFILE+'.hyp'; { ... }
	TEXELDATAPATH     = 'Daten\';
	TEXELSCRIPTPATH   = 'Skripte\';
	{$ENDIF}
	{$ENDIF}
	TEXELTEMPPATH     = 'Temp\';
	TEXELTIMER        =    2000;
	TEXELCOMPAT       =      38;
	Ctrl_Insert       =   20992;
	CtrlShift_Insert  =   21008;
	Ctrl_Return       =    7178;
	Ctrl_Help         =   25088;
	FIXRSC            =    true;
	FIX_BBONLY        =   false;
	PA_HORIZONTAL     =       0;
	PA_VERTICAL       =       1;
	PA_BLOCK          =       2;
	CELL_SELECTED     =       1;
	CELL_PROTECTED    =       2;
	CELL_HASNOTE      =       4; { ... }
	CELL_CHANGED      =      16;
	CELL_INVISIBLE    =      32; { ... }
	CELL_CALCULATED   =      64;
	CELL_USED         =     128;
	CELL_EMPTYMASK    = CELL_PROTECTED; { ... }
	GOP_ABANDON       = GOP_USERDEF;
	CTYPE_EMPTY       =       0;
	CTYPE_TEXT        =       1;
	CTYPE_FORMULA     =       2;
	CTYPE_CONST       =       3;
	CTYPE_PARSED      =      42;
	RF_COLABS         =       1;
	RF_ROWABS         =       2;
	CRF_UMBRUCH       =       1;
	TFL_TEXT2LEFT     =       1;
	TFL_TEXT2RIGHT    =       2;
	TFL_TEXTFROMLEFT  =       4;
	TFL_TEXTFROMRIGHT =       8;
	TFL_CLIP          =     128;
	TFL_OVERFLOWMASK  = TFL_TEXT2LEFT or TFL_TEXT2RIGHT or TFL_TEXTFROMLEFT or TFL_TEXTFROMRIGHT;
	TFL_LEFTMASK      = TFL_TEXT2LEFT or TFL_TEXTFROMRIGHT;
	TFL_RIGHTMASK     = TFL_TEXT2RIGHT or TFL_TEXTFROMLEFT;
	TFL_GITTERMASK    = TFL_TEXT2RIGHT or TFL_TEXTFROMRIGHT;
	TFL_LEFTBORDER    = TFL_TEXT2LEFT or TFL_TEXTFROMLEFT;
	TFL_RIGHTBORDER   = TFL_TEXT2RIGHT or TFL_TEXTFROMRIGHT;
	TA_HOR_DEFAULT    =     $03; { ... }
	TA_VER_DEFAULT    =     $30; { ... }
	TA_UNTEN          =     $00;
	TA_OBEN           =     $10;
	TA_MITTE          =     $20;
	INS_FORMULA       =       1;
	INS_VALUE         =       2;
	INS_FORMAT        =       4;
	INS_NOTE          =       8;
	INS_ALL           = INS_FORMULA or INS_VALUE or INS_FORMAT or INS_NOTE;
	INS_OP_NONE       =       0;
	INS_OP_ADD        =       1;
	INS_OP_SUB        =       2;
	INS_OP_MUL        =       3;
	INS_OP_DIV        =       4;
	CRS_NONE          =       4;
	CRS_DOWN          =       7;
	CRS_RIGHT         =       5;
	CRS_UP            =       1;
	CRS_LEFT          =       3;
	CRS_NW            =       0;
	CRS_NE            =       2;
	CRS_SW            =       6;
	CRS_SE            =       8;
	OBJ_NONE          =       0;
	OBJ_TOGGLEALL     =       1;
	OBJ_COLOFFSET     =      -1;
	OBJ_ROWOFFSET     =  -65537;
	OBJ_CSIZEOFFSET   = -131073;
	OBJ_RSIZEOFFSET   = -196609;
	DEV_PLOTTER       =       0; { GDOS-Ger„te }
	DEV_PRINTER       =       1;
	DEV_META          =       2;
	DEV_CAMERA        =       3;
	DEV_TABLET        =       4;
	DEV_MEMORY        =       5;
	DEV_FAX           =       6;
	DEV_IMG           =       7;
	MINPERCENT        =       5;
	MAXPERCENT        =     999;
	MINPAGES          =       1;
	MAXPAGESOLD       =     999;
	MAXPAGES          =    9999;
	MAXCIPHERS        =      15;
	PFMAX             =      19;
	FSEL_OPEN         =       0;
	FSEL_SAVE         =       1;
	FSEL_EMBED        =       2;
	FSEL_LOADCSV      =       7;
	FSEL_LOADDIF      =       8;
	FSEL_LOADASCII    =       9;
	FSEL_SAVE2        =      11;
	FSEL_LOADXLS      =      12;
	FSEL_LOADLDW      =      14;
	FSEL_LOAD123      =      15;
	FSEL_LOADDBF      =      16;
	FSEL_EXPORT       =      20;
	FSEL_LOADIMG      =      21;
	FSEL_LOADTEXT     =      22;
	FSEL_DIAGRAM      =      23;
	FE_OK             =       0; { Fehlermeldungen }
	FE_DIVBYZERO      =      -1;
	FE_CIRCREF        =      -2;
	FE_OPUNKNOWN      =      -3;
	FE_CELLOUTOFRANGE =      -4;
	FE_UNDEFINED      =      -5;
	FE_ERROR          =      -6;
	FE_OVERFLOW       =      -7;
	FE_EXTERN         =      -8;
	NT_ENDOFDATA      =      -1;
	NT_LIST_EMPTY     =       0;
	NT_CONST          =       1; { Operatoren }
	NT_CELL           =       2;
	NT_RANGE          =       3;
	NT_VARIABLE       =       4;
	NT_PLUS           =      10;
	NT_MINUS          =      11;
	NT_MULT           =      12;
	NT_DIV            =      13;
	NT_POWER          =      14;
	NT_NEGATE         =      15;
	NT_EQUAL          =      20;
	NT_GREATER        =      21;
	NT_LESS           =      22;
	NT_GREATEREQUAL   =      23;
	NT_LESSEQUAL      =      24;
	NT_UNEQUAL        =      25;
	NT_KLAMMER        =      30;
	NT_DEFINE         =      31; { ... }
	NT_RND            =    1000; { Funktionen }
	NT_FEHLER         =    1001;
	NT_HEUTE          =    1010;
	NT_JETZT          =    1011;
	NT_STD1           =    1012;
	NT_MIN1           =    1013;
	NT_SEK1           =    1014;
	NT_ISTZAHL        =    1100;
	NT_ISTTEXT        =    1101;
	NT_ISTLEER        =    1102;
	NT_ISTFEHLER      =    1103;
	NT_ANZAHL         =    1150;
	NT_SPALTEN        =    1151;
	NT_ZEILEN         =    1152;
	NT_ANZAHL2        =    1153;
	NT_MDET           =    1160;
	NT_SIN            =    2000;
	NT_COS            =    2001;
	NT_TAN            =    2002;
	NT_COT            =    2003;
	NT_SINH           =    2004;
	NT_COSH           =    2005;
	NT_TANH           =    2006;
	NT_ARCSIN         =    2007;
	NT_ARCCOS         =    2008;
	NT_ARCTAN         =    2009;
	NT_ARCCOT         =    2010;
	NT_ARSINH         =    2011;
	NT_ARCOSH         =    2012;
	NT_ARTANH         =    2013;
	NT_ARCOTH         =    2014;
	NT_SEC            =    2015;
	NT_COSEC          =    2016;
	NT_COTH           =    2017;
	NT_GRAD           =    2090;
	NT_RAD            =    2091;
	NT_SGN            =    2100;
	NT_ABS            =    2101;
	NT_FRAC           =    2102;
	NT_INT            =    2103;
	NT_ROUND          =    2104;
	NT_TRUNC          =    2105;
	NT_GERADE         =    2106;
	NT_UNGERADE       =    2107;
	NT_BNICHT         =    2108;
	NT_KEHRWERT       =    2109;
	NT_EXP            =    2150;
	NT_LN             =    2151;
	NT_LOG10          =    2152;
	NT_SQRT           =    2153;
	NT_FAK            =    2154;
	NT_NICHT          =    2155;
	NT_LD             =    2156;
	NT_SQR            =    2157;
	NT_STDNORMVERT    =    2200;
	NT_BALMER         =    2250;
	NT_STUNDE         =    2260;
	NT_MINUTE         =    2261;
	NT_SEKUNDE        =    2262;
	NT_JAHR           =    2263;
	NT_MONAT          =    2264;
	NT_TAG            =    2265;
	NT_OSTERN         =    2266;
	NT_TAGE           =    2267;
	NT_SCHALTJAHR     =    2268;
	NT_STUNDEN        =    2269;
	NT_LOG            =    2300;
	NT_WOCHENTAG      =    2310;
	NT_EXPVERT        =    2400;
	NT_RANDOM         =    2401;
	NT_ROOT           =    2402;
	NT_ARCTAN2        =    2403;
	NT_MOD            =    2404;
	NT_INTDIV         =    2405;
	NT_BSCHIEBL       =    2410;
	NT_BSCHIEBR       =    2411;
	NT_SUMME          =    5000; { ab hier fn's mit bel. Parametern! }
	NT_PRODUKT        =    5001;
	NT_MIN            =    5002;
	NT_MAX            =    5003;
	NT_UND            =    5004;
	NT_ODER           =    5005;
	NT_BUND           =    5010;
	NT_BODER          =    5011;
	NT_BEOR           =    5012;
	NT_SCRIPTNO       =    5020;
	NT_MITTEL         =    5100;
	NT_GEOMITTEL      =    5101;
	NT_HARMITTEL      =    5102;
	NT_QUADMITTEL     =    5103;
	NT_VARIANZ        =    5110;
	NT_VARIANZN       =    5111;
	NT_STDABW         =    5112;
	NT_STDABWN        =    5113;
	NT_MITTELABW      =    5114;
	NT_SUMQUADABW     =    5115;
	NT_MEDIAN         =    5116;
	NT_QUARTILUNTEN   =    5117;
	NT_QUARTILOBEN    =    5118;
	NT_QUARTILSABST   =    5119;
	NT_SPANNWEITE     =    5120;
	NT_GLEICHVERT     =    5200;
	NT_NORMVERT       =    5201;
	NT_DATUM          =    5210;
	NT_ZEIT           =    5211;
	NT_LIA            =    5250;
	NT_ADA            =    5251;
	NT_GDA            =    5252;
	NT_DIGA           =    5253;
	NT_DDA            =    5254;
	NT_RMZ            =    5255;
	NT_WENN           =    5300;
	NT_WAHL           =    5301;
	NT_QUANTIL        =    5302;
	{ von 9000..9999 (-1000..-1) externe Texel-Funktionen }
	{ von 10000..32000 (0..22000) benutzerdefinierte Funktionen }
	NT_EXTMIN         =    9000;
	NT_EXTMAX         =   32000;
	{$IFDEF FRENCH}
	{$I texel_f.i}
	{$I texel2_f.i}
	{$ELSE}
	{$IFDEF ENGLISH}
	{$I texel_e.i}
	{$I texel2_e.i}
	{$ELSE}
	{$I texel.i}
	{$I texel2.i}
	{$ENDIF}
	{$ENDIF}

	FF_SYSTEM         =    $0001; { Fontselektor-Flags }
	FF_MONOSPACED     =    $0002;
	FF_PROPORTIONAL   =    $0004;
	FF_BITMAP         =    $0008;
	FF_SPD            =    $0010;
	FF_TTF            =    $0020;
	FF_PFB            =    $0040;
	FF_CFN            =    $0080;
	FF_VECTOR         = FF_SPD or FF_TTF or FF_PFB or FF_CFN;
	FF_ALL            = FF_MONOSPACED or FF_PROPORTIONAL or FF_VECTOR or FF_BITMAP;
	FF_CHANGED        =    $8000;
  FF_VEKTOR         = FF_VECTOR;
  FF_MONO           = FF_MONOSPACED;
  FF_PROP           = FF_PROPORTIONAL;

	CC_WINDOW         =    $0001;
	CC_APPMODAL       =    $0002;
	CC_FIX31          =    $0004;
	CC_FAKESTYLE      =    $0008;
	CC_CLOSER         =    $0010;
	CC_NOSIZE         =    $0100;
	CC_NOCOLOR        =    $0200;
	CC_NOATTR         =    $0400;
	CC_NOWIDTH        =    $0800;
	CC_NOKERN         =    $1000;
	CC_NOSKEW         =    $2000;
	CC_DFLTSIZE       =   $10000;
	CC_INVSTYLE       =   $20000;

	XF_SIZE           =    $0001;
	XF_COLOR          =    $0002;
	XF_ATTR           =    $0004;
	XF_WIDTH          =    $0008;
	XF_KERN           =    $0010;
	XF_SKEW           =    $0020;
	XF_FIX31          =    $0100;
	XF_POPUP          =    $0200;
	XF_DRAGDROP       =    $0400;

	xFS_PARERROR      =       -9;
	xFS_LOADERROR     =       -8;
	xFS_RES_ERROR     =       -7;
	xFS_NO_HANDLE     =       -6;
	xFS_NO_WINDOW     =       -5;
	xFS_NO_FONTS      =       -4;
	xFS_NO_FONTSIZE   =       -3;
	xFS_ACTIVE        =       -2;
	xFS_ERROR         =       -1;
	xFS_STOP          =        0;
	xFS_OK            =        1;
	xFS_HELP          =        2;
	xFS_EVENT         =        3;
	xFS_POPUP         =        4;

	THA_LEFT          =        0;
	THA_CENTER        =        1;
	THA_RIGHT         =        2;

	TVA_BOTTOM        =        0;
	TVA_CENTER        =        1;
	TVA_TOP           =        2;

	V_CHAR_IND        =       -1;
	V_CHAR_ASC        =       -2;
	V_CHAR_PRT        =       -3;
	V_CHAR_ALL        =       -4;

	MAP_DIRECT        =        0;
	MAP_ASCII         =        1;

	PDLG_3D            =       1;
	PDLG_CANCEL        =       1;
	PDLG_OK            =       2;
	PDLG_PREFS         =   $0000;
	PDLG_PRINT         =   $0001;
	PDLG_ALWAYS_COPIES =   $0010;
	PDLG_ALWAYS_ORIENT =   $0020;
	PDLG_ALWAYS_SCALE  =   $0040;

	FNTS_BTMP         =        1;
	FNTS_OUTL         =        2;
	FNTS_MONO         =        4;
	FNTS_PROP         =        8;
	FNTS_ALL          = FNTS_BTMP or FNTS_OUTL or FNTS_MONO or FNTS_PROP;

	FNTS_3D           =        1;

	FNTS_SNAME        =    $0001;
	FNTS_SSTYLE       =    $0002;
	FNTS_SSIZE        =    $0004;
	FNTS_SRATIO       =    $0008;

	FNTS_CHNAME       =    $0100;
	FNTS_CHSTYLE      =    $0200;
	FNTS_CHSIZE       =    $0400;
	FNTS_CHRATIO      =    $0800;
	FNTS_RATIO        =    $1000;
	FNTS_BSET         =    $2000;
	FNTS_BMARK        =    $4000;

	FNTS_CANCEL       =        1;
	FNTS_OK           =        2;
	FNTS_SET          =        3;
	FNTS_MARK         =        4;
	FNTS_OPT          =        5;

	STIC_DEVICE       =        0;
	STIC_BIG          =        1;
	STIC_SMALL        =        2;

type

	PPRN_SETTINGS = ^PRN_SETTINGS;
	PRN_SETTINGS  = record
		magic       : TCookieID;
		len,
		format,
		reserved,
		page_flags  : longint;
		first_page,
		last_page,
		no_copies,
		orientation : integer;
		scale       : longint;
		driver_id,
		driver_type : integer;
		driver_mode,
		reserved1,
		reserved2,
		printer_id,
		mode_id     : longint;
		mode_hdpi,
		mode_vdpi   : integer;
		quality_id,
		color_mode,
		plane_flags,
		dither_mode,
		dither_value,
		size_id,
		type_id,
		input_id,
		output_id,
		contrast,
		brightness,
		reserved3,
		reserved4,
		reserved5,
		reserved6,
		reserved7,
		reserved8   : longint;
		device      : array [0..127] of char;
		mac_settings: array [0..119] of byte
	end;
	
	PPDLG_SUB = ^PDLG_SUB;
	PDLG_SUB  = record
		next        : PPDLG_SUB;
		length,
		format,
		reserved    : longint;
		drivers     : pointer;
		option_flags,
		sub_id      : integer;
		dialog      : pointer;
		tree        : PObj;
		index_offset,
		reserved1   : integer;
		reserved2,
		reserved3,
		reserved4   : longint;
		init_dlg    : function(d1,d2: pointer; d3,d4,d5: longint; settings: PPRN_SETTINGS; sub: PPDLG_SUB): longint;
		do_dlg      : function(d1,d2: pointer; d3,d4,d5: longint; settings: PPRN_SETTINGS; sub: PPDLG_SUB; exit_obj: integer): longint;
		reset_dlg   : function(d1,d2: pointer; d3,d4,d5: longint; settings: PPRN_SETTINGS; sub: PPDLG_SUB): longint;
		reserved5   : longint;
		sub_icon    : PObj;
		sub_tree    : PTree;
		reserved6,
		reserved7,
		private1,
		private2,
		private3,
		private4    : longint
	end;

	ITAB_REF = pointer;

	COLOR_RGB = record
		reserved,
		red,
		green,
		blue    : word
	end;

	COLOR_CMYK = record
		cyan,
		magenta,
		yellow,
		black  : word
	end;

	COLOR_ENTRY  = record
		case boolean of
		false: (rgb : COLOR_RGB);
		true:  (cmyk: COLOR_CMYK)
	end;

	CTAB_REF  = ^COLOR_TAB;
	COLOR_TAB = record
		magic,
		length,
		format,
		reserved,
		map_id,
		color_space,
		flags,
		no_colors,
		reserved1,
		reserved2,
		reserved3,
		reserved4  : longint;
		colors     : array [0..255] of COLOR_ENTRY
	end;

	PBITMAPPtr = ^PBITMAP;
	PBITMAP    = record
		magic,
		length,
		format,
		reserved : longint;
		addr     : pointer;
		width,
		bits,
		px_format,
		xmin,
		ymin,
		xmax,
		ymax     : longint;
		ctab     : CTAB_REF;
		itab     : ITAB_REF;
		reserved0,
		reserved1: longint
	end;

	UFSLPtr = ^UFSL;
	UFSL    = record
		id           : longint;
		version      : word;
		dialtyp      : integer;
		font_selinit : function(d1,d2: pointer; d3,d4,d5: longint): integer;
		font_selinput: function(d1,d2: pointer; d3,d4,d5: longint; vdihandle,fanz: integer; text: PChar; ftype: integer; var fretid,fretsize: integer): integer;
		helpbutton,
		helpfunc     : longint
	end;

	FSIZE = record
		case boolean of
		false: (size  : integer);
		true:  (size31: fix31)
	end;

	FONTINFOPtr = ^FONTINFO;
	FONTINFO    = record
		fontid,
		fonttype  : integer;
		fontname  : PChar;
		fontsize,
		fontwidth : FSIZE;
		trackkern,
		pairkern  : byte;
		fontattr,
		fontskew,
		fontcol,
		backcol,
		halign,
		valign,
		rotation,
		validtype : integer;
		validchars: PChar
	end;

	xFSL_PARPtr = ^xFSL_PAR;
	xFSL_PAR    = record
		par_size,
		pfi_size   : integer;
		control    : longint;
		headline,
		example,
		helptext   : PChar;
		font       : FONTINFOPtr;
		fontflags  : word;
		poptext    : PChar;
		num_entries,
		sel_entry  : integer;
		popup      : pointer;
		helpinfo   : PChar
	end;

	xFSLPtr = ^xFSL;
	xFSL    = record
		id        : TCookieID;
		revision  : word;
		product   : TCookieID;
		version   : word;
		xfsl_input: function(d1,d2: pointer; d3,d4,d5: longint; vdihandle: integer; fontflags: word; headline: PChar; var fid,fsize: integer): integer;
		xfsl_init : function(d1,d2: pointer; d3,d4,d5: longint; vdihandle: integer; xpar: xFSL_PARPtr): integer;
		xfsl_event: function(d1,d2: pointer; d3,d4,d5: longint; xfsl_handle: integer; event: EVENTPtr): integer;
		xfsl_exit : procedure(d1,d2: pointer; d3,d4,d5: longint; xfsl_handle: integer);
		xfsl_info : function(d1,d2: pointer; d3,d4,d5: longint): longint;
	end;
	
	PSTIC = ^TSTIC;
	TSTIC = record
		version  : integer;
		magic    : TCookieID;
		str_icon : function(d1,d2: pointer; d3,d4,d5: longint; s: PChar; tree: integer): PObj;
		ext_icon : procedure(d1,d2: pointer; d3,d4,d5: longint; id: integer; big: PObj; small: PObj; flag: integer);
		id_icon  : function(d1,d2: pointer; d3,d4,d5: longint; id, tree: integer): PObj;
		top_icon : function(d1,d2: pointer; d3,d4,d5: longint; tree: integer): PObj;
		menu_icon: function(d1,d2: pointer; d3,d4,d5: longint; tree: integer): PObj;
	end;

	PIMGHeader = ^TIMGHeader;
	TIMGHeader = record
		version,
		headlen,
		planes,
		pat_run,
		pix_width,
		pix_height,
		sl_width,
		sl_height : integer
	end;

	PNVDIStruct = ^TNVDIStruct;
	TNVDIStruct = record
		version,
		datum  : word
	end;

	PNumber = ^TNumber;
	TNumber = real;

	PCalcWindow = ^TCalcWindow;
	PNode       = ^TNode;

	PLGRECT = ^LGRECT;
	LGRECT  = record
		case boolean of
			false: (X,Y,W,H,X1,Y1,X2,Y2: longint);
			true:  (A1,A2              : array [0..3] of longint)
	end;
	
	PLRECT = ^LRECT;
	LRECT  = record
		x,y,w,h: longint
	end;

	PTAG = ^TTAG;
	TTAG = record
		tag_id   : TCookieID;
		tag_len,
		tag_flags: longint
	end;

	TCursor = record
		Block   : boolean;
		OldRow,
		OldCol,
		Row,
		Col,
		RowStart,
		ColStart,
		RowEnd,
		ColEnd  : integer
	end;
	
	POldTxtVal = ^TOldTxtVal;
	TOldTxtVal = record
		oldfont,
		oldsize,
		oldtcolor,
		oldeffects,
		oldrotat,
		oldskew,
    brd1w,
    brd2w,
    brd3w,
    brd1h,
    brd2h,
    brd3h     : integer;
    gitter    : boolean
	end;

	PTxtVal = ^TTxtVal;
	TTxtVal = record
		Font,
		Size,
		Rotat,
		Skew   : integer;
		Color,
		Effects,
		Align,
		Flags  : byte
	end;

	PConst = ^TConst;
	TConst = record
		Value : TNumber;
		Txt   : PString;
		FPts  : byte
	end;

	PFormula = ^TFormula;
	TFormula = record
		Value : TNumber;
		Func  : PNode;
		VarDef: PString;
		FPts  : byte;
		Error : shortint
	end;

	PCombiData = ^TCombiData;
	TCombiData = record
		case byte of
			0: (Value  : longint);
			1: (Txt    : PString);
			2: (Konst  : PConst);
			3: (Formula: PFormula)
	end;

	PBorders = ^TBorders;
	TBorders = record
		case byte of
			0: (Left,
			    Top,
			    Right,
			    Bottom,
			    Hor,
			    Vert  : byte);
			1: (Val1: integer;
			    Val2: longint)
	end;

	PCell = ^TCell;
	TCell = record
		Data    : TCombiData;
		Flags,
		Typ,
		Color,
		Style,
		Interior,
		Resvd   : byte;
		Format  : integer;
		Border  : TBorders;
		TxtVal  : TTxtVal
	end;

	PCombiNode = ^TCombiNode;
	TCombiNode = record
		case byte of
			0: (Node  : PNode);
			1: (RowRef,
			    ColRef: integer);
			2: (Txt   : PString);
			3: (List  : PItemList);
			4: (Flg   : integer);
			5: (All   : longint)
	end;

	TNode = record
		Typ  : integer;
		Left,
		Right: TCombiNode;
		case byte of
			0: (Num    : PNumber);
			1: (RowRef,
			    ColRef : integer);
			2: (Count  : longint);
			3: (Varb   : PString);
			4: (Ref1Flg,
			    Ref2Flg: integer);
			5: (All    : longint)
	end;

	PDiagrammBuf = ^TDiagrammBuf;
	TDiagrammBuf = record
		rb1,
		rb2,
		rb3,
		rb4,
		rb5,
		typLinie,
		typBalken,
		typKreis,
		Farbe,
		Absolut,
		xyLinear,
		xyFirst,
		xyAlternate,
		xyLine,
		xyPt,
		xyLinept,
		Stapeln,
		DreiD,
		Neben,
		stilLinie,
		stilPunkt  : integer;
		Titel      : string[41];
		Legende,
		Border,
		nRow,
		nColumn,
		Font,
		Size,
		dRows,
		dColumns,
		Ticks      : integer;
		numTicks   : string[3];
		alName     : string[41];
		alTicks    : integer;
		alNum      : string[3];
		alMin,
		alMax      : string[13];
		auName     : string[41];
		auTicks    : integer;
		auNum      : string[3];
		auMin,
		auMax      : string[13];
		szWidth,
		szHeight   : string[7];
		objFilename: string
	end;
	
	PSortBuf = ^TSortBuf;
	TSortBuf = record
		Pop1,
		Up1,
		Down1,
		Pop2,
		Up2,
		Down2,
		Pop3,
		Up3,
		Down3,
		Columns,
		Rows,
		Ins,
		Pre,
		Post,
		Chars,
		EmptyPre,
		EmptyPost,
		Lexikal,
		Absolut,
		Attribute: integer
	end;

	PFindBuf = ^TFindBuf;
	TFindBuf = record
		search  : string[45];
		rows,
		columns,
		cse,
		complete,
		formula,
		value,
		txt,
		iform,
		ival,
		vor,
		zurueck,
		resvd   : integer
	end;

	PReplaceBuf = ^TReplaceBuf;
	TReplaceBuf = record
		search,
		replace : string[45];
		rows,
		columns,
		cse,
		complete,
		formula,
		value,
		txt,
		vor,
		zurueck,
		resvd   : integer
	end;

	PInfoBuf = ^TInfoBuf;
	TInfoBuf = record
		Autor,
		Stichwort,
		Rem1,
		Rem2,
		Rem3,
		Rem4     : string[51];
		Encrypt,
		Resvd    : integer;
		Created,
		Last,
		Resvd0   : longint;
		Used,
		Printed,
		Version,
		Release  : word
	end;

	PExportAscBuf = ^TExportAscBuf;
	TExportAscBuf = record
		hor,
		vert   : integer;
		rctxt  : string[21];
		rcval  : integer;
		celltxt: string[21];
		cellval: integer;
		texttxt: string[5];
		textval,
		quote,
		numbers,
		formula,
		value  : integer
	end;

	PImportAscBuf = ^TImportAscBuf;
	TImportAscBuf = record
		hor,
		vert   : integer;
		rctxt  : string[21];
		rcval  : integer;
		celltxt: string[21];
		cellval: integer;
		texttxt: string[5];
		textval,
		quote,
		numbers,
		filter : integer
	end;

	PZielBuf = ^TZielBuf;
	TZielBuf = record
		zzelle,
		vzelle     : string[7];
		wert       : string[15];
		iterationen: string[7]
	end;

	PExportBuf = ^TExportBuf;
	TExportBuf = record
		exporttype,
		clipboard,
		bereich,
		htmldoctype,
		htmlsavedt,
		htmlcolor,
		csvformula,
		csvvalue,
		difformula,
		difvalue,
		difstandard,
		difexcel   : integer;
		ascii      : TExportAscBuf;
		difformat,
		csvformat,
		asciiformat,
		htmlembed,
		filter     : integer
	end;

	PProgressWindow = ^TProgressWindow;
	TProgressWindow = object(TDialog)
		count,
		maxanz: longint;
		pc1,
		pc2   : PControl;
		constructor Init(AMax: longint; Titel,Datei: string);
		function GetStyle: integer; virtual;
		procedure SetupWindow; virtual;
		procedure MakeWindow; virtual;
		procedure Progress(anz: longint);
		procedure SetMax(AMax: longint);
	end;

	PHyperDialog = ^THyperDialog;
	THyperDialog = object(TDialog)
		ddtext     : PString;
		ddfiles    : PChar;
		hdIconTitle,
		HyperHelp  : string;
		constructor Init(AParent: PWindow; ATitle,HypHelp,hdTitle: string; Indx: integer);
		function Help: boolean; virtual;
		function WMKeyDown(Stat,Key: integer): boolean; virtual;
		function DDReadArgs(dSize: longint; PipeHnd,OrgID,mX,mY,KStat: integer): boolean; virtual;
		function DDHeaderReply(dType,dName,fName: string; dSize: longint; OrgID,mX,mY,KStat: integer): byte; virtual;
		function DDReadData(dType,dName,fName: string; dSize: longint; PipeHnd,OrgID,mX,mY,KStat: integer): boolean; virtual;
		procedure DDFinished(OrgID,mX,mY,KStat: integer); virtual;
		function GetIconTitle: string; virtual;
	end;

	PBlockChangeDialog = ^TBlockChangeDialog;
	TBlockChangeDialog = object(THyperDialog)
		function GetClassName: string; virtual;
		procedure BlockChanged(blk: string); virtual;
	end;

	PPrintPercBox = ^TPrintPercBox;
	TPrintPercBox = object(TComboBox)
		procedure SetValue(Sel: integer); virtual;
	end;

	PSave = ^TSave;
	TSave = object(TKeyMenu)
		procedure Work; virtual;
		function Save(fname: string): boolean;
	end;

	PSaveAs = ^TSaveAs;
	TSaveAs = object(TKeyMenu)
		procedure Work; virtual;
		procedure SaveAs(const fname: string; flag: integer);
	end;

	PAbandon = ^TAbandon;
	TAbandon = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PASCIIImportDialog = ^TASCIIImportDialog;
	TASCIIImportDialog = object(THyperDialog)
		pcb: PComboBox;
		function OK: boolean; virtual;
	end;

	PImport = ^ TImport;

	PGDBCDialog = ^TGDBCDialog;
	TGDBCDialog = object(THyperDialog)
		st     : PStatic;
		pb0,
		pb1,pb2,
		pb3,pb4: PButton;
		lb1,lb2: PListBox;
		import : PImport;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure CheckButtons;
		procedure LoadFields(lb: PListBox);
	end;

	PImportBox = ^TImportBox;
	TImportBox = object(TComboBox)
		function CreatePopup: boolean; virtual;
	end;

	PImportRowColBox = ^TImportRowColBox;
	TImportRowColBox = object(TImportBox)
		procedure SetValue(Sel: integer); virtual;
	end;

	PImportButton = ^TImportButton;
	TImportButton = object(TRadioButton)
		pircb: PImportRowColBox;
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
	end;

	PImportCellBox = ^TImportCellBox;
	TImportCellBox = object(TImportBox)
		procedure SetValue(Sel: integer); virtual;
	end;

	PImportTextBox = ^TImportTextBox;
	TImportTextBox = object(TImportBox)
		procedure SetValue(Sel: integer); virtual;
	end;

	TImport = object(TSubMenu)
		st      : PStatic;
		ascii   : PASCIIImportDialog;
		gdbc    : PGDBCDialog;
		quelle,
		filename: string;
		procedure HandleMenu(Indx: integer); virtual;
		procedure LoadGDBC(fname: string);
		procedure ImportDBF(fname: string; fields: PStringCollection);
		procedure Load123(fname: string);
		procedure LoadXLS(fname: string);
		procedure LoadLDW(fname: string);
		procedure LoadASCII(fname: string);
		procedure ImportASCII(fname,rctrenn,celltrenn,tquote: string; numtrenn: char; hor,quote: boolean; flt: integer);
		procedure LoadCSV(fname: string);
		procedure LoadDIF(fname: string);
		procedure ImportFromClipboard;
	end;

	PAbruf = ^TAbruf;
	TAbruf = object(TSubMenu)
		cpw,
		cph,
		Count: integer;
		Dirty: boolean;
		Files: array [0..9] of PString;
		constructor Init(AParent: PEventObject; mNum,popTree,popIndex: integer);
		procedure HandleMenu(Indx: integer); virtual;
		procedure Add(fname: string; dodhst: boolean);
	end;

	PExportCheckBox = ^TExportCheckBox;
	TExportCheckBox = object(TCheckBox)
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
	end;

	PExportBox = ^TExportBox;
	TExportBox = object(TComboBox)
		procedure Work; virtual;
	end;

	PExportDialog = ^TExportDialog;
	TExportDialog = object(TBlockChangeDialog)
		bedt,
		st  : PStatic;
		pb1,
		pb2,
		pb3 : PButton;
		pcb : PExportBox;
		pecb: PExportCheckBox;
		pg0,
		pg1,
		pg2,
		pg3,
		pg4 : PGroupBox;
		procedure BlockChanged(blk: string); virtual;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure CheckButtons;
	end;

	PExport = ^TExport;
	TExport = object(TKeyMenu)
		p       : PCalcWindow;
		exflt,
		cmax,
		rmax,
		hdl     : integer;
		bufsize,
		bufcnt,
		res     : longint;
		buf     : PByteArray;
		filename: string;
		lend    : string[2];
		usepkt,
		werror  : boolean;
		function Export(const texbuf: TExportBuf; const fname: string): boolean;
		procedure SetFile(fname: string);
		procedure Work; virtual;
		function InitFile(var fname: string; const texbuf: TExportBuf): boolean;
		procedure ExitFile(bits: word; fname: string; const texbuf: TExportBuf);
		function bwrite(var buffer; count: longint): boolean;
		function writeline(s: string): boolean;
		function writes(s: string): boolean;
		procedure Save123(fname: string; const texbuf: TExportBuf);
		procedure SaveXLS(fname: string; const texbuf: TExportBuf);
		procedure SaveDIF(fname: string; const texbuf: TExportBuf);
		procedure SaveSYLK(fname: string; const texbuf: TExportBuf);
		procedure SaveCSV(fname: string; const texbuf: TExportBuf);
		procedure SaveASCII(fname: string; const texbuf: TExportBuf);
		procedure SaveText(fname: string; const texbuf: TExportBuf);
		procedure SaveLATEX(fname: string; const texbuf: TExportBuf);
		procedure SaveHTML(fname: string; const texbuf: TExportBuf);
		procedure SaveUDO(fname: string; const texbuf: TExportBuf);
	end;

	PDateButton = ^TDateButton;
	TDateButton = object(TRadioButton)
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
	end;

	PTrendButton = ^TTrendButton;
	TTrendButton = object(TCheckBox)
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
	end;

	PFillBuffer = ^TFillBuffer;
	TFillBuffer = record
		rows,
		columns,
		arithm,
		geom,
		date,
		cpy,
		trend,
		day,
		wday,
		month,
		year   : integer;
		stepval,
		endval : string[13]
	end;

	PFillDialog = ^TFillDialog;
	TFillDialog = object(TBlockChangeDialog)
		bedt: PStatic;
		ed1,
		ed2 : PEdit;
		rb5,
		rb6,
		rb7,
		rb8 : PRadioButton;
		rb1,
		rb2,
		rb3,
		rb4 : PDateButton;
		ptb : PTrendButton;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
	end;

	PFill = ^ TFill;
	TFill = object(TSubMenu)
		reihe: PFillDialog;
		procedure HandleMenu(Indx: integer); virtual;
	end;

	PFormCell = ^ TFormCell;
	TFormCell = object(TSubMenu)
		procedure HandleMenu(Indx: integer); virtual;
	end;

	PFormRow = ^ TFormRow;
	TFormRow = object(TSubMenu)
		procedure HandleMenu(Indx: integer); virtual;
	end;

	PFormCol = ^ TFormCol;
	TFormCol = object(TSubMenu)
		procedure HandleMenu(Indx: integer); virtual;
	end;

	PClear = ^ TClear;
	TClear = object(TSubMenu)
		procedure HandleMenu(Indx: integer); virtual;
	end;
	
	PObjects = ^TObjects;
	TObjects = object(TSubMenu)
		procedure HandleMenu(Indx: integer); virtual;
	end;

	PClearCellDialog = ^TClearCellDialog;
	TClearCellDialog = object(TBlockChangeDialog)
		bedt: PStatic;
		rb1,
		rb2,
		rb3,
		rb4,
		rb5 : PRadioButton;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
		procedure CheckButtons;
	end;

	PClearCell = ^TClearCell;
	TClearCell = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PInsButton = ^TInsButton;
	TInsButton = object(TRadioButton)
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
	end;

	PInsertDialog = ^TInsertDialog;
	TInsertDialog = object(TBlockChangeDialog)
		bedt: PStatic;
		rb,
		rb0 : PInsButton;
		rb1,
		rb2,
		rb3,
		rb4,
		rb5 : PRadioButton;
		cb  : PCheckBox;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
		procedure CheckButtons;
		function OK: boolean; virtual;
	end;

	PInsert = ^TInsert;
	TInsert = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PInsertCellDialog = ^TInsertCellDialog;
	TInsertCellDialog = object(TBlockChangeDialog)
		bedt: PStatic;
		pb  : PButton;
		rb2,
		rb3,
		rb4,
		rb5 : PRadioButton;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
		procedure CheckButtons;
	end;

	PInsertCell = ^TInsertCell;
	TInsertCell = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PInsertRows = ^TInsertRows;
	TInsertRows = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PInsertColumns = ^TInsertColumns;
	TInsertColumns = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PFormCategoryBox = ^TFormCategoryBox;

	PCatFormBox = ^TCatFormBox;
	TCatFormBox = object(TListBox)
		pfcb: PFormCategoryBox;
		procedure Work; virtual;
	end;

	POLEType = ^TOLEType;
	TOLEType = record
		Descr: PString;
		Ext  : string[4]
	end;

	POLECollection = ^TOLECollection;
	TOLECollection = object(TStringCollection)
		function KeyOf(Item: pointer): pointer; virtual;
		procedure FreeItem(Item: pointer); virtual;
	end;

	PFormatCollection = ^TFormatCollection;
	TFormatCollection = object(TStringCollection)
		function KeyOf(Item: pointer): pointer; virtual;
		procedure FreeItem(Item: pointer); virtual;
	end;

	TFormCategoryBox = object(TListBox)
		fbox   : PCatFormBox;
		flist  : PFormatCollection;
		preview: PStatic;
		format : PEdit;
		chgbtn,
		delbtn,
		okbtn,
		setbtn : PButton;
		procedure Work; virtual;
	end;

	PCategoryBox = ^TCategoryBox;

	PCatFuncBox = ^TCatFuncBox;
	TCatFuncBox = object(TListBox)
		pcb: PCategoryBox;
		procedure Work; virtual;
	end;

	TCategoryBox = object(TListBox)
		fbox  : PCatFuncBox;
		flist : PStringCollection;
		hlpbtn: PButton;
		procedure Work; virtual;
	end;

	PFunktionDialog = ^TFunktionDialog;
	TFunktionDialog = object(TDialog)
		descr1,
		descr2: PStatic;
		fbox  : PCatFuncBox;
		function Help: boolean; virtual;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function GetIconTitle: string; virtual;
	end;

	PFunktion = ^TFunktion;
	TFunktion = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PRahmenBox = ^TRahmenBox;
	TRahmenBox = object(TComboBox)
		function TestIndex(AnIndx: integer): boolean; virtual;
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
		procedure SetValue(Sel: integer); virtual;
	end;

	PDiagrammBox = ^TDiagrammBox;
	TDiagrammBox = object(TRahmenBox)
		procedure SetValue(Sel: integer); virtual;
	end;

	PDiagrammRadio = ^TDiagrammRadio;
	TDiagrammRadio = object(TRadioButton)
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
	end;
	
	PDiagrammDialog = ^TDiagrammDialog;
	TDiagrammDialog = object(TBlockChangeDialog)
		ofname,
		bedt    : PStatic;
		pb1     : PButton;
		ed1     : PEdit;
		obic    : PObj;
		tc,
		pc1,
		pc2,
		pc3     : PControl;
		gb1,
		gb2,
		gb3,
		gb4,
		gb5     : PGroupBox;
		cb1     : PCheckBox;
		rbt1,
		rbt2,
		rbt3,
		rb1,
		rb2,
		rb3,
		rb4,
		rb5     : PDiagrammRadio;
		pdb1,
		pdb2    : PDiagrammBox;
		obicspec: longint;
		aendern : integer;
		destructor Done; virtual;
		function CreateDiagram(tadname: string; emb: boolean): boolean;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
		procedure CheckButtons;
	end;
	
	PDiagram = ^TDiagram;
	TDiagram = object(TKeyMenu)
		procedure Work; virtual;
		procedure SetFile(fname: string);
	end;

	POLEDialog = ^TOLEDialog;
	TOLEDialog = object(THyperDialog)
		trnsbuf: integer;
		plb    : PListBox;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure EndDlg(Indx: integer; DblClick: boolean); virtual;
		procedure Embed;
	end;
	
	POLEObject = ^TOLEObject;
	TOLEObject = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PUmbruch = ^TUmbruch;	
	TUmbruch = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PGrafik = ^TGrafik;
	TGrafik = object(TKeyMenu)
		procedure Work; virtual;
		procedure Load(fname: string);
	end;

	PTextObj = ^TTextObj;
	TTextObj = object(TKeyMenu)
		procedure Work; virtual;
		procedure Load(fname: string);
	end;

	PCellProtect = ^TCellProtect;
	TCellProtect = object(TMenu)
		procedure Work; virtual;
	end;

	PCellUnprotect = ^TCellUnprotect;
	TCellUnprotect = object(TMenu)
		procedure Work; virtual;
	end;

	PPrint = ^TPrint;
	TPrint = object(TKeyMenu)
		st0 : PStatic;
    ppcb: PPrintPercBox;
		procedure Work; virtual;
		procedure Display(def: integer);
		function IsAvailable(open: boolean): boolean;
		function GetDevice: integer;
		function GetPaperSize: integer;
		procedure GetDriverNames(num,hdl: integer; var txt,dummy: string);
		function PrintSheet(num: integer): boolean;
	end;
	
	PPaper = ^TPaper;
	TPaper = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PPrintBuffer = ^TPrintBuffer;
	TPrintBuffer = record
		sheet,
		feed     : integer;
		copies,
		percent  : string[3];
		prcindx,
		driver,
		device,
		sw,
		pblock,
		alles,
		block,
		papier   : integer;
		von,
		bis      : string[3]
	end;

	PFormSheet = ^TFormSheet;
	TFormSheet = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PPreviewBox = ^TPreviewBox;
	TPreviewBox = object(TCheckBox)
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
	end;

	PPreviewDialog = ^TPreviewDialog;
	TPreviewDialog = object(THyperDialog)
		scale,
		pvscale,
		prcfak,
		mmkopf,
		mmfuss,
		fontfak,
		xmm100fak,
		ymm100fak,
		xmmfak,
		ymmfak   : real;
		colors,
		tw,th,
		rs,cs,
		re,ce,
		pagew,
		pageh,
		lcw,trh,
		cwidth,
		cheight,
		bwidth,
		bheight,
		wwidth,
		nwidth,
		xoffs,
		yoffs,
		xoffs2,
		yoffs2,
		rsc,csc,
		rec,cec,
		drvnum,
		devW,
		devH,
		pagenum,
		pages,
		pagex,
		pagey,
		pmaxx,
		pmaxy    : integer;
		XPixOffs,
		YPixOffs,
		printtime: longint;
		srect    : GRECT;
		st       : PStatic;
		pb1,
		pb2,
		pb3,
		pb4      : PButton;
		cb       : PPreviewBox;
		colfx,
		pvok,
		Speedo   : boolean;
	  ewrkout  : workout_ARRAY;
		procedure GetWindowClass(var AWndClass: TWndClass); virtual;
		function GetStyle: integer; virtual;
		function GetVDIHandle: integer; virtual;
		procedure GetWorkMax(var maxX,maxY: integer); virtual;
		procedure SetupSize; virtual;
		procedure SetupVDI; virtual;
		procedure SetupWindow; virtual;
		procedure Paint(var PaintInfo: TPaintStruct); virtual;
		function WMKeyDown(Stat,Key: integer): boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure ScanDriver(draw,ForceOpen: boolean);
		procedure Update(ForceOpen: boolean);
		procedure Shrink2Fit;
		procedure CheckButtons;
		function GetColWidth(num: integer): integer;
		function GetRowHeight(num: integer): integer;
		procedure SetFont(indx,sze: integer);
	end;

	PPreview = ^TPreview;
	TPreview = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PCalculate = ^TCalculate;
	TCalculate = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PInfoDialog = ^TInfoDialog;
	TInfoDialog = object(THyperDialog)
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
	end;

	PInfo = ^TInfo;
	TInfo = object(TKeyMenu)
		st0,
		st1,
		st2,
		st3,
		st4,
		st6: PStatic;
		procedure Work; virtual;
	end;

	PKonst = ^TKonst;
	TKonst = object(TKeyMenu)
		kbuf: record
			chng,
			list: integer;
			name,
			value: string[31];
			rem  : string[41]
		end;
		procedure Work; virtual;
	end;

	PFind = ^TFind;
	TFind = object(TKeyMenu)
		rb1,
		rb2: PRadioButton;
		procedure Work; virtual;
		procedure FindNext;
	end;

	PFindNext = ^TFindNext;
	TFindNext = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PReplace = ^TReplace;
	TReplace = object(TKeyMenu)
		rb1,
		rb2: PRadioButton;
		procedure Work; virtual;
		procedure ReplaceNext(all: boolean);
	end;

	PReplaceNext = ^TReplaceNext;
	TReplaceNext = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PGoto = ^TGoto;
	TGoto = object(TMenu)
		procedure Work; virtual;
	end;

	PZielwert = ^TZielwert;
	TZielwert = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PZielwertDialog = ^TZielwertDialog;
	TZielwertDialog = object(TBlockChangeDialog)
		ed1,
		ed2: PEdit;
		st : PStatic;
		procedure BlockChanged(blk: string); virtual;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
	end;

	PSort = ^TSort;
	TSort = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PSortBox = ^TSortBox;
	TSortBox = object(TComboBox)
		procedure SetText(ATextString: string); virtual;
	end;

	PSortButton = ^TSortButton;
	TSortButton = object(TRadioButton)
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
	end;

	PSortDialog = ^TSortDialog;
	TSortDialog = object(TBlockChangeDialog)
		bedt: PStatic;
		pcb1,
		pcb2,
		pcb3: PSortBox;
		rb1 : PSortButton;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
		procedure ScanValues;
	end;

	PFindDialog = ^TFindDialog;
	TFindDialog = object(THyperDialog)
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
	end;

	PReplaceDialog = ^TReplaceDialog;
	TReplaceDialog = object(THyperDialog)
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
	end;

	PBlockBox = ^TBlockBox;
	TBlockBox = object(TListBox)
		ed: PEdit;
		procedure Work; virtual;
	end;

	PBlockDialog = ^TBlockDialog;
	TBlockDialog = object(TDialog)
		pbb: PBlockBox;
		procedure EndDlg(Indx: integer; DblClick: boolean); virtual;
	end;

	PKonstBox = ^TKonstBox;
	TKonstBox = object(TListBox)
		procedure Work; virtual;
	end;

	PKonstDialog = ^TKonstDialog;
	TKonstDialog = object(THyperDialog)
		cb : PCheckBox;
		pkb: PKonstBox;
		pb1,
		pb2: PButton;
		ed1,
		ed2,
		ed3: PEdit;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure UpdateList(wrk: boolean);
	end;

	PFontSelectBox = ^TFontSelectBox;
	TFontSelectBox = object(TComboBox)
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
		procedure OpenPopup; virtual;
	end;

	PFontSizeBox = ^TFontSizeBox;
	TFontSizeBox = object(TFontSelectBox)
		setsize: boolean;
		procedure Work; virtual;
	end;

	PFontBox = ^TFontBox;
	TFontBox = object(TFontSelectBox)
		fsizebox: PFontSizeBox;
		newsize : integer;
		procedure SetValue(Sel: integer); virtual;
		procedure Work; virtual;
	end;

	PSheetDialog = ^TSheetDialog;
	TSheetDialog = object(THyperDialog)
		ed1,
		ed2: PEdit;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
	end;

	PFont = ^TFont;
	TFont = record
		Index,
		SizeCount: integer;
		Sizes    : PIntegerArray;
		Name     : PString
	end;

	PFunction = ^TFunction;
	TFunction = record
		Name,
		Parms,
		Descr1,
		Descr2: PString;
		Opcode,
		Group : integer
	end;

	PFunctionCollection = ^TFunctionCollection;
	TFunctionCollection = object(TStringCollection)
		function KeyOf(Item: pointer): pointer; virtual;
		procedure FreeItem(Item: pointer); virtual;
	end;

	PFormat = ^TFormat;
	TFormat = record
		Name : PString;
		Group,
		Index: integer
	end;

	PCategory = ^TCategory;
	TCategory = record
		Name : PString;
		Group: integer
	end;

	PCategoryCollection = ^TCategoryCollection;
	TCategoryCollection = object(TStringCollection)
		function KeyOf(Item: pointer): pointer; virtual;
		procedure FreeItem(Item: pointer); virtual;
	end;

	PParameter = ^TParameter;
	TParameter = record
		Value   : TNumber;
		Name,
		ListName,
		Txt,
		Descr   : PString;
		Predef  : boolean
	end;

	PVariable = ^TVariable;
	TVariable = record
		RefRow,
		RefCol: integer;
		Name: PString
	end;

	PParameterCollection = ^TParameterCollection;
	TParameterCollection = object(TStringCollection)
		function KeyOf(Item: pointer): pointer; virtual;
		procedure FreeItem(Item: pointer); virtual;
	end;

	PLinkCollection = ^TLinkCollection;
	TLinkCollection = object(TStringCollection)
		function KeyOf(Item: pointer): pointer; virtual;
		procedure FreeItem(Item: pointer); virtual;
	end;

	PVariableCollection = ^TVariableCollection;
	TVariableCollection = object(TStringCollection)
		function KeyOf(Item: pointer): pointer; virtual;
		procedure FreeItem(Item: pointer); virtual;
	end;

	PFontCollection = ^TFontCollection;
	TFontCollection = object(TStringCollection)
		function KeyOf(Item: pointer): pointer; virtual;
		procedure FreeItem(Item: pointer); virtual;
	end;

	PRowSizeDialog = ^TRowSizeDialog;
	TRowSizeDialog = object(TBlockChangeDialog)
		ed1: PStatic;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
	end;

	PColSizeDialog = ^TColSizeDialog;
	TColSizeDialog = object(TBlockChangeDialog)
		ed1: PStatic;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
	end;

	PColNameDialog = ^TColNameDialog;
	TColNameDialog = object(TBlockChangeDialog)
		st1,
		st2: PStatic;
		ed1: PEdit;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
	end;

	PRahmenBuffer = ^TRahmenBuffer;
	TRahmenBuffer = record
		gline,
		oline,
		uline,
		lline,
		rline,
		hline,
		vline,
		gcolor,
		color,
		hcolor,
		vcolor: integer
	end;

	PRahmenDialog = ^TRahmenDialog;
	TRahmenDialog = object(TBlockChangeDialog)
		bedt: PStatic;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
	end;

	PPatternDialog = ^TPatternDialog;
	TPatternDialog = object(TBlockChangeDialog)
		bedt,
		cn  : PStatic;
		pc,
		pp,
		ps  : PControl;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure Color2Name;
		procedure BlockChanged(blk: string); virtual;
	end;

	PTextAttrDialog = ^TTextAttrDialog;
	TTextAttrDialog = object(TBlockChangeDialog)
		bedt: PStatic;
		cb1,
		cb2,
		cb3,
		cb4,
		cb5,
		cb6 : PTriState;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
		function ChangeValues: boolean;
	end;

	PNumFormatsDialog = ^TNumFormatsDialog;
	TNumFormatsDialog = object(TBlockChangeDialog)
		bedt: PStatic;
		pfcb: PFormCategoryBox;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure BlockChanged(blk: string); virtual;
	end;

	PPageSetup = ^TPageSetup;
	TPageSetup = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PBorderBox = ^TBorderBox;
	TBorderBox = object(TComboBox)
		function TestIndex(AnIndx: integer): boolean; virtual;
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
		procedure SetValue(Sel: integer); virtual;
		procedure Work; virtual;
	end;

	PColorBox = ^TColorBox;
	TColorBox = object(TComboBox)
		function TestIndex(AnIndx: integer): boolean; virtual;
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
		procedure SetValue(Sel: integer); virtual;
		procedure Work; virtual;
	end;

	PTextColorBox = ^TTextColorBox;
	TTextColorBox = object(TColorBox)
		procedure Work; virtual;
	end;

	PDirectionBox = ^TDirectionBox;
	TDirectionBox = object(TComboBox)
		procedure SetValue(Sel: integer); virtual;
	end;

	PPatternBox = ^TPatternBox;
	TPatternBox = object(TComboBox)
		function TestIndex(AnIndx: integer): boolean; virtual;
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
		procedure SetValue(Sel: integer); virtual;
		procedure Work; virtual;
	end;

	PBlock = ^TBlock;
	TBlock = object(TKey)
		procedure Work; virtual;
	end;
	
	PColorToolbar = ^TColorToolbar;
	TColorToolbar = object(TToolbar)
		used     : boolean;
		oldobtype: integer;
		oldobspec: longint;
		constructor Init(AParent: PWindow; AnIndx,AColIndx: integer; Switch: boolean; Hlp: string);
		destructor Done; virtual;
	end;

	PTFett = ^TTFett;
	TTFett = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTKursiv = ^TTKursiv;
	TTKursiv = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTUnter = ^TTUnter;
	TTUnter = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTAlignLeft = ^TTAlignLeft;
	TTAlignLeft = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTAlignCenter = ^TTAlignCenter;
	TTAlignCenter = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTAlignRight = ^TTAlignRight;
	TTAlignRight = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTDezPlus = ^TTDezPlus;
	TTDezPlus = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTDezMinus = ^TTDezMinus;
	TTDezMinus = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTSumme = ^TTSumme;
	TTSumme = object(TColorToolbar)
		procedure Work; virtual;
	end;
	
	PObjAttrBox = ^TObjAttrBox;
	TObjAttrBox = object(TCheckBox)
		procedure Changed(AnIndx: integer; DblClick: boolean); virtual;
	end;
	
	PObjSizeDialog = ^TObjSizeDialog;
	TObjSizeDialog = object(THyperDialog)
		embedobj: pointer;
		ed1,
		ed2,
		ed3,
		ed4     : PEdit;
		cb1,
		cb2     : PCheckBox;
		constructor Init(AParent: PWindow; AEmbed: pointer; ATitle,HypHelp,hdTitle: string; Indx: integer);
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
	end;

	PObjAttrDialog = ^TObjAttrDialog;
	TObjAttrDialog = object(THyperDialog)
		embedobj: pointer;
		pbg     : PColorBox;
		setbtn  : integer;
		constructor Init(AParent: PWindow; AEmbed: pointer; ATitle,HypHelp,hdTitle: string; Indx,sbt: integer);
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
	end;

	PSheetBuffer = ^TSheetBuffer;
	TSheetBuffer = record
		rows    : string[5];
		columns : string[3];
		font,
		size,
		gitter,
		autocalc,
		vorlage,
		lhor,
		lvert,
		lmouse,
		llayout,
		images,
		protect,
		umbruch : integer
	end;

	PDialogBuffer = ^TDialogBuffer;
	TDialogBuffer = record
		font,
		size,
		percent,
		color,
		pattern,
		direction: integer;
		input    : string;
		txtcolor,
		border   : integer;
		resvd1,
		resvd2,
		resvd3,
		resvd4   : longint
	end;

	PEmbedBuf = ^TEmbedBuf;
	TEmbedBuf = record
		color,
		trans,
		border,
		fcolor,
		fid,
		fsize : integer
	end;

	PProtoEmbedded = ^TProtoEmbedded;
	TProtoEmbedded = object(TObject)
		FileName : string;
		Data     : pointer;
		X100,
		Y100,
		Width100,
		Height100,
		DataLen  : longint;
		ObjTyp   : integer;
		oabuf    : TEmbedBuf;
		diabuf   : PDiagrammBuf;
		prntflg,
		lckflg,
		skal,
		umbr,
		prop,
		embd     : boolean;
		Next     : PProtoEmbedded;
		constructor Init(otyp: integer; fname: string; fdat: pointer; fdatlen,x,y,w100,h100: longint; const oab: TEmbedBuf; pdb: PDiagrammBuf; prp,emb,skl,umb,prnt,lck: boolean);
		destructor Done; virtual;
		procedure Realize(p: PCalcWindow);
	end;

	PEmbedded = ^TEmbedded;
	TEmbedded = object(TObject)
		Data      : pointer;
		DataLen   : longint;
		ServerID,
		PaintX,
		PaintY,
		PaintW,
		PaintH    : integer;
		Parent    : PCalcWindow;
		Prev,
		Next      : PEmbedded;
		oabuf     : TEmbedBuf;
		osbuf     : record
			x,y,
			width,
			height: string[7];
			prop,
			sperr : integer
		end;
		constructor Init(AParent: PCalcWindow; poi: POLGAObjectInfo; fName: string; srvid,pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100,dlen: longint; dat: pointer; xyvalid,draw,prop,embd,prntflg,lckflg: boolean; poa: PEmbedBuf);
		destructor Done; virtual;
		function IsExternal: boolean; virtual;
		function GetType: integer; virtual;
		function Save(hdl: integer; emb: boolean): boolean;
		function SaveData(hdl: integer; emb: boolean): boolean; virtual;
		function GetExt(embed,default: boolean): string; virtual;
		function GetDefaultExt: string; virtual;
		procedure Link;
		procedure Unlink;
		procedure BreakLink;
		procedure CheckLink; virtual;
		procedure Update;
		function CreateLinkFile: boolean;
		procedure SetWorkstationValues(dev,colrs: integer; xofs,yofs: longint; xmm100,ymm100,perc,ffak: real; scale,outs: boolean);
		procedure Paint(handle: integer; const clip: GRECT; screen: boolean);
		procedure UserPaint(handle: integer; clip: GRECT; screen: boolean); virtual;
		procedure Redraw;
		procedure Unembed;
		function IsVisible(const r: GRECT; screen: boolean): boolean;
		procedure Resize(pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100: longint; xyvalid,draw: boolean);
		function GetPixXPos(screen: boolean): integer;
		function GetPixYPos(screen: boolean): integer;
		function GetPixWidth(screen: boolean): integer;
		function GetPixHeight(screen: boolean): integer;
		function IsInside(mx,my: integer): boolean;
		procedure Click(mX,mY,KStat: integer);
		procedure DblClick(mX,mY,KStat: integer); virtual;
		procedure RButton(mX,mY,KStat,Clicks: integer);
		procedure DoMenu(mX,mY: integer); virtual;
		procedure HandleMenu(indx: integer);
		function IsEmbedded: boolean;
		procedure SetEmbedFlag;
		procedure ClearEmbedFlag;
		procedure Select;
		procedure Deselect;
		procedure Toggle;
		function IsSelected: boolean;
		procedure Destroy;
		procedure Cut;
		procedure Copy;
		procedure Paste;
		procedure SetDirty;
		procedure ClearDirtyFlag;
		function IsDirty: boolean;
		procedure SetPropFlag;
		procedure ClearPropFlag;
		function IsProportional: boolean;
		procedure Lock;
		procedure Unlock;
		function IsLocked: boolean;
		procedure SetPrintFlag;
		procedure ClearPrintFlag;
		function CanPrint: boolean;
		procedure SetFile(s: string);
		function GetFile: string;
		function bwrite(hdl: integer; count: longint; var buffer): boolean;
		private
		objsize     : PObjSizeDialog;
		objattr     : PObjAttrDialog;
		ScaleIMG,
		outscr,
		selected,
		printflag,
		embfiledirty,
		embedflag   : boolean;
		FileName    : PString;
		objectinfo  : POLGAObjectInfo;
		fontfak,
		percent,
		xmm100fak,
		ymm100fak   : real;
		colors,
		devID       : integer;
		XOffs,
		YOffs,
		XPos_mm100,
		YPos_mm100,
		Width_mm100,
		Height_mm100: longint
	end;
	
	PEmbeddedTAD = ^TEmbeddedTAD;
	TEmbeddedTAD = object(TEmbedded)
		dbvalid: boolean;
		diabuf : TDiagrammBuf;
		constructor Init(AParent: PCalcWindow; poi: POLGAObjectInfo; fName: string; srvid,pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100,dlen: longint; dat: pointer; xyvalid,draw,prop,embd,prntflg,lckflg: boolean; poa: PEmbedBuf; pdb: PDiagrammBuf);
		function GetType: integer; virtual;
		function SaveData(hdl: integer; emb: boolean): boolean; virtual;
		procedure DoMenu(mX,mY: integer); virtual;
	end;
	
	PEmbeddedStatic = ^TEmbeddedStatic;
	TEmbeddedStatic = object(TEmbedded)
		function IsExternal: boolean; virtual;
		function GetExt(embed,default: boolean): string; virtual;
	end;

	PEmbeddedIMG = ^TEmbeddedIMG;
	TEmbeddedIMG = object(TEmbeddedStatic)
		imgxy    : ARRAY_8;
		colidx   : ARRAY_2;
		fd_dlen  : longint;
		srcMFDB,
		desMFDB  : MFDB;
		skalieren: boolean;
		constructor Init(AParent: PCalcWindow; fName: string; pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100,dlen: longint; dat: pointer; xyvalid,draw,prop,embd,skal,prntflg,lckflg: boolean; poa: PEmbedBuf);
		destructor Done; virtual;
		function GetDefaultExt: string; virtual;
		function GetType: integer; virtual;
		function SaveData(hdl: integer; emb: boolean): boolean; virtual;
		procedure CheckLink; virtual;
		function Decode: boolean;
		procedure UserPaint(handle: integer; clip: GRECT; screen: boolean); virtual;
		procedure DoMenu(mX,mY: integer); virtual;
	end;
	
	PEmbeddedText = ^TEmbeddedText;
	TEmbeddedText = object(TEmbeddedStatic)
	  txOffs,
	  tyOffs : integer;
		umbruch: boolean;
		constructor Init(AParent: PCalcWindow; fName: string; pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100,dlen: longint; dat: pointer; xyvalid,draw,prop,embd,umbr,prntflg,lckflg: boolean; poa: PEmbedBuf);
		function GetDefaultExt: string; virtual;
		function GetType: integer; virtual;
		function SaveData(hdl: integer; emb: boolean): boolean; virtual;
		procedure CheckLink; virtual;
		procedure UserPaint(handle: integer; clip: GRECT; screen: boolean); virtual;
		procedure DblClick(mX,mY,KStat: integer); virtual;
		procedure DoMenu(mX,mY: integer); virtual;
	end;

	PLinkData = ^TLinkData;
	TLinkData = record
		Descr : PString;
		ObjRef: PEmbedded;
	end;

	PLinkBox = ^TLinkBox;
	TLinkBox = object(TListBox)
		procedure Work; virtual;
	end;

	PLink = ^TLink;
	TLink = object(THyperDialog)
		pb1,
		pb2,
		pb3     : PButton;
		plb     : PLinkBox;
		linklist: PLinkCollection;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure EndDlg(Indx: integer; DblClick: boolean); virtual;
		procedure AddObject(pe: PEmbedded);
		procedure RemoveObject(pe: PEmbedded);
		procedure UpdateList(pe: PEmbedded);
	end;

	PPassWord = ^TPassWord;
	TPassWord = record
		Flag: integer;
		Code,
		Mask: longint
	end;

	PTexelHeader = ^TTexelHeader;
	TTexelHeader = record
		Magic     : array [0..3] of char;
		Version,
		Compatible: word;
		PackAlgo,
		Release,
		Resvd1,
		Resvd2,
		Resvd3,
		Resvd4    : integer
	end;

	PBlockHeader = ^TBlockHeader;
	TBlockHeader = record
		Width,
		Height,
		ColOffs,
		RowOffs,
		Resvd0,
		Resvd1,
		Resvd2,
		Resvd3,
		Resvd4 : integer
	end;

	PTexelHead2 = ^TTexelHead2;
	TTexelHead2 = record
		Resvd0,
		Resvd1,
		Resvd2,
		Resvd3,
		Resvd4,
		Resvd5,
		Resvd6,
		PassCode : longint;
		PassFlag,
		CryptFlag: integer;
		RSeed    : longint
	end;

	PPSBuffer = ^TPSBuffer;
	TPSBuffer = record
		oben,
		unten,
		links,
		rechts   : string[9];
		hcenter,
		vcenter,
		gitter,
		rows,
		columns  : integer;
		bereich  : string[15];
		hleft,
		hmid,
		hright,
		fleft,
		fmid,
		fright   : string[41];
		num1,
		num2,
		hlefton,
		hcenteron,
		hrighton,
		flefton,
		fcenteron,
		frighton,
		images   : integer;
		kopf,
		fuss     : string[9]
	end;

	PTexelParms = ^TTexelParms;
	TTexelParms = record
		Rows,
		Columns,
		Percent : integer;
		ScrlXPos,
		ScrlYPos: longint;
		CurrSize: GRECT;
		Cursor  : TCursor;
		psbuffer: TPSBuffer;
		Toolbar : integer
	end;
	
	PInputEdit = ^TInputEdit;
	TInputEdit = object(TScrollEdit)
		constructor Init(AParent: PDialog; AnIndx,ATextLen: integer);
		function IsHelpAvailable: boolean; virtual;
		function GetHelp: string; virtual;
	end;

	TCalcWindow = object(THyperDialog)
		Parms       : TTexelParms;
		LeftColWidth,
		TopRowHeight,
		PaintOffs,
		lcnum,
		tcnum,
		wWidth,
		numWidth,
		prnRangeFlag,
		fneOp,
		actFont,
		actPoint,
		alertret    : integer;
		lpoffs,
		tpoffs      : longint;
		PercentSize : real;
		PRow,
		PCol        : PWordArray;
		PRowFlags,
		PColFlags   : PByteArray;
		PColNames   : PItemList;
		fnecell,
		Sheet       : PCell;
		Dirty,
		Speedo,
		currvalid,
		tbactive,
		closing,
		inpstat     : boolean;
		insrow      : PInsertRows;
		inscol      : PInsertColumns;
		save        : PSave;
		saveas      : PSaveAs;
		abandon     : PAbandon;
		export      : PExport;
		diagramm    : PDiagram;
		objects     : PObjects;
		clrinh      : PClear;
		fill        : PFill;
		find        : PFind;
		replace     : PReplace;
		formcell    : PFormCell;
		formrow     : PFormRow;
		formcol     : PFormCol;
		insfunc     : PFunktion;
		oleobject   : POLEObject;
		links       : PLink;
		textobj     : PTextObj;
		grafik      : PGrafik;
		bblock      : PBlock;
		prnt        : PPrint;
		tbonoff,
		inpok,
		inpcancel   : PControl;
		dblock      : PStatic;
		inpline     : PInputEdit;
		dezplus     : PTDezPlus;
		dezminus    : PTDezMinus;
		tsumme      : PTSumme;
		pfett       : PTFett;
		pkursiv     : PTKursiv;
		punter      : PTUnter;
		palignleft  : PTAlignLeft;
		paligncenter: PTAlignCenter;
		palignright : PTAlignRight;
		pfbox       : PFontBox;
		pbrdbox     : PBorderBox;
		pcbox       : PColorBox;
		ptcbox      : PTextColorBox;
		ppbox       : PPatternBox;
		pdirbox     : PDirectionBox;
		rowsize     : PRowSizeDialog;
		colsize     : PColSizeDialog;
		colname     : PColNameDialog;
		textattr    : PTextAttrDialog;
		pattern     : PPatternDialog;
		rahmen      : PRahmenDialog;
		numformats  : PNumFormatsDialog;
		konstanten  : PKonstDialog;
		pagesetup   : PPageSetup;
		paper       : PPaper;
		preview     : PPreview;
		pagepreview : PPreviewDialog;
		tccbuffer   : record
			empty,
			left,
			right,
			up,
			down   : integer
		end;
		ticbuffer   : record
			left,
			right,
			up,
			down   : integer
		end;
		tibuffer    : record
			all,
			formula,
			value,
			format,
			note,
			none,
			add,
			sub,
			mul,
			divide,
			empty,
			transpose: integer
		end;
		nformbuffer : record
			category,
			frmindex: integer;
			format  : string[51]
		end;
		txabuffer   : record
			bold,
			light,
			italic,
			under,
			outl,
			shadow   : integer;
			rotat,
			skew     : string[5];
			clip,
			left,
			center,
			right,
			color,
			rotoff,
			skewoff,
			alignoff,
			coloff,
			alignoff2,
			oben,
			mitte,
			unten    : integer
		end;
		cnbuffer    : record
			nold,
			nnew: string[41]
		end;
		zwbuf       : TZielBuf;
		exportbuf   : TExportBuf;
		rsbuffer    : string[7];
		csbuffer    : string[7];
		dtbuffer    : TDialogBuffer;
		sheetbuffer : TSheetBuffer;
		prnbuffer   : TPrintBuffer;
		rabuf       : TRahmenBuffer;
		sortbuf     : TSortBuf;
		diagrammbuf : TDiagrammBuf;
		infobuf     : TInfoBuf;
		findbuf     : TFindBuf;
		replacebuf  : TReplaceBuf;
		fillbuf     : TFillBuffer;
		Fonts       : PFontCollection;
		Parameter   : PParameterCollection;
		Variables   : PVariableCollection;
		Embedded    : PEmbedded;
		UsrFormats  : PFormatCollection;
		BlockHistory: PStringCollection;
		wnd_prnt_set: PPRN_SETTINGS;
		longfile    : string;
		PassWord    : TPassWord;
		constructor Init;
		constructor InitFile(const FNam: string; pg: PProgressWindow; const AParm: TTexelParms; const ADBuf: TDialogBuffer; const ASBuf: TSheetBuffer; const FBuf: TFindBuf; const RBuf: TReplaceBuf; const FlBuf: TFillBuffer;
		                     const zBuf: TZielBuf; const ExBuf: TExportBuf; const SrtBuf: TSortBuf; const InfBuf: TInfoBuf; const DiaBuf: TDiagrammBuf;
		                     ASheet: PCell; ARow,ACol: PWordArray; CNam: PItemList; Parm: PParameterCollection; UFrm: PFormatCollection; ProtoEmb: PProtoEmbedded;
		                     apwd: TPassWord; bhist: PStringCollection; CFlags,RFlags: PByteArray; prntset: PPRN_SETTINGS; prnrange: integer; drt,checkover: boolean);
		constructor InitImport(pg: PProgressWindow; rw,cl: integer; const FNam: string; ASheet: PCell; ARow,ACol: PWordArray; CNam: PItemList; breiten: boolean);
		procedure CommonInit1;
		procedure CommonInit2(breiten: boolean);
		procedure CommonParmInit(setsize: boolean);
		function CanClose: boolean; virtual;
		function GetStyle: integer; virtual;
		function GetVDIHandle: integer; virtual;
		procedure GetWindowClass(var AWndClass: TWndClass); virtual;
		function GetClassName: string; virtual;
		function GetRawIconTitle: string;
		function GetIconTitle: string; virtual;
		function GetScroller: PScroller; virtual;
		procedure GetWorkMax(var maxX,maxY: integer); virtual;
		procedure SetupSize; virtual;
		procedure SetupVDI; virtual;
		procedure SetupWindow; virtual;
		procedure ShutdownWindow; virtual;
		procedure PaintNumbers(rect: GRECT);
		procedure PaintNames(rect: GRECT);
		function Val2Txt(fval: TNumber; var vtxt: string; fp: byte; frm: integer; cell: PCell): boolean;
		function Val2TxtF(fval: TNumber; fp: byte; frm: integer; cell: PCell): string;
		procedure InitTextValues(handle: integer; var cmpval: TOldTxtVal);
		procedure RestoreTextValues(handle: integer);
		procedure RowsClearOverflow(rs,re: integer; var cmin,cmax: integer);
		procedure RowsCheckOverflow(rs,re: integer; var cmin,cmax: integer);
		procedure SheetCheckOverflow;
		function ClearOverflow(cell: PCell; var cmin,cmax: integer): boolean;
		function CheckOverflow(cell: PCell; var cmin,cmax: integer): boolean;
		procedure OutputVectorText(handle: integer; cell: PCell; const txt: string; const tval: TTxtVal; var cmpval: TOldTxtVal; csize: ARRAY_4; isnum: boolean);
		procedure OutputKF(handle,kfx,kfy,alh,alv,pagenum,pages: integer; printtime: longint; s: string);
		procedure OutputErrorText(handle: integer; cell: PCell; const tval: TTxtVal; var cmpval: TOldTxtVal; csize: ARRAY_4; err: shortint);
		procedure Paint(var PaintInfo: TPaintStruct); virtual;
		procedure ForceVRedraw; virtual;
		procedure Print; virtual;
		procedure SelectAll; virtual;
		procedure DeselectAll;
		procedure StandardBreite(cs,ce: integer);
		procedure StandardHoehe(rs,re: integer);
		procedure InsertCell(rs,cs,re,ce: integer);
		procedure WMRubbox(r: GRECT); virtual;
		procedure WMClick(mX,mY,KStat: integer); virtual;
		procedure InternalDragDrop(mX,mY: integer);
		procedure CopyFromInternalDragDrop(from: PCalcWindow; rs,cs,re,ce,r,c: integer; mve: boolean);
		function DoRubbox(mX,mY,KStat: integer): boolean; virtual;
		procedure WMDblClick(mX,mY,KStat: integer); virtual;
		procedure WMRButton(mX,mY,KStat,Clicks: integer); virtual;
		procedure AttrDialogs(num,indx: integer; cell: PCell);
		function WMKeyDown(Stat,Key: integer): boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure GotoBlock(s: string);
		procedure ToggleToolbar;
		function SelectDisabled(AnIndx,KStat,Clicks: integer): boolean; virtual;
		function GetColWidth(num: integer): integer;
		procedure SetColWidth(num: integer; width: longint; draw: boolean);
		function GetRowHeight(num: integer): integer;
		procedure SetRowHeight(num: integer; height: longint; draw: boolean);
		function GetColWidth_mm100(num: integer): word;
		procedure SetColWidth_mm100(num: integer; width: longint; draw: boolean);
		function GetRowHeight_mm100(num: integer): word;
		procedure SetRowHeight_mm100(num: integer; height: longint; draw: boolean);
		function FindObject(x,y: integer; sizer: boolean): longint;
		function GetCell(r,c: integer): PCell;
		procedure Cell2RC(cell: PCell; var r,c: integer);
		procedure Mouse2Cell(x,y: integer; var r,c: integer);
		procedure Cell2Rect(r,c: integer; var rect: LGRECT);
		procedure Cell2VRect(r,c: integer; var vrect: GRECT);
		procedure GetSheetRect(var sr: GRECT);
		function GetBlock(blck: string; whole: boolean; var rs,cs,re,ce,f1,f2: integer): boolean;
		function GetVisibleBlockRect(rs,cs,re,ce: integer; var sr: GRECT): boolean;
		procedure DrawCells(rs,cs,re,ce: integer);
		procedure DrawBlockRaw(rs,cs,re,ce: integer; const r: GRECT);
		procedure DrawBlock(rs,cs,re,ce: integer);
		procedure DrawCursor;
		procedure EnableInpline;
		procedure SetInpline(cell: PCell);
		procedure Calculate(clr: boolean);
		procedure AutoCalculate(clr: boolean);
		function NewNode(var p: PNode): boolean;
		procedure DeleteNode(var p: PNode);
		procedure TranslateCells(rs,cs,re,ce,rdif,cdif: integer; clr: boolean);
		function BuildFunction(cell: PCell; fnames: boolean): string;
		function BuildTree(cell: PCell; p: PNode; fnames: boolean; rrel,crel: integer): string;
		function Parse(s: string; var svar: string; var baum: PNode; acell: PCell; rrel,crel: integer; varerr: boolean): boolean;
		function EvalNode(cell: PCell; knoten: PNode): TNumber;
		function Evaluate(cell: PCell): TNumber;
		function GetCellValue(cell: PCell; clr: boolean): TNumber;
		function Error2Txt(err: shortint): string;
		procedure ChangeCell(cell: PCell; intxt: string; r,c: integer; chgval: boolean);
		procedure CheckToolbarTextFX(cell: PCell);
		procedure SetCursorPos(r,c: integer; scrl: boolean);
		procedure ClearCalcFlags;
		procedure SetBlock;
		procedure SetBorderSize;
		function ColIndex2Nr(indx: string; clip: boolean): integer;
		function GetColumnIndex(Nr: integer): string;
		function GetColumnName(Nr: integer): string;
		function GetRowIndex(Nr: integer): string;
		procedure SetScrollerRange;
		procedure SetPercentSize(pct: integer);
		function GetWindowFileName: string;
		procedure SetWindowFileName(s: string);
		procedure SetDirty;
		procedure ClearDirty;
		procedure SetFont(fIndex,fSize: integer);
		function GetStdFontIndex: integer;
		function GetStdFontSize: integer;
		function GetFontIndex: integer;
		function GetFontSize: integer;
		function FontID2Index(anid: integer): integer;
		function FontSize2Index(asize: integer): integer;
		function FontChanged(OrgID,AnID,ASize,AColor,BackColor,TheEffects,ARotation,ASkew,HorAlign,VertAlign,AWidth,TrackKern: integer; Size31: fix31; PairKern,cWnd: boolean): boolean; virtual;
		procedure FontSelect;
		procedure Cut; virtual;
		procedure Copy; virtual;
		procedure Paste; virtual;
		procedure Delete; virtual;
		procedure CutCells;
		procedure CopyCells;
		procedure PasteCells;
		procedure DeleteCells;
		procedure InsertFromClipboard(what,op: integer; empty,transpose,report,copyalign: boolean);
		function FreeCell(cell: PCell; clr: boolean): boolean;
		function FreeBlock(rs,cs,re,ce: integer; clr: boolean): boolean;
		procedure ClearBlock(rs,cs,re,ce: integer);
		function IsBlockUsed(rs,cs,re,ce,tnum: integer): boolean;
		function IsEmptyCell(cell: PCell): boolean;
		procedure InsertCells(rs,cs,re,ce,dir: integer);
		procedure Sort(n1,n2,n3,nrs: integer; n1up,n2up,n3up,rows,cse,ebeg,lex,absl,noattr: boolean);
		procedure SetBorder(ltyp,lcol,rtyp,rcol,otyp,ocol,utyp,ucol,htyp,hcol,vtyp,vcol,gtyp,gcol: integer);
		function Num2Hour(num: TNumber): integer;
		function Num2Minute(num: TNumber): integer;
		function Num2Second(num: TNumber): integer;
		function IsSchaltjahr(year: integer): boolean;
		function Days(year: integer): integer;
		function Num2Year(num: TNumber): longint;
		function Num2Month(num: TNumber): integer;
		function Num2Day(num: TNumber): integer;
		function Today: TNumber;
		function Now: TNumber;
		function CountDays(Year: longint; Month,Day: integer): longint;
		function Weekday(num: TNumber; typ: integer): integer;
		function Date(Year: longint; Month,Day: integer): TNumber;
		function Time(Hour,Minute,Second: integer): TNumber;
		function DDGetPath: string; virtual;
		procedure OLGAGetInfo(OrgID,InfoNr: integer);
		procedure OLGAUpdated(OrgID,SrvID,InfoNr: integer; Link: string); virtual;
		procedure OLGARenameLink(OrgID: integer; OldLink,NewLink: string); virtual;
		procedure OLGALinkBroken(OrgID: integer; Link: string); virtual;
		procedure PRNChanged(Device,Action: integer);
		function NewNumFormat(s: string): integer;
		procedure DeselectAllObjects;
		function FirstSelectedObject: PEmbedded;
		procedure Embed(poi: POLGAObjectInfo; srvid: integer; ow,oh,x100,y100,dlen: longint; dat: pointer; poabuf: PEmbedBuf; pdb: PDiagrammbuf; xyvalid,prop,embd,drty,istad,prntflg,lckflg: boolean);
		procedure EmbedNewObject(fname: string; w100,h100,x100,y100,dlen: longint; dat: pointer; poabuf: PEmbedBuf; pdb: PDiagrammBuf; xyvalid,prop,embd,drty,istad,prntflg,lckflg: boolean);
		function PasteObject: boolean;
		procedure CallID4Server(fname: string);
		procedure Unembed(srvID: integer);
		procedure SetPercent(prc: real);
		function GetPercent: real;
		function IsNormalPrintArea: boolean;
		function IsBlockPrintArea: boolean;
		function GetPageFrom: integer;
		function GetPageTo: integer;
		function GetCopies(hdl: integer): integer;
		function DoFeed: boolean;
		function DoSheet: boolean;
		function ClearDispList: boolean;
		procedure SetTextColor(ntc: integer);
		procedure SetCellColor(nc: integer);
	end;

	PCalcScroller = ^TCalcScroller;
	TCalcScroller = object(TScroller)
		procedure RedrawParent(XDif,YDif: longint); virtual;
	end;
	
	PURLDialog = ^TURLDialog;
	TURLDialog = object(THyperDialog)
		urlbuf: string;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
	end;
	
	POpenUrl = ^TOpenUrl;
	TOpenUrl = object(TKeyMenu)
		pb1,
		pb2: PButton;
		procedure Work; virtual;
	end;

	POpen = ^TOpen;
	TOpen = object(TKeyMenu)
		procedure Work; virtual;
		procedure Load(fname: string);
	end;

	PScrapDialog = ^TScrapDialog;
	TScrapDialog = object(THyperDialog)
		ext: string;
		procedure GetWindowClass(var AWndClass: TWndClass); virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		function OK: boolean; virtual;
	end;

	PAboutDialog = ^TAboutDialog;
	TAboutDialog = object(THyperDialog)
		procedure EndDlg(Indx: integer; DblClick: boolean); virtual;
	end;

	PAbout = ^TAbout;
	TAbout = object(TMenu)
		serst     : PStatic;
		serscroll,
		sertxt    : string;
		arraycount: integer;
		tstart    : word;
		procedure Work; virtual;
	end;

	PSpecialChars = ^TSpecialChars;
	TSpecialChars = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PWeb = ^TWeb;
	TWeb = object(TMenu)
		procedure Work; virtual;
	end;

	PHelp = ^THelp;
	THelp = object(TMenu)
		procedure Work; virtual;
	end;

	PHelpItem = ^THelpItem;
	THelpItem = object(TKeyMenu)
		procedure Work; virtual;
	end;

	TTexelApplication = object(TApplication)
		ExtResource,
		ScaleIMG,
		UseExtPrn,
		UseNewToolbar,
		CheckHistory,
		GSActive,
		ColFX         : boolean;
		NVDIVersion,
		FormPredef,
		WebID,
		CABVersion,
		CABFlags4,
		CABFlags5,
		HelpID,
		GEMScriptID,
		SheetCount    : integer;
		mstimer       : longint;
		FormStart     : array [0..19] of integer;
		Browser,
		HelpItem      : string[41];
		LastPath,
		LastFile      : array [0..PFMAX] of string;
		WebMail,
		WebASH,
		fnt_titel,
		SumName,
		DataPath      : string;
		sccsid        : string[79];
		setupbuffer   : record
			stdrows     : string[5];
			stdcolumns  : string[3];
			stdcolwidth : string[3];
			autocalc,
			stdfont,
			stdfsize    : integer;
			sizerrange  : string[1];
			floatpoint,
			history     : string[3];
			cursorwrap,
			xinputmode,
			closercancel,
			opennew,
			loaddoc,
			nothing,
			fullsize,
			wysiwyg,
			recalc,
			online,
			bak,
			toolbar,
			currency,
			overflow,
			bottomline,
			pixw,
			pixh        : integer
		end;
		app_prnt_set  : PPRN_SETTINGS;
		filebuf,
		prnt_dialog,
		fnt_dialog    : pointer;
		GSInfo        : PGSInfo;
		ascbuf        : TImportAscBuf;
		stdpsbuffer   : TPSBuffer;
		websupport,
		webhelp       : PWeb;
		help1,
		help2,
		help3,
		help4         : PHelp;
		help5         : PHelpItem;
		about         : PAbout;
		openurl       : POpenUrl;
		opennewdoc    : POpen;
		abruf         : PAbruf;
		import        : PImport;
		specialchars  : PSpecialCharactersWindow;
		stdprnbuffer  : TPrintBuffer;
		Fonts         : PFontCollection;
		Functions     : PFunctionCollection;
		Categories    : PCategoryCollection;
		UsrForm,
		Formats       : PFormatCollection;
		OLETypes      : POLECollection;
		FormCategories: PStringCollection;
		importscrap   : PScrapDialog;
		ddfiles       : PChar;
		saveglobal,
		extglobal     : global_ARRAY;
		ColorTable    : TOLGAColorTable;
		Monate        : array [1..12] of string[15];
		Monate3       : array [1..12] of string[3];
		Tage          : array [0..6] of string[15];
		Tage2         : array [0..6] of string[2];
		Farben        : array [0..15] of string[19];
		procedure SetupVDI; virtual;
		procedure InitInstance; virtual;
		procedure InitMainWindow; virtual;
		procedure LoadFile(p: PCalcWindow; s: string);
		procedure Terminate; virtual;
		procedure VAStart(OrgID: integer; Cmd: PChar); virtual;
		procedure FileSelected(Window: PWindow; OrgID: integer; Group: byte; Path: string; Files: PChar); virtual;
		procedure GetXAccAttr(var XAccAttr: TXAccAttr); virtual;
		procedure GetMenuEntries(var Entries: TMenuEntries); virtual;
		function GetIconTitle: string; virtual;
		function EscText2Formula(txt: string): string;
		function Num2Txt(fval: TNumber; fp: byte; cut0: boolean): string;
		procedure Unembed(srvID: integer);
		function ScriptByNumber(nr: longint; datei,zelle,prm: string): boolean;
		function InterpreteScript(pcmd: PChar; var answ: Pipearray): integer;
		procedure HandleKeybd(Stat,Key: integer); virtual;
		procedure HandleMesag(Pipe: Pipearray); virtual;
		procedure HandleTimer; virtual;
		function GetMsTimer: longint; virtual;
		function GetStdFontIndex: integer;
		function GetStdFontSize: integer;
		procedure FontID2Index(var index: integer);
		procedure FontSize2Index(fntindx: integer; var index: integer);
		function DDReadArgs(dSize: longint; PipeHnd,OrgID,WindID,mX,mY,KStat: integer): boolean; virtual;
		procedure DDFinished(OrgID,WindID,mX,mY,KStat: integer); virtual;
		function DDGetPreferredTypes(WindID: integer): string; virtual;
		function IsInteger(s: string): boolean;
		function IsNumber(s: string; var num: TNumber; var nums: string; vorz: boolean; trenn: char): boolean;
		procedure SCChanged(OrgID: integer; Bits: word; Ext: string); virtual;
		procedure PRNChanged(OrgID,Device,Action: integer); virtual;
		procedure FNTChanged(OrgID: integer); virtual;
		function ExtPrnSel(var prnt_set: PPRN_SETTINGS; pcopyps: PPRN_SETTINGS): boolean;
		function NoFontSel: boolean;
		function Time2Str(time: longint): string;
		procedure FileChanged(const s: string);
		procedure UpdateFile(const s: string; info: integer);
		procedure OLEExit(OrgID: integer); virtual;
		procedure OLGAInit(OrgID,Msg,Ver,eFlag: integer); virtual;
		procedure OLGAGetInfo(OrgID,InfoNr: integer); virtual;
		procedure OLGAAck(Pipe: Pipearray); virtual;
		procedure OLGAObjects(OrgID,Rest: integer; Ext,Descr: string); virtual;
		function LoadExtResource(fnam: string): boolean;
		procedure FreeExtResource;
		procedure ActivateExtResource;
		procedure DeactivateExtResource;
		function num2str(s: string): string;
		function XAccText(OrgID: integer; pText: pointer): boolean; virtual;
		function HelpAvailable(loadstg: boolean): boolean;
		procedure ErrorWindowMemory(p: PWindow);
		procedure InitSheetStructs(var parms: TTexelParms; var shbuf: TSheetBuffer; var dgbuf: TDialogBuffer; var zwbuf: TZielBuf; var dibuf: TDiagrammBuf; var exbuf: TExportBuf;
		                           var srbuf: TSortBuf; var inbuf: TInfoBuf; var fibuf: TFindBuf; var rebuf: TReplaceBuf; var flbuf: TFillBuffer);
		procedure FilterString(id: integer; var s: string);
		function dosmask(s: string): string;
		function macmask(s: string): string;
		function IsLongFileName(fname: string): boolean;
		procedure AbandonFile(p: PCalcWindow);
		procedure InitCells(cell: PCell; rmax,cmax: integer);
	end;

	PNew = ^TNew;
	TNew = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PPosRealValidator = ^TPosRealValidator;
	TPosRealValidator = object(TValidator)
		procedure Error; virtual;
		function IsValid(s: string): boolean; virtual;
		function IsValidInput(var s: string; SuppressFill: boolean): boolean; virtual;
	end;

	PMinMaxValidator = ^TMinMaxValidator;
	TMinMaxValidator = object(TValidator)
		MinVal,
		MaxVal: real;
		constructor Init(mnv,mxv: real);
		procedure Error; virtual;
		function IsValid(s: string): boolean; virtual;
		function IsValidInput(var s: string; SuppressFill: boolean): boolean; virtual;
	end;

	PPosMaxValidator = ^TPosMaxValidator;
	TPosMaxValidator = object(TMinMaxValidator)
		constructor Init(mxv: real);
	end;

	PPSDialog = ^TPSDialog;
	TPSDialog = object(THyperDialog)
		ed1,
		ed2: PEdit;
		function OK: boolean; virtual;
		procedure MinimalHeadFoot;
		function ExitDlg(AnIndx: integer): boolean; virtual;
	end;

	POptions = ^TOptions;
	TOptions = object(TKeyMenu)
		procedure Work; virtual;
	end;

	PSaveOpt = ^TSaveOpt;
	TSaveOpt = object(TKeyMenu)
		procedure Work; virtual;
	end;
	
	PSaveWork = ^TSaveWork;
	TSaveWork = object(TMenu)
		procedure Work; virtual;
	end;	

	PHelpItemDialog = ^THelpItemDialog;
	THelpItemDialog = object(THyperDialog)
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
	end;

	PDeviceBox = ^TDeviceBox;
	TDeviceBox = object(TComboBox)
		procedure Work; virtual;
	end;

	PDriverBox = ^TDriverBox;
	TDriverBox = object(TComboBox)
		drvcnt    : integer;
		drivers   : array [0..24] of integer;
		shortnames: array [0..24] of string[13];
		longnames : array [0..24] of string[43]
	end;

	PPrintDialog = ^TPrintDialog;
	TPrintDialog = object(THyperDialog)
		drvinfo: PHyperDialog;
		paper  : PComboBox;
		devbox : PDeviceBox;
		drvbox : PDriverBox;
		inf,
		druck  : PButton;
		st1,
		st2,
		st3,
		st4,
		st5,
		st6,
		st7,
		st8,
		st9,
		st10,
		st11,
		st12   : PStatic;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure ShowInfo;
	end;

	POptionsDialog = ^TOptionsDialog;
	TOptionsDialog = object(THyperDialog)
		spage: PPSDialog;
		prnt : PPrintDialog;
		function OK: boolean; virtual;
		function ExitDlg(AnIndx: integer): boolean; virtual;
		procedure PageSetup;
	end;

	PTCut = ^TTCut;
	TTCut = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTCopy = ^TTCopy;
	TTCopy = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTPaste = ^TTPaste;
	TTPaste = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTFunction = ^TTFunction;
	TTFunction = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTNumber = ^TTNumber;
	TTNumber = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTDate = ^TTDate;
	TTDate = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTMoney = ^TTMoney;
	TTMoney = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTPercent = ^TTPercent;
	TTPercent = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTDiagram = ^TTDiagram;
	TTDiagram = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTHome = ^TTHome;
	TTHome = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTSortAuf = ^TTSortAuf;
	TTSortAuf = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PTSortAb = ^TTSortAb;
	TTSortAb = object(TColorToolbar)
		procedure Work; virtual;
	end;

	PPercentBox = ^TPercentBox;
	TPercentBox = object(TComboBox)
		procedure Work; virtual;
	end;

	PTexelObjectInfo = ^TTexelObjectInfo;
	TTexelObjectInfo = record
		oi     : TOLGAObjectInfo;
		r1,
		r2     : GRECT;
		fname  : array [0..255] of char;
		Data   : pointer;
		DataLen,
		x100,
		y100,
		w100,
		h100   : longint;
		oabuf  : TEmbedBuf;
		istad,
		xyvalid,
		prop,
		embd,
		dirty  : boolean;
		diabuf : TDiagrammBuf;
		prntflg,
		lckflg : boolean
	end;


const

	CELLSIZE       : longint =  sizeof(TCell);
	ev_normalfaktor: TNumber =  0.39894228040143267793;
	ev_pihalbe     : TNumber =  1.57079632679489661926;
	ev_ln2         : TNumber =  0.69314718055994530943;
	ev_ln10        : TNumber =  2.30258509299404568425;
	ev_rad2grad    : TNumber = 57.29577951308232087579;
	ev_grad2rad    : TNumber =  0.01745329251994329577;
	std1           : TNumber =  0.041666666666667;
	min1           : TNumber =  0.000694444444445;
	sek1           : TNumber =  0.000011574074075;
	TIMEROUND      : TNumber =  0.000000000001;
	RSC_LOADED     : pointer = pointer(1);
	Border1        : real    =  0.3;
	Border2        : real    =  0.6;
	Border3        : real    =  0.9;
	HUGE_VAL       : real    =  1.189731495357231765E+4932;
	DANKMAX        = 8;
	dank           : array [0..DANKMAX] of string[120] =
	                 ('                                        Was Sie noch nie wissen wollten, aber nun gezwungen werden zu lesen...   ',
	                  'Programm: Thomas Much - Handbuch und Onlinehilfe: G”tz Hoffart - Betatester: ',
                    'Hauke Ahrensfeld, Christoph Bartholme, Sven & Wilfried Behne, Oliver Buchmann, Friedrich Burgwedel, ',
                    'Alexander Clauss, Gerd Castan, J”rg Hahne, Ralf Heckmann, Gerd Hofmann, Andreas Kromke, Thomas Knneth, ',
                    'John Mcloud, Philipp Oelwein, Jan Pilgenr”der, Volker Ritzhaupt, Stefan Rogel, Ulrich Rožgoderer, Armin Schreck, ',
                    'J”rg Schulz, Uwe Seimet, Peter G. Spengler, Alexander Stehling, Wolfgang Walter und Christian Witt',
                    ' - Homepage: http://wwwrzstud.rz.uni-karlsruhe.de/~uk48/Texel',
                    ' - ASH-Mailbox: +49 (0)6221 / 303671',
                    ' - We apologise for the inconvenience.                                               ');
	VarNameSet     : set of char = ['_','0'..'9','a'..'z','A'..'Z','„','Ž','”','™','','š','ž'];
	months365      : array [0..11] of integer = (31,28,31,30,31,30,31,31,30,31,30,31);
	months366      : array [0..11] of integer = (31,29,31,30,31,30,31,31,30,31,30,31);
	{$IFNDEF BETA}
	ash_name       : array [0..30] of char = 'nnnnnnnnnnnnnnnnnnnnnnnnnnnnnn'#0;
	ash_firma      : array [0..30] of char = 'ffffffffffffffffffffffffffffff'#0;
	ash_serno      : array [0..10] of char = 'ssssssssss'#0;
	{$ENDIF}

	{$IFDEF FRENCH}
	{$I texel_f.inc}
	{$ELSE}
	{$IFDEF ENGLISH}
	{$I texel_e.inc}
	{$ELSE}
	{$I texel_g.inc}
	{$ENDIF}
	{$ENDIF}

var

	TexelApp: TTexelApplication;
	fnerror : integer;
	regname,
	regkey  : string;
	mailbuf,
	helpbuf : pointer;
	callufsl: UFSLPtr;
	callxfsl: xFSLPtr;
	pkt     : PKEYT;



function InitKeyTab: boolean;

	begin
		InitKeyTab:=false;
		if GetCookie('KEYT',longint(pkt)) then
			if pkt<>nil then
				if pkt^.Magic='KEYT' then
					if pkt^.Size>=40 then InitKeyTab:=true
	end;


function pinit_texel(d1,d2: pointer; d3,d4,d5: longint; settings: PPRN_SETTINGS; sub: PPDLG_SUB): longint;
	var tree  : PTree;
	    offset: integer;

	begin
		tree:=PTree(sub^.tree);
		offset:=sub^.index_offset;
		if sub^.private1<>0 then
			case PCalcWindow(sub^.private1)^.prnRangeFlag of
			1:
				tree^[offset+RTPSD2].ob_state:=tree^[offset+RTPSD2].ob_state or SELECTED;
			2:
				tree^[offset+RTPSD3].ob_state:=tree^[offset+RTPSD3].ob_state or SELECTED;
			else
				tree^[offset+RTPSD1].ob_state:=tree^[offset+RTPSD1].ob_state or SELECTED
			end
		else
			with TexelApp.stdprnbuffer do
				begin
					if alles=bf_Checked then tree^[offset+RTPSD2].ob_state:=tree^[offset+RTPSD2].ob_state or SELECTED
					else
						if block=bf_Checked then tree^[offset+RTPSD3].ob_state:=tree^[offset+RTPSD3].ob_state or SELECTED
						else
							tree^[offset+RTPSD1].ob_state:=tree^[offset+RTPSD1].ob_state or SELECTED
				end;
		pinit_texel:=1
	end;


function preset_texel(d1,d2: pointer; d3,d4,d5: longint; settings: PPRN_SETTINGS; sub: PPDLG_SUB): longint;
	var tree  : PTree;
	    offset: integer;

	begin
		tree:=PTree(sub^.tree);
		offset:=sub^.index_offset;
		if sub^.private1<>0 then
			begin
				if bTst(tree^[offset+RTPSD1].ob_state,SELECTED) then PCalcWindow(sub^.private1)^.prnRangeFlag:=0;
				if bTst(tree^[offset+RTPSD2].ob_state,SELECTED) then PCalcWindow(sub^.private1)^.prnRangeFlag:=1;
				if bTst(tree^[offset+RTPSD3].ob_state,SELECTED) then PCalcWindow(sub^.private1)^.prnRangeFlag:=2
			end
		else
			begin
				with TexelApp.stdprnbuffer do
					begin
						pblock:=bf_Unchecked;
						alles:=bf_Unchecked;
						block:=bf_Unchecked
					end;
				if bTst(tree^[offset+RTPSD1].ob_state,SELECTED) then TexelApp.stdprnbuffer.pblock:=bf_Checked;
				if bTst(tree^[offset+RTPSD2].ob_state,SELECTED) then TexelApp.stdprnbuffer.alles:=bf_Checked;
				if bTst(tree^[offset+RTPSD3].ob_state,SELECTED) then TexelApp.stdprnbuffer.block:=bf_Checked
			end;
		preset_texel:=1
	end;


procedure free_sub_dialogs(sub_dialogs: PPDLG_SUB);
	var next: PPDLG_SUB;

	begin
		while sub_dialogs<>nil do
			begin
				next:=sub_dialogs^.next;
				freemem(sub_dialogs,sizeof(PDLG_SUB));
				sub_dialogs:=next
			end
	end;


function arcsin(x: TNumber): TNumber;

	begin
		if abs(x)<>1.0 then
			begin
				x:=frac(x);
				arcsin:=arctan(x/sqrt(1-sqr(x)))
			end
		else
			if x=1.0 then arcsin:=ev_pihalbe
			else
				arcsin:=-ev_pihalbe
	end;


procedure LGRtoGR(r1: LGRECT; var r2: GRECT);

	begin
		r2.X:=integer(Max(Min(r1.X,32767),-32768));
		r2.Y:=integer(Max(Min(r1.Y,32767),-32768));
		r2.W:=integer(Max(Min(r1.W,32767),-32768));
		r2.H:=integer(Max(Min(r1.H,32767),-32768));
		GRtoA2(r2)
	end;


procedure LGRtoA2(var r: LGRECT);

	begin
		with r do
			begin
				X1:=X;
				Y1:=Y;
				X2:=X+W-1;
				Y2:=Y+H-1
			end
	end;


procedure LA2toGR(var r: LGRECT);

	begin
		with r do
			begin
				X:=X1;
				Y:=Y1;
				W:=X2+1-X;
				H:=Y2+1-Y
			end
	end;


function llrc_intersect(r1: LGRECT; var r2: LGRECT): boolean;
	var x,y,w,h: longint;

	begin
		x:=Max(r2.X,r1.X);
		y:=Max(r2.Y,r1.Y);
		w:=Min(r2.X+r2.W,r1.X+r1.W);
		h:=Min(r2.Y+r2.H,r1.Y+r1.H);
		r2.X:=x;
		r2.Y:=y;
		r2.W:=w-x;
		r2.H:=h-y;
		if (w>x) and (h>y) then
			begin
				LGRtoA2(r2);
				llrc_intersect:=true
			end
		else
			llrc_intersect:=false
	end;


function lrc_intersect(r1: LGRECT; var r2: GRECT): boolean;
	var x,y,w,h: longint;

	begin
		x:=Max(longint(r2.X),r1.X);
		y:=Max(longint(r2.Y),r1.Y);
		w:=Min(longint(r2.X)+longint(r2.W),r1.X+r1.W);
		h:=Min(longint(r2.Y)+longint(r2.H),r1.Y+r1.H);
		r1.X:=x;
		r1.Y:=y;
		r1.W:=w-x;
		r1.H:=h-y;
		LGRtoGR(r1,r2);
		lrc_intersect:=(w>x) and (h>y)
	end;


{$IFNDEF BETA}
function decode_name(c: PChar): string;
	var s: string;
	    q: integer;

	begin
		s:=StrPPas(c);
		if length(s)>0 then
			for q:=1 to length(s) do s[q]:=chr(ord(s[q]) xor 255);
		decode_name:=StrPTrimF(s)
	end;
{$ENDIF}


function KeyCorrect(name,key: string): boolean;
{$IFDEF BETA}
	var compkey: string;
	    q,l    : integer;

	function c2s(b1,b2: byte): string;
		var b: byte;

		begin
			b:=((b1+13) mod 256) xor ((b2+37) mod 256);
			c2s:=chr((b and 15)+65)+chr(((b shr 3) and 15)+65)
		end;

	begin
		KeyCorrect:=false;
		if length(name)<3 then exit;
		if length(key)<4 then exit;
		if length(key)<length(name) then exit;
		if gettime>EXPIRE then exit;
		compkey:='';
		if odd(length(name)) then name:=name+name[2];
		l:=length(name);
		for q:=1 to (l shr 1) do compkey:=compkey+c2s(ord(name[q]),ord(name[l+q-q]));
		KeyCorrect:=(key=compkey) and not(KeyCorrect('',''));
		{$IFDEF DEMO}
		KeyCorrect:=false
		{$ENDIF}
	end;
{$ELSE}
	label _raus;

	var s: string;

	begin
		KeyCorrect:=false;
		if StrPPas(ash_name)=StrPFill(30,'n') then goto _raus;
		if StrPPas(ash_firma)=StrPFill(30,'f') then exit;
		if StrPPas(ash_serno)=StrPFill(10,'s') then goto _raus;
		if (length(name)>0) or (length(key)>0) then exit;
		if (length(decode_name(ash_name))=0) and (length(decode_name(ash_firma))=0) then goto _raus;
		s:=decode_name(ash_serno);
		if length(s)<>10 then exit;
		if StrPLeft(s,2)<>'27' then goto _raus;
		if s[9]<>'0' then exit;
		if StrPRight(s,8)='00000000' then goto _raus;
		KeyCorrect:=((atol(StrPMid(s,3,6)) and 5)=(ord(s[10])-48)) and not(KeyCorrect('a','B'));
		exit;
		_raus:
		KeyCorrect:=false
	end;
{$ENDIF}


procedure DemoAlert(p: PWindow);

	begin
		if Application=nil then exit;
		{$IFDEF DEMO}
		Application^.Alert(p,1,NOTE,MESSAGE_DEMO_DEMO,BUTTON_OK)
		{$ELSE}
		Application^.Alert(p,1,NOTE,MESSAGE_DEMO_UNREG,BUTTON_OK)
		{$ENDIF}
	end;


function CreatePassCode(pword: string; var pmask: longint): longint;
	var q  : integer;
	    ret: longint;

	begin
		pmask:=0;
		CreatePassCode:=0;
		if length(pword)=0 then exit;
		ret:=0;
		for q:=1 to length(pword) do
			begin
				ret:=(((ret shl 6) xor ((ret shr 24) and $000ff000)) xor ord(pword[q]));
				pmask:=(((pmask shl 5) xor ((pmask shr 22) and $0000ff00)) xor ord(pword[q]))
			end;
		CreatePassCode:=ret
	end;


function CheckPassWord(pword: string; pcode: longint; var pmask: longint): boolean;

	begin
		CheckPassWord:=(CreatePassCode(pword,pmask)=pcode)
	end;


procedure vOpnwk(device: integer; var handle: integer; var workOut: workout_Array; psize: integer; fname: string; var prnset: PPRN_SETTINGS);
	var q     : integer;
	    workIn: workin_Array;

	begin
   	for q:=1 to 9 do workIn[q]:=1;
		workIn[0]:=device;
 		workIn[10]:=RC;
		if TexelApp.ExtPrnSel(prnset,TexelApp.app_prnt_set) then
			begin
				with AES_pb do
					begin
						control^[0]:=205;
						control^[1]:=1;
						control^[2]:=1;
						control^[3]:=2;
						control^[4]:=0;
						intin^[0]:=9;
						addrin^[0]:=TexelApp.prnt_dialog;
						addrin^[1]:=prnset;
						_crystal(@AES_pb);
						if intout^[0]=0 then
							begin
								handle:=0;
								exit
							end
					end;
				with VDI_pb do
					begin
						control^[0]:=1;
						control^[1]:=0;
						control^[3]:=16;
						control^[6]:=0;
						for q:=0 to 10 do intin^[q]:=workIn[q];
						intin^[11]:=prnset^.size_id;
						intin^[12]:=integer(HiWord(@prnset^.device));
						intin^[13]:=integer(LoWord(@prnset^.device));
						intin^[14]:=integer(HiWord(prnset));
						intin^[15]:=integer(LoWord(prnset));
						vdi(@VDI_pb);
						handle:=control^[6];
						for q:=0 to 44 do workOut[q]:=intout^[q];
						for q:=0 to 11 do workOut[q+45]:=ptsout^[q]
					end
			end
		else if (TexelApp.NVDIVersion>=$0300) and (Between(workIn[0],21,40) or Between(workIn[0],91,99)) then
			with VDI_pb do
				begin
					control^[0]:=1;
					control^[1]:=0;
					control^[3]:=16;
					control^[6]:=0;
					for q:=0 to 10 do intin^[q]:=workIn[q];
					if Between(workIn[0],31,40) then intin^[11]:=0
					else
						case psize of
						0..4:
							intin^[11]:=psize;
						5..9:
							intin^[11]:=psize+11
						else
							intin^[11]:=0
						end;
					if length(fname)=0 then
						begin
							intin^[12]:=0;
							intin^[13]:=0
						end
					else
						begin
							fname:=fname+#0;
							intin^[12]:=integer(HiWord(@fname[1]));
							intin^[13]:=integer(LoWord(@fname[1]))
						end;
					intin^[14]:=0;
					intin^[15]:=0;
					vdi(@VDI_pb);
					handle:=control^[6];
					for q:=0 to 44 do workOut[q]:=intout^[q];
					for q:=0 to 11 do workOut[q+45]:=ptsout^[q]
				end
		else
			v_opnwk(workIn,handle,workOut)
	end;


function vqtExtDevinfo(handle,devid: integer; var devstr,devtitle: string): boolean;
	var dummy: string;

	begin
		if TexelApp.NVDIVersion<$0300 then vqtExtDevinfo:=false
		else
			with VDI_pb do
				begin
					control^[0]:=248;
					control^[1]:=0;
					control^[3]:=7;
					control^[5]:=4242;
					control^[6]:=handle;
					intin^[0]:=devid;
					intin^[1]:=integer(HiWord(@dummy[1]));
					intin^[2]:=integer(LoWord(@dummy[1]));
					intin^[3]:=integer(HiWord(@devstr[1]));
					intin^[4]:=integer(LoWord(@devstr[1]));
					intin^[5]:=integer(HiWord(@devtitle[1]));
					intin^[6]:=integer(LoWord(@devtitle[1]));
					vdi(@VDI_pb);
					if intout^[0]=0 then vqtExtDevinfo:=false
					else
						begin
							vqtExtDevinfo:=true;
							devstr[0]:=chr(StrLen(@devstr[1]));
							devtitle[0]:=chr(StrLen(@devtitle[1]))
						end
				end
	end;


function vqtDevinfo(handle,devid: integer; var devstr,devtitle: string): boolean;
	var q: integer;

	begin
		if Application^.SpeedoActive then
			with VDI_pb do
				begin
					control^[0]:=248;
					control^[1]:=0;
					control^[3]:=1;
					control^[6]:=handle;
					intin^[0]:=devid;
					vdi(@VDI_pb);
					vqtDevinfo:=(ptsout^[0]<>0);
					devstr:='';
					if control^[4]>0 then
						for q:=0 to control^[4]-1 do devstr:=devstr+chr(intout^[q]);
					devtitle:=StrPPas(@ptsout^[1]);
					StrPTrim(devstr);
					devtitle:=StrPLeft(StrPTrimF(devtitle),42)
				end
		else
			begin
				vqtDevinfo:=false;
				devstr:='';
				devtitle:=''
			end
	end;


function vqtName(handle,element_num: integer; var name: string; var index: integer): boolean;
	var q: integer;

	begin
		with VDI_pb do
			begin
				control^[0]:=130;
				control^[1]:=0;
				control^[3]:=1;
				control^[6]:=handle;
				intin^[0]:=element_num;
				vdi(@VDI_pb);
				index:=intout^[0];
				name:='';
				q:=1;
				while (q<33) and (intout^[q]<>0) do
					begin
						name:=name+chr(intout^[q]);
						inc(q)
					end;
				StrPTrim(name);
				vqtName:=(control^[4]>=34) and (intout^[33]<>0) and Application^.SpeedoActive
			end
	end;


function vqtXFntInfo(handle,id: integer; pxfnt: PXFNT_INFO): boolean;

	begin
		if TexelApp.NVDIVersion<$0302 then vqtXFntInfo:=false
		else
			with VDI_pb do
				begin
					control^[0]:=229;
					control^[1]:=0;
					control^[3]:=1;
					control^[5]:=0;
					control^[6]:=handle;
					intin^[0]:=1;
					intin^[1]:=id;
					intin^[2]:=0;
					intin^[3]:=integer(HiWord(pxfnt));
					intin^[4]:=integer(LoWord(pxfnt));
					vdi(@VDI_pb);
					vqtXFntInfo:=(intout^[0]<>0)
				end
	end;


procedure vr_transfer_bits(handle: integer; src_bm,dst_bm: PBITMAPPtr; pxyarray: ARRAY_8; mode: integer);
	var q: integer;

	begin
		with VDI_pb do
			begin
				control^[0]:=170;
				control^[1]:=4;
				control^[3]:=4;
				control^[5]:=0;
				control^[6]:=handle;
				control^[7]:=integer(HiWord(src_bm));
				control^[8]:=integer(LoWord(src_bm));
				control^[9]:=integer(HiWord(dst_bm));
				control^[10]:=integer(LoWord(dst_bm));
				control^[11]:=0;
				control^[12]:=0;
				intin^[0]:=mode;
				intin^[1]:=0;
				intin^[2]:=0;
				intin^[3]:=0;
				for q:=0 to 7 do ptsin^[q]:=pxyarray[q];
				vdi(@VDI_pb)
			end
	end;


procedure vqt_real_extent(handle,x,y: integer; const calcString: string; var extent: ARRAY_8);
	var q,len: integer;

	begin
		len:=length(calcString);
		with VDI_pb do
			begin
				control^[0]:=240;
				control^[1]:=1;
				control^[3]:=len;
				control^[5]:=4200;
				control^[6]:=handle;
				ptsin^[0]:=x;
				ptsin^[1]:=y;
				if len>0 then
					for q:=1 to len do intin^[q-1]:=ord(calcString[q]);
				vdi(@VDI_pb);
				for q:=0 to 7 do extent[q]:=ptsout^[q]
			end
	end;


procedure vqt_my_extent(handle: integer; const calcString: string; var extent: ARRAY_8);

	begin
		if TexelApp.NVDIVersion>=$0300 then vqt_real_extent(handle,0,0,calcString,extent)
		else
			vqt_f_extent(handle,calcString,extent)
	end;


function vOrient(handle,orientation: integer): integer;

	begin
		with VDI_pb do
			begin
				control^[0]:=5;
				control^[1]:=0;
				control^[3]:=1;
				control^[4]:=0;
				control^[5]:=27;
				control^[6]:=handle;
				intin^[0]:=orientation
			end;
		vdi(@VDI_pb);
		if VDI_pb.control^[4]=1 then vOrient:=VDI_pb.intout^[0]
		else
			vOrient:=0
	end;


function vCopies(handle,copies: integer): integer;

	begin
		with VDI_pb do
			begin
				control^[0]:=5;
				control^[1]:=0;
				control^[3]:=1;
				control^[4]:=0;
				control^[5]:=28;
				control^[6]:=handle;
				intin^[0]:=copies
			end;
		vdi(@VDI_pb);
		if VDI_pb.control^[4]=1 then vCopies:=VDI_pb.intout^[0]
		else
			vCopies:=0
	end;


procedure vmCoords(handle,llx,lly,urx,ury: integer);

	begin
		with VDI_pb do
			begin
				control^[0]:=5;
				control^[1]:=0;
				control^[3]:=5;
				control^[5]:=99;
				control^[6]:=handle;
				intin^[0]:=1;
				intin^[1]:=llx;
				intin^[2]:=lly;
				intin^[3]:=urx;
				intin^[4]:=ury
			end;
		vdi(@VDI_pb)
	end;


function GetTexelTempDir: string;
	var s: string;

	begin
		s:=GetTempDir;
		if s=BootDevice+':\' then
			begin
				s:=TexelApp.DataPath+TEXELTEMPPATH;
				if not(PathExist(s)) then dcreate(CutRightF(s,1)+#0)
			end
		else
			if TexelApp.apPath<>nil then
				if s=TexelApp.apPath^ then
					begin
						s:=TexelApp.DataPath+TEXELTEMPPATH;
						if not(PathExist(s)) then dcreate(CutRightF(s,1)+#0)
					end;
		GetTexelTempDir:=s
	end;


procedure ScanFonts(handle,anz: integer; var fcoll: PFontCollection);
	var q,w,asked,
	    got,dval : integer;
	    nfnt     : string;
	    outl     : boolean;
	    fsiz     : array [0..127] of integer;
	    pfnt     : PFont;
	    xfntinfo : XFNT_INFO;

	begin
		BusyMouse;
		new(fcoll,Init(50,50));
		if fcoll<>nil then
			begin
				fcoll^.CaseSensitive:=false;
				if anz>0 then
					for q:=1 to anz do
						begin
							new(pfnt);
							if pfnt<>nil then
								begin
									outl:=vqtName(handle,q,nfnt,pfnt^.Index);
									xfntinfo.size:=sizeof(XFNT_INFO);
									if vqtXFntInfo(handle,pfnt^.Index,@xfntinfo) then nfnt:=StrPTrimF(StrPas(xfntinfo.font_name));
									pfnt^.Sizes:=nil;
									if outl then pfnt^.SizeCount:=0
									else
										begin
											pfnt^.SizeCount:=0;
											vst_font(handle,pfnt^.Index);
											asked:=999;
											got:=asked;
											while (got<=asked) and (pfnt^.SizeCount<=127) do
												begin
													asked:=got-1;
													got:=vst_point(handle,asked,dval,dval,dval,dval);
													fsiz[pfnt^.SizeCount]:=got;
													inc(pfnt^.SizeCount)
												end;
											if pfnt^.SizeCount=128 then pfnt^.SizeCount:=0
											else
												begin
													dec(pfnt^.SizeCount);
													getmem(pfnt^.Sizes,pfnt^.SizeCount shl 1);
													if pfnt^.Sizes=nil then pfnt^.SizeCount:=0
													else
														for w:=0 to pfnt^.SizeCount-1 do pfnt^.Sizes^[w]:=fsiz[w]
												end
										end;
									pfnt^.Name:=NewStr('  '+nfnt+' '#0);
									fcoll^.Insert(pfnt)
								end
						end
			end;
		SetSystemFont(handle,q,q,q,q);
		ArrowMouse
	end;


procedure ScanConst(var pcoll: PParameterCollection);
	label _raus,_weiter;

	var pp         : PParameter;
	    ttxt,cname,
	    ctxt,cdescr: string;
	    buf        : PByteArray;
	    res,w,
	    bufsize    : longint;
	    q,hdl      : integer;

	begin
		new(pcoll,Init(20,10));
		if pcoll=nil then exit;
		pcoll^.Sort:=false;
		buf:=GetMemBuffer(16384,128,bufsize);
		if buf=nil then exit;
		BusyMouse;
		if Exist(TexelApp.DataPath+TEXELVAL) then
			begin
				res:=fopen(TexelApp.DataPath+TEXELVAL,FO_READ);
				if res<0 then goto _weiter;
				hdl:=integer(res);
				ttxt:='';
				repeat
					res:=fread(hdl,bufsize,buf);
					if res>0 then
						for w:=0 to res-1 do
							if buf^[w]=CR then
								begin
									StrPTrim(ttxt);
									if length(ttxt)>0 then
										if not(ttxt[1] in [';','#']) then
											begin
												new(pp);
												if pp<>nil then
													begin
														cdescr:='';
														q:=pos(' ',ttxt);
														if q>0 then
															begin
																cname:=StrPLeft(ttxt,q-1);
																ttxt:=StrPTrimF(StrPRight(ttxt,length(ttxt)-q));
																q:=pos(' ',ttxt);
																if q>0 then
																	begin
																		ctxt:=StrPLeft(ttxt,q-1);
																		cdescr:=StrPTrimF(StrPRight(ttxt,length(ttxt)-q))
																	end
																else
																	ctxt:=ttxt;
																pp^.Value:=atof(ctxt);
																pp^.Name:=NewStr(cname);
																pp^.ListName:=NewStr('  '+cname+' '#0);
																pp^.Txt:=NewStr(ctxt);
																pp^.Descr:=NewStr(cdescr);
																pp^.Predef:=true;
																if (pp^.Name=nil) or (pp^.Txt=nil) then
																	begin
																		DisposeStr(pp^.Name);
																		DisposeStr(pp^.ListName);
																		DisposeStr(pp^.Txt);
																		DisposeStr(pp^.Descr);
																		dispose(pp)
																	end
																else
																	pcoll^.Insert(pp)
															end
														else
															dispose(pp)
													end
											end;
									ttxt:=''
								end
							else
								if buf^[w]>=32 then ttxt:=ttxt+chr(buf^[w])
				until res<>bufsize;
				fclose(hdl)
			end;
		_weiter:
		if Exist(TexelApp.DataPath+TEXELUSRVAL) then
			begin
				res:=fopen(TexelApp.DataPath+TEXELUSRVAL,FO_READ);
				if res<0 then goto _raus;
				hdl:=integer(res);
				ttxt:='';
				repeat
					res:=fread(hdl,bufsize,buf);
					if res>0 then
						for w:=0 to res-1 do
							if buf^[w]=CR then
								begin
									StrPTrim(ttxt);
									if length(ttxt)>0 then
										if not(ttxt[1] in [';','#']) then
											begin
												new(pp);
												if pp<>nil then
													begin
														cdescr:='';
														q:=pos(' ',ttxt);
														if q>0 then
															begin
																cname:=StrPLeft(ttxt,q-1);
																ttxt:=StrPTrimF(StrPRight(ttxt,length(ttxt)-q));
																q:=pos(' ',ttxt);
																if q>0 then
																	begin
																		ctxt:=StrPLeft(ttxt,q-1);
																		cdescr:=StrPTrimF(StrPRight(ttxt,length(ttxt)-q))
																	end
																else
																	ctxt:=ttxt;
																pp^.Value:=atof(ctxt);
																pp^.Name:=NewStr(cname);
																pp^.ListName:=NewStr('  '+cname+' '#0);
																pp^.Txt:=NewStr(ctxt);
																pp^.Descr:=NewStr(cdescr);
																pp^.Predef:=true;
																if (pp^.Name=nil) or (pp^.Txt=nil) then
																	begin
																		DisposeStr(pp^.Name);
																		DisposeStr(pp^.ListName);
																		DisposeStr(pp^.Txt);
																		DisposeStr(pp^.Descr);
																		dispose(pp)
																	end
																else
																	pcoll^.Insert(pp)
															end
														else
															dispose(pp)
													end
											end;
									ttxt:=''
								end
							else
								if buf^[w]>=32 then ttxt:=ttxt+chr(buf^[w])
				until res<>bufsize;
				fclose(hdl)
			end;
		_raus:
		freemem(buf,bufsize);
		ArrowMouse
	end;


constructor TProgressWindow.Init(AMax: longint; Titel,Datei: string);
	var st: PStatic;

	begin
		if not(inherited Init(nil,'',RTPROGRESS)) then fail;
		SetMax(AMax);
		new(st,Init(@self,RTPGACTION,17,false,''));
		if st<>nil then st^.SetText(Titel);
		new(st,Init(@self,RTPGFILE,43,false,''));
		if st<>nil then st^.SetText(CompressPath(Datei,42));
		new(pc1,Init(@self,RTPGBACK,''));
		if not(TexelApp.ColFX) then
			if pc1<>nil then
				pc1^.ObjAddr^.ob_spec.index:=(pc1^.ObjAddr^.ob_spec.index and $ffffff0f) or $10;
		new(pc2,Init(@self,RTPGDONE,''));
		if pc2<>nil then
			pc2^.ObjAddr^.ob_width:=0;
		MakeWindow
	end;


function TProgressWindow.GetStyle: integer;

	begin
		GetStyle:=0
	end;


procedure TProgressWindow.SetupWindow;

	begin
		inherited SetupWindow;
		Attr.ExStyle:=(Attr.ExStyle and not(ws_ex_TryModeless)) or ws_ex_Modeless
	end;


procedure TProgressWindow.MakeWindow;

	begin
		Create;
		OpenWindow;
		WMRedraw(Work.X,Work.Y,Work.W,Work.H)
	end;


procedure TProgressWindow.Progress(anz: longint);
	var nw: integer;

	begin
		inc(count,anz);
		if count>maxanz then count:=maxanz;
		if (pc2=nil) or (pc1=nil) or (maxanz<=0) then exit;
		nw:=round(count*longint(pc1^.ObjAddr^.ob_width)/maxanz);
		if nw<>pc2^.ObjAddr^.ob_width then
			begin
				pc2^.ObjAddr^.ob_width:=nw;
				pc2^.Paint
			end
	end;


procedure TProgressWindow.SetMax(AMax: longint);

	begin
		maxanz:=AMax;
		count:=0
	end;


constructor THyperDialog.Init(AParent: PWindow; ATitle, HypHelp,hdTitle: string; Indx: integer);

	begin
		if not(inherited Init(AParent,ATitle,Indx)) then fail;
		if TexelApp.ExtResource then LoadIcon(new(PIcon,Init(@self,RTICONS2,RTI2CALC,0,0,false,false,'','')));
		ddfiles:=nil;
		ddtext:=nil;
		hdIconTitle:=hdTitle;
		HyperHelp:=HypHelp
	end;


function THyperDialog.Help: boolean;
	var pipe: Pipearray;

	begin
		Help:=false;
		if (length(HyperHelp)=0) or not(TexelApp.HelpAvailable(true)) then exit;
		if Exist(TexelApp.DataPath+TEXELHELP) then StrPCopy(helpbuf,TexelApp.DataPath+TEXELHELP+' '+HyperHelp)
		else
			StrPCopy(helpbuf,GUIDES+TEXELHELP+' '+HyperHelp);
		pipe[0]:=VA_START;
		pipe[1]:=Application^.apID;
		pipe[2]:=0;
		pipe[3]:=integer(HiWord(helpbuf));
		pipe[4]:=integer(LoWord(helpbuf));
		pipe[5]:=0;
		pipe[6]:=0;
		pipe[7]:=0;
		appl_write(TexelApp.HelpID,16,@pipe)
	end;


function THyperDialog.WMKeyDown(Stat,Key: integer): boolean;

	begin
		WMKeyDown:=false;
		if Stat=K_CTRL then
			if Parent<>nil then
				if Parent^.GetClassName=TEXELWINDCLASS then
					case Key of
					Ctrl_B:
						begin
							WMKeyDown:=true;
							with PCalcWindow(Parent)^ do if bblock<>nil then bblock^.Work
						end
					end
	end;


function THyperDialog.DDReadArgs(dSize: longint; PipeHnd,OrgID,mX,mY,KStat: integer): boolean;

	begin
		DDReadArgs:=false;
		if ddfiles<>nil then freemem(ddfiles,StrLen(ddfiles)+1);
		getmem(ddfiles,dSize+1);
		if ddfiles<>nil then
			begin
				if fread(PipeHnd,dSize,ddfiles)<>dSize then
					begin
						freemem(ddfiles,dSize+1);
						ddfiles:=nil
					end
				else
					begin
						PChar(longint(ddfiles)+dSize)^:=#0;
						DDReadArgs:=true
					end
			end
		else
			inherited DDReadArgs(dSize,PipeHnd,OrgID,mX,mY,KStat)
	end;


function THyperDialog.DDHeaderReply(dType,dName,fName: string; dSize: longint; OrgID,mX,mY,KStat: integer): byte;

	begin
		dType:=StrPUpper(dType);
		if (dType='.TXT') or (dType='.ASC') or (dType='.FLT') then DDHeaderReply:=DD_OK
		else
			DDHeaderReply:=DD_EXT
	end;


function THyperDialog.DDReadData(dType,dName,fName: string; dSize: longint; PipeHnd,OrgID,mX,mY,KStat: integer): boolean;
	label _fehler;

	var buffer: array [0..1023] of byte;
	    count : integer;
	    tflag,
	    fnsh  : boolean;
	    s,tag : string;

	procedure fillstr(anz: integer);
		var q,w: integer;

		begin
			if StrPUpper(dType)='.FLT' then
				begin
					q:=0;
					while q<anz do
						begin
							if buffer[q]=9 then
								begin
									s:=StrPTrimF(s)+' ';
									tflag:=true;
									tag:=''
								end
							else
								if tflag then
									begin
										if buffer[q]=ord(':') then tflag:=false
										else
											tag:=tag+chr(buffer[q])
									end
								else
									if tag<>'Group' then
										if buffer[q]>=32 then
											if length(s)<255 then s:=s+chr(buffer[q]);
							inc(q)
						end;
					ddtext^:=StrPTrimF(s);
					count:=length(ddtext^)
				end
			else
				for q:=0 to anz do
					begin
						if fnsh then exit;
						if count>=255 then exit;
						if buffer[q]=13 then fnsh:=true
						else
							if buffer[q]>=32 then
								if (count>0) or (buffer[q]<>64) then
									begin
										inc(count);
										ddtext^[count]:=chr(buffer[q])
									end
					end
		end;

	begin
		DDReadData:=false;
		if dSize<=0 then exit;
		if ddtext=nil then getmem(ddtext,256);
		if ddtext=nil then exit;
		tflag:=true;
		tag:='';
		s:='';
		count:=0;
		fnsh:=false;
		while dSize>1024 do
			begin
				if fread(PipeHnd,1024,@buffer)<>1024 then goto _fehler;
				fillstr(1023);
				dec(dSize,1024);
			end;
		if fread(PipeHnd,dSize,@buffer)<>dSize then goto _fehler;
		fillstr(dSize-1);
		if count=0 then goto _fehler;
		ddtext^[0]:=chr(count);
		DDReadData:=true;
		exit;
		_fehler:
		freemem(ddtext,256);
		ddtext:=nil
	end;


procedure THyperDialog.DDFinished(OrgID,mX,mY,KStat: integer);
	var p  : PChar;
	    q  : integer;
	    s,e: string;

	begin
		if ddtext<>nil then
			begin
				if GetClassName=TEXELWINDCLASS then
					with PCalcWindow(@self)^ do
						if (inpline<>nil) and not(inpstat) then
							begin
								if Parms.Cursor.Block then SetCursorPos(Parms.Cursor.Row,Parms.Cursor.Col,true);
								inpline^.Clear;
								EnableInpline
							end;
				for q:=1 to length(ddtext^) do InsertChar(ddtext^[q]);
				freemem(ddtext,256);
				ddtext:=nil
			end
		else
			if ddfiles<>nil then
				begin
					p:=ddfiles;
					while p<>nil do
						begin
							s:=GetQuotedName(p);
							if GetClassName=TEXELWINDCLASS then
								begin
									e:=StrPUpper(GetExtension(s));
									if e='.IMG' then
										begin
											if PCalcWindow(@self)^.grafik<>nil then PCalcWindow(@self)^.grafik^.Load(s)
										end
									else if (e='.TXT') or (e='.ASC') then
										begin
											if PCalcWindow(@self)^.textobj<>nil then PCalcWindow(@self)^.textobj^.Load(s)
										end
									else
										TexelApp.LoadFile(PCalcWindow(@self),s)
								end
							else
								TexelApp.LoadFile(nil,s)
						end;
					freemem(ddfiles,StrLen(ddfiles)+1);
					ddfiles:=nil
				end
	end;


function THyperDialog.GetIconTitle: string;

	begin
		GetIconTitle:=hdIconTitle
	end;


function TBlockChangeDialog.GetClassName: string;

	begin
		GetClassName:=BLOCKWINDCLASS
	end;


procedure TBlockChangeDialog.BlockChanged(blk: string);

	begin
	end;


function TFunctionCollection.KeyOf(Item: pointer): pointer;

	begin
		if Item=nil then KeyOf:=nil
		else
			KeyOf:=PFunction(Item)^.Name
	end;


procedure TFunctionCollection.FreeItem(Item: pointer);

	begin
		if Item<>nil then
			begin
				DisposeStr(PFunction(Item)^.Name);
				DisposeStr(PFunction(Item)^.Parms);
				DisposeStr(PFunction(Item)^.Descr1);
				DisposeStr(PFunction(Item)^.Descr2);
				dispose(PFunction(Item))
			end
	end;


function TOLECollection.KeyOf(Item: pointer): pointer;

	begin
		if Item=nil then KeyOf:=nil
		else
			KeyOf:=POLEType(Item)^.Descr
	end;


procedure TOLECollection.FreeItem(Item: pointer);

	begin
		if Item<>nil then
			begin
				DisposeStr(POLEType(Item)^.Descr);
				dispose(POLEType(Item))
			end
	end;


function TFormatCollection.KeyOf(Item: pointer): pointer;

	begin
		if Item=nil then KeyOf:=nil
		else
			KeyOf:=PFormat(Item)^.Name
	end;


procedure TFormatCollection.FreeItem(Item: pointer);

	begin
		if Item<>nil then
			begin
				DisposeStr(PFormat(Item)^.Name);
				dispose(PFormat(Item))
			end
	end;


function TCategoryCollection.KeyOf(Item: pointer): pointer;

	begin
		if Item=nil then KeyOf:=nil
		else
			KeyOf:=PCategory(Item)^.Name
	end;


procedure TCategoryCollection.FreeItem(Item: pointer);

	begin
		if Item<>nil then
			begin
				DisposeStr(PCategory(Item)^.Name);
				dispose(PCategory(Item))
			end
	end;


function TParameterCollection.KeyOf(Item: pointer): pointer;

	begin
		if Item=nil then KeyOf:=nil
		else
			KeyOf:=PParameter(Item)^.ListName
	end;


procedure TParameterCollection.FreeItem(Item: pointer);

	begin
		if Item<>nil then
			begin
				DisposeStr(PParameter(Item)^.Name);
				DisposeStr(PParameter(Item)^.ListName);
				DisposeStr(PParameter(Item)^.Txt);
				DisposeStr(PParameter(Item)^.Descr);
				dispose(PParameter(Item))
			end
	end;


function TLinkCollection.KeyOf(Item: pointer): pointer;

	begin
		if Item=nil then KeyOf:=nil
		else
			KeyOf:=PLinkData(Item)^.Descr
	end;


procedure TLinkCollection.FreeItem(Item: pointer);

	begin
		if Item<>nil then
			begin
				DisposeStr(PLinkData(Item)^.Descr);
				dispose(PLinkData(Item))
			end
	end;


function TVariableCollection.KeyOf(Item: pointer): pointer;

	begin
		if Item=nil then KeyOf:=nil
		else
			KeyOf:=PVariable(Item)^.Name
	end;


procedure TVariableCollection.FreeItem(Item: pointer);

	begin
		if Item<>nil then
			begin
				DisposeStr(PVariable(Item)^.Name);
				dispose(PVariable(Item))
			end
	end;


function TFontCollection.KeyOf(Item: pointer): pointer;

	begin
		if Item=nil then KeyOf:=nil
		else
			KeyOf:=PFont(Item)^.Name
	end;


procedure TFontCollection.FreeItem(Item: pointer);

	begin
		if Item<>nil then
			begin
				DisposeStr(PFont(Item)^.Name);
				if PFont(Item)^.SizeCount>0 then freemem(PFont(Item)^.Sizes,PFont(Item)^.SizeCount shl 1);
				Dispose(PFont(Item))
			end
	end;


procedure TFontSelectBox.Changed(AnIndx: integer; DblClick: boolean);

	begin
		if DblClick then
			if Parent^.GetClassName=TEXELWINDCLASS then
				begin
					PCalcWindow(Parent)^.FontSelect;
					exit
				end;
		inherited Changed(AnIndx,DblClick)
	end;


procedure TFontSelectBox.OpenPopup;

	begin
		Popup^.SetOffset(GetSelection)
	end;


procedure TFontBox.SetValue(Sel: integer);

	begin
		if Popup<>nil then SetText(StrPTrimF(StrPLeft(StrPTrimF(Popup^.GetText(Sel)),25)))
	end;


procedure TFontBox.Work;
	var p      : PStringCollection;
	    pf     : PFont;
	    q,n,old,
	    neu,cm,
	    oldofs : integer;
	    dummy  : string;
	    found,
	    chng   : boolean;

	begin
		if (GetSelection<0) or (GetSelection>=List^.Count) or (fsizebox=nil) then exit;
		p:=fsizebox^.List;
		pf:=PFont(List^.At(GetSelection));
		if (p=nil) or (pf=nil) then exit;
		old:=atol(fsizebox^.GetText);
		if old=0 then old:=10;
		if fsizebox^.Popup<>nil then oldofs:=fsizebox^.Popup^.GetOffset;
		cm:=fsizebox^.GetSelection;
		fsizebox^.ClearSelection(true);
		if (pf^.SizeCount<>0) or (p^.Count<>124) then
			begin
				chng:=true;
				p^.FreeAll;
				if pf^.SizeCount=0 then
					begin
						for q:=4 to 127 do
							begin
								if q<10 then dummy:='    '
								else
									if q<100 then dummy:='   '
									else
										dummy:='  ';
								p^.Insert(NewStr(dummy+ltoa(q)+' '#0))
							end;
						neu:=old;
						cm:=neu-4
					end
				else
					begin
						found:=false;
						for q:=0 to pf^.SizeCount-1 do
							begin
								n:=pf^.Sizes^[q];
								if n<10 then dummy:='    '
								else
									if n<100 then dummy:='   '
									else
										dummy:='  ';
								p^.Insert(NewStr(dummy+ltoa(n)+' '#0));
								if not(found) then
									if n<=old then
										begin
											if q=0 then
												begin
													neu:=n;
													cm:=pf^.SizeCount-1
												end
											else
												if (old-n)>(pf^.Sizes^[q-1]-old) then
													begin
														neu:=pf^.Sizes^[q-1];
														cm:=pf^.SizeCount-q
													end
												else
													begin
														neu:=n;
														cm:=pf^.SizeCount-q-1
													end;
											found:=true
										end
							end
					end
			end
		else
			chng:=false;
		with fsizebox^ do
			begin
				if chng then
					if Popup<>nil then
						with Popup^ do
							begin
								SetCollection(p);
								SetOffset(oldofs)
							end;
				setsize:=false;
				if newsize<0 then SetSelection(cm,true)
				else
					begin
						SetSelection(PCalcWindow(Parent)^.FontSize2Index(newsize),false);
						newsize:=-1
					end;
				setsize:=true
			end
	end;


procedure TFontSizeBox.Work;
	var rs,cs,re,ce,
	    cmin,cmax,
	    x,y,nsize,
	    nfont      : integer;
	    cell       : PCell;
	    p          : PCalcWindow;

	begin
		with PWindow(Parent)^ do
			begin
				if GetClassName<>TEXELWINDCLASS then exit;
				if Attr.Status<>ws_Open then exit
			end;
		nsize:=atol(GetText);
		if nsize<4 then exit;
		p:=PCalcWindow(Parent);
		nfont:=PFont(p^.pfbox^.List^.At(p^.pfbox^.GetSelection))^.Index;
		with p^.Parms.Cursor do
			if Block then
				begin
					rs:=RowStart;
					re:=RowEnd;
					cs:=ColStart;
					ce:=ColEnd
				end
			else
				begin
					rs:=Row;
					re:=Row;
					cs:=Col;
					ce:=Col
				end;
		cmin:=cs;
		cmax:=ce;
		p^.RowsClearOverflow(rs,re,cmin,cmax);
		for y:=rs to re do
			begin
				cell:=p^.GetCell(y,cs);
				for x:=cs to ce do
					begin
						with cell^.TxtVal do
							begin
								if not(setsize) or (Font=0) then Font:=nfont;
								if setsize or (Size=0) then Size:=nsize
							end;
						inc(longint(cell),CELLSIZE)
					end
			end;
		p^.RowsCheckOverflow(rs,re,cmin,cmax);
		p^.SetDirty;
		p^.DrawCells(rs,cmin,re,cmax)
	end;


function TRowSizeDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		if AnIndx=RTRSROW then WMKeyDown(K_CTRL,Ctrl_B)
	end;


function TRowSizeDialog.OK: boolean;
	var valid    : boolean;
	    von,bis,q: integer;
	    p        : PCalcWindow;
	    nh       : longint;

	begin
		valid:=inherited OK;
		if valid then
			begin
				p:=PCalcWindow(Parent);
				with p^ do
					begin
						GetBlock(dblock^.GetText,false,von,q,bis,q,q,q);
						nh:=Max(round(atof(rsbuffer)*100.0-longint(Application^.Attr.PixH)/10.0),0)
					end;
				if bis>von then
					for q:=bis downto von+1 do p^.SetRowHeight_mm100(q,nh,false);
				p^.SetRowHeight_mm100(von,nh,true)
			end;
		OK:=valid
	end;


procedure TRowSizeDialog.BlockChanged(blk: string);
	var rs,re,dummy: integer;

	begin
		PCalcWindow(Parent)^.GetBlock(blk,false,rs,dummy,re,dummy,dummy,dummy);
		if ed1<>nil then
			begin
				if rs=re then ed1^.SetText(STRING_ROW+': '+PCalcWindow(Parent)^.GetRowIndex(rs))
				else
					ed1^.SetText(STRING_ROW+': '+PCalcWindow(Parent)^.GetRowIndex(rs)+' '+STRING_ROWTO+' '+PCalcWindow(Parent)^.GetRowIndex(re))
			end
	end;


function TColSizeDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		if AnIndx=RTCSCOLUMN then WMKeyDown(K_CTRL,Ctrl_B)
	end;


function TColSizeDialog.OK: boolean;
	var valid    : boolean;
	    von,bis,q: integer;
	    p        : PCalcWindow;
	    nw       : longint;

	begin
		valid:=inherited OK;
		if valid then
			begin
				p:=PCalcWindow(Parent);
				with p^ do
					begin
						GetBlock(dblock^.GetText,false,q,von,q,bis,q,q);
						nw:=Max(round(atof(csbuffer)*100.0-longint(Application^.Attr.PixW)/10.0),0)
					end;
				if bis>von then
					for q:=bis downto von+1 do p^.SetColWidth_mm100(q,nw,false);
				p^.SetColWidth_mm100(von,nw,true)
			end;
		OK:=valid
	end;


procedure TColSizeDialog.BlockChanged(blk: string);
	var cs,ce,dummy: integer;
	    p          : PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		p^.GetBlock(blk,false,dummy,cs,dummy,ce,dummy,dummy);
		if ed1<>nil then
			begin
				if cs=ce then ed1^.SetText(STRING_COL+': '+p^.GetColumnIndex(cs))
				else
					ed1^.SetText(STRING_COL+': '+p^.GetColumnIndex(cs)+' '+STRING_COLTO+' '+p^.GetColumnIndex(ce))
			end
	end;


function TColNameDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		if AnIndx=RTCNCOLUMN then WMKeyDown(K_CTRL,Ctrl_B)
	end;


function TColNameDialog.OK: boolean;
	var valid,v: boolean;
	    q      : integer;
	    r      : GRECT;
	    p      : PCalcWindow;
	    ncol   : string;

	begin
		valid:=inherited OK;
		if valid then
			begin
				p:=PCalcWindow(Parent);
				with p^ do
					with cnbuffer do
						begin
							StrPTrim(nnew);
							StrPTrim(nold);
							if nold<>nnew then
								begin
									ncol:=StrPTrimF(StrPRight(st1^.GetText,length(st1^.GetText)-7));
									q:=ColIndex2Nr(ncol,true);
									DisposeStr(PString(PColNames^[q]));
									if nnew<>ncol then PColNames^[q]:=NewStr(nnew);
									SetDirty;
									wind_update(BEG_UPDATE);
									HideMouse;
									v:=FirstWorkRect(r);
									while v do
										begin
											PaintNames(r);
											v:=NextWorkRect(r)
										end;
									vs_clip(Application^.vdiHandle,CLIP_ON,SysInfo.Desktop.A2);
									ShowMouse;
									wind_update(END_UPDATE)
								end
						end
			end;
		OK:=valid
	end;


procedure TColNameDialog.BlockChanged(blk: string);
	var cs,dummy: integer;
	    p       : PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		p^.GetBlock(blk,false,dummy,cs,dummy,dummy,dummy,dummy);
		if st1<>nil then st1^.SetText(STRING_COL+':     '+p^.GetColumnIndex(cs));
		if st2<>nil then st2^.SetText(p^.GetColumnName(cs));
		if ed1<>nil then ed1^.SetText(p^.GetColumnName(cs))
	end;


function TRahmenBox.TestIndex(AnIndx: integer): boolean;

	begin
		if AnIndx=ObjAddr^.ob_head then
			begin
				TestIndex:=true;
				exit
			end;
		TestIndex:=inherited TestIndex(AnIndx)
	end;


procedure TRahmenBox.Changed(AnIndx: integer; DblClick: boolean);

	begin
		if AnIndx=ObjAddr^.ob_head then AnIndx:=ObjIndx;
		inherited Changed(AnIndx,DblClick)
	end;


procedure TRahmenBox.SetValue(Sel: integer);
	var p: PTree;

	begin
		if Sel<3 then
			begin
				with PCalcWindow(Parent)^.DlgTree^[ObjAddr^.ob_head] do ob_flags:=ob_flags or HIDETREE;
				inherited SetValue(Sel)
			end
		else
			begin
				p:=Application^.GetAddr(RTICONS);
				with PCalcWindow(Parent)^.DlgTree^[ObjAddr^.ob_head] do
					begin
						ob_flags:=ob_flags and not(HIDETREE);
						ob_spec.bit_blk^.bi_pdata:=p^[p^[RTILINIEN].ob_head+Sel-3].ob_spec.bit_blk^.bi_pdata
					end;
				SetText('')
			end
	end;


function TRahmenDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTRASETZEN);
		OK:=valid
	end;


procedure TRahmenDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk)
	end;


function TRahmenDialog.ExitDlg(AnIndx: integer): boolean;
	var trb: TRahmenBuffer;
	    prb: pointer;

	begin
		ExitDlg:=false;
		case AnIndx of
		RTRABEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTRASETZEN:
			begin
				prb:=TransferBuffer;
				TransferBuffer:=@trb;
				TransferData(tf_GetData);
				TransferBuffer:=prb;
				with trb do
					PCalcWindow(Parent)^.SetBorder(lline-1,color,rline-1,color,oline-1,color,uline-1,color,hline-1,hcolor,vline-1,vcolor,gline-1,gcolor)
			end
		end
	end;


function TPatternDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTMSETZEN);
		OK:=valid
	end;


procedure TPatternDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk)
	end;


function TPatternDialog.ExitDlg(AnIndx: integer): boolean;
	var dummy,
	    st,pt,
	    x,y,
	    rs,cs,
	    re,ce: integer;
	    p    : PCalcWindow;
	    cell : PCell;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTMBEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTMSETZEN:
			begin
				with p^.Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				st:=(ps^.ObjAddr^.ob_spec.index shr 4) and $7;
				if st=7 then st:=8;
				dummy:=ps^.GetColor;
				if (st=0) and (dummy=White) then
					begin
						pt:=FIS_HOLLOW;
						st:=8
					end
				else
					if st=8 then pt:=FIS_SOLID
					else
						pt:=FIS_PATTERN;
				for y:=rs to re do
					begin
						cell:=p^.GetCell(y,cs);
						for x:=cs to ce do
							begin
								cell^.Color:=dummy;
								cell^.Interior:=pt;
								cell^.Style:=st;
								inc(longint(cell),CELLSIZE)
							end
					end;
				p^.SetDirty;
				p^.DrawCells(rs,cs,re,ce)
			end
		else
			if (AnIndx>=pc^.ObjAddr^.ob_head) and (AnIndx<=pc^.ObjAddr^.ob_tail) then
				begin
					ps^.SetColor(AnIndx-pc^.ObjAddr^.ob_head);
					Color2Name
				end
			else
				if (AnIndx>=pp^.ObjAddr^.ob_head) and (AnIndx<=pp^.ObjAddr^.ob_tail) then
					begin
						dummy:=AnIndx-pp^.ObjAddr^.ob_head;
						if dummy<>((ps^.ObjAddr^.ob_spec.index shr 4) and $7) then
							begin
								with ps^.ObjAddr^.ob_spec do index:=(index and $ffffff8f) or (dummy shl 4);
								ps^.Paint
							end
					end
		end
	end;


procedure TPatternDialog.Color2Name;
	var s: string;

	begin
		s:=TexelApp.Farben[ps^.GetColor];
		cn^.SetText(StrPSpace(15-length(s))+s)
	end;


function TTextAttrDialog.ChangeValues: boolean;
	var rs,cs,re,
	    ce,x,y,
	    cmin,cmax,
	    nalgn,
	    nalgn2,
	    dummy,
	    nrot,nskw: integer;
	    p        : PCalcWindow;
	    cell     : PCell;

	begin
		p:=PCalcWindow(Parent);
		ChangeValues:=false;
		if p^.GetBlock(bedt^.GetText,false,rs,cs,re,ce,dummy,dummy) then
			begin
				cmin:=cs;
				cmax:=ce;
				p^.RowsClearOverflow(rs,re,cmin,cmax);
				if p^.txabuffer.right=bf_Checked then nalgn:=TA_RIGHT
				else
					if p^.txabuffer.center=bf_Checked then nalgn:=TA_CENTER
					else
						nalgn:=TA_LEFT;
				if p^.txabuffer.oben=bf_Checked then nalgn2:=TA_OBEN
				else
					if p^.txabuffer.mitte=bf_Checked then nalgn2:=TA_MITTE
					else
						nalgn2:=TA_UNTEN;
				nrot:=round(atof(p^.txabuffer.rotat)*10);
				nskw:=round(atof(p^.txabuffer.skew)*10);
				for y:=rs to re do
					begin
						cell:=p^.GetCell(y,cs);
						for x:=cs to ce do
							begin
								with cell^.TxtVal do
									begin
										if p^.txabuffer.rotoff=bf_Checked then Rotat:=nrot;
										if p^.txabuffer.skewoff=bf_Checked then Skew:=nskw;
										if p^.txabuffer.coloff=bf_Checked then Color:=p^.txabuffer.color;
										if p^.txabuffer.alignoff=bf_Checked then Align:=(Align and $f0) or nalgn;
										if p^.txabuffer.alignoff2=bf_Checked then Align:=(Align and $0f) or nalgn2;
										if p^.txabuffer.clip=bf_Checked then Flags:=Flags or TFL_CLIP
										else
											if p^.txabuffer.clip=bf_Unchecked then Flags:=Flags and not(TFL_CLIP);
										if p^.txabuffer.bold=bf_Checked then Effects:=Effects or TF_THICKENED
										else
											if p^.txabuffer.bold=bf_Unchecked then Effects:=Effects and not(TF_THICKENED);
										if p^.txabuffer.light=bf_Checked then Effects:=Effects or TF_LIGHTENED
										else
											if p^.txabuffer.light=bf_Unchecked then Effects:=Effects and not(TF_LIGHTENED);
										if p^.txabuffer.italic=bf_Checked then Effects:=Effects or TF_SLANTED
										else
											if p^.txabuffer.italic=bf_Unchecked then Effects:=Effects and not(TF_SLANTED);
										if p^.txabuffer.under=bf_Checked then Effects:=Effects or TF_UNDERLINED
										else
											if p^.txabuffer.under=bf_Unchecked then Effects:=Effects and not(TF_UNDERLINED);
										if p^.txabuffer.outl=bf_Checked then Effects:=Effects or TF_OUTLINED
										else
											if p^.txabuffer.outl=bf_Unchecked then Effects:=Effects and not(TF_OUTLINED);
										if p^.txabuffer.shadow=bf_Checked then Effects:=Effects or TF_SHADOWED
										else
											if p^.txabuffer.shadow=bf_Unchecked then Effects:=Effects and not(TF_SHADOWED);
									end;
								inc(longint(cell),CELLSIZE)
							end
					end;
				p^.RowsCheckOverflow(rs,re,cmin,cmax);
				p^.SetDirty;
				p^.DrawCells(rs,cmin,re,cmax);
				p^.CheckToolbarTextFX(p^.GetCell(rs,cs));
				ChangeValues:=true
			end
		else
			Application^.Alert(@self,1,NOTE,MESSAGE_GENERAL_RANGE,BUTTON_OK)
	end;


procedure TTextAttrDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk)
	end;


function TTextAttrDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then valid:=ChangeValues;
		OK:=valid
	end;


function TTextAttrDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		case AnIndx of
		RTTABEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTTANONE:
			begin
				if cb1<>nil then cb1^.Uncheck;
				if cb2<>nil then cb2^.Uncheck;
				if cb3<>nil then cb3^.Uncheck;
				if cb4<>nil then cb4^.Uncheck;
				if cb5<>nil then cb5^.Uncheck;
				if cb6<>nil then cb6^.Uncheck
			end;
		RTTAFXOFF:
			begin
				if cb1<>nil then cb1^.Gray;
				if cb2<>nil then cb2^.Gray;
				if cb3<>nil then cb3^.Gray;
				if cb4<>nil then cb4^.Gray;
				if cb5<>nil then cb5^.Gray;
				if cb6<>nil then cb6^.Gray
			end;
		RTTASET:
			begin
				TransferData(tf_GetData);
				ChangeValues
			end
		end;
		ExitDlg:=false
	end;


function TNumFormatsDialog.ExitDlg(AnIndx: integer): boolean;
	var p    : PCalcWindow;
	    rs,cs,
	    re,ce,
	    x,y,
	    idx  : integer;
	    cell : PCell;
	    vrnd : boolean;
	    s    : string;
	    pfm  : PFormat;

	function checkinp: boolean;
		var q,anz: integer;

		begin
			checkinp:=false;
			if p^.UsrFormats=nil then
				begin
					Application^.Bing;
					exit
				end;
			s:=StrPTrimF(p^.nformbuffer.format);
			if length(s)=0 then
				begin
					Application^.Alert(@self,1,NOTE,MESSAGE_NUMFORM_EMPTY,BUTTON_OK);
					exit
				end;
			anz:=0;
			for q:=1 to length(s) do if s[q]=';' then inc(anz);
			if anz>2 then
				begin
					Application^.Alert(@self,1,NOTE,MESSAGE_NUMFORM_PARTS,BUTTON_OK);
					exit
				end;
			anz:=0;
			for q:=1 to length(s) do
				if s[q] in ['(','[','{'] then
					begin
						if anz<>0 then break
						else
							if s[q]='(' then anz:=1
							else
								if s[q]='[' then anz:=2
								else
									anz:=3
					end
				else
					if (s[q]=')') then
						begin
							dec(anz);
							if anz<>0 then break
						end
					else
						if (s[q]=']') then
							begin
								dec(anz,2);
								if anz<>0 then break
							end
						else
							if (s[q]='}') then
								begin
									dec(anz,3);
									if anz<>0 then break
								end;
			if anz<>0 then
				begin
					Application^.Alert(@self,1,NOTE,MESSAGE_NUMFORM_BRACES,BUTTON_OK);
					exit
				end;
			checkinp:=true
		end;

	begin
		p:=PCalcWindow(Parent);
		TransferData(tf_GetData);
		case AnIndx of
		RTFBEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTFNEW:
			if checkinp then p^.NewNumFormat(s);
		RTFCHANGE:
			if checkinp then
				begin
					idx:=PFormat(pfcb^.fbox^.List^.At(p^.nformbuffer.frmindex))^.Index;
					pfm:=PFormat(p^.UsrFormats^.At(idx-1000));
					DisposeStr(pfm^.Name);
					pfm^.Name:=NewStr(s);
					p^.SetDirty;
					pfcb^.Work;
					p^.ForceVRedraw
				end;
		RTFDELETE:
			begin
				idx:=PFormat(pfcb^.fbox^.List^.At(p^.nformbuffer.frmindex))^.Index;
				pfm:=PFormat(p^.UsrFormats^.At(idx-1000));
				if Application^.Alert(@self,1,WAIT,MESSAGE_NUMFORM_DEL1+StrPTrimF(pfm^.Name^)+MESSAGE_NUMFORM_DEL2,BUTTON_YESNO)=1 then
					begin
						if p^.UsrFormats^.Count>(idx-999) then
							for y:=idx-999 to p^.UsrFormats^.Count-1 do dec(PFormat(p^.UsrFormats^.At(y))^.Index);
						p^.UsrFormats^.AtDelete(idx-1000);
						cell:=p^.Sheet;
						for y:=0 to p^.Parms.Rows do
							for x:=0 to p^.Parms.Columns do
								begin
									if cell^.Format=idx then cell^.Format:=0
									else
										if cell^.Format>idx then dec(cell^.Format);
									inc(longint(cell),CELLSIZE)
								end;
						p^.SetDirty;
						pfcb^.Work;
						p^.ForceVRedraw
					end
			end;
		RTFSET:
			begin
				idx:=PFormat(pfcb^.fbox^.List^.At(p^.nformbuffer.frmindex))^.Index;
				with p^ do
					begin
						with Parms.Cursor do
							if Block then
								begin
									rs:=RowStart;
									re:=RowEnd;
									cs:=ColStart;
									ce:=ColEnd
								end
							else
								begin
									rs:=Row;
									re:=Row;
									cs:=Col;
									ce:=Col
								end;
						vrnd:=false;
						for y:=rs to re do
							begin
								cell:=GetCell(y,cs);
								for x:=cs to ce do
									begin
										if cell^.Format<>idx then
											begin
												cell^.Format:=idx;
												vrnd:=true
											end;
										inc(longint(cell),CELLSIZE)
									end
							end;
						if vrnd then
							begin
								SetDirty;
								DrawCells(rs,cs,re,ce)
							end
						else
							Application^.Bing
					end
			end
		end;
		ExitDlg:=false
	end;


procedure TNumFormatsDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk);
		pfcb^.fbox^.Work
	end;


function TNumFormatsDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTFSET);
		OK:=valid
	end;


constructor TInputEdit.Init(AParent: PDialog; AnIndx,ATextLen: integer);

	begin
		if not(inherited Init(AParent,AnIndx,ATextLen,'')) then fail
	end;


function TInputEdit.IsHelpAvailable: boolean;

	begin
		IsHelpAvailable:=true
	end;


function TInputEdit.GetHelp: string;
	var txt: string;

	begin
		txt:=GetText;
		if length(GetText)=0 then GetHelp:=BUBBLE_INPUT_EMPTY
		else
			GetHelp:='"'+txt+'"'
	end;


constructor TCalcWindow.Init;
	var dummy: longint;

	begin
		currvalid:=false;
		if not(inherited Init(nil,TEXELWINDPREFIX+'['+STRING_NONAME+' '+ltoa(TexelApp.SheetCount+1)+']',STG_CALCWINDOW,'',RTWDIALOG)) then fail;
		CommonInit1;
		inc(TexelApp.SheetCount);
		CommonParmInit(true);
		getmem(PRow,(Parms.Rows+1) shl 1);
		getmem(PCol,(Parms.Columns+1) shl 1);
		getmem(PColNames,(Parms.Columns+1) shl 2);
		if PColNames<>nil then fillchar(PColNames^,(Parms.Columns+1) shl 2,0);
		dummy:=longint(Parms.Rows+1)*longint(Parms.Columns+1)*CELLSIZE;
		getmem(Sheet,dummy);
		if Sheet<>nil then fillchar(Sheet^,dummy,0);
		if (PRow=nil) or (PCol=nil) or (Sheet=nil) or (PColNames=nil) or (PRowFlags=nil) or (PColFlags=nil) then
			begin
				TexelApp.ErrorWindowMemory(@self);
				Done;
				ArrowMouse;
				fail
			end;
		TexelApp.InitCells(Sheet,Parms.Rows+1,Parms.Columns+1);
		Sheet^.Flags:=CELL_SELECTED;
		ScanConst(Parameter);
		CommonInit2(true);
		pdirbox^.SetSelection(CRS_DOWN,true);
		if abandon<>nil then abandon^.Disable
	end;


constructor TCalcWindow.InitImport(pg: PProgressWindow; rw,cl: integer; const FNam: string; ASheet: PCell; ARow,ACol: PWordArray; CNam: PItemList; breiten: boolean);
	var cell : PCell;
	    q,w  : longint;
	    vars : string;
	    dummy: PString;

	begin
		currvalid:=false;
		if FNam=StrPUpper(FNam) then vars:=StrPUpper(TEXELEXTENSION)
		else
			vars:=TEXELEXTENSION;
		if not(inherited Init(nil,CompressPath(GetPath(FNam)+GetFilename(FNam,false)+'.'+vars,76),STG_CALCWINDOW,'',RTWDIALOG)) then
			begin
				if pg<>nil then dispose(pg,Done);
				fail
			end;
		CommonInit1;
		longfile:=GetPath(FNam)+GetFilename(FNam,false)+'.'+vars;
		Parms.Rows:=rw;
		Parms.Columns:=cl;
		CommonParmInit(false);
		if (PRowFlags=nil) or (PColFlags=nil) then
			begin
				if PRowFlags<>nil then freemem(PRowFlags,Parms.Rows+1);
				if PColFlags<>nil then freemem(PColFlags,Parms.Columns+1);
				TexelApp.ErrorWindowMemory(@self);
				fail
			end;
		Sheet:=ASheet;
		PRow:=ARow;
		PCol:=ACol;
		PColNames:=CNam;
		ScanConst(Parameter);
		cell:=Sheet;
		for w:=0 to Parms.Rows do
			begin
				for q:=0 to Parms.Columns do
					begin
						if cell^.Typ=CTYPE_PARSED then
							begin
								{ !!! }
							end
						else
							if cell^.Typ=CTYPE_FORMULA then
								begin
									if Parse(cell^.Data.Formula^.VarDef^,vars,cell^.Data.Formula^.Func,cell,0,0,true) then
										begin
											DisposeStr(cell^.Data.Formula^.VarDef);
											cell^.Data.Formula^.VarDef:=NewStr(vars)
										end
									else
										begin
											dummy:=cell^.Data.Formula^.VarDef;
											dispose(cell^.Data.Formula);
											cell^.Typ:=CTYPE_TEXT;
											cell^.Data.Txt:=dummy
										end
								end;
						inc(longint(cell),CELLSIZE)
					end;
				if pg<>nil then pg^.Progress(1)
			end;
		Sheet^.Flags:=CELL_SELECTED;
		if pg<>nil then dispose(pg,Done);
		CommonInit2(breiten);
		pdirbox^.SetSelection(CRS_DOWN,true);
		if abandon<>nil then abandon^.Disable;
		SetCursorPos(0,0,true);
		SheetCheckOverflow;
		Calculate(true)
	end;


constructor TCalcWindow.InitFile(const FNam: string; pg: PProgressWindow; const AParm: TTexelParms; const ADBuf: TDialogBuffer; const ASBuf: TSheetBuffer; const FBuf: TFindBuf; const RBuf: TReplaceBuf; const FlBuf: TFillBuffer;
                                 const zBuf: TZielBuf; const ExBuf: TExportBuf; const SrtBuf: TSortBuf; const InfBuf: TInfoBuf; const DiaBuf: TDiagrammBuf;
                                 ASheet: PCell; ARow,ACol: PWordArray; CNam: PItemList; Parm: PParameterCollection; UFrm: PFormatCollection; ProtoEmb: PProtoEmbedded;
                                 apwd: TPassWord; bhist: PStringCollection; CFlags,RFlags: PByteArray; prntset: PPRN_SETTINGS; prnrange: integer; drt,checkover: boolean);
	var cell: PCell;
	    q,w : longint;
	    vars: string;
	    r,c : integer;
	    pv  : PVariable;

	begin
		Curr:=AParm.CurrSize;
		currvalid:=true;
		if not(inherited Init(nil,CompressPath(FNam,76),STG_CALCWINDOW,'',RTWDIALOG)) then
			begin
				if pg<>nil then dispose(pg,Done);
				fail
			end;
		CommonInit1;
		PassWord:=apwd;
		BlockHistory:=bhist;
		longfile:=FNam;
		Parms:=AParm;
		dtbuffer:=ADBuf;
		sheetbuffer:=ASBuf;
		findbuf:=FBuf;
		replacebuf:=RBuf;
		fillbuf:=FlBuf;
		exportbuf:=ExBuf;
		diagrammbuf:=DiaBuf;
		zwbuf:=zBuf;
		sortbuf:=SrtBuf;
		infobuf:=InfBuf;
		Sheet:=ASheet;
		PRow:=ARow;
		PCol:=ACol;
		PColNames:=CNam;
		PColFlags:=CFlags;
		PRowFlags:=RFlags;
		Parameter:=Parm;
		UsrFormats:=UFrm;
		tbactive:=(Parms.Toolbar=bf_Checked);
		if prntset<>nil then TexelApp.ExtPrnSel(wnd_prnt_set,prntset);
		if prnrange>=0 then prnRangeFlag:=prnrange;
		cell:=Sheet;
		for w:=0 to Parms.Rows do
			begin
				for q:=0 to Parms.Columns do
					begin
						if cell^.Typ=CTYPE_PARSED then
							begin
								cell^.Typ:=CTYPE_FORMULA;
								if cell^.Data.Formula^.VarDef<>nil then
									begin
										if Variables=nil then
											begin
												new(Variables,Init(20,10));
												if Variables<>nil then Variables^.CaseSensitive:=false
											end;
										if Variables<>nil then
											begin
												new(pv);
												if pv<>nil then
													begin
														pv^.Name:=NewStr(cell^.Data.Formula^.VarDef^);
														if pv^.Name=nil then dispose(pv)
														else
															begin
																pv^.RefRow:=w;
																pv^.RefCol:=q;
																Variables^.Insert(pv)
															end
													end
											end
									end
							end
						else
							if cell^.Typ=CTYPE_FORMULA then
								with cell^.Data.Formula^ do
									begin
										Parse(VarDef^,vars,Func,cell,0,0,true);
										DisposeStr(VarDef);
										VarDef:=NewStr(vars)
									end;
						inc(longint(cell),CELLSIZE)
					end;
				if pg<>nil then pg^.Progress(1)
			end;
		with Parms.Cursor do
			if not(Block) then
				begin
					cell:=GetCell(Row,Col);
					with cell^ do Flags:=Flags or CELL_SELECTED
				end
			else
				for r:=RowStart to RowEnd do
					begin
						cell:=GetCell(r,ColStart);
						for c:=ColStart to ColEnd do
							begin
								with cell^ do Flags:=Flags or CELL_SELECTED;
								inc(longint(cell),CELLSIZE)
							end
					end;
		if pg<>nil then dispose(pg,Done);
		CommonInit2(true);
		with dtbuffer do
			if (direction>=0) and (direction<=3) then pdirbox^.SetSelection(direction,true);
		if checkover then SheetCheckOverflow;
		if TexelApp.setupbuffer.recalc=bf_Checked then Calculate(true);
		if ProtoEmb<>nil then ProtoEmb^.Realize(@self);
		if drt then SetDirty;
		if abandon<>nil then abandon^.Disable
	end;


procedure TCalcWindow.CommonInit1;

	begin
		BusyMouse;
		wnd_prnt_set:=nil;
		Variables:=nil;
		BlockHistory:=nil;
		Embedded:=nil;
		Parameter:=nil;
		Fonts:=nil;
		rowsize:=nil;
		colsize:=nil;
		colname:=nil;
		textattr:=nil;
		pattern:=nil;
		rahmen:=nil;
		links:=nil;
		numformats:=nil;
		konstanten:=nil;
		pagepreview:=nil;
		if TexelApp.stdprnbuffer.alles=bf_Checked then prnRangeFlag:=1
		else
			if TexelApp.stdprnbuffer.block=bf_Checked then prnRangeFlag:=2
			else
				prnRangeFlag:=0;
		fnecell:=nil;
		fneOp:=0;
		Dirty:=false;
		closing:=false;
		PassWord.Flag:=0;
		PassWord.Code:=0;
		PassWord.Mask:=0;
		numWidth:=0;
		longfile:='';
		tbactive:=(TexelApp.setupbuffer.toolbar=bf_Checked)
	end;


procedure TCalcWindow.CommonInit2(breiten: boolean);
	var pf    : PFont;
	    fsizes: PStringCollection;
	    pfsb  : PFontSizeBox;
	    q,w   : integer;
	    sze   : longint;
	    ppcb  : PPercentBox;
	    s     : string;
	    found : boolean;
	    pfm   : PFormat;

	begin
		new(tbonoff,Init(@self,RTWDTBSWITCH,BUBBLE_FNBAR_TBONOFF));
		if tbactive then ToggleToolbar;
		sheetbuffer.rows:=ltoa(Parms.Rows+1);
		sheetbuffer.columns:=ltoa(Parms.Columns+1);
		PercentSize:=Parms.Percent/100;
		fillchar(rabuf,sizeof(rabuf),0);
		ScanFonts(vdiHandle,Attr.sysFonts+Attr.addFonts,Fonts);
		SetFont(GetStdFontIndex,GetStdFontSize);
		if (TexelApp.UsrForm^.Count>0) and (UsrFormats<>nil) then
			for q:=0 to TexelApp.UsrForm^.Count-1 do
				begin
					s:=PFormat(TexelApp.UsrForm^.At(q))^.Name^;
					found:=false;
					if UsrFormats^.Count>0 then
						for w:=0 to UsrFormats^.Count-1 do
							if PFormat(UsrFormats^.At(w))^.Name^=s then
								begin
									found:=true;
									break
								end;
					if not(found) then
						begin
							new(pfm);
							if pfm<>nil then
								begin
									pfm^.Name:=NewStr(s);
									pfm^.Group:=1;
									pfm^.Index:=1000+UsrFormats^.Count;
									UsrFormats^.Insert(pfm)
								end
						end
				end;
		new(pfbox,InitCollection(@self,RTWDFONTPOP,RTWDFONTCYC,id_No,26,Fonts,false,false,false,BUBBLE_FNBAR_FONTID));
		if pfbox<>nil then
			begin
				pfbox^.SetShortcut('F');
				pfbox^.newsize:=-1;
				new(fsizes,Init(130,20));
				new(pfsb,InitCollection(@self,RTWDSIZEPOP,RTWDSIZECYC,id_No,6,fsizes,true,false,false,BUBBLE_FNBAR_FONTSIZE));
				pfsb^.SetShortcut('R');
				pfsb^.setsize:=true;
				pfbox^.fsizebox:=pfsb;
				pfbox^.Work;
				pfsb^.ChangeAlways:=true;
				pfbox^.ChangeAlways:=true
			end;
		new(ppcb,Init(@self,RTWDPERCENTPOP,RTWDPERCENTCYC,id_No,RTPOPUPS,RTPPERCENT,id_No,false,false,BUBBLE_FNBAR_PERCENT));
		if ppcb<>nil then ppcb^.SetShortcut('Z');
		new(pcbox,Init(@self,RTWCOLORPOP,RTWCOLORCYC,id_No,RTPOPUPS,RTPCOLOR,RTPCOLSTART,false,false,BUBBLE_FNBAR_BACKCOLOR));
		new(ppbox,Init(@self,RTWPATTERNPOP,RTWPATTERNCYC,id_No,RTPOPUPS,RTPPATTERN,id_No,false,false,BUBBLE_FNBAR_PATTERN));
		new(pdirbox,Init(@self,RTWDCRSDIR,id_No,id_No,RTPOPUPS,RTPCRSDIR,id_No,false,false,BUBBLE_FNBAR_AUTOCURSOR));
		new(dblock,Init(@self,RTWDBLOCK,16,false,BUBBLE_FNBAR_BLOCK));
		new(inpcancel,Init(@self,RTWDCANCEL,BUBBLE_FNBAR_CANCEL));
		new(inpok,Init(@self,RTWDOK,BUBBLE_FNBAR_OK));
		new(inpline,Init(@self,RTWDINPUT,256));
		new(ptcbox,Init(@self,RTWTCOLORPOP,RTWTCOLORCYC,id_No,RTPOPUPS,RTPCOLOR,RTPCOLSTART,false,false,BUBBLE_FNBAR_TEXTCOLOR));
		new(pbrdbox,Init(@self,RTWBORDERPOP,RTWBORDERCYC,id_No,RTPOPUPS,RTPRAHMEN,id_No,false,false,BUBBLE_FNBAR_BORDER));
		if pdirbox<>nil then
			begin
				if pdirbox^.Popup<>nil then pdirbox^.Popup^.AutoCheck:=false;
				pdirbox^.ChangeAlways:=true;
				pdirbox^.CenterX:=true
			end;
		if pbrdbox<>nil then
			begin
				pbrdbox^.CenterX:=true;
				pbrdbox^.ChangeAlways:=true
			end;
		if pcbox<>nil then pcbox^.ChangeAlways:=true;
		if ptcbox<>nil then ptcbox^.ChangeAlways:=true;
		if ppbox<>nil then
			begin
				ppbox^.ChangeAlways:=true;
				ppbox^.CenterX:=true
			end;
		if inpcancel<>nil then inpcancel^.Hide(false);
		if inpok<>nil then inpok^.Hide(false);
		if inpline<>nil then
			begin
				if MagiCVersion>=$0300 then inpline^.ObjAddr^.ob_spec.ted_info^.te_thickness:=-2;
				inpline^.Disable
			end;
		inpstat:=false;
		TransferBuffer:=@dtbuffer;
		if not(currvalid) then
			begin
				sze:=round(longint(Attr.boxHeight)*longint(Application^.Attr.PixH)/10.0);
				for q:=0 to Parms.Rows do SetRowHeight_mm100(q,sze,false);
				if breiten then
					begin
						sze:=round(longint(wWidth)*atol(TexelApp.setupbuffer.stdcolwidth)*longint(Application^.Attr.PixW)/10.0);
						for q:=0 to Parms.Columns do SetColWidth_mm100(q,sze,false)
					end
			end;
		SetBorderSize;
		SetBlock;
		if not(TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set)) then
			if paper<>nil then paper^.Disable;
		if currvalid then Scroller^.ScrollTo(Parms.ScrlXPos,Parms.ScrlYPos);
		ArrowMouse;
		if AppFlag then
			begin
				MakeWindow;
				if Application^.ChkError=em_InvalidWindow then
					begin
						Application^.Alert(@self,1,NOTE,MESSAGE_WINDOW_WINDOWS,BUTTON_OK);
						Free
					end
			end
	end;


procedure TCalcWindow.CommonParmInit(setsize: boolean);

	begin
		new(UsrFormats,Init(50,25));
		if UsrFormats<>nil then UsrFormats^.Sort:=false;
		if setsize then
			with Parms do
				begin
					Rows:=atol(TexelApp.setupbuffer.stdrows)-1;
					Columns:=atol(TexelApp.setupbuffer.stdcolumns)-1
				end;
		TexelApp.InitSheetStructs(Parms,sheetbuffer,dtbuffer,zwbuf,diagrammbuf,exportbuf,sortbuf,infobuf,findbuf,replacebuf,fillbuf);
		getmem(PRowFlags,Parms.Rows+1);
		getmem(PColFlags,Parms.Columns+1);
		if PRowFlags<>nil then fillchar(PRowFlags^,Parms.Rows+1,0);
		if PColFlags<>nil then fillchar(PColFlags^,Parms.Columns+1,0)
	end;


function TCalcWindow.CanClose: boolean;
	var valid: boolean;
	    ret  : integer;

	begin
		valid:=inherited CanClose;
		if valid and Dirty then
			begin
				ret:=Application^.Alert(@self,1,WAIT,MESSAGE_WINDOW_CLOSE1+GetRawIconTitle+MESSAGE_WINDOW_CLOSE2,BUTTON_YESNOCANCEL);
				if ret=1 then
					begin
						closing:=true;
						alertret:=0;
						save^.Work;
						valid:=(alertret<>3);
						closing:=false
					end
				else
					if ret<>2 then valid:=false
			end;
		CanClose:=valid
	end;


function TCalcWindow.GetStyle: integer;

	begin
		GetStyle:=inherited GetStyle or SLIDER or FULLER or SIZER
	end;


function TCalcWindow.GetVDIHandle: integer;

	begin
		GetVDIHandle:=id_NewHandle
	end;


procedure TCalcWindow.GetWindowClass(var AWndClass: TWndClass);

	begin
		inherited GetWindowClass(AWndClass);
		with AWndClass do
			Style:=Style or cs_WorkBackground or cs_WindowMenuToolbar or cs_OLGADocument or cs_FreeOnClose or cs_Rubbox
	end;


function TCalcWindow.GetClassName: string;

	begin
		GetClassName:=TEXELWINDCLASS
	end;


function TCalcWindow.GetRawIconTitle: string;
	var t: string;

	begin
		t:=GetTitle;
		if StrPLeft(t,2)='* ' then t:=StrPRight(t,length(t)-2);
		if length(longfile)=0 then
			begin
				t:=StrPRight(t,length(t)-19);
				t:='TEXEL '+StrPLeft(t,length(t)-1)
			end
		else
			begin
				t:=StrPRight(longfile,length(longfile)-RPos('\',longfile));
				if RPos('.',t)>0 then t:=StrPLeft(t,RPos('.',t)-1)
			end;
		GetRawIconTitle:=t
	end;


function TCalcWindow.GetIconTitle: string;

	begin
		if Dirty then GetIconTitle:='*'+GetRawIconTitle
		else
			GetIconTitle:=GetRawIconTitle
	end;


function TCalcWindow.GetScroller: PScroller;

	begin
		GetScroller:=new(PCalcScroller,Init(@self,1,1,1,1));
		if Scroller<>nil then
			with Scroller^ do Style:=Style or scs_BitbltScrolling
	end;


procedure TCalcWindow.GetWorkMax(var maxX,maxY: integer);

	begin
		maxX:=maxint;
		maxY:=maxint
	end;


procedure TCalcWindow.SetupSize;
	var oldcurr: GRECT;

	procedure CheckBottomLine;
	
		begin
			if TexelApp.setupbuffer.bottomline=bf_Checked then
				begin
					dec(Full.H,TexelApp.Attr.boxSHeight);
					GRtoA2(Full);
					Curr:=Full;
					Calc(WC_WORK,Curr,Work)
				end
		end;

	begin
		with DlgTree^[ROOT] do
			begin
				PaintOffs:=ob_height+1;
				ob_width:=Application^.Attr.MaxPX
			end;
		oldcurr:=Curr;
		TWindow.SetupSize;
		if currvalid then
			begin
				if TexelApp.setupbuffer.fullsize=bf_Unchecked then
					begin
						GRtoA2(oldcurr);
						if oldcurr.X2>Sysinfo.Desktop.X2 then dec(oldcurr.X,oldcurr.X2-Sysinfo.Desktop.X2);
						if oldcurr.X<Sysinfo.Desktop.X then oldcurr.X:=SysInfo.Desktop.X;
						if oldcurr.X+oldcurr.W>=Sysinfo.Desktop.X2 then oldcurr.W:=Sysinfo.Desktop.X2+1-oldcurr.X;
						if oldcurr.Y2>Sysinfo.Desktop.Y2 then dec(oldcurr.Y,oldcurr.Y2-Sysinfo.Desktop.Y2);
						if oldcurr.Y<Sysinfo.Desktop.Y then oldcurr.Y:=SysInfo.Desktop.Y;
						if oldcurr.Y+oldcurr.H>=Sysinfo.Desktop.Y2 then oldcurr.H:=Sysinfo.Desktop.Y2+1-oldcurr.Y;
						GRtoA2(oldcurr);
						Curr:=oldcurr;
						Calc(WC_WORK,Curr,Work)
					end
				else
					CheckBottomLine
			end
		else
			CheckBottomLine
	end;


procedure TCalcWindow.SetupVDI;
	var dummy: integer;

	begin
		Attr.ExStyle:=Attr.ExStyle or ws_ex_LoadFonts;
		inherited SetupVDI;
		Speedo:=Application^.SpeedoActive;
		if Speedo then vst_kern(vdiHandle,0,1,dummy,dummy)
	end;


procedure TCalcWindow.SetupWindow;
	var pt: PColorToolbar;

	begin
		inherited SetupWindow;
		Attr.ExStyle:=(Attr.ExStyle and not(ws_ex_TryModeless)) or ws_ex_Modeless;
		if currvalid or (TexelApp.setupbuffer.bottomline=bf_Checked) then Attr.ExStyle:=Attr.ExStyle and not(ws_ex_CenterOnce);
		LoadMenu(RTWMENU,false);
		LoadIcon(new(PIcon,Init(@self,RTICONS,RTICALC,0,0,false,false,'','')));
		new(bblock,Init(@self,K_CTRL,Ctrl_B,nil,false));
		new(save,Init(@self,K_CTRL,Ctrl_S,RTWMSAVE,RTWM2));
		new(saveas,Init(@self,K_CTRL,Ctrl_M,RTWMSAVEAS,RTWM2));
		new(abandon,Init(@self,K_CTRL,Ctrl_H,RTWMABANDON,RTWM2));
		new(export,Init(@self,K_CTRL,Ctrl_E,RTWMEXPORT,RTWM2));
		new(prnt,Init(@self,K_CTRL,Ctrl_P,RTWMPRINT,RTWM2));
		new(pagesetup,Init(@self,K_CTRL+K_SHIFT,Ctrl_P,RTWMPAGESETUP,RTWM2));
		new(preview,Init(@self,K_ALT,Alt_P,RTWMPREVIEW,RTWM2));
		new(paper,Init(@self,K_ALT+K_SHIFT,Alt_P,RTWMPAPER,RTWM2));
		new(PInfo,Init(@self,K_CTRL,Ctrl_I,RTWMINFO,RTWM2));
		new(clrinh,Init(@self,RTWMCLEAR,RTPOPUPS,RTPCLEAR));
		new(objects,Init(@self,RTWMOBJECTS,RTPOPUPS,RTPOBJECTS));
		if objects<>nil then objects^.Disable;
		new(PClearCell,Init(@self,K_CTRL,Ctrl_D,RTWMCLEARCELL,RTWM3));
		new(find,Init(@self,K_CTRL,Ctrl_F,RTWMFIND,RTWM3));
		if find<>nil then
			begin
				find^.rb1:=nil;
				find^.rb2:=nil
			end;
		new(PFindNext,Init(@self,K_CTRL,Ctrl_G,RTWMFINDNEXT,RTWM3));
		new(replace,Init(@self,K_CTRL,Ctrl_R,RTWMREPLACE,RTWM3));
		if replace<>nil then
			begin
				replace^.rb1:=nil;
				replace^.rb2:=nil
			end;
		new(PReplaceNext,Init(@self,K_CTRL,Ctrl_T,RTWMREPLACENEXT,RTWM3));
		new(PCellProtect,Init(@self,RTWMPROTECT,nil,false));
		new(PCellUnprotect,Init(@self,RTWMUNPROTECT,nil,false));
		new(PInsert,Init(@self,K_NORMAL,S_Insert,RTWMINSERT,RTWM4));
		new(PInsertCell,Init(@self,K_CTRL+K_SHIFT,Ctrl_V,RTWMINSCELL,RTWM4));
		new(insrow,Init(@self,K_CTRL,Ctrl_Insert,RTWMINSROWS,RTWM4));
		new(inscol,Init(@self,K_CTRL+K_SHIFT,CtrlShift_Insert,RTWMINSCOLS,RTWM4));
		new(PUmbruch,Init(@self,K_CTRL+K_SHIFT,Ctrl_U,RTWMUMBRUCH,RTWM4));
		new(insfunc,Init(@self,K_CTRL+K_SHIFT,Ctrl_F,RTWMFUNCTION,RTWM4));
		new(diagramm,Init(@self,K_CTRL+K_SHIFT,Ctrl_D,RTWMDIAGRAM,RTWM4));
		new(grafik,Init(@self,K_CTRL+K_SHIFT,Ctrl_G,RTWMIMAGE,RTWM4));
		new(textobj,Init(@self,K_ALT+K_SHIFT,Alt_T,RTWMTEXT,RTWM4));
		new(oleobject,Init(@self,K_CTRL+K_SHIFT,Ctrl_O,RTWMOBJECT,RTWM4));
		if oleobject<>nil then
			if TexelApp.OLETypes<>nil then oleobject^.Enable;
		new(fill,Init(@self,RTWMFILL,RTPOPUPS,RTPFILL));
		if fill<>nil then fill^.reihe:=nil;
		if fill<>nil then fill^.Disable; { !!! }
		new(formcell,Init(@self,RTWMFORMCELL,RTPOPUPS,RTPFORMCELL));
		new(formrow,Init(@self,RTWMFORMROW,RTPOPUPS,RTPFORMROW));
		new(formcol,Init(@self,RTWMFORMCOL,RTPOPUPS,RTPFORMCOL));
		new(PFormSheet,Init(@self,K_CTRL+K_SHIFT,Ctrl_B,RTWMFORMSHEET,RTWM5));
		new(PZielwert,Init(@self,K_ALT+K_SHIFT,Alt_S,RTWMFINDVALUE,RTWM6));
		new(PSort,Init(@self,K_ALT,Alt_S,RTWMSORT,RTWM6));
		new(PKonst,Init(@self,K_CTRL,Ctrl_K,RTWMCONST,RTWM6));
		new(PCalculate,Init(@self,K_CTRL,Ctrl_Return,RTWMUPDATE,RTWM6));
		new(PGoto,Init(@self,RTWMGOTO,nil,false));
		new(pt,Init(@self,RTWTSAVE,RTWTCSAVE,false,BUBBLE_TOOLBAR_SAVE));
		if pt<>nil then pt^.SetMenuIndex(RTWMSAVE);
		new(pt,Init(@self,RTWTPRINT,RTWTCPRINT,false,BUBBLE_TOOLBAR_PRINT));
		if pt<>nil then pt^.SetMenuIndex(RTWMPRINT);
		if not(Application^.GDOSActive) then
			begin
				if prnt<>nil then prnt^.Disable;
				if preview<>nil then preview^.Disable;
				if paper<>nil then paper^.Disable;
				if pt<>nil then pt^.Disable
			end;
		new(PTCut,Init(@self,RTWTCUT,RTWTCCUT,false,BUBBLE_TOOLBAR_CUT));
		new(PTCopy,Init(@self,RTWTCOPY,RTWTCCOPY,false,BUBBLE_TOOLBAR_COPY));
		new(PTPaste,Init(@self,RTWTPASTE,RTWTCPASTE,false,BUBBLE_TOOLBAR_PASTE));
		new(tsumme,Init(@self,RTWTSUM,RTWTCSUM,false,BUBBLE_TOOLBAR_SUM));
		new(PTFunction,Init(@self,RTWTFN,RTWTCFN,false,BUBBLE_TOOLBAR_FN));
		new(pfett,Init(@self,RTWTFETT,RTWTCFETT,true,BUBBLE_TOOLBAR_BOLD));
		new(pkursiv,Init(@self,RTWTKURSIV,RTWTCKURSIV,true,BUBBLE_TOOLBAR_ITALIC));
		new(punter,Init(@self,RTWTUNTERSTR,RTWTCUNTERSTR,true,BUBBLE_TOOLBAR_UNDERL));
		new(palignleft,Init(@self,RTWTLINKS,RTWTCLINKS,true,BUBBLE_TOOLBAR_LEFT));
		new(paligncenter,Init(@self,RTWTMITTE,RTWTCMITTE,true,BUBBLE_TOOLBAR_CENTER));
		new(palignright,Init(@self,RTWTRECHTS,RTWTCRECHTS,true,BUBBLE_TOOLBAR_RIGHT));
		new(PTNumber,Init(@self,RTWTNUMBER,RTWTCNUMBER,false,BUBBLE_TOOLBAR_NUMBER));
		new(PTDate,Init(@self,RTWTDATE,RTWTCDATE,false,BUBBLE_TOOLBAR_DATE));
		new(PTMoney,Init(@self,RTWTMONEY,RTWTCMONEY,false,BUBBLE_TOOLBAR_MONEY));
		new(PTPercent,Init(@self,RTWTPERCENT,RTWTCPERCENT,false,BUBBLE_TOOLBAR_PERCENT));
		new(PTSortAuf,Init(@self,RTWTSORTAUF,RTWTCSORTAUF,false,BUBBLE_TOOLBAR_SORTUP));
		new(PTSortAb,Init(@self,RTWTSORTAB,RTWTCSORTAB,false,BUBBLE_TOOLBAR_SORTDOWN));
		new(dezplus,Init(@self,RTWTDEZPLUS,RTWTCDEZPLUS,false,BUBBLE_TOOLBAR_FPLUS));
		new(dezminus,Init(@self,RTWTDEZMINUS,RTWTCDEZMINUS,false,BUBBLE_TOOLBAR_FMINUS));
		new(PTDiagram,Init(@self,RTWTDIAGRAM,RTWTCDIAGRAM,false,BUBBLE_TOOLBAR_DIAGRAM));
		new(PTHome,Init(@self,RTWTHOME,RTWTCHOME,false,BUBBLE_TOOLBAR_HOME));
		Fonts:=nil;
		PColNames:=nil;
		PRowFlags:=nil;
		PColFlags:=nil;
		PRow:=nil;
		PCol:=nil;
		Sheet:=nil
	end;


procedure TCalcWindow.ShutdownWindow;
	var q   : longint;
	    cell: PCell;

	begin
		links:=nil;
		while (Embedded<>nil) do Embedded^.Free;
		if Fonts<>nil then dispose(Fonts,Done);
		if Parameter<>nil then dispose(Parameter,Done);
		if UsrFormats<>nil then dispose(UsrFormats,Done);
		if Variables<>nil then dispose(Variables,Done);
		if BlockHistory<>nil then dispose(BlockHistory,Done);
		if PColNames<>nil then
			begin
				for q:=0 to Parms.Columns do DisposeStr(PString(PColNames^[q]));
				freemem(PColNames,(Parms.Columns+1) shl 2);
			end;
		if PRowFlags<>nil then freemem(PRowFlags,Parms.Rows+1);
		if PColFlags<>nil then freemem(PColFlags,Parms.Columns+1);
		if PRow<>nil then freemem(PRow,(Parms.Rows+1) shl 1);
		if PCol<>nil then freemem(PCol,(Parms.Columns+1) shl 1);
		if wnd_prnt_set<>nil then
			with AES_pb do
				begin
					control^[0]:=205;
					control^[1]:=1;
					control^[2]:=1;
					control^[3]:=1;
					control^[4]:=0;
					intin^[0]:=6;
					addrin^[0]:=wnd_prnt_set;
					_crystal(@AES_pb)
				end;
		if Sheet<>nil then
			begin
				cell:=Sheet;
				for q:=0 to longint(Parms.Rows)*longint(Parms.Columns)+longint(Parms.Rows)+longint(Parms.Columns) do
					begin
						case cell^.Typ of
						CTYPE_TEXT:
							DisposeStr(cell^.Data.Txt);
						CTYPE_CONST:
							begin
								DisposeStr(cell^.Data.Konst^.Txt);
								dispose(cell^.Data.Konst)
							end;
						CTYPE_FORMULA:
							begin
								DisposeStr(cell^.Data.Formula^.VarDef);
								DeleteNode(cell^.Data.Formula^.Func);
								dispose(cell^.Data.Formula)
							end
						end;
						inc(longint(cell),CELLSIZE)
					end;
				freemem(Sheet,longint(Parms.Rows+1)*longint(Parms.Columns+1)*CELLSIZE)
			end
	end;


procedure TCalcWindow.PaintNumbers(rect: GRECT);
	var clp,clp2: GRECT;
	    w,dummy : integer;
	    xy      : ARRAY_4;

	begin
		if TexelApp.ColFX then
			begin
				vsf_interior(vdiHandle,FIS_SOLID);
				vsf_color(vdiHandle,LWhite)
			end;
		
		{ Offsets berechnen... }
		
		{ oberen Offset berechnen }
		tpoffs:=Scroller^.YPos;
		tcnum:=0;
		while tpoffs>=0 do
			begin
				dec(tpoffs,GetRowHeight(tcnum));
				inc(tcnum)
			end;
		dec(tcnum);
		inc(tpoffs,GetRowHeight(tcnum));
		{ erste Spalte jeder Zeile }
		w:=tcnum;
		clp.X:=Work.X;
		clp.Y:=Work.Y+PaintOffs+TopRowHeight+1;
		clp.W:=LeftColWidth;
		clp.H:=GetRowHeight(w)-tpoffs;
		xy[0]:=clp.X-1;
		xy[1]:=clp.Y-tpoffs-1;
		xy[2]:=clp.X+clp.W;
		GRtoA2(clp);
		vst_alignment(vdiHandle,TA_CENTER,TA_BOTTOM,dummy,dummy);
		repeat
			clp2:=clp;
			inc(w);
			if rc_intersect(rect,clp2) then
				begin
					vs_clip(Application^.vdiHandle,CLIP_ON,clp2.A2);
					vs_clip(vdiHandle,CLIP_ON,clp2.A2);
					xy[3]:=clp.Y2;
					v_bar(Application^.vdiHandle,xy);
					dec(xy[3]);
					if TexelApp.ColFX then
						begin
							inc(xy[0],2);
							inc(xy[1],2);
							v_bar(vdiHandle,xy);
							dec(xy[0],2)
						end;
					vswr_mode(vdiHandle,MD_TRANS);
					v_gtext(vdiHandle,(xy[0]+xy[2]) shr 1,xy[3],ltoa(w));
					vswr_mode(vdiHandle,MD_REPLACE)
				end;
			if w>Parms.Rows then break;
			clp.Y1:=clp.Y2+1;
			inc(clp.Y2,GetRowHeight(w));
			A2toGR(clp);
			xy[1]:=clp.Y-1
		until clp.Y1>Work.Y2;
		if clp.Y2<Work.Y2 then
			begin
				vs_clip(vdiHandle,CLIP_ON,SysInfo.Desktop.A2);
				if TexelApp.ColFX then
					begin
						vsf_interior(vdiHandle,FIS_SOLID);
						vsf_color(vdiHandle,LWhite)
					end
				else
					vsf_interior(vdiHandle,FIS_HOLLOW);
				clp2.X:=Work.X1;
				clp2.Y:=clp.Y2+1;
				clp2.W:=LeftColWidth;
				clp2.H:=Work.Y2-clp.Y2;
				if rc_intersect(rect,clp2) then vr_recfl(vdiHandle,clp2.A2)
			end;
		vst_alignment(vdiHandle,TA_LEFT,TA_BASELINE,dummy,dummy)
	end;


procedure TCalcWindow.PaintNames(rect: GRECT);
	var clp,clp2: GRECT;
	    q,dummy : integer;
	    xy      : ARRAY_4;

	begin
		if TexelApp.ColFX then
			begin
				vsf_interior(vdiHandle,FIS_SOLID);
				vsf_color(vdiHandle,LWhite)
			end;
		
		{ Offsets berechnen... }
		
		{ linken Offset berechnen }
		lpoffs:=Scroller^.XPos;
		lcnum:=0;
		while lpoffs>=0 do
			begin
				dec(lpoffs,GetColWidth(lcnum));
				inc(lcnum)
			end;
		dec(lcnum);
		inc(lpoffs,GetColWidth(lcnum));
		{ erste Zeile zeichnen }
		q:=lcnum;
		clp.X:=Work.X+LeftColWidth+1;
		clp.Y:=Work.Y+PaintOffs;
		clp.W:=GetColWidth(q)-lpoffs-1;
		clp.H:=TopRowHeight;
		xy[0]:=clp.X-lpoffs-1;
		xy[1]:=clp.Y-1;
		xy[3]:=clp.Y+clp.H;
		GRtoA2(clp);
		vst_alignment(vdiHandle,TA_CENTER,TA_BOTTOM,dummy,dummy);
		repeat
			clp2:=clp;
			if rc_intersect(rect,clp2) then
				begin
					vs_clip(Application^.vdiHandle,CLIP_ON,clp2.A2);
					vs_clip(vdiHandle,CLIP_ON,clp2.A2);
					xy[2]:=clp.X2;
					v_bar(Application^.vdiHandle,xy);
					if TexelApp.ColFX then
						begin
							inc(xy[0],2);
							inc(xy[1],2);
							dec(xy[2]);
							v_bar(vdiHandle,xy);
							dec(xy[1],2)
						end;
					vswr_mode(vdiHandle,MD_TRANS);
					v_gtext(vdiHandle,(xy[0]+xy[2]) shr 1,xy[3],GetColumnName(q));
					vswr_mode(vdiHandle,MD_REPLACE)
				end;
			inc(q);
			if q>Parms.Columns then break;
			clp.X1:=clp.X2+1;
			inc(clp.X2,GetColWidth(q));
			A2toGR(clp);
			xy[0]:=clp.X-1
		until clp.X1>Work.X2;
		if clp.X2<Work.X2 then
			begin
				vs_clip(vdiHandle,CLIP_ON,SysInfo.Desktop.A2);
				if TexelApp.ColFX then
					begin
						vsf_interior(vdiHandle,FIS_SOLID);
						vsf_color(vdiHandle,LWhite)
					end
				else
					vsf_interior(vdiHandle,FIS_HOLLOW);
				clp2.X:=clp.X2+1;
				clp2.Y:=Work.Y+PaintOffs;
				clp2.W:=Work.X2-clp.X2;
				clp2.H:=TopRowHeight;
				if rc_intersect(rect,clp2) then vr_recfl(vdiHandle,clp2.A2)
			end;
		vst_alignment(vdiHandle,TA_LEFT,TA_BASELINE,dummy,dummy)
	end;


function TCalcWindow.Val2TxtF(fval: TNumber; fp: byte; frm: integer; cell: PCell): string;
	var txt: string;

	begin
		Val2Txt(fval,txt,fp,frm,cell);
		Val2TxtF:=txt
	end;


function TCalcWindow.Val2Txt(fval: TNumber; var vtxt: string; fp: byte; frm: integer; cell: PCell): boolean;
	var q,usr: integer;

	procedure interprete;
		var pmz,
		    state   : integer;
		    n       : longint;
		    pfm     : PFormat;
		    orgval  : TNumber;
		    dummy,
		    dummy2  : string[19];
		    frmt    : string[59];
		    ret     : string;
		    ch      : char;
		    backflag,
	  	  found   : boolean;

		procedure symb2val;
			label _fvalvalid;
			
			var w: integer;

			function fvalvalid(s: string): boolean;
				var s2: string[19];
				    i : integer;
			
				function s2valid: boolean;
				
					begin
						s2valid:=false;
						case s2[1] of
						'=':
							begin
								if atof(CutLeftF(s2,1))<>orgval then exit
							end;
						'>':
							begin
								if s2[2]='=' then
									begin
										if orgval<atof(CutLeftF(s2,2)) then exit
									end
								else
									if orgval<=atof(CutLeftF(s2,1)) then exit
							end;
						'<':
							begin
								if s2[2]='=' then
									begin
										if orgval>atof(CutLeftF(s2,2)) then exit
									end
								else
									if orgval>=atof(CutLeftF(s2,1)) then exit
							end;
						else
							begin
								exit
							end
						end;
						s2valid:=true
					end;
			
				begin
					fvalvalid:=true;
					while length(s)>0 do
						begin
							i:=pos(',',s);
							if i>0 then
								begin
									s2:=StrPLeft(s,i-1);
									s:=StrPRight(s,length(s)-i)
								end
							else
								begin
									s2:=s;
									s:=''
								end;
							if not(s2valid) then
								begin
									fvalvalid:=false;
									exit
								end
						end
				end;

			begin
				if dummy='T' then
					begin
						vtxt:=vtxt+ltoa(Num2Day(fval));
						exit
					end;
				if dummy='TT' then
					begin
						n:=Num2Day(fval);
						if n<10 then vtxt:=vtxt+'0';
						vtxt:=vtxt+ltoa(n);
						exit
					end;
				if dummy='TTT' then
					begin
						vtxt:=vtxt+TexelApp.Tage2[Weekday(fval,3)];
						exit
					end;
				if dummy='TTTT' then
					begin
						vtxt:=vtxt+TexelApp.Tage[Weekday(fval,3)];
						exit
					end;
				if dummy='M' then
					begin
						vtxt:=vtxt+ltoa(Num2Month(fval));
						exit
					end;
				if dummy='MM' then
					begin
						n:=Num2Month(fval);
						if n<10 then vtxt:=vtxt+'0';
						vtxt:=vtxt+ltoa(n);
						exit
					end;
				if dummy='MMM' then
					begin
						vtxt:=vtxt+TexelApp.Monate3[Num2Month(fval)];
						exit
					end;
				if dummy='MMMM' then
					begin
						vtxt:=vtxt+TexelApp.Monate[Num2Month(fval)];
						exit
					end;
				if dummy='J' then
					begin
						vtxt:=vtxt+ltoa(Num2Year(fval) mod 100);
						exit
					end;
				if dummy='JJ' then
					begin
						n:=Num2Year(fval) mod 100;
						if n<10 then vtxt:=vtxt+'0';
						vtxt:=vtxt+ltoa(n);
						exit
					end;
				if dummy='JJJJ' then
					begin
						vtxt:=vtxt+ltoa(Num2Year(fval));
						exit
					end;
				if dummy='H' then
					begin
						n:=Num2Hour(fval);
						if n>12 then dec(n,12);
						vtxt:=vtxt+ltoa(n);
						exit
					end;
				if dummy='HH' then
					begin
						n:=Num2Hour(fval);
						if n>12 then dec(n,12);
						if n<10 then vtxt:=vtxt+'0';
						vtxt:=vtxt+ltoa(n);
						exit
					end;
				if dummy='#h' then
					begin
						vtxt:=vtxt+ltoa(Num2Hour(fval)+24*trunc(fval));
						exit
					end;
				if dummy='h' then
					begin
						vtxt:=vtxt+ltoa(Num2Hour(fval));
						exit
					end;
				if dummy='hh' then
					begin
						n:=Num2Hour(fval);
						if n<10 then vtxt:=vtxt+'0';
						vtxt:=vtxt+ltoa(n);
						exit
					end;
				if dummy='m' then
					begin
						vtxt:=vtxt+ltoa(Num2Minute(fval));
						exit
					end;
				if dummy='mm' then
					begin
						n:=Num2Minute(fval);
						if n<10 then vtxt:=vtxt+'0';
						vtxt:=vtxt+ltoa(n);
						exit
					end;
				if dummy='s' then
					begin
						vtxt:=vtxt+ltoa(Num2Second(fval));
						exit
					end;
				if dummy='ss' then
					begin
						n:=Num2Second(fval);
						if n<10 then vtxt:=vtxt+'0';
						vtxt:=vtxt+ltoa(n);
						exit
					end;
				if dummy='w' then
					begin
						if abs(fval)>maxlongint then vtxt:=vtxt+'###'
						else
							vtxt:=vtxt+ltoa(trunc(fval) mod 360);
						exit
					end;
				if dummy='wm' then
					begin
						if abs(fval)>maxlongint then vtxt:=vtxt+'##'
						else
							vtxt:=vtxt+ltoa(trunc(frac(fval)*60.0));
						exit
					end;
				if dummy='ws' then
					begin
						if abs(fval)>maxlongint then vtxt:=vtxt+'##'
						else
							vtxt:=vtxt+ltoa(trunc(frac(frac(fval)*60.0)*60.0));
						exit
					end;
				if StrPLeft(dummy,1)='$' then
					begin
						vtxt:=vtxt+CutLeftF(ltoh(trunc(fval),atol(CutLeftF(dummy,1))),1);
						exit
					end;
				if StrPLeft(dummy,1)='%' then
					begin
						vtxt:=vtxt+CutLeftF(ltob(trunc(fval),atol(CutLeftF(dummy,1))),1);
						exit
					end;
				if StrPLeft(dummy,1)='&' then
					begin
						vtxt:=vtxt+CutLeftF(ltoo(trunc(fval),atol(CutLeftF(dummy,1))),1);
						exit
					end;
				w:=pos('/',dummy);
				if w>0 then
					begin
						n:=Num2Hour(fval);
						if n>12 then vtxt:=vtxt+StrPRight(dummy,length(dummy)-w)
						else
							vtxt:=vtxt+StrPLeft(dummy,w-1);
						exit
					end;
				{ Attribute ... }
				if cell<>nil then
					begin
						w:=pos('|',dummy);
						if w>0 then
							begin
								dummy2:=StrPRight(dummy,length(dummy)-w);
								dummy:=StrPLeft(dummy,w-1);
								while length(dummy2)>0 do
									begin
										w:=pos('|',dummy2);
										if w>0 then
											begin
												if fvalvalid(StrPLeft(dummy2,w-1)) then goto _fvalvalid;
												dummy2:=StrPRight(dummy2,length(dummy2)-w)
											end
										else
											begin
												if fvalvalid(dummy2) then goto _fvalvalid;
												dummy2:=''
											end
									end;
								exit
							end;
						_fvalvalid:
						if dummy[1]='\' then
							begin
								backflag:=true;
								CutLeft(dummy,1)
							end
						else
							backflag:=false;
						found:=false;
						for w:=0 to 15 do
							if dummy=TexelApp.Farben[w] then
								begin
									found:=true;
									break
								end;
						if found then
							begin
								if backflag then
									begin
										cell^.Color:=w;
										cell^.Interior:=FIS_SOLID;
										cell^.Style:=8;
										Val2Txt:=true
									end
								else
									cell^.TxtVal.Color:=w
							end
					end
			end;

		procedure num2val;
			label _wiss;

			var w,e: integer;
			    r  : TNumber;

			procedure vorkomma(v: TNumber);
				label _ende;

				var i: integer;

				begin
					ret:='';
					while e>0 do
						begin
							if dummy[e]='0' then
								begin
									v:=int(v)/10.0;
									ret:=chr(round(frac(v)*10.0)+48)+ret
								end
							else
								if dummy[e]='#' then
									begin
										if v<1.0 then
											begin
												i:=0;
												while not(ret[i+1] in ['0'..'9']) and (i<length(ret)) do inc(i);
												ret:=StrPRight(ret,length(ret)-i);
												goto _ende
											end
										else
											begin
												v:=int(v)/10.0;
												ret:=chr(round(frac(v)*10.0)+48)+ret;
												if v<1.0 then goto _ende
											end
									end
								else
									ret:=dummy[e]+ret;
							dec(e)
						end;
					while v>=1.0 do
						begin
							v:=int(v)/10.0;
							ret:=chr(round(frac(v)*10.0)+48)+ret
						end;
					_ende:
					vtxt:=vtxt+ret
				end;

			procedure nachkomma(k: TNumber);
			
				begin
					e:=w+1;
					while e<=length(dummy) do
						begin
							if dummy[e]='0' then
								begin
									k:=k*10.0;
									vtxt:=vtxt+chr(trunc(k)+48);
									k:=frac(k)
								end
							else
								vtxt:=vtxt+dummy[e];
							inc(e)
						end
				end;

			procedure num2wiss;
				var k    : TNumber;
				    i,j,l: integer;

				begin
					j:=0;
					k:=fval;
					if k>=1.0 then
						begin
							while k>=1e100 do
								begin
									k:=k/1e100;
									inc(j,100)
								end;
							while k>=1e10 do
								begin
									k:=k/1e10;
									inc(j,10)
								end;
							while k>=10 do
								begin
									k:=k/10;
									inc(j)
								end
						end
					else
						if k>0.0 then
							begin
								while k<=1e-100 do
									begin
										k:=k*1e100;
										dec(j,100)
									end;
								while k<=1e-10 do
									begin
										k:=k*1e10;
										dec(j,10)
									end;
								while k<1.0 do
									begin
										k:=k*10;
										dec(j)
									end
							end;
					i:=e;
					l:=length(dummy);
					dummy[0]:=chr(i-1);
					w:=pos('|',dummy);
					if w>0 then
						begin
							r:=0.5;
							e:=w+1;
							while e<=length(dummy) do
								begin
									if dummy[e]='0' then r:=r/10.0;
									inc(e)
								end;
							r:=k+r;
							e:=w-1;
							if e>0 then vorkomma(int(r));
							nachkomma(frac(r))
						end
					else
						vtxt:=vtxt+'#####';
					vtxt:=vtxt+'E';
					if dummy[i+1]='+' then
						begin
							if j>=0 then vtxt:=vtxt+'+';
							i:=l-i-1
						end
					else
						i:=l-i;
					if j<0 then
						begin
							vtxt:=vtxt+'-';
							j:=-j
						end;
					ret:=ltoa(j);
					while length(ret)<i do ret:='0'+ret;
					vtxt:=vtxt+ret
				end;

			begin
				if fval<0.0 then
					begin
						vtxt:=vtxt+'-';
						fval:=-fval
					end;
				_wiss:
				e:=pos('E',dummy);
				if e>0 then num2wiss
				else
					begin
						if fval>1e29 then
							begin
								dummy:='0|,0000E+0';
								goto _wiss
							end;
						w:=pos('|',dummy);
						if w>0 then
							begin
								r:=0.5;
								e:=w+1;
								while e<=length(dummy) do
									begin
										if dummy[e]='0' then r:=r/10.0;
										inc(e)
									end;
								r:=fval+r;
								e:=w-1;
								if e>0 then vorkomma(int(r));
								nachkomma(frac(r))
							end
						else
							begin
								e:=length(dummy);
								if e>0 then
									begin
										if frac(fval)>=0.5 then vorkomma(int(fval)+1.0)
										else
											vorkomma(int(fval))
									end
							end
					end
			end;

		begin
			if frm>=1000 then pfm:=PFormat(UsrFormats^.At(frm-1000))
			else
				pfm:=PFormat(TexelApp.Formats^.At(frm));
			frmt:=pfm^.Name^;
			vtxt:='';
			orgval:=fval;
			q:=pos(';',frmt);
			if q>0 then
				begin
					n:=RPos(';',frmt);
					if q=n then
						begin
							if fval<0.0 then
								begin
									fval:=-fval;
									frmt:=StrPRight(frmt,length(frmt)-q)
								end
							else
								frmt:=StrPLeft(frmt,q-1)
						end
					else
						if fval>0.0 then frmt:=StrPLeft(frmt,q-1)
						else
							if fval<0.0 then
								begin
									fval:=-fval;
									frmt:=StrPMid(frmt,q+1,n-q-1)
								end
							else
								frmt:=StrPRight(frmt,length(frmt)-n)
				end;
			q:=1;
			dummy:='';
			state:=0;
			while (q<=length(frmt)) do
				begin
					ch:=frmt[q];
					if state=1 then
						begin
							if ch=']' then
								begin
									symb2val;
									dummy:='';
									state:=0
								end
							else
								dummy:=dummy+ch
						end
					else
						if state=2 then
							begin
								if ch='}' then
									begin
										num2val;
										dummy:='';
										state:=0
									end
								else
									dummy:=dummy+ch
							end
						else
							if state=3 then
								begin
									if ch=')' then
										begin
											fval:=fval*atof(dummy);
											dummy:='';
											state:=0
										end
									else
										dummy:=dummy+ch
								end
							else
								if ch='[' then state:=1
								else
									if ch='{' then state:=2
									else
										if ch='(' then state:=3
										else
											vtxt:=vtxt+ch;
					inc(q)
				end
		end;

	begin
		Val2Txt:=false;
		if (frm>0) and (frm<=TexelApp.FormPredef) then interprete
		else
			begin
				if UsrFormats=nil then usr:=0
				else
					usr:=1000+UsrFormats^.Count;
				if (frm>=1000) and (frm<usr) then interprete
				else
					vtxt:=TexelApp.Num2Txt(fval,fp,false)
			end
	end;


procedure TCalcWindow.InitTextValues(handle: integer; var cmpval: TOldTxtVal);
	var dummy: integer;

	begin
		with cmpval do
			begin
				oldtcolor:=Black;
				oldeffects:=TF_NORMAL;
				oldskew:=0;
				oldrotat:=0
			end;
		vst_color(handle,cmpval.oldtcolor);
		vst_effects(handle,cmpval.oldeffects);
		vst_rotation(handle,cmpval.oldrotat);
		if Speedo then vst_skew(handle,cmpval.oldskew);
		vst_alignment(handle,TA_LEFT,TA_TOP,dummy,dummy)
	end;


procedure TCalcWindow.RestoreTextValues(handle: integer);
	var dummy: integer;

	begin
		vst_color(handle,Black);
		vst_effects(handle,TF_NORMAL);
		vst_rotation(handle,0);
		if Speedo then vst_skew(handle,0);
		vst_alignment(handle,TA_LEFT,TA_BASELINE,dummy,dummy)
	end;


procedure TCalcWindow.RowsClearOverflow(rs,re: integer; var cmin,cmax: integer);
	var x,y,
	    cmi,cmx: integer;
	    cell   : PCell;

	begin
		for y:=rs to re do
			begin
				cell:=GetCell(y,0);
				for x:=0 to Parms.Columns do
					begin
						if ClearOverflow(cell,cmi,cmx) then
							begin
								if cmi<cmin then cmin:=cmi;
								if cmx>cmax then cmax:=cmx
							end;
						inc(longint(cell),CELLSIZE)
					end
			end
	end;


procedure TCalcWindow.RowsCheckOverflow(rs,re: integer; var cmin,cmax: integer);
	var cell: PCell;
	    x,y,
	    cmi,
	    cmx : integer;

	begin
		cell:=GetCell(rs,0);
		for y:=rs to re do
			for x:=0 to Parms.Columns do
				begin
					if CheckOverflow(cell,cmi,cmx) then
						begin
							if cmi<cmin then cmin:=cmi;
							if cmx>cmax then cmax:=cmx
						end;
					inc(longint(cell),CELLSIZE)
				end
	end;


procedure TCalcWindow.SheetCheckOverflow;
	var r,c,
	    dummy: integer;
	    cell : PCell;

	begin
		BusyMouse;
		cell:=Sheet;
		for r:=0 to Parms.Rows do
			for c:=0 to Parms.Columns do
				begin
					CheckOverflow(cell,dummy,dummy);
					inc(longint(cell),CELLSIZE)
				end;
		ArrowMouse
	end;


function TCalcWindow.ClearOverflow(cell: PCell; var cmin,cmax: integer): boolean;
	var r,c,c2: integer;
	    cell2 : PCell;

	begin
		ClearOverflow:=false;
		if cell^.Typ<>CTYPE_TEXT then exit;
		Cell2RC(cell,r,c);
		ClearOverflow:=((cell^.TxtVal.Flags and (TFL_LEFTMASK or TFL_RIGHTMASK))>0);
		cmin:=c;
		cmax:=c;
		cell2:=cell;
		c2:=c;
		while ((cell2^.TxtVal.Flags and TFL_LEFTMASK)>0) and (c2>=0) do
			begin
				cmin:=c2;
				cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags and not(TFL_LEFTMASK);
				dec(longint(cell2),CELLSIZE);
				dec(c2)
			end;
		cell2:=cell;
		c2:=c;
		while ((cell2^.TxtVal.Flags and TFL_RIGHTMASK)>0) and (c2<=Parms.Columns) do
			begin
				cmax:=c2;
				cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags and not(TFL_RIGHTMASK);
				inc(longint(cell2),CELLSIZE);
				inc(c2)
			end
	end;


function TCalcWindow.CheckOverflow(cell: PCell; var cmin,cmax: integer): boolean;
	var r,c,c2,
	    dummy,
	    xmin,xmax,
	    txtwidth,
	    colwidth : integer;
	    extent   : ARRAY_8;
	    cell2    : PCell;

	begin
		CheckOverflow:=false;
		if cell^.Typ<>CTYPE_TEXT then exit;
		if cell^.Data.Value=0 then exit;
		if bTst(cell^.TxtVal.Flags,TFL_CLIP) then exit;
		if (cell^.TxtVal.Rotat<>0) and (cell^.TxtVal.Rotat<>1800) then exit;
		Cell2RC(cell,r,c);
		colwidth:=GetColWidth(c);
		SetFont(cell^.TxtVal.Font,cell^.TxtVal.Size);
		vst_effects(vdiHandle,cell^.TxtVal.Effects);
		vst_rotation(vdiHandle,cell^.TxtVal.Rotat);
		if Speedo then vst_skew(vdiHandle,cell^.TxtVal.Skew);
		vst_alignment(vdiHandle,TA_LEFT,TA_TOP,dummy,dummy);
		if Speedo then vqt_my_extent(vdiHandle,cell^.Data.Txt^,extent)
		else
			vqt_extent(vdiHandle,cell^.Data.Txt^,extent);
		xmin:=Min(Min(extent[0],extent[2]),Min(extent[4],extent[6]));
		xmax:=Max(Max(extent[0],extent[2]),Max(extent[4],extent[6]));
		txtwidth:=xmax-xmin;
		if txtwidth>colwidth then
			begin
				case (cell^.TxtVal.Align and $0f) of
				TA_RIGHT:
					begin
						cell^.TxtVal.Flags:=cell^.TxtVal.Flags or TFL_TEXT2LEFT;
						c2:=c-1;
						cell2:=PCell(longint(cell)-CELLSIZE);
						dec(txtwidth,colwidth);
						while (txtwidth>0) and (c2>=0) do
							begin
								if bTst(PColFlags^[c2],CRF_UMBRUCH) then break;
								if cell2^.Typ<>CTYPE_EMPTY then break;
								if (cell2^.TxtVal.Flags and TFL_OVERFLOWMASK)<>0 then break;
								cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags or TFL_LEFTMASK;
								dec(txtwidth,GetColWidth(c2));
								dec(longint(cell2),CELLSIZE);
								dec(c2)
							end;
						inc(longint(cell2),CELLSIZE);
						cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags and not(TFL_TEXT2LEFT);
						cmin:=c2+1;
						cmax:=c
					end;
				TA_CENTER:
					begin
						dec(txtwidth,colwidth);
						dummy:=txtwidth shr 1;
						txtwidth:=dummy;
						cell^.TxtVal.Flags:=cell^.TxtVal.Flags or TFL_TEXT2LEFT;
						c2:=c-1;
						cell2:=PCell(longint(cell)-CELLSIZE);
						while (txtwidth>0) and (c2>=0) do
							begin
								if bTst(PColFlags^[c2],CRF_UMBRUCH) then break;
								if cell2^.Typ<>CTYPE_EMPTY then break;
								if (cell2^.TxtVal.Flags and TFL_OVERFLOWMASK)<>0 then break;
								cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags or TFL_LEFTMASK;
								dec(txtwidth,GetColWidth(c2));
								dec(longint(cell2),CELLSIZE);
								dec(c2)
							end;
						inc(longint(cell2),CELLSIZE);
						cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags and not(TFL_TEXT2LEFT);
						cmin:=c2+1;
						txtwidth:=dummy;
						cell^.TxtVal.Flags:=cell^.TxtVal.Flags or TFL_TEXT2RIGHT;
						c2:=c+1;
						cell2:=PCell(longint(cell)+CELLSIZE);
						while (txtwidth>0) and (c2<=Parms.Columns) do
							begin
								if bTst(PColFlags^[c2-1],CRF_UMBRUCH) then break;
								if cell2^.Typ<>CTYPE_EMPTY then break;
								if (cell2^.TxtVal.Flags and TFL_OVERFLOWMASK)<>0 then break;
								cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags or TFL_RIGHTMASK;
								dec(txtwidth,GetColWidth(c2));
								inc(longint(cell2),CELLSIZE);
								inc(c2)
							end;
						dec(longint(cell2),CELLSIZE);
						cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags and not(TFL_TEXT2RIGHT);
						cmax:=c2-1
					end
				else
					begin
						cell^.TxtVal.Flags:=cell^.TxtVal.Flags or TFL_TEXT2RIGHT;
						c2:=c+1;
						cell2:=PCell(longint(cell)+CELLSIZE);
						dec(txtwidth,colwidth);
						while (txtwidth>0) and (c2<=Parms.Columns) do
							begin
								if bTst(PColFlags^[c2-1],CRF_UMBRUCH) then break;
								if cell2^.Typ<>CTYPE_EMPTY then break;
								if (cell2^.TxtVal.Flags and TFL_OVERFLOWMASK)<>0 then break;
								cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags or TFL_RIGHTMASK;
								dec(txtwidth,GetColWidth(c2));
								inc(longint(cell2),CELLSIZE);
								inc(c2)
							end;
						dec(longint(cell2),CELLSIZE);
						cell2^.TxtVal.Flags:=cell2^.TxtVal.Flags and not(TFL_TEXT2RIGHT);
						cmax:=c2-1;
						cmin:=c
					end
				end;
				CheckOverflow:=true
			end;
		SetFont(GetStdFontIndex,GetStdFontSize);
		RestoreTextValues(vdiHandle)
	end;


procedure TCalcWindow.OutputVectorText(handle: integer; cell: PCell; const txt: string; const tval: TTxtVal; var cmpval: TOldTxtVal; csize: ARRAY_4; isnum: boolean);
	var extent   : ARRAY_8;
	    dummy,
	    xmin,ymin,
	    xmax,ymax,
	    tx,ty    : integer;

	procedure doalign;
	
		begin
			xmin:=Min(Min(extent[0],extent[2]),Min(extent[4],extent[6]));
			ymin:=Min(Min(extent[1],extent[3]),Min(extent[5],extent[7]));
			xmax:=Max(Max(extent[0],extent[2]),Max(extent[4],extent[6]));
			ymax:=Max(Max(extent[1],extent[3]),Max(extent[5],extent[7]));
			case (cell^.TxtVal.Align and $f0) of
			TA_OBEN:
				begin
					ty:=csize[1]+cmpval.brd1h-ymin;
					if cell^.Border.Top>16 then
						case (cell^.Border.Top shr 4) of
						2:
							inc(ty,cmpval.brd1h);
						3:
							inc(ty,cmpval.brd2h);
						4,5:
							inc(ty,cmpval.brd3h)
						end
				end;
			TA_MITTE:
				ty:=((csize[1]+csize[3]) shr 1)-((ymin+ymax) shr 1);
			else
				begin
					ty:=csize[3]-cmpval.brd1h-ymax;
					if cmpval.gitter then inc(ty);
					if cell^.Border.Bottom>16 then
						case (cell^.Border.Bottom shr 4) of
						2:
							dec(ty,cmpval.brd1h);
						3:
							dec(ty,cmpval.brd2h);
						4,5:
							dec(ty,cmpval.brd3h)
						end
				end
			end;
			case (cell^.TxtVal.Align and $0f) of
			TA_RIGHT:
				begin
					tx:=csize[2]-cmpval.brd1w-xmax;
					if not(cmpval.gitter) then dec(tx);
					if cell^.Border.Right>16 then
						case (cell^.Border.Right shr 4) of
						2:
							dec(tx,cmpval.brd1w);
						3:
							dec(tx,cmpval.brd2w);
						4,5:
							dec(tx,cmpval.brd3w)
						end
				end;
			TA_CENTER:
				tx:=((csize[0]+csize[2]) shr 1)-((xmin+xmax) shr 1);
			else
				begin
					tx:=csize[0]+Max(cmpval.brd1w,1)-xmin;
					if cell^.Border.Left>16 then
						case (cell^.Border.Left shr 4) of
						2:
							inc(tx,cmpval.brd1w);
						3:
							inc(tx,cmpval.brd2w);
						4,5:
							inc(tx,cmpval.brd3w)
						end
				end
			end
		end;

	procedure checkrotat;
	
		begin
			case cmpval.oldrotat of
			900:
				begin
					extent[1]:=-extent[1];
					extent[3]:=-extent[3];
					extent[5]:=-extent[5];
					extent[7]:=-extent[7]
				end;
			1800:
				begin
					extent[0]:=-extent[0];
					extent[1]:=-extent[1];
					extent[2]:=-extent[2];
					extent[3]:=-extent[3];
					extent[4]:=-extent[4];
					extent[5]:=-extent[5];
					extent[6]:=-extent[6];
					extent[7]:=-extent[7]
				end;
			2700:
				begin
					extent[0]:=-extent[0];
					extent[2]:=-extent[2];
					extent[4]:=-extent[4];
					extent[6]:=-extent[6]
				end
			end
		end;

	function overflow: boolean;

		begin
			inc(xmin,tx);
			inc(xmax,tx);
			inc(ymin,ty);
			inc(ymax,ty);
			overflow:=((xmin<csize[0]-cmpval.brd1w-1) or (ymin<csize[1]-cmpval.brd1h-1) or (xmax>csize[2]+cmpval.brd1w+1) or (ymax>csize[3]+cmpval.brd1h+1))
		end;

	begin
		{ Textattribute setzen}
		if tval.Color<>cmpval.oldtcolor then
			begin
				vst_color(handle,tval.Color);
				cmpval.oldtcolor:=tval.Color
			end;
		if tval.Effects<>cmpval.oldeffects then
			begin
				vst_effects(handle,tval.Effects);
				cmpval.oldeffects:=tval.Effects
			end;
		if tval.Rotat<>cmpval.oldrotat then
			begin
				vst_rotation(handle,tval.Rotat);
				cmpval.oldrotat:=tval.Rotat
			end;
		if tval.Skew<>cmpval.oldskew then
			begin
				if Speedo then vst_skew(handle,tval.Skew);
				cmpval.oldskew:=tval.Skew
			end;
		{ Text ausgeben }
		if TexelApp.NVDIVersion>=$0300 then
			begin
				vqt_real_extent(handle,0,0,txt,extent);
				doalign;
				if isnum then
					if TexelApp.setupbuffer.overflow=bf_Checked then
						if overflow then
							begin
								v_ftext(handle,tx,ty,StrPFill(length(txt),'#'));
								exit
						  end;
				v_ftext(handle,tx,ty,txt)
			end
		else
			begin
				if Speedo then vqt_f_extent(handle,txt,extent)
				else
					vqt_extent(handle,txt,extent);
				checkrotat;
				doalign;
				if isnum then
					if TexelApp.setupbuffer.overflow=bf_Checked then
						if overflow then
							begin
								if Speedo then v_ftext(handle,tx,ty,StrPFill(length(txt),'#'))
								else
									v_gtext(handle,tx,ty,StrPFill(length(txt),'#'));
								exit
							end;
				if Speedo then v_ftext(handle,tx,ty,txt)
				else
					v_gtext(handle,tx,ty,txt)
			end
	end;


procedure TCalcWindow.OutputKF(handle,kfx,kfy,alh,alv,pagenum,pages: integer; printtime: longint; s: string);
	var k,dummy: integer;
	    wert,s2: string;

	begin
		if length(s)=0 then exit;
		k:=pos('#',s);
		s2:='';
		while k>0 do
			begin
				wert:='';
				case upcase(s[k+1]) of
				'#':
					wert:='#';
				'D':
					wert:=StrPLeft(TexelApp.Time2Str(printtime),8);
				'T','Z':
					wert:=StrPRight(TexelApp.Time2Str(printtime),5);
				'F':
					begin
						wert:=GetWindowFilename;
						if length(wert)=0 then wert:=GetRawIconTitle
					end;
				'P','S':
					wert:=ltoa(pagenum+1);
				'G':
					wert:=ltoa(pages);
				'A':
					wert:=infobuf.Autor;
				end;
				s2:=s2+StrPLeft(s,k-1)+wert;
				s:=StrPRight(s,length(s)-k-1);
				k:=pos('#',s)
			end;
		vst_alignment(handle,alh,alv,dummy,dummy);
		if Speedo then v_ftext(handle,kfx,kfy,s2+s)
		else
			v_gtext(handle,kfx,kfy,s2+s)
	end;


procedure TCalcWindow.OutputErrorText(handle: integer; cell: PCell; const tval: TTxtVal; var cmpval: TOldTxtVal; csize: ARRAY_4; err: shortint);
	var s: string;

	begin
		s:=Error2Txt(err);
		OutputVectorText(handle,cell,s,tval,cmpval,csize,false)
	end;


procedure TCalcWindow.Paint(var PaintInfo: TPaintStruct);
	label _nextgit,_endgit;

	var cnum,lofs,
      greylen   : longint;
	    clp,clp2,
	    gclp,
	    clp3,bclp : GRECT;
	    xy,xy2,xy3,
	    brd,tover,
	    notexy,
	    protxy    : ARRAY_4;
	    q,w,yofs,
	    dummy,b,
	    tx,ty,c2,
	    protsize,
	    oldlcolor,
	    oldcolor,
	    oldstyle,
	    oldinter  : integer;
	    pttrn     : word;
	    umbruch,
	    umorgit,
	    greyed    : boolean;
	    sval      : string;
	    colarray  : ARRAY_2;
	    ext       : ARRAY_8;
	    pe        : PEmbedded;
	    srcmfdb,
	    dstmfdb   : MFDB;
	    pgrey     : PWord;
	    grey50    : pointer;
	    cmpval    : TOldTxtVal;
	    cell2     : PCell;

	procedure setfontattr(const tval: TTxtVal);
	
		begin
			if (tval.Font<>cmpval.oldfont) or (tval.Size<>cmpval.oldsize) then
				begin
					SetFont(tval.Font,tval.Size);
					cmpval.oldsize:=tval.Size;
					cmpval.oldfont:=tval.Font
				end
		end;

	procedure drawbackground;
	
		begin
			with PCell(cnum)^ do
				begin
					if Style<>oldstyle then
						begin
							vsf_style(vdiHandle,Style);
							oldstyle:=Style
						end;
					if Interior<>oldinter then
						begin
							vsf_interior(vdiHandle,Interior);
							oldinter:=Interior
						end;
					if Color<>oldcolor then
						begin
							vsf_color(vdiHandle,Color);
							oldcolor:=Color
						end
				end;
			vr_recfl(vdiHandle,xy3)
		end;
	
	procedure greyout;
		var w,q: integer;
	
		begin
			ext[4]:=clp2.X1;
			ext[5]:=clp2.Y1;
			ext[6]:=clp2.X2;
			ext[7]:=clp2.Y2;
			ext[2]:=clp2.W-1;
			ext[3]:=clp2.H-1;
			srcmfdb.fd_stand:=0;
			srcmfdb.fd_nplanes:=1;
			srcmfdb.fd_w:=clp2.W;
			srcmfdb.fd_h:=clp2.H;
			srcmfdb.fd_wdwidth:=(clp2.W+15) shr 4;
			greylen:=longint(srcmfdb.fd_h)*longint(srcmfdb.fd_wdwidth shl 1);
			getmem(grey50,greylen);
			if grey50<>nil then
				begin
					pttrn:=$5555;
					pgrey:=PWord(grey50);
					for q:=0 to clp2.H-1 do
						begin
							for w:=1 to  srcmfdb.fd_wdwidth do
								begin
									pgrey^:=pttrn;
									inc(longint(pgrey),2)
								end;
							pttrn:=pttrn xor $ffff
						end;
					srcmfdb.fd_addr:=grey50;
					dstmfdb.fd_addr:=nil;
					vs_clip(vdiHandle,CLIP_ON,clp2.A2);
					vrt_cpyfm(vdiHandle,2,ext,srcmfdb,dstmfdb,colarray);
					freemem(grey50,greylen)
				end
		end;

	begin
		{ Dialog zeichnen }
		inherited Paint(PaintInfo);
		{ Offsets berechnen... }
		yofs:=Work.Y+PaintOffs;
		{ Linie zwischen Dialog und Blatt }
		pxya[0]:=Work.X1;
		pxya[1]:=yofs-1;
		pxya[2]:=Work.X2;
		pxya[3]:=pxya[1];
		v_pline(Application^.vdiHandle,2,pxya);
		{ Quadrat links oben zeichnen }
		xy[0]:=Work.X;
		xy[1]:=yofs;
		xy[2]:=xy[0]+LeftColWidth-1;
		xy[3]:=xy[1]+TopRowHeight-1;
		vsf_color(vdiHandle,White);
		v_bar(vdiHandle,xy);
		if TexelApp.ColFX then
			begin
				inc(xy[0]);
				inc(xy[1]);
				vsf_interior(vdiHandle,FIS_SOLID);
				vsf_color(vdiHandle,LWhite);
				v_bar(vdiHandle,xy)
			end;
		{ durchgezogene Linien }
		pxya[0]:=Work.X1;
		pxya[1]:=yofs+TopRowHeight;
		pxya[2]:=Work.X2;
		pxya[3]:=pxya[1];
		v_pline(Application^.vdiHandle,2,pxya);
		pxya[0]:=Work.X1+LeftColWidth;
		pxya[1]:=yofs;
		pxya[2]:=pxya[0];
		pxya[3]:=Work.Y2;
		v_pline(Application^.vdiHandle,2,pxya);
		PaintNames(PaintInfo.rcPaint);
		PaintNumbers(PaintInfo.rcPaint);
		{ Zeilen durchlaufen }
		lofs:=longint(Parms.Columns+1)*CELLSIZE;
		w:=tcnum;
		q:=GetRowHeight(w);
		clp.X:=Work.X;
		clp.Y:=yofs+TopRowHeight+1;
		clp.W:=LeftColWidth;
		clp.H:=q-tpoffs;
		GRtoA2(clp);
		xy3[3]:=clp.Y2;
		xy3[1]:=xy3[3]-q;
		if sheetbuffer.protect=bf_Unchecked then protsize:=-1
		else
			protsize:=round(2*percentsize);
		with cmpval do
			begin
				oldfont:=GetFontIndex;
				oldsize:=GetFontSize;
				brd1w:=Max(round(percentsize*Border1*1000.0/longint(Application^.Attr.PixW))-1,0);
				brd2w:=Max(round(percentsize*Border2*1000.0/longint(Application^.Attr.PixW))-1,0);
				brd3w:=Max(round(percentsize*Border3*1000.0/longint(Application^.Attr.PixW))-1,0);
				brd1h:=Max(round(percentsize*Border1*1000.0/longint(Application^.Attr.PixH))-1,0);
				brd2h:=Max(round(percentsize*Border2*1000.0/longint(Application^.Attr.PixH))-1,0);
				brd3h:=Max(round(percentsize*Border3*1000.0/longint(Application^.Attr.PixH))-1,0);
				gitter:=(sheetbuffer.gitter=bf_Checked)
			end;
		oldcolor:=White;
		oldlcolor:=Black;
		oldstyle:=0;
		oldinter:=FIS_HOLLOW;
		umbruch:=(sheetbuffer.umbruch=bf_Checked);
		umorgit:=cmpval.gitter or umbruch;
		vsf_color(vdiHandle,oldcolor);
		vsf_style(vdiHandle,oldstyle);
		vsf_interior(vdiHandle,oldinter);
		vsf_interior(Application^.vdiHandle,FIS_SOLID);
		vsl_color(vdiHandle,oldlcolor);
		SetFont(cmpval.oldfont,cmpval.oldsize);
		InitTextValues(vdiHandle,cmpval);
		repeat
			inc(w);
			{ Spalten durchlaufen }
			cnum:=longint(Sheet)+(longint(w-1)*longint(Parms.Columns+1)+longint(lcnum))*CELLSIZE;
			q:=lcnum;
			clp3.X:=clp.X2+2;
			clp3.Y:=clp.Y;
			clp3.W:=GetColWidth(q)-lpoffs-1;
			clp3.H:=clp.H;
			xy3[0]:=clp.X2+1-lpoffs;
			if cmpval.gitter then dec(xy3[3]);
			protxy[1]:=xy3[1];
			protxy[3]:=protxy[1]+protsize;
			notexy[1]:=protxy[3]+1;
			notexy[3]:=notexy[1]+protsize;
			GRtoA2(clp3);
			repeat
				clp2:=clp3;
				if rc_intersect(PaintInfo.rcPaint,clp2) then
					begin
						vs_clip(Application^.vdiHandle,CLIP_ON,clp2.A2);
						vs_clip(vdiHandle,CLIP_ON,clp2.A2);
						xy3[2]:=clp3.X2;
						if cmpval.gitter then
							if (PCell(cnum)^.TxtVal.Flags and TFL_GITTERMASK)=0 then dec(xy3[2]);
						{ Zellinhalt }
						drawbackground;
						with PCell(cnum)^ do
							begin
								vswr_mode(vdiHandle,MD_TRANS);
								case Typ of
								CTYPE_TEXT:
									if Data.Value<>0 then
										begin
											setfontattr(TxtVal);
											OutputVectorText(vdiHandle,PCell(cnum),Data.Txt^,TxtVal,cmpval,xy3,false)
										end;
								CTYPE_CONST:
									with Data.Konst^ do
										begin
											if Val2Txt(Value,sval,FPts,Format,PCell(cnum)) then drawbackground;
											setfontattr(TxtVal);
											OutputVectorText(vdiHandle,PCell(cnum),sval,TxtVal,cmpval,xy3,true)
										end;
								CTYPE_FORMULA:
									with Data.Formula^ do
										if Error=FE_OK then
											begin
												if Val2Txt(Value,sval,FPts,Format,PCell(cnum)) then drawbackground;
												setfontattr(TxtVal);
												OutputVectorText(vdiHandle,PCell(cnum),sval,TxtVal,cmpval,xy3,true)
											end
										else
											begin
												setfontattr(TxtVal);
												OutputErrorText(vdiHandle,PCell(cnum),TxtVal,cmpval,xy3,Error)
											end;
								CTYPE_EMPTY:
									begin
										if bTst(TxtVal.Flags,TFL_TEXTFROMLEFT) then
											begin
												tover:=xy3;
												c2:=q;
												cell2:=PCell(cnum);
												repeat
													dec(longint(cell2),CELLSIZE);
													dec(c2);
													if c2<0 then break
													else
														begin
															tover[2]:=tover[0]-1;
															dec(tover[0],GetColWidth(c2))
														end;
												until (cell2^.TxtVal.Flags and TFL_RIGHTMASK)=TFL_TEXT2RIGHT;
												if c2>=0 then
													begin
														setfontattr(cell2^.TxtVal);
														OutputVectorText(vdiHandle,cell2,cell2^.Data.Txt^,cell2^.TxtVal,cmpval,tover,false)
													end
											end
										else
											if bTst(TxtVal.Flags,TFL_TEXTFROMRIGHT) then
												begin
													tover:=xy3;
													c2:=q;
													cell2:=PCell(cnum);
													repeat
														inc(longint(cell2),CELLSIZE);
														inc(c2);
														if c2>Parms.Columns then break
														else
															begin
																tover[0]:=tover[2]+1;
																inc(tover[2],GetColWidth(c2));
																if cmpval.gitter then dec(tover[2])
															end;
													until (cell2^.TxtVal.Flags and TFL_LEFTMASK)=TFL_TEXT2LEFT;
													if c2<=Parms.Columns then
														begin
															setfontattr(cell2^.TxtVal);
															OutputVectorText(vdiHandle,cell2,cell2^.Data.Txt^,cell2^.TxtVal,cmpval,tover,false)
														end
												end
									end
								end;
								vswr_mode(vdiHandle,MD_REPLACE);
								if cmpval.gitter then
									begin
										if (PCell(cnum)^.TxtVal.Flags and TFL_GITTERMASK)=0 then inc(xy3[2]);
										inc(xy3[3])
									end;
								with Border do
									if (Val1<>0) or (Val2<>0) then
										begin
											bclp.X:=clp3.X-1;
											bclp.Y:=clp3.Y-1;
											bclp.W:=clp3.W+1;
											bclp.H:=clp3.H+1;
											if rc_intersect(PaintInfo.rcPaint,bclp) then
												begin
													vs_clip(vdiHandle,CLIP_ON,bclp.A2);
													if Left>=16 then
														if (TxtVal.Flags and TFL_LEFTBORDER)=0 then
															begin
																if (Left and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Left and $f;
																		vsl_color(vdiHandle,oldlcolor)
																	end;
																case (Left shr 4) of
																1:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=xy3[1];
																		brd[2]:=brd[0];
																		brd[3]:=xy3[3];
																		v_pline(vdiHandle,2,brd)
																	end;
																2:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd1w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				inc(brd[0])
																			end
																	end;
																3:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd2w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				inc(brd[0])
																			end
																	end;
																4:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd3w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				inc(brd[0])
																			end
																	end;
																5:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd1w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				inc(brd[0])
																			end;
																		brd[0]:=xy3[0]+cmpval.brd3w;
																		for b:=0 to cmpval.brd1w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				dec(brd[0])
																			end
																	end
																end
															end;
													if Right>=16 then
														if (TxtVal.Flags and TFL_RIGHTBORDER)=0 then
															begin
																if (Right and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Right and $f;
																		vsl_color(vdiHandle,oldlcolor)
																	end;
																case (Right shr 4) of
																1:
																	begin
																		brd[0]:=xy3[2];
																		brd[1]:=xy3[1];
																		brd[2]:=brd[0];
																		brd[3]:=xy3[3];
																		v_pline(vdiHandle,2,brd)
																	end;
																2:
																	begin
																		brd[0]:=xy3[2];
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd1w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				dec(brd[0])
																			end
																	end;
																3:
																	begin
																		brd[0]:=xy3[2];
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd2w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				dec(brd[0])
																			end
																	end;
																4:
																	begin
																		brd[0]:=xy3[2];
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd3w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				dec(brd[0])
																			end
																	end;
																5:
																	begin
																		brd[0]:=xy3[2];
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd1w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				dec(brd[0])
																			end;
																		brd[0]:=xy3[2]-cmpval.brd3w;
																		for b:=0 to cmpval.brd1w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(vdiHandle,2,brd);
																				inc(brd[0])
																			end
																	end
																end
															end;
													if Top>=16 then
														begin
															if (Top and $f)<>oldlcolor then
																begin
																	oldlcolor:=Top and $f;
																	vsl_color(vdiHandle,oldlcolor)
																end;
															case (Top shr 4) of
															1:
																begin
																	brd[0]:=xy3[0];
																	brd[1]:=xy3[1];
																	brd[2]:=xy3[2];
																	brd[3]:=brd[1];
																	v_pline(vdiHandle,2,brd)
																end;
															2:
																begin
																	brd[1]:=xy3[1];
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd1h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[1])
																		end
																end;
															3:
																begin
																	brd[1]:=xy3[1];
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd2h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[1])
																		end
																end;
															4:
																begin
																	brd[1]:=xy3[1];
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd3h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[1])
																		end
																end;
															5:
																begin
																	brd[1]:=xy3[1];
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd1h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[1])
																		end;
																	brd[1]:=xy3[1]+cmpval.brd3h;
																	for b:=0 to cmpval.brd1h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			dec(brd[1])
																		end
																end
															end
														end;
													if Bottom>=16 then
														begin
															if (Bottom and $f)<>oldlcolor then
																begin
																	oldlcolor:=Bottom and $f;
																	vsl_color(vdiHandle,oldlcolor)
																end;
															case (Bottom shr 4) of
															1:
																begin
																	brd[0]:=xy3[0];
																	brd[1]:=xy3[3];
																	brd[2]:=xy3[2];
																	brd[3]:=brd[1];
																	v_pline(vdiHandle,2,brd)
																end;
															2:
																begin
																	brd[1]:=xy3[3];
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd1h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			dec(brd[1])
																		end
																end;
															3:
																begin
																	brd[1]:=xy3[3];
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd2h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			dec(brd[1])
																		end
																end;
															4:
																begin
																	brd[1]:=xy3[3];
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd3h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			dec(brd[1])
																		end
																end;
															5:
																begin
																	brd[1]:=xy3[3];
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd1h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			dec(brd[1])
																		end;
																	brd[1]:=xy3[3]-cmpval.brd3h;
																	for b:=0 to cmpval.brd1h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[1])
																		end
																end
															end
														end;
													if Hor>=16 then
														begin
															if (Hor and $f)<>oldlcolor then
																begin
																	oldlcolor:=Hor and $f;
																	vsl_color(vdiHandle,oldlcolor)
																end;
															case (Hor shr 4) of
															1:
																begin
																	brd[0]:=xy3[0];
																	brd[1]:=(xy3[1]+xy3[3]) shr 1;
																	brd[2]:=xy3[2];
																	brd[3]:=brd[1];
																	v_pline(vdiHandle,2,brd)
																end;
															2:
																begin
																	brd[1]:=(xy3[1]+xy3[3]-cmpval.brd1h) shr 1;
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd1h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[1])
																		end
																end;
															3:
																begin
																	brd[1]:=(xy3[1]+xy3[3]-cmpval.brd2h) shr 1;
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd2h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[1])
																		end
																end;
															4:
																begin
																	brd[1]:=(xy3[1]+xy3[3]-cmpval.brd3h) shr 1;
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd3h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[1])
																		end
																end;
															5:
																begin
																	brd[1]:=(xy3[1]+xy3[3]-cmpval.brd3h) shr 1;
																	brd[0]:=xy3[0];
																	brd[2]:=xy3[2];
																	for b:=0 to cmpval.brd1h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[1])
																		end;
																	brd[1]:=(xy3[1]+xy3[3]+cmpval.brd3h) shr 1;
																	for b:=0 to cmpval.brd1h do
																		begin
																			brd[3]:=brd[1];
																			v_pline(vdiHandle,2,brd);
																			dec(brd[1])
																		end
																end
															end
														end;
													if Vert>=16 then
														begin
															if (Vert and $f)<>oldlcolor then
																begin
																	oldlcolor:=Vert and $f;
																	vsl_color(vdiHandle,oldlcolor)
																end;
															case (Vert shr 4) of
															1:
																begin
																	brd[0]:=(xy3[0]+xy3[2]) shr 1;
																	brd[1]:=xy3[1];
																	brd[2]:=brd[0];
																	brd[3]:=xy3[3];
																	v_pline(vdiHandle,2,brd)
																end;
															2:
																begin
																	brd[0]:=(xy3[0]+xy3[2]-cmpval.brd1w) shr 1;
																	brd[1]:=xy3[1];
																	brd[3]:=xy3[3];
																	for b:=0 to cmpval.brd1w do
																		begin
																			brd[2]:=brd[0];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[0])
																		end
																end;
															3:
																begin
																	brd[0]:=(xy3[0]+xy3[2]-cmpval.brd2w) shr 1;
																	brd[1]:=xy3[1];
																	brd[3]:=xy3[3];
																	for b:=0 to cmpval.brd2w do
																		begin
																			brd[2]:=brd[0];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[0])
																		end
																end;
															4:
																begin
																	brd[0]:=(xy3[0]+xy3[2]-cmpval.brd3w) shr 1;
																	brd[1]:=xy3[1];
																	brd[3]:=xy3[3];
																	for b:=0 to cmpval.brd3w do
																		begin
																			brd[2]:=brd[0];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[0])
																		end
																end;
															5:
																begin
																	brd[0]:=(xy3[0]+xy3[2]-cmpval.brd3w) shr 1;
																	brd[1]:=xy3[1];
																	brd[3]:=xy3[3];
																	for b:=0 to cmpval.brd1w do
																		begin
																			brd[2]:=brd[0];
																			v_pline(vdiHandle,2,brd);
																			inc(brd[0])
																		end;
																	brd[0]:=(xy3[0]+xy3[2]+cmpval.brd3w) shr 1;
																	for b:=0 to cmpval.brd1w do
																		begin
																			brd[2]:=brd[0];
																			v_pline(vdiHandle,2,brd);
																			dec(brd[0])
																		end
																end
															end
														end;
													vs_clip(vdiHandle,CLIP_ON,clp2.A2)
												end
										end;
								if cmpval.gitter then dec(xy3[3])
							end;
						if umorgit then
							begin
								if not(cmpval.gitter) then dec(xy3[3]);
								{ Begrenzungslinien }
								if TexelApp.ColFX then vsl_color(Application^.vdiHandle,LWhite)
								else
									vsl_type(Application^.vdiHandle,LT_USERDEF);
								if PCell(cnum)^.Border.Right<16 then
									if (PCell(cnum)^.TxtVal.Flags and TFL_GITTERMASK)=0 then
										begin
											if q<Parms.Columns then
												if PCell(cnum+CELLSIZE)^.Border.Left>=16 then goto _nextgit;
											xy2[0]:=xy3[2];
											xy2[1]:=xy3[1];
											xy2[2]:=xy2[0];
											xy2[3]:=xy3[3]+1;
											if bTst(PColFlags^[q],CRF_UMBRUCH) and umbruch then
												begin
													vsl_type(Application^.vdiHandle,LT_DASHDOTDOT);
													vsl_color(Application^.vdiHandle,LRed);
													v_pline(Application^.vdiHandle,2,xy2);
													if TexelApp.ColFX then
														begin
															vsl_color(Application^.vdiHandle,LWhite);
															vsl_type(Application^.vdiHandle,LT_SOLID)
														end
													else
														vsl_type(Application^.vdiHandle,LT_USERDEF)
												end
											else
												if cmpval.gitter then v_pline(Application^.vdiHandle,2,xy2)
										end;
								_nextgit:
								if PCell(cnum)^.Border.Bottom<16 then
									begin
										if w<=Parms.Rows then
											if PCell(cnum+lofs)^.Border.Top>=16 then goto _endgit;
										xy2[0]:=xy3[0];
										xy2[1]:=xy3[3]+1;
										xy2[2]:=xy3[2];
										xy2[3]:=xy2[1];
										if bTst(PRowFlags^[w-1],CRF_UMBRUCH) and umbruch then
											begin
												vsl_type(Application^.vdiHandle,LT_DASHDOTDOT);
												vsl_color(Application^.vdiHandle,LRed);
												v_pline(Application^.vdiHandle,2,xy2)
											end
										else
											if cmpval.gitter then v_pline(Application^.vdiHandle,2,xy2)
									end;
								_endgit:
								vsl_type(Application^.vdiHandle,LT_SOLID);
								vsl_color(Application^.vdiHandle,Black)
							end
						else
							dec(xy3[3]);
						if bTst(PCell(cnum)^.Flags,CELL_PROTECTED) then
							if protsize>0 then
								begin
									protxy[0]:=xy3[0];
									protxy[2]:=protxy[0]+protsize;
									vsf_color(Application^.vdiHandle,Red);
									vr_recfl(Application^.vdiHandle,protxy);
									vsf_color(Application^.vdiHandle,Black)
								end;
						if bTst(PCell(cnum)^.Flags,CELL_HASNOTE) then
							if protsize>0 then
								begin
									notexy[0]:=xy3[0];
									notexy[2]:=notexy[0]+protsize;
									vsf_color(Application^.vdiHandle,Green);
									vr_recfl(Application^.vdiHandle,notexy);
									vsf_color(Application^.vdiHandle,Black)
								end;
						if bTst(PCell(cnum)^.Flags,CELL_SELECTED) then
							begin
								dec(xy3[2]);
								vswr_mode(Application^.vdiHandle,MD_XOR);
								vr_recfl(Application^.vdiHandle,xy3);
								vswr_mode(Application^.vdiHandle,MD_REPLACE)
							end;
						if not(cmpval.gitter) then inc(xy3[3])
					end;
				inc(q);
				if q>Parms.Columns then break;
				clp3.X1:=clp3.X2+1;
				inc(clp3.X2,GetColWidth(q));
				A2toGR(clp3);
				xy3[0]:=clp3.X-1;
				inc(cnum,CELLSIZE)
			until clp3.X1>Work.X2;
			{ n„chste Zeile }
			if w>Parms.Rows then break;
			clp.Y1:=clp.Y2+1;
			xy3[1]:=clp.Y2;
			inc(clp.Y2,GetRowHeight(w));
			A2toGR(clp);
			xy3[3]:=xy3[1]+clp.H
		until clp.Y1>Work.Y2;
		vsl_color(vdiHandle,Black);
		vs_clip(vdiHandle,CLIP_ON,SysInfo.Desktop.A2);
		if TexelApp.ColFX then
			begin
				vsf_interior(vdiHandle,FIS_SOLID);
				vsf_color(vdiHandle,LWhite)
			end
		else
			vsf_interior(vdiHandle,FIS_HOLLOW);
		if clp3.X2<Work.X2 then
			begin
				clp2.X:=clp3.X2+1;
				clp2.Y:=yofs+TopRowHeight+1;
				clp2.W:=Work.X2-clp3.X2;
				clp2.H:=Work.Y2+1-clp2.Y;
				clp3:=clp2;
				if rc_intersect(PaintInfo.rcPaint,clp2) then vr_recfl(vdiHandle,clp2.A2)
			end
		else
			clp3.W:=0;
		if clp.Y2<Work.Y2 then
			begin
				clp2.X:=Work.X1+LeftColWidth+1;
				clp2.Y:=clp.Y2+1;
				clp2.W:=Work.X2+1-clp2.X;
				clp2.H:=Work.Y2-clp.Y2;
				clp:=clp2;
				if rc_intersect(PaintInfo.rcPaint,clp2) then vr_recfl(vdiHandle,clp2.A2)
			end
		else
			clp.W:=0;
		if Embedded<>nil then
			if sheetbuffer.images=bf_Checked then
				begin
					GetSheetRect(bclp);
					if rc_intersect(PaintInfo.rcPaint,bclp) then
						begin
							ext[0]:=0;
							ext[1]:=0;
							colarray[0]:=0;
							colarray[1]:=0;
							pe:=Embedded;
							while pe<>nil do
								begin
									if pe^.IsVisible(bclp,true) then
										begin
											vs_clip(vdiHandle,CLIP_ON,bclp.A2);
											pe^.Paint(vdiHandle,bclp,true);
											gclp.X:=pe^.GetPixXPos(true);
											gclp.Y:=pe^.GetPixYPos(true);
											gclp.W:=pe^.GetPixWidth(true);
											gclp.H:=pe^.GetPixHeight(true);
											greyed:=false;
											if clp.W>0 then
												begin
													clp2:=gclp;
													if rc_intersect(bclp,clp2) then
														if rc_intersect(clp,clp2) then
															begin
																greyout;
																greyed:=true
															end
												end;
											if clp3.W>0 then
												begin
													clp2:=gclp;
													if greyed then
														begin
															GRtoA2(clp2);
															clp2.Y2:=clp.Y-1;
															A2toGR(clp2)
														end;
													if rc_intersect(bclp,clp2) then
														if rc_intersect(clp3,clp2) then greyout
												end
										end;
									pe:=pe^.Next
								end
						end
				end;
		vsl_color(vdiHandle,Black);
		vs_clip(vdiHandle,CLIP_ON,SysInfo.Desktop.A2);
		SetFont(GetStdFontIndex,GetStdFontSize);
		RestoreTextValues(vdiHandle);
		vsf_interior(Application^.vdiHandle,FIS_HOLLOW);
		vs_clip(Application^.vdiHandle,CLIP_ON,SysInfo.Desktop.A2)
	end;


procedure TCalcWindow.ForceVRedraw;
	var pipe: Pipearray;

	begin
		pipe[0]:=WM_REDRAW;
		pipe[1]:=Application^.apID;
		pipe[2]:=0;
		pipe[3]:=Attr.gemHandle;
		pipe[4]:=Work.X;
		pipe[5]:=Work.Y+PaintOffs;
		pipe[6]:=Work.W;
		pipe[7]:=Work.H-PaintOffs;
		appl_write(pipe[1],16,@pipe)
	end;


function TCalcWindow.GetColWidth_mm100(num: integer): word;

	begin
		GetColWidth_mm100:=PCol^[num]
	end;


procedure TCalcWindow.SetColWidth_mm100(num: integer; width: longint; draw: boolean);
	var cmin,
	    cmax: integer;
	    sr  : GRECT;

	begin
		if width>65535 then width:=65535
		else
			if width<0 then width:=0;
		PCol^[num]:=width;
		if draw then
			begin
				SetScrollerRange;
				cmin:=num;
				cmax:=num;
				RowsClearOverflow(0,Parms.Rows,cmin,cmax);
				RowsCheckOverflow(0,Parms.Rows,cmin,cmax);
				wind_update(BEG_UPDATE);
				if GetVisibleBlockRect(0,cmin,Parms.Rows,Parms.Columns,sr) then WMRedraw(sr.X-1,Work.Y+PaintOffs,Work.X+Work.W,Work.H);
				wind_update(END_UPDATE);
				SetDirty
			end
	end;


function TCalcWindow.GetRowHeight_mm100(num: integer): word;

	begin
		GetRowHeight_mm100:=PRow^[num]
	end;


procedure TCalcWindow.SetRowHeight_mm100(num: integer; height: longint; draw: boolean);
	var r   : LGRECT;
	    pipe: Pipearray;

	begin
		if height>65535 then height:=65535
		else
			if height<0 then height:=0;
		PRow^[num]:=height;
		if draw then
			begin
				SetScrollerRange;
				Cell2Rect(num,0,r);
				pipe[0]:=WM_REDRAW;
				pipe[1]:=Application^.apID;
				pipe[2]:=0;
				pipe[3]:=Attr.gemHandle;
				pipe[4]:=Work.X;
				pipe[5]:=Max(integer(r.Y),Work.Y+PaintOffs);
				pipe[6]:=Work.W;
				pipe[7]:=Work.H;
				appl_write(pipe[1],16,@pipe);
				SetDirty
			end
	end;


function TCalcWindow.GetColWidth(num: integer): integer;

	begin
		GetColWidth:=round(longint(PCol^[num])*10.0*PercentSize/longint(Application^.Attr.PixW))+1
	end;


procedure TCalcWindow.SetColWidth(num: integer; width: longint; draw: boolean);

	begin
		SetColWidth_mm100(num,round(longint(width)*longint(Application^.Attr.PixW)/10.0),draw)
	end;


function TCalcWindow.GetRowHeight(num: integer): integer;

	begin
		GetRowHeight:=round(longint(PRow^[num])*10.0*PercentSize/longint(Application^.Attr.PixH))+1
	end;


procedure TCalcWindow.SetRowHeight(num: integer; height: longint; draw: boolean);

	begin
		SetRowHeight_mm100(num,round(longint(height)*longint(Application^.Attr.PixH)/10.0),draw)
	end;


procedure TCalcWindow.InsertCell(rs,cs,re,ce: integer);
	var txt  : string;
	    w,x  : integer;
	    tl,tr: char;

	begin
		txt:=StrPTrimF(inpline^.GetText);
		if length(txt)>0 then
			if txt[1]<>'=' then
				begin
					Application^.Bing;
					exit
				end;
		if (rs=re) and (cs=ce) then
			begin
				if (length(txt)=0) or (txt='=') then
					begin
						txt:='='+GetColumnIndex(cs)+GetRowIndex(rs);
						inpline^.SetText(txt);
						inpline^.SetCursor(length(txt))
					end
				else
					begin
						w:=inpline^.GetCursor;
						if w<1 then Application^.Bing
						else
							begin
								txt:=inpline^.GetText;
								tl:=txt[w];
								if w<length(txt) then tr:=txt[w+1]
								else
									tr:=#0;
								if ((tl in [' ','(','+','-','*','/','^',',','=']) and (tr in [#0,' ',')','+','-','*','/','^',','])) or ((tl=':') and (tr in [#0,')'])) then
									begin
										x:=length(txt)-w;
										txt:=StrPTrimF(StrPLeft(txt,w)+GetColumnIndex(cs)+GetRowIndex(rs)+StrPRight(txt,x));
										inpline^.SetText(txt);
										inpline^.SetCursor(length(txt)-x)
									end
								else
									Application^.Bing
							end
					end
			end
		else
			begin
				w:=inpline^.GetCursor;
				if w<1 then Application^.Bing
				else
					begin
						txt:=inpline^.GetText;
						tl:=txt[w];
						if w<length(txt) then tr:=txt[w+1]
						else
							tr:=#0;
						if (tl in [' ','(',',']) and (tr in [' ',')',',']) then
							begin
								x:=length(txt)-w;
								txt:=StrPTrimF(StrPLeft(txt,w)+GetColumnIndex(cs)+GetRowIndex(rs)+':'+GetColumnIndex(ce)+GetRowIndex(re)+StrPRight(txt,x));
								inpline^.SetText(txt);
								inpline^.SetCursor(length(txt)-x)
							end
						else
							Application^.Bing
					end
			end
	end;


procedure TCalcWindow.WMRubbox(r: GRECT);
	var cell      : PCell;
	    xl,xr,yo,
	    yu,cl,rw  : integer;

	begin
		inc(r.X,Work.X);
		inc(r.Y,Work.Y);
		GRtoA2(r);
		Mouse2Cell(r.X1,r.Y1,yo,xl);
		Mouse2Cell(r.X2,r.Y2,yu,xr);
		if inpstat then InsertCell(yo,xl,yu,xr)
		else
			with Parms.Cursor do
				if (xr>xl) or (yu>yo) then
					begin
						DrawCursor;
						DeselectAll;
						Block:=true;
						RowStart:=yo;
						ColStart:=xl;
						RowEnd:=yu;
						ColEnd:=xr;
						SetBlock;
						for rw:=yo to yu do
							begin
								cell:=GetCell(rw,xl);
								for cl:=xl to xr do
									begin
										with cell^ do Flags:=Flags or CELL_SELECTED;
										inc(longint(cell),CELLSIZE)
									end
							end;
						DrawCursor
					end
				else
					SetCursorPos(yo,xl,true)
	end;


procedure TCalcWindow.Mouse2Cell(x,y: integer; var r,c: integer);
	var q: longint;

	begin
		q:=(FindObject(x,y,false)-longint(Sheet)) div CELLSIZE;
		r:=q div (Parms.Columns+1);
		c:=q mod (Parms.Columns+1)
	end;


procedure TCalcWindow.DeselectAll;
	var x,y : integer;
	    cell: PCell;

	begin
		with Parms.Cursor do
			if Block then
				begin
					for y:=RowStart to RowEnd do
						begin
							cell:=GetCell(y,ColStart);
							for x:=ColStart to ColEnd do
								begin
									with cell^ do Flags:=Flags and not(CELL_SELECTED);
									inc(longint(cell),CELLSIZE)
								end
						end
				end
			else
				begin
					cell:=GetCell(Row,Col);
					with cell^ do Flags:=Flags and not(CELL_SELECTED)
				end
	end;


procedure TCalcWindow.StandardBreite(cs,ce: integer);
	var nw: longint;
	    q : integer;

	begin
		nw:=round(longint(wWidth)*atol(TexelApp.setupbuffer.stdcolwidth)*longint(Application^.Attr.PixW)/10.0);
		if ce>cs then
			for q:=ce downto cs+1 do SetColWidth_mm100(q,nw,false);
		SetColWidth_mm100(cs,nw,true)
	end;


procedure TCalcWindow.StandardHoehe(rs,re: integer);
	var nh: longint;
	    q : integer;

	begin
		nh:=round(longint(Attr.boxHeight)*longint(Application^.Attr.PixH)/10.0);
		if re>rs then
			for q:=re downto rs+1 do SetRowHeight_mm100(q,nh,false);
		SetRowHeight_mm100(rs,nh,true)
	end;


procedure TCalcWindow.WMRButton(mX,mY,KStat,Clicks: integer);
	var p     : PPopup;
	    num   : longint;
	    indx,w,
	    cmin,
	    cmax,
	    r,c   : integer;
	    cell  : PCell;
	    pe    : PEmbedded;

	procedure checkp2;

		begin
			p^.Disable(2);
			if Clipboard=nil then exit;
			with Clipboard^ do
				begin
					if not(OpenClipboard(false)) then exit;
					if GetPriorityClipboardFormat(TEXELEXTENSION+'.dif.csv')=TEXELEXTENSION then p^.Enable(2);
					{ andere Formate... }
					CloseClipboard
				end
		end;

	begin
		if Clicks<>1 then exit;
		num:=FindObject(mX,mY,false);
		if num=OBJ_TOGGLEALL then
			begin
				Application^.BubbleHelp(mX,mY,BUBBLE_SHEET_TOGGLE);
				exit
			end;
		if inpstat then
			begin
				Application^.Bing;
				exit
			end;
		if num<=OBJ_ROWOFFSET then
			begin
				indx:=OBJ_ROWOFFSET-num;
				if not(Parms.Cursor.Block) or (indx<Parms.Cursor.RowStart) or (indx>Parms.Cursor.RowEnd) or (Parms.Cursor.ColStart<>0) or (Parms.Cursor.ColEnd<>Parms.Columns) then
					begin
						DrawCursor;
						DeselectAll;
						with Parms.Cursor do
							begin
								Block:=true;
								RowStart:=indx;
								ColStart:=0;
								RowEnd:=RowStart;
								ColEnd:=Parms.Columns
							end;
						SetBlock;
						cell:=GetCell(Parms.Cursor.RowStart,0);
						for w:=0 to Parms.Columns do
							begin
								cell^.Flags:=cell^.Flags or CELL_SELECTED;
								inc(longint(cell),CELLSIZE)
							end;
						DrawCursor
					end;
				new(p,Init(@self,RTPOPUPS,RTPROWS,id_No));
				if p<>nil then
					begin
						checkp2;
						if Parms.Cursor.RowStart<>Parms.Cursor.RowEnd then p^.Disable(9)
						else
							if bTst(PRowFlags^[Parms.Cursor.RowStart],CRF_UMBRUCH) then p^.Check(9);
						case Application^.Popup(p,mX,mY,POP_CENTER) of
						0:
							CutCells;
						1:
							CopyCells;
						2:
							PasteCells;
						3:
							DeleteCells;
						5:
							AttrDialogs(2,indx,nil);
						6:
							{ ... };
						7:
							with Parms.Cursor do StandardHoehe(RowStart,RowEnd);
						9:
							begin
								PRowFlags^[Parms.Cursor.RowStart]:=PRowFlags^[Parms.Cursor.RowStart] xor CRF_UMBRUCH;
								DrawCells(Parms.Cursor.RowStart,0,Parms.Cursor.RowStart,Parms.Columns);
								SetDirty
							end;
						11:
							{ ... };
						12:
							{ ... }
						end
					end;
				exit
			end;
		if num<=OBJ_COLOFFSET then
			begin
				indx:=OBJ_COLOFFSET-num;
				if not(Parms.Cursor.Block) or (indx<Parms.Cursor.ColStart) or (indx>Parms.Cursor.ColEnd) or (Parms.Cursor.RowStart<>0) or (Parms.Cursor.RowEnd<>Parms.Rows) then
					begin
						DrawCursor;
						DeselectAll;
						with Parms.Cursor do
							begin
								Block:=true;
								RowStart:=0;
								ColStart:=indx;
								RowEnd:=Parms.Rows;
								ColEnd:=ColStart
							end;
						SetBlock;
						cell:=GetCell(0,Parms.Cursor.ColStart);
						for w:=0 to Parms.Rows do
							begin
								cell^.Flags:=cell^.Flags or CELL_SELECTED;
								inc(longint(cell),longint(Parms.Columns+1)*CELLSIZE)
							end;
						DrawCursor
					end;
				new(p,Init(@self,RTPOPUPS,RTPCOLUMNS,id_No));
				if p<>nil then
					begin
						checkp2;
						if Parms.Cursor.ColStart<>Parms.Cursor.ColEnd then p^.Disable(11)
						else
							if bTst(PColFlags^[Parms.Cursor.ColStart],CRF_UMBRUCH) then p^.Check(11);
						case Application^.Popup(p,mX,mY,POP_CENTER) of
						0:
							CutCells;
						1:
							CopyCells;
						2:
							PasteCells;
						3:
							DeleteCells;
						5:
							AttrDialogs(3,indx,nil);
						6:
							{ ... };
						7:
							with Parms.Cursor do StandardBreite(ColStart,ColEnd);
						9:
							AttrDialogs(4,indx,nil);
						11:
							begin
								cmin:=Parms.Cursor.ColStart;
								cmax:=cmin;
								RowsClearOverflow(0,Parms.Rows,cmin,cmax);
								PColFlags^[Parms.Cursor.ColStart]:=PColFlags^[Parms.Cursor.ColStart] xor CRF_UMBRUCH;
								RowsCheckOverflow(0,Parms.Rows,cmin,cmax);
								DrawCells(0,cmin,Parms.Rows,cmax);
								SetDirty
							end;
						13:
							{ ... };
						14:
							{ ... }
						end
					end;
				exit
			end;
		if num>$7fff then
			begin
				if Embedded<>nil then
					if sheetbuffer.images=bf_Checked then
						begin
							pe:=Embedded;
							while pe^.Next<>nil do pe:=pe^.Next;
							while pe<>nil do
								begin
									if pe^.IsInside(mX,mY) then
										begin
											pe^.RButton(mX,mY,KStat,Clicks);
											exit
										end;
									pe:=pe^.Prev
								end
						end;
				cell:=PCell(num);
				Cell2RC(cell,r,c);
				if not(Parms.Cursor.Block) or not(Between(r,Parms.Cursor.RowStart,Parms.Cursor.RowEnd)) or not(Between(c,Parms.Cursor.ColStart,Parms.Cursor.ColEnd)) then SetCursorPos(r,c,true);
				new(p,Init(@self,RTPOPUPS,RTPCELLS,id_No));
				if p<>nil then
					begin
						checkp2;
						if TexelApp.NoFontSel then p^.Disable(5);
{						if not(Parms.Cursor.Block) then !!! } p^.Disable(11);
{						if not(Parms.Cursor.Block) then ... } p^.Disable(13);
						case Application^.Popup(p,mX,mY,POP_CENTER) of
						0:
							CutCells;
						1:
							CopyCells;
						2:
							PasteCells;
						3:
							DeleteCells;
						5:
							FontSelect;
						6:
							AttrDialogs(0,0,cell);
						7:
							AttrDialogs(1,0,cell);
						8:
							AttrDialogs(6,0,cell);
						9:
							AttrDialogs(5,0,cell);
						11:
							if fill<>nil then fill^.HandleMenu(5);
						13:
							{ Export ... }
						end
					end
			end
	end;


procedure TCalcWindow.AttrDialogs(num,indx: integer; cell: PCell);
	var pe   : PEdit;
	    pc   : PTriState;
	    pcc  : PCheckBox;
	    pb   : PButton;
	    st   : PStatic;
	    pfcb : PFormCategoryBox;
	    x,y,
	    dummy: integer;
	    offs,
	    q    : longint;
	    c1,c2: PCell;
	    lfb,
	    rtb,
	    topb,
	    botb : byte;
	    lfeq,
	    rteq,
	    topeq,
	    boteq: boolean;

	function bequal(b1,b2: byte): boolean;
	
		begin
			bequal:=(((b1 and $0f)=(b2 and $0f)) or ((b1 shr 4)=0) or ((b2 shr 4)=0))
		end;
	
	function bcolor(b1,b2,b3,b4: byte): byte;
	
		begin
			if (b1 shr 4)>0 then bcolor:=(b1 and $0f)
			else if (b2 shr 4)>0 then bcolor:=(b2 and $0f)
			else if (b3 shr 4)>0 then bcolor:=(b3 and $0f)
			else if (b4 shr 4)>0 then bcolor:=(b4 and $0f)
			else
				bcolor:=White
		end;

	begin
		case num of
		0:
			begin
				if textattr=nil then
					begin
						new(textattr,Init(@self,TEXELWINDPREFIX+TITLE_TEXTATTR,STG_TEXTATTR,ICNTITLE_TEXTATTR,RTTEXTATTR));
						if textattr<>nil then
							begin
								new(PGroupBox,Init(textattr,RTTABEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
								new(PGroupBox,Init(textattr,RTTAEFFECTS,GROUP_TEXT_FX,''));
								new(PGroupBox,Init(textattr,RTTAANGLE,GROUP_TEXT_ANGLE,''));
								new(PGroupBox,Init(textattr,RTTAALIGN,GROUP_TEXT_ALIGNMENT,''));
								new(PGroupBox,Init(textattr,RTTAMISC,GROUP_TEXT_MISC,''));
								new(textattr^.bedt,Init(textattr,RTTABEDIT,16,false,BUBBLE_GENERAL_RANGE));
								new(textattr^.cb1,Init(textattr,RTTABOLD,BUBBLE_TEXTATTR_BOLD));
								new(textattr^.cb2,Init(textattr,RTTALIGHT,BUBBLE_TEXTATTR_LIGHT));
								new(textattr^.cb3,Init(textattr,RTTAITALIC,BUBBLE_TEXTATTR_ITALIC));
								new(textattr^.cb4,Init(textattr,RTTAUNDERLINED,BUBBLE_TEXTATTR_UNDERL));
								new(textattr^.cb5,Init(textattr,RTTAOUTLINE,BUBBLE_TEXTATTR_OUTL));
								new(textattr^.cb6,Init(textattr,RTTASHADOW,BUBBLE_TEXTATTR_SHADOW));
								new(PEdit,Init(textattr,RTTAROTAT,6,BUBBLE_TEXTATTR_ROTAT));
								new(pe,Init(textattr,RTTASKEW,6,BUBBLE_TEXTATTR_SKEW));
								if not(Speedo) then
									if pe<>nil then pe^.Disable;
								new(PTriState,Init(textattr,RTTACLIP,BUBBLE_TEXTATTR_CLIP));
								new(PRadioButton,Init(textattr,RTTALEFT,true,BUBBLE_TEXTATTR_LEFT));
								new(PRadioButton,Init(textattr,RTTACENTER,true,BUBBLE_TEXTATTR_CENTER));
								new(PRadioButton,Init(textattr,RTTARIGHT,true,BUBBLE_TEXTATTR_RIGHT));
								new(PColorBox,Init(textattr,RTTACOLOR,RTTACOLCYC,RTTACOLTITLE,RTPOPUPS,RTPCOLOR,RTPCOLSTART,false,false,BUBBLE_TEXTATTR_COLOR));
								new(PCheckBox,Init(textattr,RTTAROTOFF,true,BUBBLE_TEXTATTR_CROTAT));
								new(pcc,Init(textattr,RTTASKEWOFF,true,BUBBLE_TEXTATTR_CSKEW));
								if not(Speedo) then
									if pcc<>nil then pcc^.Disable;
								new(PCheckBox,Init(textattr,RTTAALIGNOFF,true,BUBBLE_TEXTATTR_CHALIGN));
								new(PCheckBox,Init(textattr,RTTACOLOFF,true,BUBBLE_TEXTATTR_CCOLOR));
								new(PCheckBox,Init(textattr,RTTAALIGNOFF2,true,BUBBLE_TEXTATTR_CVALIGN));
								new(PRadioButton,Init(textattr,RTTAOBEN,true,BUBBLE_TEXTATTR_TOP));
								new(PRadioButton,Init(textattr,RTTAMITTE,true,BUBBLE_TEXTATTR_MIDDLE));
								new(PRadioButton,Init(textattr,RTTAUNTEN,true,BUBBLE_TEXTATTR_BOTTOM));
								new(PButton,Init(textattr,RTTANONE,id_No,true,BUBBLE_TEXTATTR_FXOFF));
								new(PButton,Init(textattr,RTTAFXOFF,id_No,true,BUBBLE_TEXTATTR_FXIGNOR));
								new(pb,Init(textattr,RTTAHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(textattr,RTTACANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(PButton,Init(textattr,RTTASET,id_No,true,BUBBLE_GENERAL_SET));
								new(PButton,Init(textattr,RTTAOK,id_OK,true,BUBBLE_GENERAL_SETOK));
								with txabuffer do
									begin
										rotoff:=bf_Checked;
										skewoff:=bf_Checked;
										alignoff:=bf_Checked;
										coloff:=bf_Checked;
										alignoff2:=bf_Checked
									end;
								textattr^.TransferBuffer:=@txabuffer
							end
					end;
				if textattr<>nil then
					begin
						textattr^.bedt^.SetText(StrPTrimF(dblock^.GetText));
						with txabuffer do
							begin
								left:=bf_Unchecked;
								center:=bf_Unchecked;
								right:=bf_Unchecked;
								unten:=bf_Unchecked;
								mitte:=bf_Unchecked;
								oben:=bf_Unchecked
							end;
						with cell^.TxtVal do
							begin
								txabuffer.rotat:=ftoa(Rotat/10);
								txabuffer.skew:=ftoa(Skew/10);
								txabuffer.color:=Color;
								case (Align and $0f) of
								TA_CENTER:
									txabuffer.center:=bf_Checked;
								TA_RIGHT:
									txabuffer.right:=bf_Checked;
								else
									txabuffer.left:=bf_Checked
								end;
								case (Align and $f0) of
								TA_OBEN:
									txabuffer.oben:=bf_Checked;
								TA_MITTE:
									txabuffer.mitte:=bf_Checked
								else
									txabuffer.unten:=bf_Checked
								end;
								if bTst(Flags,TFL_CLIP) then txabuffer.clip:=bf_Checked
								else
									txabuffer.clip:=bf_Unchecked;
								if bTst(Effects,TF_THICKENED) then txabuffer.bold:=bf_Checked
								else
									txabuffer.bold:=bf_Unchecked;
								if bTst(Effects,TF_LIGHTENED) then txabuffer.light:=bf_Checked
								else
									txabuffer.light:=bf_Unchecked;
								if bTst(Effects,TF_SLANTED) then txabuffer.italic:=bf_Checked
								else
									txabuffer.italic:=bf_Unchecked;
								if bTst(Effects,TF_UNDERLINED) then txabuffer.under:=bf_Checked
								else
									txabuffer.under:=bf_Unchecked;
								if bTst(Effects,TF_OUTLINED) then txabuffer.outl:=bf_Checked
								else
									txabuffer.outl:=bf_Unchecked;
								if bTst(Effects,TF_SHADOWED) then txabuffer.shadow:=bf_Checked
								else
									txabuffer.shadow:=bf_Unchecked
							end;
						if (txabuffer.left=bf_Unchecked) and (txabuffer.center=bf_Unchecked) and (txabuffer.right=bf_Unchecked) then txabuffer.left:=bf_Checked;
						textattr^.TransferData(tf_SetData);
						textattr^.MakeWindow
					end
			end;
		1:
			begin
				if numformats=nil then
					begin
						new(numformats,Init(@self,TEXELWINDPREFIX+TITLE_NUMFORMAT,STG_NUMFORMAT,ICNTITLE_NUMFORMAT,RTFORMATS));
						if numformats<>nil then
							begin
								new(PGroupBox,Init(numformats,RTFBEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
								new(numformats^.bedt,Init(numformats,RTFBEDIT,16,false,BUBBLE_GENERAL_RANGE));
								new(pfcb,Init(numformats,RTFCATEGORY,RTFCATSLID,RTFCATDEC,RTFCATINC,TexelApp.FormCategories,false,BUBBLE_NUMFORM_CATEGORY));
								new(pfcb^.flist,Init(75,25));
								new(pfcb^.fbox,Init(numformats,RTFFORMATS,RTFFORMSLID,RTFFORMDEC,RTFFORMINC,pfcb^.flist,true,BUBBLE_NUMFORM_FORMLIST));
								if pfcb^.fbox<>nil then pfcb^.fbox^.pfcb:=pfcb;
								new(pfcb^.format,Init(numformats,RTFFORMAT,51,BUBBLE_NUMFORM_FORMAT));
								new(pfcb^.preview,Init(numformats,RTFPREVIEW,31,false,BUBBLE_NUMFORM_PREVIEW));
								new(PButton,Init(numformats,RTFNEW,id_No,true,BUBBLE_NUMFORM_NEW));
								new(pfcb^.delbtn,Init(numformats,RTFDELETE,id_No,true,BUBBLE_NUMFORM_DELETE));
								new(pfcb^.chgbtn,Init(numformats,RTFCHANGE,id_No,true,BUBBLE_NUMFORM_CHANGE));
								new(pb,Init(numformats,RTFHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(numformats,RTFABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(pfcb^.setbtn,Init(numformats,RTFSET,id_No,true,BUBBLE_GENERAL_SET));
								new(pfcb^.okbtn,Init(numformats,RTFOK,id_OK,true,BUBBLE_GENERAL_SETOK));
								numformats^.pfcb:=pfcb;
								if pfcb<>nil then pfcb^.Work;
								with nformbuffer do
									begin
										category:=0;
										frmindex:=0;
										format:=StrPTrimF(PFormat(pfcb^.fbox^.List^.At(0))^.Name^)
									end;
								numformats^.TransferBuffer:=@nformbuffer
							end
					end;
				if numformats<>nil then
					begin
						numformats^.bedt^.SetText(StrPTrimF(dblock^.GetText));
						nformbuffer.category:=0;
						nformbuffer.frmindex:=0;
						if cell^.Format>=1000 then nformbuffer.category:=1
						else
							if cell^.Format<>0 then
								if TexelApp.Formats^.Count>0 then
									for q:=0 to TexelApp.Formats^.Count-1 do
										if PFormat(TexelApp.Formats^.At(q))^.Index=cell^.Format then
											begin
												nformbuffer.category:=PFormat(TexelApp.Formats^.At(q))^.Group;
												break
											end;
						numformats^.pfcb^.SetSelection(nformbuffer.category);
						numformats^.pfcb^.Work;
						if numformats^.pfcb^.fbox^.List^.Count>0 then
							for q:=0 to numformats^.pfcb^.fbox^.List^.Count-1 do
								if PFormat(numformats^.pfcb^.fbox^.List^.At(q))^.Index=cell^.Format then
									begin
										nformbuffer.frmindex:=q;
										break
									end;
						numformats^.pfcb^.ScrollBar^.SetPosition(nformbuffer.category);
						numformats^.pfcb^.fbox^.ScrollBar^.SetPosition(nformbuffer.frmindex);
						numformats^.MakeWindow;
						numformats^.pfcb^.fbox^.Work
					end
			end;
		2:
			begin
				if rowsize=nil then
					begin
						new(rowsize,Init(@self,TEXELWINDPREFIX+TITLE_ROWSIZE,STG_ROWSIZE,ICNTITLE_ROWSIZE,RTROWSIZE));
						if rowsize<>nil then
							begin
								new(rowsize^.ed1,Init(rowsize,RTRSROW,23,false,BUBBLE_ROWSIZE_BLOCK));
								new(pe,Init(rowsize,RTRSHEIGHT,7,BUBBLE_ROWSIZE_HEIGHT));
								if pe<>nil then pe^.SetValidator(new(PPosMaxValidator,Init(655.35)));
								new(pb,Init(rowsize,RTRSHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(rowsize,RTRSCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(PButton,Init(rowsize,RTRSOK,id_OK,true,BUBBLE_ROWSIZE_OK));
								rowsize^.TransferBuffer:=@rsbuffer
							end
					end;
				if rowsize<>nil then
					begin
						if not(Parms.Cursor.Block) or (indx<Parms.Cursor.RowStart) or (indx>Parms.Cursor.RowEnd) or (Parms.Cursor.ColStart<>0) or (Parms.Cursor.ColEnd<>Parms.Columns) then rowsize^.ed1^.SetText(STRING_ROW+': '+GetRowIndex(indx))
						else
							if Parms.Cursor.RowStart=Parms.Cursor.RowEnd then rowsize^.ed1^.SetText(STRING_ROW+': '+GetRowIndex(Parms.Cursor.RowStart))
							else
								rowsize^.ed1^.SetText(STRING_ROW+': '+GetRowIndex(Parms.Cursor.RowStart)+' '+STRING_ROWTO+' '+GetRowIndex(Parms.Cursor.RowEnd));
						rsbuffer:=StrPLeft(ftoa(((GetRowHeight_mm100(indx))+round(longint(Application^.Attr.PixH)/10.0))/100.0),6);
						rowsize^.TransferData(tf_SetData);
						rowsize^.MakeWindow
					end
			end;
		3:
			begin
				if colsize=nil then
					begin
						new(colsize,Init(@self,TEXELWINDPREFIX+TITLE_COLSIZE,STG_COLSIZE,ICNTITLE_COLSIZE,RTCOLSIZE));
						if colsize<>nil then
							begin
								new(colsize^.ed1,Init(colsize,RTCSCOLUMN,23,false,BUBBLE_COLSIZE_BLOCK));
								new(pe,Init(colsize,RTCSWIDTH,7,BUBBLE_COLSIZE_WIDTH));
								if pe<>nil then pe^.SetValidator(new(PPosMaxValidator,Init(655.35)));
								new(pb,Init(colsize,RTCSHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(colsize,RTCSCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(PButton,Init(colsize,RTCSOK,id_OK,true,BUBBLE_COLSIZE_OK));
								colsize^.TransferBuffer:=@csbuffer
							end
					end;
				if colsize<>nil then
					begin
						if not(Parms.Cursor.Block) or (indx<Parms.Cursor.ColStart) or (indx>Parms.Cursor.ColEnd) or (Parms.Cursor.RowStart<>0) or (Parms.Cursor.RowEnd<>Parms.Rows) then colsize^.ed1^.SetText(STRING_COL+': '+GetColumnIndex(indx))
						else
							if Parms.Cursor.ColStart=Parms.Cursor.ColEnd then colsize^.ed1^.SetText(STRING_COL+': '+GetColumnIndex(Parms.Cursor.ColStart))
							else
								colsize^.ed1^.SetText(STRING_COL+': '+GetColumnIndex(Parms.Cursor.ColStart)+' '+STRING_COLTO+' '+GetColumnIndex(Parms.Cursor.ColEnd));
						csbuffer:=StrPLeft(ftoa((GetColWidth_mm100(indx)+round(longint(Application^.Attr.PixW)/10.0))/100.0),6);
						colsize^.TransferData(tf_SetData);
						colsize^.MakeWindow
					end
			end;
		4:
			begin
				if colname=nil then
					begin
						new(colname,Init(@self,TEXELWINDPREFIX+TITLE_COLNAME,STG_COLNAME,ICNTITLE_COLNAME,RTCOLNAME));
						if colname<>nil then
							begin
								new(colname^.st1,Init(colname,RTCNCOLUMN,53,false,BUBBLE_COLNAME_SEL));
								new(colname^.st2,Init(colname,RTCNOLD,41,false,BUBBLE_COLNAME_OLD));
								if colname^.st2<>nil then colname^.st2^.EnableTransfer;
								new(colname^.ed1,Init(colname,RTCNNEW,41,BUBBLE_COLNAME_NEW));
								new(pb,Init(colname,RTCNHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(colname,RTCNCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(PButton,Init(colname,RTCNOK,id_OK,true,BUBBLE_COLNAME_OK));
								colname^.TransferBuffer:=@cnbuffer
							end
					end;
				if colname<>nil then
					begin
						colname^.st1^.SetText(STRING_COL+':     '+GetColumnIndex(indx));
						with cnbuffer do
							begin
								nold:=GetColumnName(indx);
								nnew:=nold
							end;
						colname^.TransferData(tf_SetData);
						colname^.MakeWindow
					end
			end;
		5:
			begin
				if pattern=nil then
					begin
						new(pattern,Init(@self,TEXELWINDPREFIX+TITLE_PATTERN,STG_PATTERN,ICNTITLE_PATTERN,RTMUSTER));
						if pattern<>nil then
							begin
								new(PGroupBox,Init(pattern,RTMBEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
								new(pattern^.bedt,Init(pattern,RTMBEDIT,16,false,BUBBLE_GENERAL_RANGE));
								new(pattern^.cn,Init(pattern,RTMCOLORNAME,16,false,BUBBLE_PATTERN_NAME));
								new(pattern^.pc,Init(pattern,RTMCOLORS,BUBBLE_PATTERN_COLORS));
								new(pattern^.pp,Init(pattern,RTMPATTERN,BUBBLE_PATTERN_PATTERN));
								new(pattern^.ps,Init(pattern,RTMSHOW,BUBBLE_PATTERN_PREVIEW));
								new(pb,Init(pattern,RTMHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(pattern,RTMABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(PButton,Init(pattern,RTMSETZEN,id_No,true,BUBBLE_GENERAL_SET));
								new(PButton,Init(pattern,RTMOK,id_OK,true,BUBBLE_GENERAL_SETOK))
							end
					end;
				if pattern<>nil then
					begin
						pattern^.bedt^.SetText(StrPTrimF(dblock^.GetText));
						if cell^.Interior=FIS_HOLLOW then
							begin
								with pattern^.ps^.ObjAddr^.ob_spec do index:=(index and $ffffff8f) or (7 shl 4);
								pattern^.ps^.SetColor(White)
							end
						else
							begin
								dummy:=cell^.Style;
								if dummy=8 then dummy:=7;
								with pattern^.ps^.ObjAddr^.ob_spec do index:=(index and $ffffff8f) or (dummy shl 4);
								pattern^.ps^.SetColor(cell^.Color)
							end;
						pattern^.Color2Name;
						pattern^.MakeWindow
					end
			end;
		6:
			begin
				if rahmen=nil then
					begin
						new(rahmen,Init(@self,TEXELWINDPREFIX+TITLE_BORDERS,STG_BORDERS,ICNTITLE_BORDERS,RTRAHMEN));
						if rahmen<>nil then
							begin
								new(PGroupBox,Init(rahmen,RTRABEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
								new(PGroupBox,Init(rahmen,RTRABREITEN,'',''));
								new(PGroupBox,Init(rahmen,RTRAZELLE,GROUP_BORDER_CELLS,''));
								new(PGroupBox,Init(rahmen,RTRAGESAMT,GROUP_BORDER_BLOCK,''));
								new(rahmen^.bedt,Init(rahmen,RTRABEDIT,22,false,BUBBLE_GENERAL_RANGE));
								new(PRahmenBox,Init(rahmen,RTRAGLINE,RTRAGCYC,RTRAGTITLE,RTPOPUPS,RTPBORDERS,id_No,false,false,BUBBLE_BORDER_OUTLINE));
								new(PRahmenBox,Init(rahmen,RTRAOLINE,RTRAOCYC,RTRAOTITLE,RTPOPUPS,RTPBORDERS,id_No,false,false,BUBBLE_BORDER_TOP));
								new(PRahmenBox,Init(rahmen,RTRAULINE,RTRAUCYC,RTRAUTITLE,RTPOPUPS,RTPBORDERS,id_No,false,false,BUBBLE_BORDER_BOTTOM));
								new(PRahmenBox,Init(rahmen,RTRALLINE,RTRALCYC,RTRALTITLE,RTPOPUPS,RTPBORDERS,id_No,false,false,BUBBLE_BORDER_LEFT));
								new(PRahmenBox,Init(rahmen,RTRARLINE,RTRARCYC,RTRARTITLE,RTPOPUPS,RTPBORDERS,id_No,false,false,BUBBLE_BORDER_RIGHT));
								new(PRahmenBox,Init(rahmen,RTRAHLINE,RTRAHCYC,RTRAHTITLE,RTPOPUPS,RTPBORDERS,id_No,false,false,BUBBLE_BORDER_HOR));
								new(PRahmenBox,Init(rahmen,RTRAVLINE,RTRAVCYC,RTRAVTITLE,RTPOPUPS,RTPBORDERS,id_No,false,false,BUBBLE_BORDER_VERT));
								new(PColorBox,Init(rahmen,RTRAGCOLOR,RTRAGCOLORCYC,id_No,RTPOPUPS,RTPCOLOR,RTPCOLSTART,false,false,BUBBLE_BORDER_OCOLOR));
								new(PColorBox,Init(rahmen,RTRACOLOR,RTRACOLORCYC,id_No,RTPOPUPS,RTPCOLOR,RTPCOLSTART,false,false,BUBBLE_BORDER_4COLOR));
								new(PColorBox,Init(rahmen,RTRAHCOLOR,RTRAHCOLORCYC,id_No,RTPOPUPS,RTPCOLOR,RTPCOLSTART,false,false,BUBBLE_BORDER_HCOLOR));
								new(PColorBox,Init(rahmen,RTRAVCOLOR,RTRAVCOLORCYC,id_No,RTPOPUPS,RTPCOLOR,RTPCOLSTART,false,false,BUBBLE_BORDER_VCOLOR));
								new(pb,Init(rahmen,RTRAHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(rahmen,RTRAABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(PButton,Init(rahmen,RTRASETZEN,id_No,true,BUBBLE_GENERAL_SET));
								new(PButton,Init(rahmen,RTRAOK,id_OK,true,BUBBLE_GENERAL_SETOK));
								rahmen^.TransferBuffer:=@rabuf
							end
					end;
				if rahmen<>nil then
					begin
						rahmen^.bedt^.SetText(StrPTrimF(dblock^.GetText));
						with rabuf do
							begin
								lline:=0;
								rline:=0;
								oline:=0;
								uline:=0;
								hline:=0;
								vline:=0;
								gline:=0;
								color:=Black;
								hcolor:=Black;
								vcolor:=Black;
								gcolor:=Black
							end;
						if Parms.Cursor.Block then
							begin
								lfeq:=true;
								rteq:=true;
								topeq:=true;
								boteq:=true;
								c1:=GetCell(Parms.Cursor.RowStart,Parms.Cursor.ColStart);
								c2:=GetCell(Parms.Cursor.RowEnd,Parms.Cursor.ColStart);
								topb:=c1^.Border.Top;
								botb:=c2^.Border.Bottom;
								for x:=Parms.Cursor.ColStart to Parms.Cursor.ColEnd do
									begin
										if c1^.Border.Top<>topb then topeq:=false;
										if c2^.Border.Bottom<>botb then boteq:=false;
										inc(longint(c1),CELLSIZE);
										inc(longint(c2),CELLSIZE)
									end;
								c1:=GetCell(Parms.Cursor.RowStart,Parms.Cursor.ColStart);
								c2:=GetCell(Parms.Cursor.RowStart,Parms.Cursor.ColEnd);
								lfb:=c1^.Border.Left;
								rtb:=c2^.Border.Right;
								offs:=CELLSIZE*longint(Parms.Columns+1);
								for y:=Parms.Cursor.RowStart to Parms.Cursor.RowEnd do
									begin
										if c1^.Border.Left<>lfb then lfeq:=false;
										if c2^.Border.Right<>rtb then rteq:=false;
										inc(longint(c1),offs);
										inc(longint(c2),offs)
									end;
								if lfeq and rteq and topeq and boteq and (lfb=rtb) and (lfb=topb) and (lfb=botb) and (rtb=topb) and (rtb=botb) and (topb=botb) then
									begin
										rabuf.gcolor:=lfb and $0f;
										rabuf.gline:=(lfb shr 4)+1
									end
								else
									if bequal(lfb,rtb) and bequal(lfb,topb) and bequal(lfb,botb) and bequal(rtb,topb) and bequal(rtb,botb) and bequal(topb,botb) then
										begin
											rabuf.color:=bcolor(lfb,rtb,topb,botb);
											if lfeq and (Parms.Cursor.ColStart=Parms.Cursor.ColEnd) then rabuf.lline:=(lfb shr 4)+1;
											if rteq and (Parms.Cursor.ColStart=Parms.Cursor.ColEnd) then rabuf.rline:=(rtb shr 4)+1;
											if topeq and (Parms.Cursor.RowStart=Parms.Cursor.RowEnd) then rabuf.oline:=(topb shr 4)+1;
											if boteq and (Parms.Cursor.RowStart=Parms.Cursor.RowEnd) then rabuf.uline:=(botb shr 4)+1
										end
							end
						else
							with cell^.Border do
								begin
									rabuf.hline:=(Hor shr 4)+1;
									rabuf.hcolor:=Hor and $0f;
									rabuf.vline:=(Vert shr 4)+1;
									rabuf.vcolor:=Vert and $0f;
									if bequal(Left,Right) and bequal(Left,Top) and bequal(Left,Bottom) and bequal(Right,Top) and bequal(Right,Bottom) and bequal(Top,Bottom) then
										begin
											rabuf.color:=bcolor(Left,Right,Top,Bottom);
											rabuf.lline:=(Left shr 4)+1;
											rabuf.rline:=(Right shr 4)+1;
											rabuf.oline:=(Top shr 4)+1;
											rabuf.uline:=(Bottom shr 4)+1
										end
								end;
						rahmen^.MakeWindow
					end
			end
		end
	end;


function TCalcWindow.WMKeyDown(Stat,Key: integer): boolean;
	label _repon;

	var vr : GRECT;
	    r,c: integer;

	procedure insrtchar;

		begin
			if inpline=nil then exit;
			if chr(Key)<#32 then exit;
			if not(inpstat) then
				begin
					if Parms.Cursor.Block then SetCursorPos(Parms.Cursor.Row,Parms.Cursor.Col,true);
					inpline^.Clear;
					EnableInpline;
					InsertChar(chr(Key))
				end
		end;

	procedure crsoffs(dx,dy,wrap: integer);

		begin
			inc(dx,Parms.Cursor.Col);
			inc(dy,Parms.Cursor.Row);
			if dy<0 then
				begin
					if wrap=bf_Unchecked then dy:=0
					else
						if dx=0 then dy:=0
						else
							begin
								dy:=Parms.Rows;
								dec(dx)
							end
				end
			else
				if dy>Parms.Rows then
					begin
						if wrap=bf_Unchecked then dy:=Parms.Rows
						else
							if dx=Parms.Columns then dy:=Parms.Rows
							else
								begin
									dy:=0;
									inc(dx)
								end
					end;
			if dx<0 then
				begin
					if wrap=bf_Unchecked then dx:=0
					else
						if dy=0 then dx:=0
						else
							begin
								dx:=Parms.Columns;
								dec(dy)
							end
				end
			else
				if dx>Parms.Columns then
					begin
						if wrap=bf_Unchecked then dx:=Parms.Columns
						else
							if dy=Parms.Rows then dx:=Parms.Columns
							else
								begin
									dx:=0;
									inc(dy)
								end
					end;
			SetCursorPos(dy,dx,true)
		end;

	function anzh(dir: integer): integer;
		var ah: integer;

		begin
			GetVWork(vr);
			if vr.W<1 then
				begin
					anzh:=Parms.Cursor.Col;
					exit
				end;
			ah:=Parms.Cursor.Col;
			while (vr.W>0) and (ah>=0) and (ah<=Parms.Columns) do
				begin
					dec(vr.W,GetColWidth(ah));
					inc(ah,dir)
				end;
			dec(ah,dir);
			if ah=Parms.Cursor.Col then inc(ah,dir);
			anzh:=ah
		end;

	function anzv(dir: integer): integer;
		var av: integer;

		begin
			GetVWork(vr);
			if vr.H<1 then
				begin
					anzv:=Parms.Cursor.Row;
					exit
				end;
			av:=Parms.Cursor.Row;
			while (vr.H>0) and (av>=0) and (av<=Parms.Rows) do
				begin
					dec(vr.H,GetRowHeight(av));
					inc(av,dir)
				end;
			dec(av,dir);
			if av=Parms.Cursor.Row then inc(av,dir);
			anzv:=av
		end;

	begin
		KeyRepeatOff;
		WMKeyDown:=true;
		if Stat=K_NORMAL then
			begin
				if (Key=Return) or (Key=Enter) then
					case pdirbox^.GetSelection of
					CRS_DOWN:
						Key:=Cur_Down;
					CRS_RIGHT:
						Key:=Cur_Right;
					CRS_UP:
						Key:=Cur_Up;
					CRS_LEFT:
						Key:=Cur_Left;
					CRS_NW:
						begin
							crsoffs(-1,-1,TexelApp.setupbuffer.cursorwrap);
							goto _repon
						end;
					CRS_NE:
						begin
							crsoffs(1,-1,TexelApp.setupbuffer.cursorwrap);
							goto _repon
						end;
					CRS_SW:
						begin
							crsoffs(-1,1,TexelApp.setupbuffer.cursorwrap);
							goto _repon
						end;
					CRS_SE:
						begin
							crsoffs(1,1,TexelApp.setupbuffer.cursorwrap);
							goto _repon
						end
					else
						begin
							SetCursorPos(Parms.Cursor.Row,Parms.Cursor.Col,true);
							goto _repon
						end
					end;
				case Key of
				Backspace,S_Insert:;
				Tab:
					if inpline<>nil then
						begin
							if not(inpstat) then
								begin
									if Parms.Cursor.Block then SetCursorPos(Parms.Cursor.Row,Parms.Cursor.Col,true);
									EnableInpline
								end
							else
								ExitDlg(RTWDCANCEL)
						end;
				Cur_Up:
					crsoffs(0,-1,TexelApp.setupbuffer.cursorwrap);
				Cur_Down:
					crsoffs(0,1,TexelApp.setupbuffer.cursorwrap);
				Cur_Left:
					crsoffs(-1,0,TexelApp.setupbuffer.cursorwrap);
				Cur_Right:
					crsoffs(1,0,TexelApp.setupbuffer.cursorwrap);
				F2:
					if pfett<>nil then
						begin
							pfett^.Toggle;
							pfett^.Work
						end;
				F3:
					if pkursiv<>nil then
						begin
							pkursiv^.Toggle;
							pkursiv^.Work
						end;
				F4:
					if punter<>nil then
						begin
							punter^.Toggle;
							punter^.Work
						end;
				F5:
					if palignleft<>nil then palignleft^.Work;
				F6:
					if paligncenter<>nil then paligncenter^.Work;
				F7:
					if palignright<>nil then palignright^.Work;
				F8:
					if dezplus<>nil then dezplus^.Work;
				F9:
					if dezminus<>nil then dezminus^.Work;
				F10:
					if tsumme<>nil then tsumme^.Work;
				18688:
					crsoffs(0,anzv(-1)-Parms.Cursor.Row,bf_Unchecked);
				20736:
					crsoffs(0,anzv(1)-Parms.Cursor.Row,bf_Unchecked);
				20224:
					begin
						SetCursorPos(Parms.Rows,Parms.Columns,false);
						Scroller^.ScrollTo(Scroller^.XRange,Scroller^.YRange)
					end;
				Home:
					begin
						SetCursorPos(0,0,false);
						Scroller^.ScrollTo(0,0)
					end
				else
					insrtchar
				end;
				goto _repon
			end;
		if Stat=K_CTRL then
			begin
				case Key of
				18432:
					Scroller^.ScrollBy(0,-Scroller^.YPage);
				20480:
					Scroller^.ScrollBy(0,Scroller^.YPage);
				29440:
					Scroller^.ScrollBy(-Scroller^.XPage,0);
				29696:
					Scroller^.ScrollBy(Scroller^.XPage,0);
				Ctrl_Z:
					FontSelect;
				30464:
					SetCursorPos(Parms.Cursor.OldRow,Parms.Cursor.OldCol,true)
				else
					WMKeyDown:=false
				end;
				goto _repon
			end;
		if Stat=K_ALT then
			begin
				case Key of
				Alt_D:
					if clrinh<>nil then clrinh^.HandleMenu(1);
				Alt_V:
					if Embedded<>nil then
						if objects<>nil then objects^.HandleMenu(9);
				Alt_H:
					formrow^.HandleMenu(0);
				Alt_B:
					formcol^.HandleMenu(0)
				else
					insrtchar
				end;
				goto _repon
			end;
		if (Stat and K_SHIFT)>0 then
			begin
				if bTst(Stat,K_CTRL) then
					case (MapKey(Key) and $00ff) of
					65:
{						if fill<>nil then fill^.HandleMenu(5) !!! };
					77:
						AttrDialogs(5,0,GetCell(Parms.Cursor.Row,Parms.Cursor.Col));
					84:
						AttrDialogs(0,0,GetCell(Parms.Cursor.Row,Parms.Cursor.Col));
					90:
						AttrDialogs(1,0,GetCell(Parms.Cursor.Row,Parms.Cursor.Col));
					82:
						AttrDialogs(6,0,GetCell(Parms.Cursor.Row,Parms.Cursor.Col));
					56:
						pdirbox^.SetSelection(CRS_UP,true);
					52,115:
						pdirbox^.SetSelection(CRS_LEFT,true);
					54,116:
						pdirbox^.SetSelection(CRS_RIGHT,true);
					50:
						pdirbox^.SetSelection(CRS_DOWN,true)
					end
				else
					if bTst(Stat,K_ALT) then
						case Key of
						Alt_D:
							if clrinh<>nil then clrinh^.HandleMenu(0);
						else
							begin
								if chr(Key)=#0 then WMKeyDown:=false
								else
									insrtchar
							end
						end
					else
						case Key of
						Shift_Home:
							begin
								SetCursorPos(Parms.Rows,Parms.Columns,false);
								Scroller^.ScrollTo(Scroller^.XRange,Scroller^.YRange)
							end;
						Shift_CU:
							crsoffs(0,anzv(-1)-Parms.Cursor.Row,bf_Unchecked);
						Shift_CD:
							crsoffs(0,anzv(1)-Parms.Cursor.Row,bf_Unchecked);
						Shift_CL:
							crsoffs(anzh(-1)-Parms.Cursor.Col,0,bf_Unchecked);
						Shift_CR:
							crsoffs(anzh(1)-Parms.Cursor.Col,0,bf_Unchecked);
						else
							insrtchar
						end;
				goto _repon
			end;
		WMKeyDown:=false;
		_repon:
		KeyRepeatRestore
	end;


function TCalcWindow.ExitDlg(AnIndx: integer): boolean;
	var s    : string;
	    p    : PBlockDialog;
	    ed   : PEdit;
	    psc  : PStringCollection;
	    q    : integer;
	    pbuf : record
		    inp: string[15];
		    sel: integer
	    end;

	begin
		case AnIndx of
		RTWDBLOCK:
			begin
				new(p,Init(@self,'',RTBLOCK));
				if p<>nil then
					begin
						if BlockHistory=nil then new(BlockHistory,Init(5+atol(TexelApp.setupbuffer.history),10));
						if BlockHistory<>nil then
							begin
								BlockHistory^.Sort:=false;
								s:='  '+dblock^.GetText+#0;
								BlockHistory^.Insert(NewStr(s));
								if BlockHistory^.Count>1 then
									for q:=0 to BlockHistory^.Count-2 do
										if PString(BlockHistory^.At(q))^=s then
											begin
												BlockHistory^.AtFree(q);
												break
											end;
								while BlockHistory^.Count>atol(TexelApp.setupbuffer.history) do BlockHistory^.AtFree(0)
							end;
						p^.Attr.ExStyle:=(p^.Attr.ExStyle and not(ws_ex_Center2Parent)) or ws_ex_Popup;
						new(ed,Init(p,RTBINPUT,16,BUBBLE_BLOCK_EDIT));
						new(psc,Init(50+atol(TexelApp.setupbuffer.history),20));
						if psc<>nil then
							begin
								psc^.Sort:=false;
								if Variables<>nil then
									if Variables^.Count>0 then
										for q:=0 to Variables^.Count-1 do
											begin
												with PVariable(Variables^.At(q))^ do
													begin
														s:=' '+GetColumnIndex(RefCol)+GetRowIndex(RefRow)+#0;
														if length(Name^)>20-length(s) then s:='  '+StrPLeft(Name^,17-length(s))+'...'+s
														else
															s:='  '+Name^+StrPSpace(20-length(Name^)-length(s))+s
													end;
												psc^.Insert(NewStr(s))
											end;
								if BlockHistory<>nil then
									if BlockHistory^.Count>0 then
										for q:=0 to BlockHistory^.Count-1 do psc^.AtInsert(0,NewStr(PString(BlockHistory^.At(q))^))
							end;
						new(p^.pbb,Init(p,RTBLIST,RTBLSLIDER,RTBLUP,RTBLDOWN,psc,true,BUBBLE_BLOCK_LIST));
						if p^.pbb<>nil then p^.pbb^.ed:=ed;
						new(PButton,Init(p,RTBCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(p,RTBOK,id_OK,true,BUBBLE_BLOCK_OK));
						pbuf.inp:=StrPTrimF(dblock^.GetText);
						pbuf.sel:=0;
						p^.TransferBuffer:=@pbuf;
						if Application^.ExecDialog(p)=RTBOK then
							if pbuf.inp<>StrPTrimF(dblock^.GetText) then GotoBlock(pbuf.inp)
					end
			end;
		RTWDOK:
			SetCursorPos(Parms.Cursor.Row,Parms.Cursor.Col,true);
		RTWDCANCEL:
			begin
				if inpcancel<>nil then inpcancel^.Hide(true);
				if inpok<>nil then inpok^.Hide(true);
				inpline^.Disable;
				SetInpline(GetCell(Parms.Cursor.Row,Parms.Cursor.Col));
				inpstat:=false;
				with Parms.Cursor do DrawCells(Row,Col,Row,Col)
			end;
		RTWDTBSWITCH:
			ToggleToolbar;
		end;
		ExitDlg:=false
	end;


procedure TCalcWindow.ToggleToolbar;
	var pt: PTree;

	begin
		pt:=Application^.GetAddr(RTICONS);
		if Class.ToolbarTree<>nil then
			begin
				if (tbonoff<>nil) and (pt<>nil) then
					tbonoff^.ObjAddr^.ob_spec.bit_blk^.bi_pdata:=pt^[RTITBON].ob_spec.bit_blk^.bi_pdata;
				FreeToolbar(RTWTOOLBAR);
			end
		else
			begin
				if (tbonoff<>nil) and (pt<>nil) then
					tbonoff^.ObjAddr^.ob_spec.bit_blk^.bi_pdata:=pt^[RTITBOFF].ob_spec.bit_blk^.bi_pdata;
				LoadToolbar(RTWTOOLBAR);
				if Class.ToolbarTree<>nil then
					with Class.ToolbarTree^[0] do
						begin
							ob_height:=Class.ToolbarTree^[ob_head].ob_spec.icon_blk^.ib_hicon+(Class.ToolbarTree^[ob_head].ob_y shl 1);
							if MagiCVersion>=$0300 then ob_spec.index:=(ob_spec.index and $ff00ffff) or $00020000
						end
			end
	end;


procedure TCalcWindow.GotoBlock(s: string);
	var dummy,
	    rs,cs,
	    re,ce,
	    rw,cl: integer;
	    cell : PCell;

	begin
		if GetBlock(s,false,rs,cs,re,ce,dummy,dummy) then
			with Parms.Cursor do
				if (re>rs) or (ce>cs) then
					begin
						DrawCursor;
						DeselectAll;
						Block:=true;
						RowStart:=rs;
						ColStart:=cs;
						RowEnd:=re;
						ColEnd:=ce;
						SetBlock;
						for rw:=rs to re do
							begin
								cell:=GetCell(rw,cs);
								for cl:=cs to ce do
									begin
										with cell^ do Flags:=Flags or CELL_SELECTED;
										inc(longint(cell),CELLSIZE)
									end
							end;
						DrawCursor
					end
				else
					SetCursorPos(rs,cs,true)
	end;


function TCalcWindow.SelectDisabled(AnIndx,KStat,Clicks: integer): boolean;

	begin
		if AnIndx=RTWDINPUT then
			begin
				SelectDisabled:=true;
				if inpline=nil then exit;
				if Parms.Cursor.Block then SetCursorPos(Parms.Cursor.Row,Parms.Cursor.Col,true);
				EnableInpline
			end
		else
			SelectDisabled:=false
	end;


procedure TCalcWindow.WMClick(mX,mY,KStat: integer);
	label _setcursor,_normal;

	var num,nr,onr,
	    xsc,ysc    : longint;
	    rs,cs,re,ce,
	    dummy,btn,
	    w,r,c,x,y,
	    ro,co,
	    ms,ks,r2,c2,
	    xo,yo,xofs,
	    yofs,xn,yn : integer;
	    cell       : PCell;
	    rci        : GRECT;
	    rct        : LGRECT;
	    pe         : PEmbedded;

	procedure InvertBlock(rs,cs,re,ce: integer);
		var x,y : integer;
		    cell: PCell;

		begin
			DrawBlock(rs,cs,re,ce);
			for y:=rs to re do
				begin
					cell:=GetCell(y,cs);
					for x:=cs to ce do
						begin
							with cell^ do Flags:=Flags xor CELL_SELECTED;
							inc(longint(cell),CELLSIZE)
						end
				end
		end;

	procedure DrawHVCursor(vert: boolean);
		var valid: boolean;
		    rect : GRECT;

		begin
			if vert then
				begin
					pxya[0]:=x-xofs;
					pxya[1]:=rci.Y1;
					pxya[2]:=pxya[0];
					pxya[3]:=rci.Y2
				end
			else
				begin
					pxya[0]:=rci.X1;
					pxya[1]:=y-yofs;
					pxya[2]:=rci.X2;
					pxya[3]:=pxya[1]
				end;
			HideMouse;
			valid:=FirstWorkRect(rect);
			while valid do
				begin
					if rc_intersect(rci,rect) then
						begin
							vs_clip(vdiHandle,CLIP_ON,rect.A2);
							v_pline(vdiHandle,2,pxya)
						end;
					valid:=NextWorkRect(rect)
				end;
			ShowMouse
		end;

	procedure DrawIntersection;
		var rso,cso,reo,ceo: integer;
		    oldb,newb,same : GRECT;

		procedure Invert(rect: GRECT);
		
			begin
				GRtoA2(rect);
				if same.Y1>rect.Y1 then InvertBlock(rect.Y1,Min(same.X1,rect.X1),same.Y1-1,Max(same.X2,rect.X2));
				if same.Y2<rect.Y2 then InvertBlock(same.Y2+1,Min(same.X1,rect.X1),rect.Y2,Max(same.X2,rect.X2));
				if same.X1>rect.X1 then InvertBlock(Max(rect.Y1,same.Y1),rect.X1,Min(rect.Y2,same.Y2),same.X1-1);
				if same.X2<rect.X2 then InvertBlock(Max(rect.Y1,same.Y1),same.X2+1,Min(rect.Y2,same.Y2),rect.X2)
			end;

		begin
			with Parms.Cursor do
				begin
					if Block then
						begin
							rso:=RowStart;
							cso:=ColStart;
							reo:=RowEnd;
							ceo:=ColEnd
						end
					else
						begin
							rso:=Row;
							cso:=Col;
							reo:=rso;
							ceo:=cso
						end;
					Block:=true;
					RowStart:=Min(r,r2);
					ColStart:=Min(c,c2);
					RowEnd:=Max(r,r2);
					ColEnd:=Max(c,c2);
					SetBlock;
					with oldb do
						begin
							X:=cso;
							Y:=rso;
							W:=ceo+1-cso;
							H:=reo+1-rso
						end;
					with newb do
						begin
							X:=ColStart;
							Y:=RowStart;
							W:=ColEnd+1-ColStart;
							H:=RowEnd+1-RowStart
						end;
					same:=newb;
					rc_intersect(oldb,same);
					GRtoA2(same);
					Invert(oldb);
					Invert(newb)
				end
		end;

	begin
		if Application^.GetPTopWindow=nil then Top;
		num:=FindObject(mX,mY,true);
		if num=OBJ_TOGGLEALL then
			begin
				if inpstat then
					begin
						Application^.Bing;
						exit
					end;
				if Parms.Cursor.Block then
					begin
						DrawCursor;
						DeselectAll;
						Parms.Cursor.Block:=false;
						SetBlock;
						cell:=GetCell(Parms.Cursor.Row,Parms.Cursor.Col);
						with cell^ do Flags:=Flags or CELL_SELECTED;
						DrawCursor
					end
				else
					SelectAll;
				Application^.ReleaseMouseButton(1);
				exit
			end;
		if num<=OBJ_RSIZEOFFSET then
			begin
				wind_update(BEG_UPDATE);
				wind_update(BEG_MCTRL);
				SetMouse(IDC_CROSS,nil);
				graf_mkstate(x,yo,ms,ks);
				num:=OBJ_RSIZEOFFSET-num;
				Cell2Rect(num,0,rct);
				yofs:=yo-rct.Y2-1;
				yn:=yo;
				rci:=Work;
				inc(rci.Y,PaintOffs+TopRowHeight+1);
				dec(rci.H,PaintOffs+TopRowHeight+1);
				vswr_mode(vdiHandle,MD_XOR);
				vsl_type(vdiHandle,LT_USERDEF);
				repeat
					y:=yn;
					DrawHVCursor(false);
					repeat
						graf_mkstate(x,yn,ms,ks);
						if yn<rct.Y1+1 then yn:=rct.Y1+1
					until (y<>yn) or ((ms and 3)<>1);
					DrawHVCursor(false)
				until (ms and 3)<>1;
				vsl_type(vdiHandle,LT_SOLID);
				vswr_mode(vdiHandle,MD_REPLACE);
				vs_clip(vdihandle,CLIP_ON,SysInfo.Desktop.A2);
				repeat
					graf_mkstate(x,x,xo,x)
				until (xo and 3)=0;
				LastMouse;
				wind_update(END_MCTRL);
				wind_update(END_UPDATE);
				if (y<>yo) and not(bTst(ms,2)) then SetRowHeight(num,round((GetRowHeight(num)+y-yo-1)/PercentSize),true);
				exit
			end;
		if num<=OBJ_CSIZEOFFSET then
			begin
				wind_update(BEG_UPDATE);
				wind_update(BEG_MCTRL);
				SetMouse(IDC_CROSS,nil);
				graf_mkstate(xo,y,ms,ks);
				num:=OBJ_CSIZEOFFSET-num;
				Cell2Rect(0,num,rct);
				xofs:=xo-rct.X2-1;
				xn:=xo;
				rci:=Work;
				inc(rci.X,LeftColWidth+1);
				inc(rci.Y,PaintOffs);
				dec(rci.W,LeftColWidth+1);
				dec(rci.H,PaintOffs);
				vswr_mode(vdiHandle,MD_XOR);
				vsl_type(vdiHandle,LT_USERDEF);
				repeat
					x:=xn;
					DrawHVCursor(true);
					repeat
						graf_mkstate(xn,y,ms,ks);
						if xn<rct.X1+1 then xn:=rct.X1+1
					until (x<>xn) or ((ms and 3)<>1);
					DrawHVCursor(true)
				until (ms and 3)<>1;
				vsl_type(vdiHandle,LT_SOLID);
				vswr_mode(vdiHandle,MD_REPLACE);
				vs_clip(vdihandle,CLIP_ON,SysInfo.Desktop.A2);
				repeat
					graf_mkstate(y,y,yo,y)
				until (yo and 3)=0;
				LastMouse;
				wind_update(END_MCTRL);
				wind_update(END_UPDATE);
				if (x<>xo) and not(bTst(ms,2)) then SetColWidth(num,round((GetColWidth(num)+x-xo-1)/PercentSize),true);
				exit
			end;
		if num<=OBJ_ROWOFFSET then
			begin
				if inpstat then
					begin
						Application^.Bing;
						exit
					end;
				DrawCursor;
				DeselectAll;
				with Parms.Cursor do
					begin
						Block:=true;
						RowStart:=OBJ_ROWOFFSET-num;
						ColStart:=0;
						RowEnd:=RowStart;
						ColEnd:=Parms.Columns
					end;
				SetBlock;
				cell:=GetCell(Parms.Cursor.RowStart,0);
				for w:=0 to Parms.Columns do
					begin
						cell^.Flags:=cell^.Flags or CELL_SELECTED;
						inc(longint(cell),CELLSIZE)
					end;
				DrawCursor;
				wind_update(BEG_MCTRL);
				onr:=num;
				graf_mkstate(x,y,ms,ks);
				while bTst(ms,1) do
					begin
						if y<Work.Y1+PaintOffs+TopRowHeight+1 then Scroller^.ScrollBy(0,-GetRowHeight(OBJ_ROWOFFSET-onr))
						else
							if y>Work.Y2 then Scroller^.ScrollBy(0,GetRowHeight(OBJ_ROWOFFSET-onr));
						nr:=FindObject(Work.X,Max(y,Work.Y+PaintOffs+TopRowHeight+1),false);
						if nr<>onr then
							if nr<=OBJ_ROWOFFSET then
								begin
									with Parms.Cursor do
										if nr<num then
											begin
												RowStart:=OBJ_ROWOFFSET-num;
												RowEnd:=OBJ_ROWOFFSET-nr
											end
										else
											begin
												RowStart:=OBJ_ROWOFFSET-nr;
												RowEnd:=OBJ_ROWOFFSET-num
											end;
									SetBlock;
									if onr<nr then
										begin
											r:=OBJ_ROWOFFSET-nr;
											r2:=OBJ_ROWOFFSET-onr
										end
									else
										begin
											r:=OBJ_ROWOFFSET-onr;
											r2:=OBJ_ROWOFFSET-nr
										end;
									if Sgn(num-onr)=-Sgn(num-nr) then
										begin
											InvertBlock(r,0,OBJ_ROWOFFSET-num-1,Parms.Columns);
											InvertBlock(OBJ_ROWOFFSET+1-num,0,r2,Parms.Columns)
										end
									else
										begin
											if nr<num then inc(r)
											else
												if nr>num then dec(r2)
												else
													begin
														if onr<num then inc(r)
														else
															dec(r2)
													end;
											InvertBlock(r,0,r2,Parms.Columns)
										end;
									onr:=nr
								end;
						graf_mkstate(x,y,ms,ks)
					end;
				wind_update(END_MCTRL);
				exit
			end;
		if num<=OBJ_COLOFFSET then
			begin
				if inpstat then
					begin
						Application^.Bing;
						exit
					end;
				DrawCursor;
				DeselectAll;
				with Parms.Cursor do
					begin
						Block:=true;
						RowStart:=0;
						ColStart:=OBJ_COLOFFSET-num;
						RowEnd:=Parms.Rows;
						ColEnd:=ColStart
					end;
				SetBlock;
				cell:=GetCell(0,Parms.Cursor.ColStart);
				for w:=0 to Parms.Rows do
					begin
						cell^.Flags:=cell^.Flags or CELL_SELECTED;
						inc(longint(cell),longint(Parms.Columns+1)*CELLSIZE)
					end;
				DrawCursor;
				wind_update(BEG_MCTRL);
				onr:=num;
				graf_mkstate(x,y,ms,ks);
				while bTst(ms,1) do
					begin
						if x<Work.X1+LeftColWidth+1 then Scroller^.ScrollBy(-GetColWidth(OBJ_COLOFFSET-onr),0)
						else
							if x>Work.X2 then Scroller^.ScrollBy(GetColWidth(OBJ_COLOFFSET-onr),0);
						nr:=FindObject(Max(x,Work.X+LeftColWidth+1),Work.Y+PaintOffs,false);
						if nr<>onr then
							if (nr>OBJ_ROWOFFSET) and (nr<=OBJ_COLOFFSET) then
								begin
									with Parms.Cursor do
										if nr<num then
											begin
												ColStart:=OBJ_COLOFFSET-num;
												ColEnd:=OBJ_COLOFFSET-nr
											end
										else
											begin
												ColStart:=OBJ_COLOFFSET-nr;
												ColEnd:=OBJ_COLOFFSET-num
											end;
									SetBlock;
									if onr<nr then
										begin
											r:=OBJ_COLOFFSET-nr;
											r2:=OBJ_COLOFFSET-onr
										end
									else
										begin
											r:=OBJ_COLOFFSET-onr;
											r2:=OBJ_COLOFFSET-nr
										end;
									if Sgn(num-onr)=-Sgn(num-nr) then
										begin
											InvertBlock(0,r,Parms.Rows,OBJ_COLOFFSET-num-1);
											InvertBlock(0,OBJ_COLOFFSET+1-num,Parms.Rows,r2)
										end
									else
										begin
											if nr<num then inc(r)
											else
												if nr>num then dec(r2)
												else
													begin
														if onr<num then inc(r)
														else
															dec(r2)
													end;
											InvertBlock(0,r,Parms.Rows,r2)
										end;
									onr:=nr
								end;
						graf_mkstate(x,y,ms,ks)
					end;
				wind_update(END_MCTRL);
				exit
			end;
		if num>$7fff then
			begin
				if Embedded<>nil then
					if sheetbuffer.images=bf_Checked then
						begin
							pe:=Embedded;
							while pe^.Next<>nil do pe:=pe^.Next;
							while pe<>nil do
								begin
									if pe^.IsInside(mX,mY) then
										begin
											pe^.Click(mX,mY,KStat);
											exit
										end;
									pe:=pe^.Prev
								end
						end;
				Mouse2Cell(mX,mY,r,c);
				with Parms.Cursor do
					begin
						if (TexelApp.setupbuffer.online=bf_Checked) and not(inpstat) then
							begin
								if (Block and Between(r,RowStart,RowEnd) and Between(c,ColStart,ColEnd)) or (not(Block) and (r=Row) and (c=Col) and ((Kbshift(-1) and (K_SHIFT or K_CTRL))>0)) then goto _normal;
								if (Kbshift(-1) and (K_SHIFT or K_CTRL))>0 then goto _normal;
								if bTst(Kbshift(-1),K_ALT) then goto _normal;
								wind_update(BEG_UPDATE);
								wind_update(BEG_MCTRL);
								graf_mouse(POINT_HAND,nil);
								onr:=num;
								r2:=r;
								c2:=c;
								repeat
									if (r2=r) and (c2=c) then SetCursorPos(r,c,true)
									else
										DrawIntersection;
									ro:=r2;
									co:=c2;
									repeat
										graf_mkstate(x,y,ms,ks);
										if x<Work.X1+LeftColWidth+1 then xsc:=-GetColWidth(Min(co,c))
										else
											if x>Work.X2 then xsc:=GetColWidth(Max(co,c))
											else
												xsc:=0;
										if y<Work.Y1+PaintOffs+TopRowHeight+1 then ysc:=-GetRowHeight(Min(ro,r))
										else
											if y>Work.Y2 then ysc:=GetRowHeight(Max(ro,r))
											else
												ysc:=0;
										if (xsc<>0) or (ysc<>0) then Scroller^.ScrollBy(xsc,ysc);
										nr:=FindObject(Max(x,Work.X+LeftColWidth+1),Max(y,Work.Y+PaintOffs+TopRowHeight+1),false)
									until (nr<>onr) or not(bTst(ms,1));
									if nr<>onr then
										if nr>$7fff then
											begin
												Cell2RC(PCell(nr),r2,c2);
												onr:=nr
											end
								until not(bTst(ms,1));
								graf_mouse(ARROW,nil);
								wind_update(END_MCTRL);
								wind_update(END_UPDATE);
								exit
							end;
						_normal:
						if bTst(KStat,K_ALT) then
							begin
								if Block then
									begin
										rs:=RowStart;
										cs:=ColStart;
										re:=RowEnd;
										ce:=ColEnd
									end
								else
									begin
										rs:=Row;
										cs:=Col;
										re:=Row;
										ce:=Col
									end;
								if Between(r,rs,re) then
									begin
										if r-rs<re-r then rs:=r
										else
											re:=r
									end
								else
									if r<rs then rs:=r
									else
										re:=r;
								if Between(c,cs,ce) then
									begin
										if c-cs<ce-c then cs:=c
										else
											ce:=c
									end
								else
									if c<cs then cs:=c
									else
										ce:=c;
								if (ce>cs) or (re>rs) then
									begin
										DrawCursor;
										DeselectAll;
										Block:=true;
										RowStart:=rs;
										ColStart:=cs;
										RowEnd:=re;
										ColEnd:=ce;
										SetBlock;
										for y:=rs to re do
											begin
												cell:=GetCell(y,cs);
												for x:=cs to ce do
													begin
														with cell^ do Flags:=Flags or CELL_SELECTED;
														inc(longint(cell),CELLSIZE)
													end
											end;
										DrawCursor
									end
								else
									SetCursorPos(rs,cs,true);
								Application^.ReleaseMouseButton(1)
							end
						else
							if (Block and Between(r,RowStart,RowEnd) and Between(c,ColStart,ColEnd)) or (not(Block) and (r=Row) and (c=Col)) then
								begin
									evnt_timer(10,0);
									graf_mkstate(w,w,ms,w);
									if not(bTst(ms,1)) then goto _setcursor;
									InternalDragDrop(mX,mY)
								end
							else
								begin
									_setcursor:
									if inpstat then InsertCell(r,c,r,c)
									else
										SetCursorPos(r,c,true);
									Application^.ReleaseMouseButton(1)
								end
					end
			end
	end;


procedure TCalcWindow.InternalDragDrop(mX,mY: integer);
	var rci,sr,
	    thisr   : GRECT;
	    forcexit: boolean;
	    x,y,
	    x2,y2,
	    ro,co,
	    ur,uc,
	    bs,r,c,
	    rs,cs,
	    re,ce,
	    xs,ys,
	    xe,ye,
	    wnd,
	    dummy   : integer;
	    oldx,
	    oldy,
	    xsc,
	    ysc     : longint;
	    pw      : PWindow;
	    pcw     : PCalcWindow;

	procedure InvertDragDropCell;
		var rect,rc: GRECT;
		    valid  : boolean;

		begin
			if pcw=nil then exit;
			if (ro<0) or (co<0) then exit;
			pcw^.Cell2VRect(ro,co,rect);
			valid:=pcw^.FirstWorkRect(rc);
			while valid do
				begin
					if rc_intersect(rect,rc) then vr_recfl(Application^.vdiHandle,rc.A2);
					valid:=pcw^.NextWorkRect(rc)
				end
		end;

	procedure getrc(var r,c: integer);

		begin
			if Between(x,sr.X1,sr.X2) and Between(y,sr.Y1,sr.Y2) then
				begin
					pcw^.Mouse2Cell(x,y,r,c);
					if pcw=@self then
						if ((r=ur) and (c=uc)) or ((r=rs) and (c=cs)) then
							begin
								r:=-1;
								c:=-1
							end
				end
			else
				begin
					r:=-1;
					c:=-1
				end
		end;

	begin
		wind_update(BEG_UPDATE);
		wind_update(BEG_MCTRL);
		GetSheetRect(thisr);
		with Parms.Cursor do
			if Block then
				begin
					GetVisibleBlockRect(RowStart,ColStart,RowEnd,ColEnd,rci);
					rs:=RowStart;
					cs:=ColStart;
					re:=RowEnd;
					ce:=ColEnd
				end
			else
				begin
					GetVisibleBlockRect(Row,Col,Row,Col,rci);
					rs:=Row;
					cs:=Col;
					re:=Row;
					ce:=Col
				end;
		SetMouse(FLAT_HAND,nil);
		vswr_mode(Application^.vdiHandle,MD_XOR);
		vsl_type(Application^.vdiHandle,LT_USERDEF);
		vsf_interior(Application^.vdiHandle,FIS_PATTERN);
		Mouse2Cell(mX,mY,ur,uc);
		x2:=mX;
		y2:=mY;
		wnd:=0;
		pcw:=nil;
		HideMouse;
		repeat
			x:=x2;
			y:=y2;
			dummy:=wind_find(x,y);
			if dummy>0 then
				begin
					if dummy<>wnd then
						begin
							InvertDragDropCell;
							pcw:=nil;
							wnd:=dummy;
							pw:=Application^.GetGPWindow(wnd);
							if pw<>nil then
								if pw^.GetClassName=TEXELWINDCLASS then pcw:=PCalcWindow(pw);
							if pcw<>nil then
								begin
									pcw^.GetSheetRect(sr);
									getrc(ro,co);
									InvertDragDropCell
								end
						end
					else
						if pcw<>nil then
							begin
								getrc(r,c);
								if (r<>ro) or (c<>co) then
									begin
										InvertDragDropCell;
										ro:=r;
										co:=c;
										InvertDragDropCell
									end
							end
				end
			else
				if wnd>0 then
					begin
						InvertDragDropCell;
						pcw:=nil;
						wnd:=0
					end;
			forcexit:=false;
			if (pcw=nil) or (pcw=@self) then
				if IsTop then
					begin
						Mouse2Cell(thisr.X1,thisr.Y1,ys,xs);
						Mouse2Cell(thisr.X2,thisr.Y2,ye,xe);
						if x<thisr.X1 then xsc:=-GetColWidth(xs)
						else
							if x>thisr.X2 then xsc:=GetColWidth(xe)
							else
								xsc:=0;
						if y<thisr.Y1 then ysc:=-GetRowHeight(ys)
						else
							if y>thisr.Y2 then ysc:=GetRowHeight(ye)
							else
								ysc:=0;
						if (xsc<>0) or (ysc<>0) then
							begin
								vswr_mode(Application^.vdiHandle,MD_REPLACE);
								vsl_type(Application^.vdiHandle,LT_SOLID);
								vsf_interior(Application^.vdiHandle,FIS_HOLLOW);
								oldy:=Scroller^.YPos;
								oldx:=Scroller^.XPos;
								Scroller^.ScrollBy(xsc,ysc);
								evnt_timer(10,0);
								vswr_mode(Application^.vdiHandle,MD_XOR);
								vsl_type(Application^.vdiHandle,LT_USERDEF);
								vsf_interior(Application^.vdiHandle,FIS_PATTERN);
								forcexit:=((Scroller^.YPos<>oldy) or (Scroller^.XPos<>oldx))
							end
					end;
			pxya[0]:=rci.X1+x-mX;
			pxya[1]:=rci.Y1+y-mY;
			pxya[2]:=rci.X2+x-mX;
			pxya[3]:=pxya[1];
			pxya[4]:=pxya[2];
			pxya[5]:=rci.Y2+y-mY;
			pxya[6]:=pxya[0];
			pxya[7]:=pxya[5];
			pxya[8]:=pxya[0];
			pxya[9]:=pxya[1];
			v_pline(Application^.vdiHandle,5,pxya);
			ShowMouse;
			repeat
				graf_mkstate(x2,y2,bs,dummy)
			until (x<>x2) or (y<>y2) or (bs<>1) or forcexit;
			HideMouse;
			v_pline(Application^.vdiHandle,5,pxya)
		until bs<>1;
		InvertDragDropCell;
		ShowMouse;
		vswr_mode(Application^.vdiHandle,MD_REPLACE);
		vsl_type(Application^.vdiHandle,LT_SOLID);
		vsf_interior(Application^.vdiHandle,FIS_HOLLOW);
		LastMouse;
		wind_update(END_MCTRL);
		wind_update(END_UPDATE);
		if bs=0 then
			if pcw<>nil then
				if (ro>=0) and (co>=0) then pcw^.CopyFromInternalDragDrop(@self,rs,cs,re,ce,ro,co,(Kbshift(-1) and K_CTRL)>0)
	end;


procedure TCalcWindow.CopyFromInternalDragDrop(from: PCalcWindow; rs,cs,re,ce,r,c: integer; mve: boolean);
	label _raus;

	var rbis,cbis,
	    x,y,yend,
	    yinc,xsc,
	    xstart,
	    xend,xinc,
	    cmin,cmax,
	    cminf,cmaxf,
	    rmin,rmax,
	    rrel,crel  : integer;
	    q,w,
	    cellinc    : longint;
	    cell,fcell : PCell;
	    lossy,
	    vorh,mvrnd : boolean;
	    oldsel     : byte;
	    ptxt,vars  : string;
	    pp         : PParameter;

	begin
		BusyMouse;
		mvrnd:=false;
		rbis:=r+re-rs;
		cbis:=c+ce-cs;
		lossy:=false;
		if rbis>Parms.Rows then
			begin
				rbis:=Parms.Rows;
				re:=rs+rbis-r;
				lossy:=true
			end;
		if cbis>Parms.Columns then
			begin
				cbis:=Parms.Columns;
				ce:=cs+cbis-c;
				lossy:=true
			end;
		if lossy then
			begin
				if mve then
					begin
						if Application^.Alert(@self,1,WAIT,MESSAGE_WINDOW_DDMOVE,BUTTON_GOCANCEL)<>1 then goto _raus
					end
				else
					begin
						if Application^.Alert(@self,1,WAIT,MESSAGE_WINDOW_DDCOPY,BUTTON_GOCANCEL)<>1 then goto _raus
					end
			end;
		if IsBlockUsed(r,c,rbis,cbis,1) then goto _raus;
		rrel:=r-rs;
		crel:=c-cs;
		if from=@self then
			begin
				if r>rs then
					begin
						y:=re;
						yend:=rs-1;
						yinc:=-1
					end
				else
					begin
						y:=rs;
						yend:=re+1;
						yinc:=1
					end;
				if c>cs then
					begin
						xstart:=ce;
						xsc:=cbis;
						xend:=cs-1;
						xinc:=-1;
						cellinc:=-CELLSIZE
					end
				else
					begin
						xstart:=cs;
						xsc:=c;
						xend:=ce+1;
						xinc:=1;
						cellinc:=CELLSIZE
					end;
				cmin:=Min(cs,c);
				cmax:=Max(ce,cbis);
				rmin:=Min(rs,r);
				rmax:=Max(re,rbis);
				RowsClearOverflow(rmin,rmax,cmin,cmax)
			end
		else
			begin
				y:=rs;
				yend:=re+1;
				yinc:=1;
				xstart:=cs;
				xsc:=c;
				xend:=ce+1;
				xinc:=1;
				cellinc:=CELLSIZE;
				cmin:=c;
				cmax:=cbis;
				RowsClearOverflow(r,rbis,cmin,cmax);
				if mve then
					begin
						cminf:=cs;
						cmaxf:=ce;
						from^.RowsClearOverflow(rs,re,cminf,cmaxf)
					end
			end;
		repeat
			fcell:=from^.GetCell(y,xstart);
			cell:=GetCell(r+y-rs,xsc);
			x:=xstart;
			repeat
				oldsel:=cell^.Flags and CELL_SELECTED;
				FreeCell(cell,false);
				cell^:=fcell^;
				cell^.Flags:=(cell^.Flags and CELL_EMPTYMASK) or oldsel;
				cell^.TxtVal.Flags:=cell^.TxtVal.Flags and not(TFL_OVERFLOWMASK);
				cell^.Data.Value:=0;
				case cell^.Typ of
				CTYPE_TEXT:
					cell^.Data.Txt:=NewStr(fcell^.Data.Txt^);
				CTYPE_CONST:
					begin
						new(cell^.Data.Konst);
						if cell^.Data.Konst<>nil then
							with cell^.Data.Konst^ do
								begin
									Value:=fcell^.Data.Konst^.Value;
									FPts:=fcell^.Data.Konst^.FPts;
									Txt:=NewStr(fcell^.Data.Konst^.Txt^)
								end
						else
							cell^.Typ:=CTYPE_EMPTY
					end;
				CTYPE_FORMULA:
					begin
						new(cell^.Data.Formula);
						if cell^.Data.Formula<>nil then
							with cell^.Data.Formula^ do
								begin
									Value:=fcell^.Data.Formula^.Value;
									FPts:=fcell^.Data.Formula^.FPts;
									Error:=FE_OK;
									vorh:=false;
									if fcell^.Data.Formula^.VarDef<>nil then
										if Variables<>nil then
											if Variables^.Count>0 then
												begin
													ptxt:=StrPUpper(fcell^.Data.Formula^.VarDef^);
													for q:=0 to Variables^.Count-1 do
														if ptxt=StrPUpper(PVariable(Variables^.At(q))^.Name^) then
															begin
																vorh:=true;
																break
															end
												end;
									ptxt:='='+from^.BuildTree(fcell,fcell^.Data.Formula^.Func,true,rrel,crel);
									if not(vorh) then
										if fcell^.Data.Formula^.VarDef<>nil then ptxt:='='+fcell^.Data.Formula^.VarDef^+ptxt;
									{ varerr/Parse optimieren ... }
									{ Baum kopieren !!! }
									if Parse(ptxt,vars,Func,cell,0,0,true) then VarDef:=NewStr(vars)
									else
										begin
											dispose(cell^.Data.Formula);
											cell^.Typ:=CTYPE_TEXT;
											cell^.Data.Txt:=NewStr(ptxt)
										end
								end
						else
							cell^.Typ:=CTYPE_EMPTY
					end
				end;
				if mve then
					if not(from^.IsEmptyCell(fcell)) then
						begin
							from^.FreeCell(fcell,true);
							mvrnd:=true
						end;
				if cell^.Format>=1000 then
					if from<>@self then
						begin
							w:=0;
							if UsrFormats^.Count>0 then
								begin
									ptxt:=PFormat(from^.UsrFormats^.At(cell^.Format-1000))^.Name^;
									for q:=0 to UsrFormats^.Count-1 do
										if PFormat(UsrFormats^.At(q))^.Name^=ptxt then
											begin
												w:=PFormat(UsrFormats^.At(q))^.Index;
												break
											end
								end;
							if w=0 then w:=NewNumFormat(ptxt);
							cell^.Format:=w
						end;
				inc(longint(fcell),cellinc);
				inc(longint(cell),cellinc);
				inc(x,xinc)
			until(x=xend);
			inc(y,yinc)
		until y=yend;
		if from<>@self then
			if from^.Parameter^.Count>0 then
				begin
					for w:=0 to from^.Parameter^.Count-1 do
						begin
							ptxt:=StrPUpper(PParameter(from^.Parameter^.At(w))^.Name^);
							vorh:=false;
							if Parameter^.Count>0 then
								for q:=0 to Parameter^.Count-1 do
									if StrPUpper(PParameter(Parameter^.At(q))^.Name^)=ptxt then
										begin
											vorh:=true;
											break
										end;
							if not(vorh) then
								begin
									new(pp);
									if pp<>nil then
										begin
											pp^.Value:=PParameter(from^.Parameter^.At(w))^.Value;
											pp^.Name:=NewStr(PParameter(from^.Parameter^.At(w))^.Name^);
											pp^.ListName:=NewStr('  '+pp^.Name^+' '#0);
											pp^.Txt:=NewStr(PParameter(from^.Parameter^.At(w))^.Txt^);
											pp^.Descr:=NewStr(PParameter(from^.Parameter^.At(w))^.Descr^);
											pp^.Predef:=false;
											if (pp^.Name=nil) or (pp^.Txt=nil) then
												begin
													DisposeStr(pp^.Name);
													DisposeStr(pp^.ListName);
													DisposeStr(pp^.Txt);
													DisposeStr(pp^.Descr);
													dispose(pp)
												end
											else
												Parameter^.Insert(pp)
										end
								end
						end;
					if konstanten<>nil then konstanten^.UpdateList(true)
				end;
		if from=@self then
			begin
				RowsCheckOverflow(rmin,rmax,cmin,cmax);
				SetDirty;
				DrawCells(rmin,cmin,rmax,cmax);
				AutoCalculate(true)
			end
		else
			begin
				RowsCheckOverflow(r,rbis,cmin,cmax);
				if mve then from^.RowsCheckOverflow(rs,re,cminf,cmaxf);
				SetDirty;
				DrawCells(r,cmin,rbis,cmax);
				AutoCalculate(true);
				if mvrnd then
					begin
						from^.SetDirty;
						from^.DrawCells(rs,cminf,re,cmaxf);
						from^.AutoCalculate(true)
					end
			end;
		_raus:
		ArrowMouse
	end;


function TCalcWindow.DoRubbox(mX,mY,KStat: integer): boolean;
	var r,c: integer;

	begin
		Mouse2Cell(mX,mY,r,c);
		with Parms.Cursor do
			if (Block and Between(r,RowStart,RowEnd) and Between(c,ColStart,ColEnd)) or (not(Block) and (r=Row) and (c=Col) and ((Kbshift(-1) and (K_SHIFT or K_CTRL))>0)) then DoRubbox:=false
			else
				if (Kbshift(-1) and (K_SHIFT or K_CTRL))>0 then
					begin
						SetCursorPos(r,c,true);
						DoRubbox:=false
					end
				else
					DoRubbox:=not(bTst(Kbshift(-1),K_ALT)) and ((TexelApp.setupbuffer.online=bf_Unchecked) or inpstat)
	end;


procedure TCalcWindow.WMDblClick(mX,mY,KStat: integer);
	var r,c: integer;
	    pe : PEmbedded;

	begin
		if FindObject(mX,mY,true)>$7fff then
			begin
				if Embedded<>nil then
					if sheetbuffer.images=bf_Checked then
						begin
							pe:=Embedded;
							while pe^.Next<>nil do pe:=pe^.Next;
							while pe<>nil do
								begin
									if pe^.IsInside(mX,mY) then
										begin
											pe^.DblClick(mX,mY,KStat);
											exit
										end;
									pe:=pe^.Prev
								end
						end;
				Mouse2Cell(mX,mY,r,c);
				SetCursorPos(r,c,true);
				Application^.ReleaseMouseButton(1);
				if inpline<>nil then
					if not(inpstat) then EnableInpline
			end
	end;


function TCalcWindow.FindObject(x,y: integer; sizer: boolean): longint;
	var lcoffs,lroffs,
	    xl,yl,dummy,
	    range        : longint;
	    cnum,rnum    : integer;
	    r            : LGRECT;

	begin
		FindObject:=OBJ_NONE;
		dec(x,Work.X);
		dec(y,Work.Y+PaintOffs);
		
		{ Offsets berechnen... }
		
		if y<=TopRowHeight then
			begin
				if x<=LeftColWidth then
					begin
						FindObject:=OBJ_TOGGLEALL;
						exit
					end;
				xl:=x+Scroller^.XPos+1-LeftColWidth;
				lcoffs:=0;
				cnum:=0;
				while (lcoffs<xl) and (cnum<=Parms.Columns) do
					begin
						inc(lcoffs,GetColWidth(cnum));
						inc(cnum)
					end;
				if sizer then
					begin
						Cell2Rect(0,cnum-1,r);
						range:=atol(TexelApp.setupbuffer.sizerrange);
						if cnum>1 then
							begin
								dummy:=longint(x)+longint(Work.X)+1-r.X;
								if (dummy>=0) and (dummy<=range) then
									begin
										FindObject:=OBJ_CSIZEOFFSET+2-cnum;
										exit
									end
							end;
						dummy:=r.X2+1-longint(x)-longint(Work.X);
						if (dummy>=0) and (dummy<=range) then
							begin
								FindObject:=OBJ_CSIZEOFFSET+1-cnum;
								exit
							end
					end;
				FindObject:=OBJ_COLOFFSET+1-cnum
			end
		else
			if x<=LeftColWidth then
				begin
					yl:=y+Scroller^.YPos+1-TopRowHeight;
					lroffs:=0;
					rnum:=0;
					while (lroffs<yl) and (rnum<=Parms.Rows) do
						begin
							inc(lroffs,GetRowHeight(rnum));
							inc(rnum)
						end;
					if sizer then
						begin
							Cell2Rect(rnum-1,0,r);
							range:=atol(TexelApp.setupbuffer.sizerrange);
							if rnum>1 then
								begin
									dummy:=longint(y)+longint(Work.Y)+longint(PaintOffs)+1-r.Y;
									if (dummy>=0) and (dummy<=range) then
										begin
											FindObject:=OBJ_RSIZEOFFSET+2-rnum;
											exit
										end
								end;
							dummy:=r.Y2+1-longint(y)-longint(Work.Y)-longint(PaintOffs);
							if (dummy>=0) and (dummy<=range) then
								begin
									FindObject:=OBJ_RSIZEOFFSET+1-rnum;
									exit
								end
						end;
					FindObject:=OBJ_ROWOFFSET+1-rnum
				end
			else
				begin
					xl:=x+Scroller^.XPos+1-LeftColWidth;
					lcoffs:=0;
					cnum:=0;
					while (lcoffs<xl) and (cnum<=Parms.Columns) do
						begin
							inc(lcoffs,GetColWidth(cnum));
							inc(cnum)
						end;
					dec(cnum);
					yl:=y+Scroller^.YPos+1-TopRowHeight;
					lroffs:=0;
					rnum:=0;
					while (lroffs<yl) and (rnum<=Parms.Rows) do
						begin
							inc(lroffs,GetRowHeight(rnum));
							inc(rnum)
						end;
					dec(rnum);
					FindObject:=longint(Sheet)+(longint(rnum)*longint(Parms.Columns+1)+longint(cnum))*CELLSIZE;
				end
	end;


procedure TCalcWindow.SelectAll;
	var q,cnum: longint;

	begin
		with Parms.Cursor do
			if Block then
				if (RowStart=0) and (ColStart=0) and (RowEnd=Parms.Rows) and (ColEnd=Parms.Columns) then exit;
		DrawCursor;
		with Parms.Cursor do
			begin
				Block:=true;
				RowStart:=0;
				ColStart:=0;
				RowEnd:=Parms.Rows;
				ColEnd:=Parms.Columns
			end;
		SetBlock;
		cnum:=longint(Sheet);
		for q:=1 to longint(Parms.Rows+1)*longint(Parms.Columns+1) do
			begin
				with PCell(cnum)^ do Flags:=Flags or CELL_SELECTED;
				inc(cnum,CELLSIZE)
			end;
		DrawCursor
	end;


function TCalcWindow.GetCell(r,c: integer): PCell;

	begin
		GetCell:=PCell(longint(Sheet)+(longint(r)*longint(Parms.Columns+1)+longint(c))*CELLSIZE)
	end;


procedure TCalcWindow.Cell2RC(cell: PCell; var r,c: integer);
	var q: longint;

	begin
		if cell=nil then
			begin
				r:=0;
				c:=0
			end
		else
			begin
				q:=(longint(cell)-longint(Sheet)) div CELLSIZE;
				r:=q div (Parms.Columns+1);
				c:=q mod (Parms.Columns+1)
			end
	end;


procedure TCalcWindow.Cell2Rect(r,c: integer; var rect: LGRECT);
	var xoffs,yoffs: longint;
	    q          : integer;

	begin
		xoffs:=LeftColWidth+Work.X-Scroller^.XPos;
		if c>0 then
			for q:=0 to c-1 do inc(xoffs,GetColWidth(q));
		yoffs:=PaintOffs+TopRowHeight+Work.Y+1-Scroller^.YPos;
		if r>0 then
			for q:=0 to r-1 do inc(yoffs,GetRowHeight(q));
		with rect do
			begin
				X:=xoffs;
				Y:=yoffs;
				W:=GetColWidth(c)-1;
				H:=GetRowHeight(r)-1
			end;
		LGRtoA2(rect)
	end;


procedure TCalcWindow.GetSheetRect(var sr: GRECT);

	begin
		sr:=Work;
		with sr do
			begin
				inc(X,LeftColWidth+1);
				dec(W,LeftColWidth+1);
				inc(Y,PaintOffs+TopRowHeight+1);
				dec(H,PaintOffs+TopRowHeight+1)
			end;
		GRtoA2(sr)
	end;


procedure TCalcWindow.Cell2VRect(r,c: integer; var vrect: GRECT);
	var rect: LGRECT;

	begin
		Cell2Rect(r,c,rect);
		GetSheetRect(vrect);
		if not(lrc_intersect(rect,vrect)) then
			with vrect do
				begin
					X:=Application^.Attr.MaxPX+10;
					Y:=0;
					W:=1;
					H:=1
				end;
		GRtoA2(vrect)
	end;


function TCalcWindow.GetBlock(blck: string; whole: boolean; var rs,cs,re,ce,f1,f2: integer): boolean;
	var c,flg1,flg2: integer;

	function cellcorrect(cl: string; nr: integer; var r,c,flg: integer): boolean;
		var q,w,qs,ws: integer;

		begin
			cellcorrect:=false;
			StrPTrim(cl);
			if length(cl)=0 then exit;
			if (cl[1]='$') and whole then
				begin
					flg:=RF_COLABS;
					qs:=2
				end
			else
				begin
					flg:=0;
					qs:=1
				end;
			q:=qs;
			while (cl[q] in ['A'..'Z']) and (q<=length(cl)) do inc(q);
			if q=qs then
				if whole then exit;
			ws:=q;
			if ws<=length(cl) then
				if cl[ws]='$' then
					if whole then
						begin
							inc(ws);
							flg:=flg or RF_ROWABS
						end;
			w:=ws;
			while (cl[w] in ['0'..'9']) and (w<=length(cl)) do inc(w);
			if w=ws then
				if whole or (w=qs) then exit;
			if w=length(cl)+1 then
				begin
					if q>qs then
						begin
							c:=ColIndex2Nr(StrPRight(cl,length(cl)+1-qs),true);
							if nr=0 then ce:=c
						end
					else
						case nr of
						0:
							begin
								c:=0;
								ce:=Parms.Columns
							end;
						1:
							c:=0;
						2:
							c:=Parms.Columns
						end;
					if w>ws then
						begin
							r:=Min(Max(atol(StrPRight(cl,length(cl)+1-ws))-1,0),Parms.Rows);
							if nr=0 then re:=r
						end
					else
						case nr of
						0:
							begin
								r:=0;
								re:=Parms.Rows
							end;
						1:
							r:=0;
						2:
							r:=Parms.Rows
						end;
					cellcorrect:=true
				end
		end;

	begin
		GetBlock:=false;
		f1:=0;
		f2:=0;
		blck:=StrPUpper(blck);
		c:=pos(':',blck);
		if c>0 then
			begin
				flg1:=0;
				if not(cellcorrect(StrPLeft(blck,c-1),1,rs,cs,flg1)) then exit;
				flg2:=0;
				if cellcorrect(StrPRight(blck,length(blck)-c),2,re,ce,flg2) then
					begin
						GetBlock:=true;
						if re<rs then
							begin
								c:=re;
								re:=rs;
								rs:=c;
								if bTst(flg2,RF_ROWABS) then f1:=f1 or RF_ROWABS;
								if bTst(flg1,RF_ROWABS) then f2:=f2 or RF_ROWABS
							end
						else
							begin
								if bTst(flg1,RF_ROWABS) then f1:=f1 or RF_ROWABS;
								if bTst(flg2,RF_ROWABS) then f2:=f2 or RF_ROWABS
							end;
						if ce<cs then
							begin
								c:=ce;
								ce:=cs;
								cs:=c;
								if bTst(flg2,RF_COLABS) then f1:=f1 or RF_COLABS;
								if bTst(flg1,RF_COLABS) then f2:=f2 or RF_COLABS
							end
						else
							begin
								if bTst(flg1,RF_COLABS) then f1:=f1 or RF_COLABS;
								if bTst(flg2,RF_COLABS) then f2:=f2 or RF_COLABS
							end
					end
			end
		else
			if not(whole) then
				if cellcorrect(blck,0,rs,cs,f1) then GetBlock:=true
	end;


function TCalcWindow.GetVisibleBlockRect(rs,cs,re,ce: integer; var sr: GRECT): boolean;
	var crs,crs2,r: LGRECT;

	begin
		Cell2Rect(rs,cs,crs);
		Cell2Rect(re,ce,crs2);
		GetSheetRect(sr);
		r.X:=crs.X;
		r.Y:=crs.Y;
		r.W:=crs2.X2+2-r.X;
		r.H:=crs2.Y2+2-r.Y;
		GetVisibleBlockRect:=lrc_intersect(r,sr)
	end;


procedure TCalcWindow.DrawCells(rs,cs,re,ce: integer);
	var sr: GRECT;

	begin
		wind_update(BEG_UPDATE);
		if GetVisibleBlockRect(rs,cs,re,ce,sr) then WMRedraw(sr.X-1,sr.Y-1,sr.W+2,sr.H+2);
		wind_update(END_UPDATE)
	end;


procedure TCalcWindow.DrawBlockRaw(rs,cs,re,ce: integer; const r: GRECT);
	var crs,crs2,crs3: LGRECT;
	    r2           : GRECT;
	    x,y          : integer;

	begin
		vswr_mode(vdiHandle,MD_XOR);
		vsf_interior(vdiHandle,FIS_SOLID);
		Cell2Rect(rs,cs,crs);
		for y:=rs to re do
			begin
				crs.H:=GetRowHeight(y)-1;
				crs2:=crs;
				crs2.X:=r.X;
				crs2.W:=r.W;
				r2:=r;
				if lrc_intersect(crs2,r2) then
					begin
						crs2:=crs;
						for x:=cs to ce do
							begin
								crs2.W:=GetColWidth(x)-1;
								crs3:=crs2;
								r2:=r;
								if lrc_intersect(crs3,r2) then vr_recfl(vdiHandle,r2.A2);
								inc(crs2.X,crs2.W+1)
							end
					end;
				inc(crs.Y,crs.H+1)
			end;
		vsf_interior(vdiHandle,FIS_HOLLOW);
		vswr_mode(vdiHandle,MD_REPLACE)
	end;


procedure TCalcWindow.DrawBlock(rs,cs,re,ce: integer);
	var valid        : boolean;
	    r,r2,sr      : GRECT;
	    crs,crs2,crs3: LGRECT;
	    x,y          : integer;

	begin
		wind_update(BEG_UPDATE);
		HideMouse;
		vswr_mode(vdiHandle,MD_XOR);
		vsf_interior(vdiHandle,FIS_SOLID);
		GetSheetRect(sr);
		valid:=FirstWorkRect(r);
		while valid do
			begin
				if rc_intersect(sr,r) then
					begin
						Cell2Rect(rs,cs,crs);
						for y:=rs to re do
							begin
								crs.H:=GetRowHeight(y)-1;
								crs2:=crs;
								crs2.X:=r.X;
								crs2.W:=r.W;
								r2:=r;
								if lrc_intersect(crs2,r2) then
									begin
										crs2:=crs;
										for x:=cs to ce do
											begin
												crs2.W:=GetColWidth(x)-1;
												crs3:=crs2;
												r2:=r;
												if lrc_intersect(crs3,r2) then vr_recfl(vdiHandle,r2.A2);
												inc(crs2.X,crs2.W+1)
											end
									end;
								inc(crs.Y,crs.H+1)
							end
					end;
				valid:=NextWorkRect(r)
			end;
		vsf_interior(vdiHandle,FIS_HOLLOW);
		vswr_mode(vdiHandle,MD_REPLACE);
		ShowMouse;
		wind_update(END_UPDATE)
	end;


procedure TCalcWindow.DrawCursor;
	var valid: boolean;
	    r,crs: GRECT;

	begin
		if Parms.Cursor.Block then with Parms.Cursor do DrawBlock(RowStart,ColStart,RowEnd,ColEnd)
		else
			begin
				wind_update(BEG_UPDATE);
				HideMouse;
				vswr_mode(vdiHandle,MD_XOR);
				vsf_interior(vdiHandle,FIS_SOLID);
				Cell2VRect(Parms.Cursor.Row,Parms.Cursor.Col,crs);
				valid:=FirstWorkRect(r);
				while valid do
					begin
						if rc_intersect(crs,r) then vr_recfl(vdiHandle,r.A2);
						valid:=NextWorkRect(r)
					end;
				vsf_interior(vdiHandle,FIS_HOLLOW);
				vswr_mode(vdiHandle,MD_REPLACE);
				ShowMouse;
				wind_update(END_UPDATE)
			end
	end;


procedure TCalcWindow.EnableInpline;

	begin
		DeselectAllObjects;
		inpline^.Enable;
		if inpcancel<>nil then inpcancel^.Unhide;
		if inpok<>nil then inpok^.Unhide;
		inpstat:=true
	end;


procedure TCalcWindow.SetInpline(cell: PCell);
	var txt: string;

	procedure settxt(s: string);
		var q: integer;
	
		begin
			q:=length(s);
			if q<=54 { ... } then inpline^.SetCursor(q)
			else
				inpline^.SetCursor(0);
			inpline^.SetText(s)
		end;

	begin
		if inpline=nil then exit;
		if cell=nil then
			begin
				if length(inpline^.GetText)>0 then
					begin
						inpline^.SetCursor(0);
						inpline^.Clear
					end;
				exit
			end;
		if cell^.Data.Value=0 then
			begin
				if length(inpline^.GetText)>0 then
					begin
						inpline^.SetCursor(0);
						inpline^.Clear
					end;
				exit
			end;
		case cell^.Typ of
		CTYPE_TEXT:
			begin
				txt:=cell^.Data.Txt^;
				case (cell^.TxtVal.Align and $0f) of
				TA_CENTER:
					txt:='^'+txt;
				TA_RIGHT:
					txt:='"'+txt
				else
					txt:=''''+txt
				end;
				if inpline^.GetText<>txt then settxt(txt)
			end;
		CTYPE_CONST:
			begin
				if inpline^.GetText<>cell^.Data.Konst^.Txt^ then settxt(cell^.Data.Konst^.Txt^)
			end;
		CTYPE_FORMULA:
			begin
				txt:=BuildFunction(cell,true);
				if inpline^.GetText<>txt then settxt(txt)
			end
		else
			begin
				if length(inpline^.GetText)>0 then
					begin
						inpline^.SetCursor(0);
						inpline^.Clear
					end
			end
		end
	end;


procedure TCalcWindow.Calculate(clr: boolean);
	var cell  : PCell;
	    q,w   : integer;

	begin
		if Sheet=nil then exit;
		BusyMouse;
		if clr then ClearCalcFlags;
		cell:=Sheet;
		for q:=0 to Parms.Rows do
			for w:=0 to Parms.Columns do
				begin
					if cell^.Typ=CTYPE_FORMULA then GetCellValue(cell,false);
					inc(longint(cell),CELLSIZE)
				end;
		ArrowMouse
	end;


procedure TCalcWindow.AutoCalculate(clr: boolean);

	begin
		if sheetbuffer.autocalc=bf_Checked then Calculate(clr)
	end;


function TCalcWindow.NewNode(var p: PNode): boolean;

	begin
		new(p);
		if p<>nil then
			begin
				NewNode:=true;
				p^.Typ:=0;
				p^.Count:=0;
				p^.Left.Node:=nil;
				p^.Right.Node:=nil
			end
		else
			NewNode:=false
	end;


procedure TCalcWindow.DeleteNode(var p: PNode);
	var q: integer;

	begin
		if p=nil then exit;
		if p^.Typ<5000 then
			begin
				if p^.Typ>=10 then
					begin
						DeleteNode(p^.Right.Node);
						DeleteNode(p^.Left.Node)
					end
				else
					if p^.Typ=NT_CONST then
						begin
							dispose(p^.Num);
							DisposeStr(p^.Left.Txt)
						end
					else
						if p^.Typ=NT_VARIABLE then DisposeStr(p^.Varb)
			end
		else
			if p^.Left.List<>nil then
				begin
					for q:=0 to p^.Count-1 do DeleteNode(PNode(p^.Left.List^[q]));
					freemem(p^.Left.List,p^.Count shl 2)
				end;
		dispose(p);
		p:=nil
	end;


procedure TCalcWindow.TranslateCells(rs,cs,re,ce,rdif,cdif: integer; clr: boolean);
	var x,y     : integer;
	    cell    : PCell;
	    q       : longint;
	    inside,
	    inside2,
	    xyinside: boolean;

	function RefInBlock(r,c,flg: integer): boolean;

		begin
			if not(bTst(flg,RF_COLABS)) then
				begin
					inc(c,x);
					if xyinside then dec(c,cdif)
				end;
			if not(bTst(flg,RF_ROWABS)) then
				begin
					inc(r,y);
					if xyinside then dec(r,rdif)
				end;
			RefInBlock:=Between(r,rs,re) and Between(c,cs,ce)
		end;

	procedure TranslateNode(p: PNode);
		var q: integer;

		begin
			if p=nil then exit;
			if p^.Typ<5000 then
				begin
					if p^.Typ>=10 then
						begin
							TranslateNode(p^.Right.Node);
							TranslateNode(p^.Left.Node)
						end
					else
						if p^.Typ=NT_CELL then
							begin
								inside:=RefInBlock(p^.RowRef,p^.ColRef,p^.Right.Flg);
								if bTst(p^.Right.Flg,RF_COLABS) then
									begin
										if inside then inc(p^.ColRef,cdif)
									end
								else
									if xyinside then
										begin
											if not(inside) then dec(p^.ColRef,cdif)
										end
									else
										if inside then inc(p^.ColRef,cdif);
								if bTst(p^.Right.Flg,RF_ROWABS) then
									begin
										if inside then inc(p^.RowRef,rdif)
									end
								else
									if xyinside then
										begin
											if not(inside) then dec(p^.RowRef,rdif)
										end
									else
										if inside then inc(p^.RowRef,rdif)
							end
						else
							if p^.Typ=NT_RANGE then
								begin
									inside:=RefInBlock(p^.Left.RowRef,p^.Left.ColRef,p^.Ref1Flg);
									inside2:=RefInBlock(p^.Right.RowRef,p^.Right.ColRef,p^.Ref2Flg);
									if bTst(p^.Ref1Flg,RF_COLABS) then
										begin
											if inside then inc(p^.Left.ColRef,cdif)
										end
									else
										if xyinside then
											begin
												if not(inside) then dec(p^.Left.ColRef,cdif)
											end
										else
											if inside then inc(p^.Left.ColRef,cdif);
									if bTst(p^.Ref1Flg,RF_ROWABS) then
										begin
											if inside then inc(p^.Left.RowRef,rdif)
										end
									else
										if xyinside then
											begin
												if not(inside) then dec(p^.Left.RowRef,rdif)
											end
										else
											if inside then inc(p^.Left.RowRef,rdif);
									if bTst(p^.Ref2Flg,RF_COLABS) then
										begin
											if inside2 then inc(p^.Right.ColRef,cdif)
										end
									else
										if xyinside then
											begin
												if not(inside2) then dec(p^.Right.ColRef,cdif)
											end
										else
											if inside2 then inc(p^.Right.ColRef,cdif);
									if bTst(p^.Ref2Flg,RF_ROWABS) then
										begin
											if inside2 then inc(p^.Right.RowRef,rdif)
										end
									else
									if xyinside then
										begin
											if not(inside2) then dec(p^.Right.RowRef,rdif)
										end
									else
										if inside2 then inc(p^.Right.RowRef,rdif)
								end
				end
			else
				if p^.Left.List<>nil then
					for q:=0 to p^.Count-1 do TranslateNode(PNode(p^.Left.List^[q]))
		end;

	begin
		if Variables<>nil then
			if Variables^.Count>0 then
				for q:=0 to Variables^.Count-1 do
					with PVariable(Variables^.At(q))^ do
						if Between(RefRow,rs,re) then
							if Between(RefCol,cs,ce) then
								begin
									inc(RefRow,rdif);
									inc(RefCol,cdif)
								end;
		for y:=0 to Parms.Rows do
			begin
				cell:=GetCell(y,0);
				for x:=0 to Parms.Columns do
					begin
						if cell^.Typ=CTYPE_FORMULA then
							begin
								xyinside:=Between(x,cs,ce) and Between(y,rs,re);
								TranslateNode(cell^.Data.Formula^.Func)
							end;
						inc(longint(cell),CELLSIZE)
					end
			end
	end;


function TCalcWindow.BuildFunction(cell: PCell; fnames: boolean): string;
	var txt: string;

	begin
		txt:='='+BuildTree(cell,cell^.Data.Formula^.Func,fnames,0,0);
		if cell^.Data.Formula^.VarDef<>nil then txt:='='+cell^.Data.Formula^.VarDef^+txt;
		BuildFunction:=txt
	end;


function TCalcWindow.BuildTree(cell: PCell; p: PNode; fnames: boolean; rrel,crel: integer): string;

	function getfunc: string;
		var q: longint;

		begin
			if fnames then
				begin
					q:=TexelApp.Functions^.Count-1;
					while q>=0 do
						begin
							if PFunction(TexelApp.Functions^.At(q))^.Opcode=p^.Typ then
								begin
									getfunc:=PFunction(TexelApp.Functions^.At(q))^.Name^;
									exit
								end;
							dec(q)
						end;
					getfunc:=''
				end
			else
				getfunc:=#27+ltoa(p^.Typ)+#27
		end;

	function build5000: string;
		var txt: string;
		    q  : integer;

		begin
			build5000:='';
			if p^.Left.List=nil then exit;
			txt:='';
			for q:=0 to p^.Count-1 do
				if p^.Left.List^[q]<>nil then
					begin
						if length(txt)>0 then txt:=txt+',';
						txt:=txt+BuildTree(cell,PNode(p^.Left.List^[q]),fnames,rrel,crel)
					end;
			build5000:=txt
		end;

	function buildref(c,r: integer; flg: integer): string;
		var ar,ac: integer;

		begin
			if bTst(flg,RF_COLABS or RF_ROWABS) then buildref:='$'+GetColumnIndex(c)+'$'+GetRowIndex(r)
			else
				begin
					Cell2RC(cell,ar,ac);
					if (flg and (RF_COLABS or RF_ROWABS))=0 then buildref:=GetColumnIndex(ac+c+crel)+GetRowIndex(ar+r+rrel)
					else
						if bTst(flg,RF_COLABS) then buildref:='$'+GetColumnIndex(c)+GetRowIndex(ar+r+rrel)
						else
							buildref:=GetColumnIndex(ac+c+crel)+'$'+GetRowIndex(r)
				end
		end;

	begin
		BuildTree:='';
		if p=nil then exit;
		if p^.Typ>=5000 then BuildTree:=getfunc+'('+build5000+')'
		else
			begin
				if p^.Typ>=1000 then
					begin
						if p^.Right.Node<>nil then BuildTree:=getfunc+'('+BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+','+BuildTree(cell,p^.Right.Node,fnames,rrel,crel)+')'
						else
							if p^.Left.Node<>nil then BuildTree:=getfunc+'('+BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+')'
							else
								BuildTree:=getfunc
					end
				else
					case p^.Typ of
					NT_CONST:
						if p^.Left.Txt=nil then BuildTree:=Val2TxtF(p^.Num^,MAXCIPHERS,0,nil)
						else
							BuildTree:=p^.Left.Txt^;
					NT_CELL:
						BuildTree:=buildref(p^.ColRef,p^.RowRef,p^.Right.Flg);
					NT_RANGE:
						BuildTree:=buildref(p^.Left.ColRef,p^.Left.RowRef,p^.Ref1Flg)+':'+buildref(p^.Right.ColRef,p^.Right.RowRef,p^.Ref2Flg);
					NT_VARIABLE:
						BuildTree:=p^.Varb^;
					NT_KLAMMER:
						BuildTree:='('+BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+')';
{					NT_DEFINE:
						BuildTree:=BuildTree(cell,p^.Right.Node,fnames,rrel,crel); ... }
					NT_PLUS:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'+'+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_MINUS:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'-'+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_MULT:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'*'+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_DIV:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'/'+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_POWER:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'^'+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_NEGATE:
						BuildTree:='-'+BuildTree(cell,p^.Left.Node,fnames,rrel,crel);
					NT_EQUAL:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'='+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_GREATER:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'>'+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_LESS:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'<'+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_GREATEREQUAL:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'>='+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_LESSEQUAL:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'<='+BuildTree(cell,p^.Right.Node,fnames,rrel,crel);
					NT_UNEQUAL:
						BuildTree:=BuildTree(cell,p^.Left.Node,fnames,rrel,crel)+'<>'+BuildTree(cell,p^.Right.Node,fnames,rrel,crel)
					end
			end
	end;


function TCalcWindow.Parse(s: string; var svar: string; var baum: PNode; acell: PCell; rrel,crel: integer; varerr: boolean): boolean;
	label _novar;

	var bvar,dvar: string;
	    i,j,ar,ac: integer;
	    fehler,
	    retimmed : boolean;
	    pv       : PVariable;

	procedure vergleich(var s: string; var baum: PNode); forward;

	function konstante(var s: string; var baum: PNode): boolean;
		var q  : integer;
		    cmp: string;
		    tc : char;

		begin
			StrPTrim(s);
			konstante:=false;
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			if Parameter=nil then exit;
			q:=Parameter^.Count-1;
			while q>=0 do
				begin
					cmp:=PParameter(Parameter^.At(q))^.Name^;
					if StrPLeft(s,length(cmp))=StrPUpper(cmp) then
						begin
							if length(s)>length(cmp) then tc:=s[length(cmp)+1]
							else
								tc:=#0;
							if not(tc in VarNameSet) then
								begin
									s:=StrPRight(s,length(s)-length(cmp));
									konstante:=true;
									if NewNode(baum) then
										begin
											baum^.Typ:=NT_CONST;
											new(baum^.Num);
											if baum^.Num<>nil then
												begin
													baum^.Num^:=PParameter(Parameter^.At(q))^.Value;
													baum^.Left.Txt:=NewStr(cmp)
												end
											else
												begin
													dispose(baum);
													baum:=nil;
													fehler:=true
												end
										end
									else
										fehler:=true;
									exit
								end
						end;
					dec(q)
				end
		end;

	function zelle(var s: string; var baum: PNode): boolean;
		var q,w,
		    qs,ws,
		    cref,
		    flg,
		    rref : integer;
		    r,c  : longint;
		    pn   : PNode;

		begin
			StrPTrim(s);
			zelle:=false;
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			if s[1]='$' then
				begin
					flg:=RF_COLABS;
					qs:=2
				end
			else
				begin
					flg:=0;
					qs:=1
				end;
			q:=qs;
			while (s[q] in ['A'..'Z']) and (q<=length(s)) do inc(q);
			ws:=q;
			if ws<=length(s) then
				if s[ws]='$' then
					begin
						inc(ws);
						flg:=flg or RF_ROWABS
					end;
			w:=ws;
			while (s[w] in ['0'..'9']) and (w<=length(s)) do inc(w);
			if (q>qs) and (q<qs+3) and (w-ws>0) and (w-ws<6) then
				begin
					if q=qs+1 then cref:=ord(s[qs])-65
					else
						if q=qs+2 then cref:=ord(s[qs])*26+ord(s[qs+1])-1729
						else
							cref:=-1;
					rref:=atol(StrPMid(s,ws,w-ws))-1;
					s:=StrPRight(s,length(s)+1-w);
					zelle:=true;
					if NewNode(baum) then
						begin
							baum^.Typ:=NT_CELL;
							if bTst(flg,RF_COLABS) then baum^.ColRef:=cref
							else
								baum^.ColRef:=cref+crel-ac;
							if bTst(flg,RF_ROWABS) then baum^.RowRef:=rref
							else
								baum^.RowRef:=rref+rrel-ar;
							baum^.Right.Flg:=flg
						end
					else
						fehler:=true
				end
		end;

	function zahl(var s: string; var baum: PNode): boolean;
		label _ok,_again;

		var q,stat,
		    old   : integer;
		    lz    : boolean;
		    os    : string;

		begin
			StrPTrim(s);
			zahl:=false;
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			if s[1]='.' then
				begin
					stat:=1;
					lz:=true;
					q:=2
				end
			else
				begin
					stat:=0;
					lz:=false;
					q:=1
				end;
			_again:
			if stat=2 then
				if s[q] in ['-','+'] then inc(q);
			old:=q;
			while (q<=length(s)) and (s[q] in ['0'..'9']) do inc(q);
			if old=q then exit;
			if q>length(s) then goto _ok;
			if stat=0 then
				begin
					if s[q]='.' then
						begin
							inc(q);
							stat:=1;
							goto _again
						end
					else
						if s[q]='E' then
							begin
								inc(q);
								stat:=2;
								goto _again
							end
				end
			else
				if stat=1 then
					if s[q]='E' then
						begin
							inc(q);
							stat:=2;
							goto _again
						end;
			_ok:
			zahl:=true;
			os:=StrPLeft(s,q-1);
			if lz then os:='0'+os;
			s:=StrPRight(s,length(s)+1-q);
			if NewNode(baum) then
				begin
					baum^.Typ:=NT_CONST;
					new(baum^.Num);
					if baum^.Num<>nil then
						begin
							baum^.Num^:=atof(os);
							baum^.Left.Txt:=NewStr(os)
						end
					else
						begin
							dispose(baum);
							baum:=nil;
							fehler:=true
						end
				end
			else
				fehler:=true
		end;

	function bereich(var s: string; var baum: PNode): boolean;
		var rs,cs,re,ce,f1,f2: integer;

		begin
			StrPTrim(s);
			bereich:=false;
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			if retimmed then exit;
			if GetBlock(s,true,rs,cs,re,ce,f1,f2) then
				begin
					bereich:=true;
					s:='';
					if NewNode(baum) then
						begin
							baum^.Typ:=NT_RANGE;
							if not(bTst(f1,RF_ROWABS)) then inc(rs,rrel-ar);
							if not(bTst(f1,RF_COLABS)) then inc(cs,crel-ac);
							if not(bTst(f2,RF_ROWABS)) then inc(re,rrel-ar);
							if not(bTst(f2,RF_COLABS)) then inc(ce,crel-ac);
							baum^.Left.ColRef:=cs;
							baum^.Left.RowRef:=rs;
							baum^.Right.ColRef:=ce;
							baum^.Right.RowRef:=re;
							baum^.Ref1Flg:=f1;
							baum^.Ref2Flg:=f2
						end
					else
						fehler:=true
				end
		end;

	function scanbraces(const s: string; l: integer; var r: integer): boolean;
		var q: integer;

		begin
			q:=1;
			r:=l+1;
			while (r<=length(s)) and (q>0) do
				begin
					if s[r]='(' then inc(q)
					else
						if s[r]=')' then dec(q);
					inc(r)
				end;
			dec(r);
			scanbraces:=(q=0)
		end;

	function countparts(const s: string): integer;
		var t,q,r: integer;

		begin
			q:=1;
			r:=2;
			t:=1;
			while (r<=length(s)) and (q>0) do
				begin
					if (s[r] in [';',',']) and (q=1) then inc(t)
					else
						if s[r]='(' then inc(q)
						else
							if s[r]=')' then dec(q);
					inc(r)
				end;
			countparts:=t
		end;

	function scanpart(const s: string; r: integer): integer;
		var q: integer;

		begin
			q:=1;
			while (r<=length(s)) and (q>0) do
				begin
					if (s[r] in [';',',']) and (q=1) then
						begin
							scanpart:=r;
							exit
						end
					else
						if s[r]='(' then inc(q)
						else
							if s[r]=')' then dec(q);
					inc(r)
				end;
			scanpart:=r-1
		end;

	function funktion(var s: string; var baum: PNode): boolean;
		label _bpende;

		var q,r,w,t,
		    z,old  : integer;
		    cmp    : string;
		    pf     : PFunction;
		    pn     : PNode;
		    tc     : char;

		begin
			StrPTrim(s);
			funktion:=false;
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			q:=TexelApp.Functions^.Count-1;
			while q>=0 do
				begin
					pf:=PFunction(TexelApp.Functions^.At(q));
					cmp:=pf^.Name^;
					if StrPLeft(s,length(cmp))=StrPUpper(cmp) then
						begin
							if length(s)>length(cmp) then tc:=s[length(cmp)+1]
							else
								tc:=#0;
							if not(tc in VarNameSet) then
								begin
									s:=StrPRight(s,length(s)-length(cmp));
									funktion:=true;
									if pf^.Parms^='0' then
										begin
											if NewNode(baum) then baum^.Typ:=pf^.Opcode
											else
												fehler:=true
										end
									else
										if pf^.Parms^='1' then
											begin
												if scanbraces(s,1,r) then
													begin
														cmp:=StrPMid(s,2,r-2);
														s:=StrPRight(s,length(s)-r);
														vergleich(cmp,baum);
														if not(fehler) then
															begin
																if NewNode(pn) then
																	begin
																		pn^.Typ:=pf^.Opcode;
																		pn^.Left.Node:=baum;
																		baum:=pn
																	end
																else
																	fehler:=true
															end
													end
												else
													fehler:=true
											end
										else
											if pf^.Parms^='1!' then
												begin
													if scanbraces(s,1,r) then
														begin
															cmp:=StrPMid(s,2,r-2);
															s:=StrPRight(s,length(s)-r);
															retimmed:=false;
															if not(bereich(cmp,baum)) then
																if not(fehler) then
																	if not(zelle(cmp,baum)) then fehler:=true;
															if not(fehler) then
																begin
																	if NewNode(pn) then
																		begin
																			pn^.Typ:=pf^.Opcode;
																			pn^.Left.Node:=baum;
																			baum:=pn
																		end
																	else
																		fehler:=true
																end
														end
													else
														fehler:=true
												end
											else
												if StrPLeft(pf^.Parms^,1)='2' then
													begin
														if scanbraces(s,1,r) then
															begin
																w:=scanpart(s,2);
																if w=r then
																	if StrPRight(pf^.Parms^,1)<>'?' then
																		begin
																			fehler:=true;
																			exit
																		end;
																cmp:=StrPMid(s,2,w-2);
																vergleich(cmp,baum);
																if not(fehler) then
																	begin
																		if NewNode(pn) then
																			begin
																				pn^.Typ:=pf^.Opcode;
																				pn^.Left.Node:=baum;
																				baum:=pn;
																				if w<r then
																					begin
																						cmp:=StrPMid(s,w+1,r-w-1);
																						vergleich(cmp,pn);
																						if not(fehler) then baum^.Right.Node:=pn
																					end
																			end
																		else
																			fehler:=true
																	end;
																s:=StrPRight(s,length(s)-r)
															end
														else
															fehler:=true
													end
												else
													if scanbraces(s,1,r) then
														begin
															t:=countparts(s);
															if NewNode(baum) then
																begin
																	baum^.Typ:=pf^.Opcode;
																	baum^.Count:=t;
																	getmem(baum^.Left.List,t shl 2);
																	if baum^.Left.List<>nil then fillchar(baum^.Left.List^,t shl 2,0)
																	else
																		begin
																			fehler:=true;
																			goto _bpende
																		end
																end
															else
																begin
																	fehler:=true;
																	goto _bpende
																end;
															retimmed:=(StrPLeft(pf^.Parms^,1)<>'#');
															w:=scanpart(s,2);
															cmp:=StrPMid(s,2,w-2);
															if not(bereich(cmp,pn)) then
																if not(fehler) then vergleich(cmp,pn);
															if not(fehler) then
																begin
																	baum^.Left.List^[0]:=pn;
																	z:=1;
																	while (w<r) and (z<t) and not(fehler) do
																		begin
																			old:=w+1;
																			w:=scanpart(s,old);
																			cmp:=StrPMid(s,old,w-old);
																			if not(bereich(cmp,pn)) then
																				if not(fehler) then vergleich(cmp,pn);
																			if not(fehler) then
																				begin
																					baum^.Left.List^[z]:=pn;
																					inc(z)
																				end
																		end;
																	if not(fehler) then
																		if StrPMid(pf^.Parms^,2,1)<>'*' then
																			begin
																				if z<atol(StrPMid(pf^.Parms^,2,1)) then fehler:=true
																				else
																					if StrPRight(pf^.Parms^,1)<>'*' then
																						if z>atol(StrPRight(pf^.Parms^,1)) then fehler:=true
																			end
																end;
															_bpende:
															s:=StrPRight(s,length(s)-r)
														end
													else
														fehler:=true;
									exit
								end
						end;
					dec(q)
				end
		end;

	function variable(var s: string; var baum: PNode): boolean;
		var q : integer;
		    os: string;

		begin
			StrPTrim(s);
			variable:=false;
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			q:=1;
			while (q<=length(s)) and (s[q] in VarNameSet) do inc(q);
			if q=1 then exit;
			os:=StrPLeft(s,q-1);
			s:=StrPRight(s,length(s)+1-q);
			variable:=true;
			if NewNode(baum) then
				begin
					baum^.Typ:=NT_VARIABLE;
					if Variables<>nil then
						if Variables^.Count>0 then
							for q:=0 to Variables^.Count-1 do
								with PVariable(Variables^.At(q))^ do
									if os=StrPUpper(Name^) then
										begin
											os:=Name^;
											break
										end;
					baum^.Varb:=NewStr(os);
					if baum^.Varb=nil then
						begin
							dispose(baum);
							baum:=nil;
							fehler:=true
						end
				end
			else
				fehler:=true
		end;

	procedure faktor(var s: string; var baum: PNode);
		var q : integer;
		    s2: string;
		    pn: PNode;

		begin
			StrPTrim(s);
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			if s[1]='(' then
				begin
					if scanbraces(s,1,q) then
						begin
							s2:=StrPMid(s,2,q-2);
							s:=StrPRight(s,length(s)-q);
							vergleich(s2,baum);
							if NewNode(pn) then
								begin
									pn^.Typ:=NT_KLAMMER;
									pn^.Left.Node:=baum;
									baum:=pn
								end
							else
								fehler:=true
						end
					else
						fehler:=true
				end
			else
				if not(funktion(s,baum)) then
					if not(zelle(s,baum)) then
						if not(konstante(s,baum)) then
							if not(zahl(s,baum)) then
								if not(variable(s,baum)) then fehler:=true;
			StrPTrim(s)
		end;

	procedure vorzfaktor(var s: string; var baum: PNode);
		var pn : PNode;
		    neg: boolean;

		begin
			StrPTrim(s);
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			neg:=false;
			if s[1] in ['+','-'] then
				begin
					if s[1]='-' then neg:=true;
					s:=StrPRight(s,length(s)-1)
				end;
			faktor(s,baum);
			if neg then
				if NewNode(pn) then
					begin
						pn^.Typ:=NT_NEGATE;
						pn^.Left.Node:=baum;
						baum:=pn
					end
				else
					fehler:=true
		end;

	procedure potenz(var s: string; var baum: PNode);
		var pn: PNode;

		begin
			StrPTrim(s);
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			vorzfaktor(s,baum);
			while (length(s)>0) and (s[1]='^') and not(fehler) do
				if NewNode(pn) then
					begin
						pn^.Typ:=NT_POWER;
						pn^.Left.Node:=baum;
						baum:=pn;
						s:=StrPRight(s,length(s)-1);
						pn:=nil;
						vorzfaktor(s,pn);
						baum^.Right.Node:=pn
					end
				else
					fehler:=true
		end;

	procedure produkt(var s: string; var baum: PNode);
		var pn: PNode;

		begin
			StrPTrim(s);
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			potenz(s,baum);
			while (length(s)>0) and ((s[1]='*') or (s[1]='/')) and not(fehler) do
				if NewNode(pn) then
					begin
						if s[1]='*' then pn^.Typ:=NT_MULT
						else
							pn^.Typ:=NT_DIV;
						pn^.Left.Node:=baum;
						baum:=pn;
						s:=StrPRight(s,length(s)-1);
						pn:=nil;
						potenz(s,pn);
						baum^.Right.Node:=pn
					end
				else
					fehler:=true
		end;

	procedure summe(var s: string; var baum: PNode);
		var pn: PNode;

		begin
			StrPTrim(s);
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			produkt(s,baum);
			while (length(s)>0) and ((s[1]='+') or (s[1]='-')) and not(fehler) do
				if NewNode(pn) then
					begin
						if s[1]='+' then pn^.Typ:=NT_PLUS
						else
							pn^.Typ:=NT_MINUS;
						pn^.Left.Node:=baum;
						baum:=pn;
						s:=StrPRight(s,length(s)-1);
						pn:=nil;
						produkt(s,pn);
						baum^.Right.Node:=pn
					end
				else
					fehler:=true
		end;

	procedure vergleich(var s: string; var baum: PNode);
		var pn: PNode;

		begin
			StrPTrim(s);
			if length(s)=0 then
				begin
					fehler:=true;
					exit
				end;
			summe(s,baum);
			while (length(s)>0) and (s[1] in ['<','>','=']) and not(fehler) do
				if NewNode(pn) then
					begin
						if s[1]='=' then
							begin
								pn^.Typ:=NT_EQUAL;
								s:=StrPRight(s,length(s)-1)
							end
						else
							if StrPLeft(s,2)='>=' then
								begin
									pn^.Typ:=NT_GREATEREQUAL;
									s:=StrPRight(s,length(s)-2)
								end
							else
								if StrPLeft(s,2)='<=' then
									begin
										pn^.Typ:=NT_LESSEQUAL;
										s:=StrPRight(s,length(s)-2)
									end
								else
									if StrPLeft(s,2)='<>' then
										begin
											pn^.Typ:=NT_UNEQUAL;
											s:=StrPRight(s,length(s)-2)
										end
									else
										if s[1]='<' then
											begin
												pn^.Typ:=NT_LESS;
												s:=StrPRight(s,length(s)-1)
											end
										else
											begin
												pn^.Typ:=NT_GREATER;
												s:=StrPRight(s,length(s)-1)
											end;
						pn^.Left.Node:=baum;
						baum:=pn;
						pn:=nil;
						summe(s,pn);
						baum^.Right.Node:=pn
					end
				else
					fehler:=true;
			if length(s)>0 then fehler:=true
		end;

	procedure optimiere(var baum: PNode);

		begin
			if baum=nil then exit;
			if baum^.Typ>=5000 then
				begin
					{ ... }
				end
			else
				if baum^.Typ>=10 then
					begin
						optimiere(baum^.Left.Node);
						optimiere(baum^.Right.Node)
					end;
			{ ... }
		end;

	begin
		baum:=nil;
		Parse:=false;
		StrPTrim(s);
		svar:='';
		if length(s)=0 then exit;
		if s[1]='=' then
			begin
				Cell2RC(acell,ar,ac);
				bvar:='';
				s:=StrPRight(s,length(s)-1);
				i:=pos('=',s);
				if i>0 then
					begin
						dvar:=StrPUpper(StrPTrimF(StrPLeft(s,i-1)));
						if length(dvar)>0 then
							begin
								if dvar[1] in ['0'..'9'] then goto _novar;
								for j:=1 to length(dvar) do if not(dvar[j] in VarNameSet) then goto _novar;
								if zelle(dvar,baum) then
									begin
										if baum<>nil then DeleteNode(baum);
										goto _novar
									end;
								if konstante(dvar,baum) then
									begin
										if baum<>nil then DeleteNode(baum);
										goto _novar
									end;
								if funktion(dvar,baum) then
									begin
										if baum<>nil then DeleteNode(baum);
										goto _novar
									end
							end;
						bvar:=StrPTrimF(StrPLeft(s,i-1));
						s:=StrPRight(s,length(s)-i);
						if length(bvar)>0 then
							if Variables<>nil then
								if Variables^.Count>0 then
									for i:=0 to Variables^.Count-1 do
										with PVariable(Variables^.At(i))^ do
											if StrPUpper(bvar)=StrPUpper(Name^) then
												begin
													if varerr then
														begin
															Application^.Alert(@self,1,NOTE,MESSAGE_WINDOW_VAR1+StrPUpper(bvar)+MESSAGE_WINDOW_VAR2+GetColumnIndex(RefCol)+GetRowIndex(RefRow)+MESSAGE_WINDOW_VAR3,BUTTON_OK);
															exit
														end
													else
														begin
															bvar:='';
															goto _novar
														end
												end
					end;
				_novar:
				fehler:=false;
				s:=StrPUpper(s);
				vergleich(s,baum);
				if fehler then DeleteNode(baum)
				else
					if baum<>nil then
						begin
{							optimiere(baum); ... }
							if length(bvar)>0 then
								begin
									if Variables=nil then
										begin
											new(Variables,Init(20,10));
											if Variables<>nil then Variables^.CaseSensitive:=false
										end;
									if Variables<>nil then
										begin
											new(pv);
											if pv<>nil then
												begin
													pv^.Name:=NewStr(bvar);
													if pv^.Name=nil then dispose(pv)
													else
														begin
															pv^.RefRow:=ar;
															pv^.RefCol:=ac;
															Variables^.Insert(pv)
														end
												end
										end;
									svar:=bvar
								end;
							Parse:=true
						end
			end
	end;


function TCalcWindow.EvalNode(cell: PCell; knoten: PNode): TNumber;
	type pmarray = ^tmarray;
	     tmarray = array [0..maxint] of TNumber;

	var dummy,dummy2,
	    dummy3,dummy4: TNumber;
	    l1,l2,manz   : longint;
	    w,ar,ac,
	    xbis,xvon,
	    yvon,ybis    : integer;
	    node         : PNode;
	    marray       : pmarray;
	    pna          : PIntegerArray;

	function isint(dummy: TNumber): boolean;

		begin
			isint:=(int(dummy)=dummy) and (abs(dummy)<=2147483647.0)
		end;

	procedure getrc(flg,rowref,colref: integer);

		begin
			if bTst(flg,RF_ROWABS or RF_COLABS) then
				begin
					ar:=rowref;
					ac:=colref
				end
			else
				begin
					Cell2RC(cell,ar,ac);
					if (flg and (RF_ROWABS or RF_COLABS))=0 then
						begin
							inc(ar,rowref);
							inc(ac,colref)
						end
					else
						if bTst(flg,RF_ROWABS) then
							begin
								inc(ac,colref);
								ar:=RowRef
							end
						else
							begin
								inc(ar,rowref);
								ac:=ColRef
							end
				end
		end;

	function getrange(node: PNode): boolean;

		begin
			getrc(node^.Ref1Flg,node^.Left.RowRef,node^.Left.ColRef);
			xvon:=ac;
			yvon:=ar;
			getrc(node^.Ref2Flg,node^.Right.RowRef,node^.Right.ColRef);
			if ac<xvon then
				begin
					xbis:=xvon;
					xvon:=ac
				end
			else
				xbis:=ac;
			if ar<yvon then
				begin
					ybis:=yvon;
					yvon:=ar
				end
			else
				ybis:=ar;
			if (yvon<0) or (ybis>Parms.Rows) or (xvon<0) or (xbis>Parms.Columns) then
				begin
					EvalNode:=0.0;
					fnerror:=FE_CELLOUTOFRANGE;
					fnecell:=cell;
					getrange:=true
				end
			else
				getrange:=false
		end;

	function bund: TNumber;
		label _sraus;

		var x,y,q: integer;
		    ret  : longint;
		    zelle: PCell;

		begin
			q:=knoten^.Count;
			if q=0 then ret:=0
			else
				ret:=$ffffffff;
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy:=EvalNode(cell,node);
									if fnerror<>FE_OK then goto _sraus;
									if not(isint(dummy)) then
										begin
											bund:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell;
											exit
										end;
									ret:=ret and trunc(dummy)
								end
							else
								begin
									if getrange(node) then goto _sraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy:=Evaluate(zelle);
															if fnerror<>FE_OK then goto _sraus;
															if not(isint(dummy)) then
																begin
																	bund:=0.0;
																	fnerror:=FE_UNDEFINED;
																	fnecell:=cell;
																	exit
																end;
															ret:=ret and trunc(dummy)
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_sraus:
			bund:=ret
		end;

	function boder: TNumber;
		label _sraus;

		var x,y,q: integer;
		    ret  : longint;
		    zelle: PCell;

		begin
			q:=knoten^.Count;
			ret:=0;
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy:=EvalNode(cell,node);
									if fnerror<>FE_OK then goto _sraus;
									if not(isint(dummy)) then
										begin
											boder:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell;
											exit
										end;
									ret:=ret or trunc(dummy)
								end
							else
								begin
									if getrange(node) then goto _sraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													dummy:=Evaluate(zelle);
													if fnerror<>FE_OK then goto _sraus;
													if not(isint(dummy)) then
														begin
															boder:=0.0;
															fnerror:=FE_UNDEFINED;
															fnecell:=cell;
															exit
														end;
													ret:=ret or trunc(dummy);
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_sraus:
			boder:=ret
		end;

	function beor: TNumber;
		label _sraus;

		var x,y,q: integer;
		    ret  : longint;
		    zelle: PCell;

		begin
			q:=knoten^.Count;
			ret:=0;
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy:=EvalNode(cell,node);
									if fnerror<>FE_OK then goto _sraus;
									if not(isint(dummy)) then
										begin
											beor:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell;
											exit
										end;
									ret:=ret xor trunc(dummy)
								end
							else
								begin
									if getrange(node) then goto _sraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													dummy:=Evaluate(zelle);
													if fnerror<>FE_OK then goto _sraus;
													if not(isint(dummy)) then
														begin
															beor:=0.0;
															fnerror:=FE_UNDEFINED;
															fnecell:=cell;
															exit
														end;
													ret:=ret xor trunc(dummy);
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_sraus:
			beor:=ret
		end;

	function summe: TNumber;
		label _sraus;

		var x,y,q: integer;
		    zelle: PCell;

		begin
			dummy:=0.0;
			q:=knoten^.Count;
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then dummy:=dummy+EvalNode(cell,node)
							else
								begin
									if getrange(node) then goto _sraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													dummy:=dummy+Evaluate(zelle);
													if fnerror<>FE_OK then goto _sraus;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_sraus:
			summe:=dummy
		end;

	function produkt: TNumber;
		label _praus;

		var x,y,q: integer;
		    zelle: PCell;

		begin
			q:=knoten^.Count;
			if q=0 then dummy:=0.0
			else
				dummy:=1.0;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then dummy:=dummy*EvalNode(cell,node)
							else
								begin
									if getrange(node) then goto _praus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy:=dummy*Evaluate(zelle);
															if fnerror<>FE_OK then goto _praus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_praus:
			produkt:=dummy
		end;

	function oder: TNumber;
		var x,y,q: integer;
		    zelle: PCell;

		begin
			oder:=0.0;
			q:=knoten^.Count;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									if EvalNode(cell,node)<>0.0 then
										begin
											oder:=1.0;
											exit
										end
								end
							else
								begin
									if getrange(node) then exit;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if Evaluate(zelle)<>0.0 then
														begin
															oder:=1.0;
															exit
														end;
													if fnerror<>FE_OK then exit;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end
		end;

	function und: TNumber;
		var x,y,q: integer;
		    zelle: PCell;

		begin
			und:=1.0;
			q:=knoten^.Count;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									if EvalNode(cell,node)=0.0 then
										begin
											und:=0.0;
											exit
										end
								end
							else
								begin
									if getrange(node) then exit;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														if Evaluate(zelle)=0.0 then
															begin
																und:=0.0;
																exit
															end;
													if fnerror<>FE_OK then exit;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end
		end;

	function minimum: TNumber;
		label _mraus;

		var x,y,q: integer;
		    zelle: PCell;
		    neu  : boolean;

		begin
			dummy:=0.0;
			q:=knoten^.Count;
			neu:=true;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy2:=EvalNode(cell,node);
									if neu then
										begin
											dummy:=dummy2;
											neu:=false
										end
									else
										if dummy2<dummy then dummy:=dummy2
								end
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy2:=Evaluate(zelle);
															if neu then
																begin
																	dummy:=dummy2;
																	neu:=false
																end
															else
																if dummy2<dummy then dummy:=dummy2;
															if fnerror<>FE_OK then goto _mraus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			minimum:=dummy
		end;

	function maximum: TNumber;
		label _mraus;

		var x,y,q: integer;
		    zelle: PCell;
		    neu  : boolean;

		begin
			dummy:=0.0;
			q:=knoten^.Count;
			neu:=true;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy2:=EvalNode(cell,node);
									if neu then
										begin
											dummy:=dummy2;
											neu:=false
										end
									else
										if dummy2>dummy then dummy:=dummy2
								end
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy2:=Evaluate(zelle);
															if neu then
																begin
																	dummy:=dummy2;
																	neu:=false
																end
															else
																if dummy2>dummy then dummy:=dummy2;
															if fnerror<>FE_OK then goto _mraus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			maximum:=dummy
		end;

	function mdet(rs,breite: integer; pc: PIntegerArray): TNumber;
		label _raus;
		
		var zelle : PCell;
		    subret,
		    mulret,
		    ret   : TNumber;
		    x,q,w : integer;
		    pna   : PIntegerArray;

		begin
			if pc=nil then
				begin
					mdet:=0.0;
					fnerror:=FE_UNDEFINED;
					fnecell:=cell;
					exit
				end;
			if breite=0 then
				begin
					zelle:=GetCell(rs,pc^[0]);
					if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then mdet:=Evaluate(zelle)
					else
						begin
							mdet:=0.0;
							fnerror:=FE_UNDEFINED;
							fnecell:=cell
						end
				end
			else
				begin
					ret:=0.0;
					for x:=0 to breite do
						begin
							getmem(pna,breite shl 1);
							if pna<>nil then
								begin
									w:=0;
									for q:=0 to breite do
										if q<>x then
											begin
												pna^[w]:=pc^[q];
												inc(w)
											end
								end;
							subret:=mdet(rs+1,breite-1,pna);
							if fnerror<>FE_OK then
								begin
									ret:=0.0;
									goto _raus
								end;
							zelle:=GetCell(rs,pc^[x]);
							if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
								begin
									mulret:=Evaluate(zelle);
									if fnerror<>FE_OK then
										begin
											ret:=0.0;
											goto _raus
										end
								end
							else
								begin
									ret:=0.0;
									fnerror:=FE_UNDEFINED;
									fnecell:=cell;
									goto _raus
								end;
							if odd(x) then ret:=ret-mulret*subret
							else
								ret:=ret+mulret*subret
						end;
					_raus:
					mdet:=ret
				end;
			freemem(pc,(breite+1) shl 1)
		end;
	
	procedure freearray;

		begin
			if marray<>nil then
				begin
					freemem(marray,manz*sizeof(TNumber));
					marray:=nil;
					manz:=0
				end
		end;
	
	function getandsortarray(firstalpha: boolean): TNumber;
		var x,y,q,
		    anz,bis: integer;
		    zelle  : PCell;
		    sorted : boolean;

		begin
			getandsortarray:=0.0;
			manz:=0;
			marray:=nil;
			if firstalpha then bis:=1 else bis:=0;
			q:=knoten^.Count;
			Cell2RC(cell,ar,ac);
			while (q>bis) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then inc(manz)
							else
								begin
									if getrange(node) then exit;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then inc(manz);
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			if manz<=0 then exit;
			if firstalpha then
				begin
					node:=PNode(knoten^.Left.List^[0]);
					if node^.Typ=NT_RANGE then exit;
					getandsortarray:=EvalNode(cell,node)
				end;
			getmem(marray,manz*sizeof(TNumber));
			if marray=nil then exit;
			q:=knoten^.Count;
			Cell2RC(cell,ar,ac);
			anz:=0;
			while (q>bis) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									marray^[anz]:=EvalNode(cell,node);
									inc(anz)
								end
							else
								begin
									if getrange(node) then
										begin
											freearray;
											exit
										end;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															marray^[anz]:=Evaluate(zelle);
															inc(anz);
															if fnerror<>FE_OK then
																begin
																	freearray;
																	exit
																end
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			if manz>1 then
				repeat
					sorted:=true;
					for q:=0 to manz-2 do
						if marray^[q]>marray^[q+1] then
							begin
								dummy:=marray^[q];
								marray^[q]:=marray^[q+1];
								marray^[q+1]:=dummy;
								sorted:=false
							end
				until sorted
		end;

	function scriptno(oldval: TNumber; extnum: integer): TNumber;
		var q,qbis,
		    cx,cy : integer;
		    prm   : string;

		begin
			scriptno:=oldval;
			qbis:=knoten^.Count;
			prm:='';
			Cell2RC(cell,ar,ac);
			cx:=ac;
			cy:=ar;
			if extnum<NT_EXTMIN then
				begin
					node:=PNode(knoten^.Left.List^[0]);
					if node=nil then
						begin
							fnerror:=FE_UNDEFINED;
							fnecell:=cell;
							scriptno:=0.0;
							exit
						end;
					if node^.Typ=NT_RANGE then
						begin
							fnerror:=FE_UNDEFINED;
							fnecell:=cell;
							scriptno:=0.0;
							exit
						end;
					dummy:=EvalNode(cell,node);
					if fnerror<>FE_OK then
						begin
							scriptno:=0.0;
							exit
						end;
					if not(isint(dummy)) then
						begin
							fnerror:=FE_UNDEFINED;
							fnecell:=cell;
							scriptno:=0.0;
							exit
						end;
					q:=1
				end
			else
				begin
					dummy:=extnum-10000;
					q:=0
				end;
			while (q<qbis) and (fnerror=FE_OK) do
				begin
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then prm:=prm+' '+Val2TxtF(EvalNode(cell,node),15,0,nil)
							else
								begin
									if getrange(node) then
										begin
											scriptno:=0.0;
											exit
										end;
									prm:=prm+' '+GetColumnIndex(xvon)+GetRowIndex(yvon)+':'+GetColumnIndex(xbis)+GetRowIndex(ybis)
								end
						end;
					inc(q)
				end;
			if fnerror=FE_OK then
				if not(TexelApp.ScriptByNumber(trunc(dummy),GetWindowFileName,GetColumnIndex(cx)+GetRowIndex(cy),prm)) then
					begin
						fnerror:=FE_EXTERN;
						fnecell:=cell;
						scriptno:=0.0
					end
		end;
	
	function quantil(alpha: TNumber): TNumber;
		var k: longint;
	
		begin
			if (marray=nil) or (alpha<=0.0) or (alpha>=1.0) then
				begin
					quantil:=0.0;
					fnerror:=FE_UNDEFINED;
					fnecell:=cell;
					exit
				end;
			dummy:=alpha*manz;
			k:=trunc(dummy);
			if isint(dummy) then quantil:=(marray^[k-1]+marray^[k])/2
			else
				quantil:=marray^[k]
		end;

	function mittelwert: TNumber;
		label _mraus;

		var x,y,q,anz: integer;
		    zelle    : PCell;

		begin
			dummy:=0.0;
			q:=knoten^.Count;
			anz:=0;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy:=dummy+EvalNode(cell,node);
									inc(anz)
								end
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy:=dummy+Evaluate(zelle);
															inc(anz);
															if fnerror<>FE_OK then goto _mraus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			if anz>0 then dummy:=dummy/anz;
			mittelwert:=dummy
		end;

	function harmittel: TNumber;
		label _mraus;

		var x,y,q,anz: integer;
		    zelle    : PCell;

		begin
			dummy:=0.0;
			q:=knoten^.Count;
			anz:=0;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy2:=EvalNode(cell,node);
									if fnerror<>FE_OK then goto _mraus;
									if dummy2=0.0 then
										begin
											harmittel:=0.0;
											fnerror:=FE_DIVBYZERO;
											fnecell:=cell;
											exit
										end;
									dummy:=dummy+1/dummy2;
									inc(anz)
								end
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy2:=Evaluate(zelle);
															if fnerror<>FE_OK then goto _mraus;
															if dummy2=0.0 then
																begin
																	harmittel:=0.0;
																	fnerror:=FE_DIVBYZERO;
																	fnecell:=cell;
																	exit
																end;
															dummy:=dummy+1/dummy2;
															inc(anz)
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			if dummy<>0 then dummy:=anz/dummy;
			harmittel:=dummy
		end;

	function quadmittel: TNumber;
		label _mraus;

		var x,y,q,anz: integer;
		    zelle    : PCell;

		begin
			dummy:=0.0;
			q:=knoten^.Count;
			anz:=0;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy:=dummy+sqr(EvalNode(cell,node));
									inc(anz)
								end
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy:=dummy+sqr(Evaluate(zelle));
															inc(anz);
															if fnerror<>FE_OK then goto _mraus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			if anz>0 then dummy:=sqrt(dummy/anz);
			quadmittel:=dummy
		end;

	function geomittel: TNumber;
		label _mraus;

		var x,y,q,anz: integer;
		    zelle    : PCell;

		begin
			dummy:=1.0;
			q:=knoten^.Count;
			anz:=0;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy:=dummy*EvalNode(cell,node);
									inc(anz)
								end
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy:=dummy*Evaluate(zelle);
															inc(anz);
															if fnerror<>FE_OK then goto _mraus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			if fnerror<>FE_OK then geomittel:=0.0
			else
				if anz>1 then
					begin
						dummy2:=1/anz;
						if dummy>0.0 then geomittel:=exp(dummy2*ln(dummy))
						else
							if dummy=0.0 then geomittel:=0.0
							else
								if frac(dummy2)<>0 then
									begin
										geomittel:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									if odd(round(dummy2)) then geomittel:=-exp(dummy2*ln(abs(dummy)))
									else
										geomittel:=exp(dummy2*ln(abs(dummy)))
					end
				else
					if anz=0 then geomittel:=0.0
					else
						geomittel:=dummy
		end;

	function varianz: TNumber;
		label _mraus;

		var x,y,q,anz: integer;
		    zelle    : PCell;

		begin
			dummy2:=mittelwert;
			dummy:=0.0;
			q:=knoten^.Count;
			anz:=0;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy:=dummy+sqr(dummy2-EvalNode(cell,node));
									inc(anz)
								end
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy:=dummy+sqr(dummy2-Evaluate(zelle));
															inc(anz);
															if fnerror<>FE_OK then goto _mraus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			if fnerror<>FE_OK then varianz:=0.0
			else
				if anz>1 then varianz:=dummy/(anz-1)
				else
					begin
						varianz:=0.0;
						fnerror:=FE_UNDEFINED;
						fnecell:=cell
					end
		end;

	function varianzn: TNumber;
		label _mraus;

		var x,y,q,anz: integer;
		    zelle    : PCell;

		begin
			dummy2:=mittelwert;
			dummy:=0.0;
			q:=knoten^.Count;
			anz:=0;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy:=dummy+sqr(dummy2-EvalNode(cell,node));
									inc(anz)
								end
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy:=dummy+sqr(dummy2-Evaluate(zelle));
															inc(anz);
															if fnerror<>FE_OK then goto _mraus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			if fnerror<>FE_OK then varianzn:=0.0
			else
				if anz>0 then varianzn:=dummy/anz
				else
					begin
						varianzn:=0.0;
						fnerror:=FE_UNDEFINED;
						fnecell:=cell
					end
		end;

	function mittelabw: TNumber;
		label _mraus;

		var x,y,q,anz: integer;
		    zelle    : PCell;

		begin
			dummy2:=mittelwert;
			dummy:=0.0;
			q:=knoten^.Count;
			anz:=0;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then
								begin
									dummy:=dummy+abs(EvalNode(cell,node)-dummy2);
									inc(anz)
								end
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy:=dummy+abs(Evaluate(zelle)-dummy2);
															inc(anz);
															if fnerror<>FE_OK then goto _mraus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			if fnerror<>FE_OK then mittelabw:=0.0
			else
				if anz>0 then mittelabw:=dummy/anz
				else
					begin
						mittelabw:=0.0;
						fnerror:=FE_UNDEFINED;
						fnecell:=cell
					end
		end;

	function sumquadabw: TNumber;
		label _mraus;

		var x,y,q: integer;
		    zelle: PCell;

		begin
			dummy2:=mittelwert;
			dummy:=0.0;
			q:=knoten^.Count;
			Cell2RC(cell,ar,ac);
			while (q>0) and (fnerror=FE_OK) do
				begin
					dec(q);
					node:=PNode(knoten^.Left.List^[q]);
					if node<>nil then
						begin
							if node^.Typ<>NT_RANGE then dummy:=dummy+sqr(EvalNode(cell,node)-dummy2)
							else
								begin
									if getrange(node) then goto _mraus;
									for y:=yvon to ybis do
										begin
											zelle:=GetCell(y,xvon);
											for x:=xvon to xbis do
												begin
													if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) then
														begin
															dummy:=dummy+sqr(Evaluate(zelle)-dummy2);
															if fnerror<>FE_OK then goto _mraus
														end;
													inc(longint(zelle),CELLSIZE)
												end
										end
								end
						end
				end;
			_mraus:
			sumquadabw:=dummy
		end;

	function istleer: TNumber;
		var x,y  : integer;
		    zelle: PCell;

		begin
			istleer:=0.0;
			node:=knoten^.Left.Node;
			if node=nil then exit;
			if node^.Typ=NT_CELL then
				begin
					getrc(node^.Right.Flg,node^.RowRef,node^.ColRef);
					if (ar>=0) and (ar<=Parms.Rows) and (ac>=0) and (ac<=Parms.Columns) then
						begin
							zelle:=GetCell(ar,ac);
							if zelle^.Data.Value<>0 then exit
						end
					else
						begin
							fnerror:=FE_CELLOUTOFRANGE;
							fnecell:=cell
						end
				end
			else
				begin
					Cell2RC(cell,ar,ac);
					if getrange(node) then exit;
					for y:=yvon to ybis do
						begin
							zelle:=GetCell(y,xvon);
							for x:=xvon to xbis do
								begin
									if zelle^.Data.Value<>0 then exit;
									inc(longint(zelle),CELLSIZE)
								end
						end
				end;
			istleer:=1.0
		end;

	function isttext: TNumber;
		var x,y  : integer;
		    zelle: PCell;

		begin
			isttext:=0.0;
			node:=knoten^.Left.Node;
			if node=nil then exit;
			if node^.Typ=NT_CELL then
				begin
					getrc(node^.Right.Flg,node^.RowRef,node^.ColRef);
					if (ar>=0) and (ar<=Parms.Rows) and (ac>=0) and (ac<=Parms.Columns) then
						begin
							zelle:=GetCell(ar,ac);
							if zelle^.Typ<>CTYPE_TEXT then exit
						end
					else
						begin
							fnerror:=FE_CELLOUTOFRANGE;
							fnecell:=cell
						end
				end
			else
				begin
					Cell2RC(cell,ar,ac);
					if getrange(node) then exit;
					for y:=yvon to ybis do
						begin
							zelle:=GetCell(y,xvon);
							for x:=xvon to xbis do
								begin
									if zelle^.Typ<>CTYPE_TEXT then exit;
									inc(longint(zelle),CELLSIZE)
								end
						end
				end;
			isttext:=1.0
		end;

	function istzahl: TNumber;
		var x,y  : integer;
		    zelle: PCell;

		begin
			istzahl:=0.0;
			node:=knoten^.Left.Node;
			if node=nil then exit;
			if node^.Typ=NT_CELL then
				begin
					getrc(node^.Right.Flg,node^.RowRef,node^.ColRef);
					if (ar>=0) and (ar<=Parms.Rows) and (ac>=0) and (ac<=Parms.Columns) then
						begin
							zelle:=GetCell(ar,ac);
							if (zelle^.Typ<>CTYPE_CONST) and (zelle^.Typ<>CTYPE_FORMULA) then exit
						end
					else
						begin
							fnerror:=FE_CELLOUTOFRANGE;
							fnecell:=cell
						end
				end
			else
				begin
					Cell2RC(cell,ar,ac);
					if getrange(node) then exit;
					for y:=yvon to ybis do
						begin
							zelle:=GetCell(y,xvon);
							for x:=xvon to xbis do
								begin
									if (zelle^.Typ<>CTYPE_CONST) and (zelle^.Typ<>CTYPE_FORMULA) then exit;
									inc(longint(zelle),CELLSIZE)
								end
						end
				end;
			istzahl:=1.0
		end;

	function anzahl(cnttxt: boolean): TNumber;
		var x,y,c: integer;
		    zelle: PCell;

		begin
			anzahl:=0.0;
			node:=knoten^.Left.Node;
			if node=nil then exit;
			if node^.Typ=NT_CELL then
				begin
					getrc(node^.Right.Flg,node^.RowRef,node^.ColRef);
					if (ar>=0) and (ar<=Parms.Rows) and (ac>=0) and (ac<=Parms.Columns) then
						begin
							zelle:=GetCell(ar,ac);
							if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) or ((zelle^.Typ=CTYPE_TEXT) and cnttxt) then anzahl:=1.0
						end
					else
						begin
							fnerror:=FE_CELLOUTOFRANGE;
							fnecell:=cell
						end
				end
			else
				begin
					c:=0;
					Cell2RC(cell,ar,ac);
					if getrange(node) then exit;
					for y:=yvon to ybis do
						begin
							zelle:=GetCell(y,xvon);
							for x:=xvon to xbis do
								begin
									if (zelle^.Typ=CTYPE_CONST) or (zelle^.Typ=CTYPE_FORMULA) or ((zelle^.Typ=CTYPE_TEXT) and cnttxt) then inc(c);
									inc(longint(zelle),CELLSIZE)
								end
						end;
					anzahl:=c
				end
		end;

	function istfehler: TNumber;
		var x,y  : integer;
		    zelle: PCell;

		begin
			istfehler:=0.0;
			node:=knoten^.Left.Node;
			if node=nil then exit;
			if node^.Typ=NT_CELL then
				begin
					getrc(node^.Right.Flg,node^.RowRef,node^.ColRef);
					if (ar>=0) and (ar<=Parms.Rows) and (ac>=0) and (ac<=Parms.Columns) then
						begin
							zelle:=GetCell(ar,ac);
							if zelle^.Typ<>CTYPE_FORMULA then exit;
							if zelle^.Data.Formula^.Error=FE_OK then exit
						end
					else
						begin
							fnerror:=FE_CELLOUTOFRANGE;
							fnecell:=cell
						end;
					istfehler:=1.0
				end
			else
				begin
					Cell2RC(cell,ar,ac);
					if getrange(node) then exit;
					for y:=yvon to ybis do
						begin
							zelle:=GetCell(y,xvon);
							for x:=xvon to xbis do
								begin
									if zelle^.Typ=CTYPE_FORMULA then
										if zelle^.Data.Formula^.Error<>FE_OK then
											begin
												istfehler:=1.0;
												exit
											end;
									inc(longint(zelle),CELLSIZE)
								end
						end
				end
		end;

	function gda: TNumber;
		var dummy5,p: TNumber;
		    i       : integer;

		begin
			dummy:=EvalNode(cell,PNode(knoten^.Left.List^[0]));
			dummy2:=EvalNode(cell,PNode(knoten^.Left.List^[1]));
			dummy3:=EvalNode(cell,PNode(knoten^.Left.List^[2]));
			dummy4:=EvalNode(cell,PNode(knoten^.Left.List^[3]));
			if knoten^.Count<5 then dummy5:=12.0
			else
				dummy5:=EvalNode(cell,PNode(knoten^.Left.List^[4]));
			if fnerror<>FE_OK then gda:=0.0
			else
				if not(isint(dummy3)) or not(isint(dummy4)) or (dummy3<1.0) or (dummy<0.0) or (dummy<dummy2) or (dummy5<0.0) or (dummy5>12.0) then
					begin
						gda:=0.0;
						fnerror:=FE_UNDEFINED;
						fnecell:=cell
					end
				else
					if (dummy4<1.0) or (dummy4>dummy3+1.0) then gda:=0.0
					else
						begin
							p:=dummy2/dummy;
							if p>0.0 then p:=exp(ln(p)/dummy3);
							p:=round((1.0-p)*1000.0)/1000.0;
							i:=round(dummy4);
							dummy2:=dummy;
							if i>0 then
								begin
									dummy2:=dummy*p*dummy5/12.0;
									dummy:=dummy-dummy2;
									dec(i)
								end;
							while i>0 do
								begin
									dummy2:=dummy*p;
									dummy:=dummy-dummy2;
									dec(i)
								end;
							if dummy4>dummy3 then dummy2:=dummy2*(12.0-dummy5)/12.0;
							gda:=dummy2
						end
		end;

	function dda: TNumber;
		var dummy5: TNumber;
		    i     : integer;

		begin
			dummy:=EvalNode(cell,PNode(knoten^.Left.List^[0]));
			dummy2:=EvalNode(cell,PNode(knoten^.Left.List^[1]));
			dummy3:=EvalNode(cell,PNode(knoten^.Left.List^[2]));
			dummy4:=EvalNode(cell,PNode(knoten^.Left.List^[3]));
			if knoten^.Count<5 then dummy5:=2.0
			else
				dummy5:=EvalNode(cell,PNode(knoten^.Left.List^[4]));
			if fnerror<>FE_OK then dda:=0.0
			else
				if not(isint(dummy3)) or not(isint(dummy4)) or (dummy3<1.0) or (dummy<0.0) or (dummy<dummy2) then
					begin
						dda:=0.0;
						fnerror:=FE_UNDEFINED;
						fnecell:=cell
					end
				else
					if (dummy4<1.0) or (dummy4>dummy3) then dda:=0.0
					else
						begin
							i:=round(dummy4);
							while (i>0) and (dummy>dummy2) do
								begin
									dummy4:=dummy*dummy5/dummy3;
									dummy:=dummy-dummy4;
									dec(i)
								end;
							if dummy<dummy2 then dda:=dummy4+dummy-dummy2
							else
								dda:=dummy4
						end
		end;

	function getvar: TNumber;
		var varup: string;
		    w    : integer;

		begin
			getvar:=0.0;
			if Variables<>nil then
				if Variables^.Count>0 then
					begin
						varup:=StrPUpper(knoten^.Varb^);
						for w:=Variables^.Count-1 downto 0 do
							with PVariable(Variables^.At(w))^ do
								if varup=StrPUpper(Name^) then
									begin
										if (RefRow>=0) and (RefRow<=Parms.Rows) and (RefCol>=0) and (RefCol<=Parms.Columns) then getvar:=Evaluate(GetCell(RefRow,RefCol))
										else
											begin
												fnerror:=FE_CELLOUTOFRANGE;
												fnecell:=cell
											end;
										exit
									end
					end
		end;

	function ostern(j: longint): TNumber;
		var a,b,c,d,e  : longint;

		begin
			a:=j mod 19;
			b:=j mod 4;
			c:=j mod 7;
			d:=(19*a+24) mod 30;
			e:=2*b+4*c+6*d;
			if j<2100 then e:=(e+5) mod 7
			else
				e:=(e+6) mod 7;
			b:=22+d+e;
			c:=d+e-9;
			if b>31 then
				begin
					l1:=4;
					if c=26 then l2:=19
					else
						if c=25 then
							begin
								if (d=28) and (a>10) then l2:=18
								else
									l2:=c
							end
						else
							l2:=c
				end
			else
				begin
					l1:=3;
					l2:=b
				end;
			ostern:=Date(j,l1,l2)
		end;

	begin
		if fnerror<>FE_OK then EvalNode:=0.0
		else
			with knoten^ do
				begin
					case Typ of
					NT_CONST:
						EvalNode:=Num^;
					NT_CELL:
						begin
							getrc(Right.Flg,RowRef,ColRef);
							if (ar>=0) and (ar<=Parms.Rows) and (ac>=0) and (ac<=Parms.Columns) then EvalNode:=Evaluate(GetCell(ar,ac))
							else
								begin
									EvalNode:=0.0;
									fnerror:=FE_CELLOUTOFRANGE;
									fnecell:=cell
								end
						end;
					NT_VARIABLE:
						EvalNode:=getvar;
					NT_KLAMMER:
						EvalNode:=EvalNode(cell,Left.Node);
					NT_DEFINE:
						EvalNode:=EvalNode(cell,Left.Node);
					NT_EQUAL:
						if EvalNode(cell,Left.Node)=EvalNode(cell,Right.Node) then EvalNode:=1.0
						else
							EvalNode:=0.0;
					NT_GREATER:
						if EvalNode(cell,Left.Node)>EvalNode(cell,Right.Node) then EvalNode:=1.0
						else
							EvalNode:=0.0;
					NT_LESS:
						if EvalNode(cell,Left.Node)<EvalNode(cell,Right.Node) then EvalNode:=1.0
						else
							EvalNode:=0.0;
					NT_GREATEREQUAL:
						if EvalNode(cell,Left.Node)>=EvalNode(cell,Right.Node) then EvalNode:=1.0
						else
							EvalNode:=0.0;
					NT_LESSEQUAL:
						if EvalNode(cell,Left.Node)<=EvalNode(cell,Right.Node) then EvalNode:=1.0
						else
							EvalNode:=0.0;
					NT_UNEQUAL:
						if EvalNode(cell,Left.Node)<>EvalNode(cell,Right.Node) then EvalNode:=1.0
						else
							EvalNode:=0.0;
					NT_PLUS:
						EvalNode:=EvalNode(cell,Left.Node)+EvalNode(cell,Right.Node);
					NT_MINUS:
						EvalNode:=EvalNode(cell,Left.Node)-EvalNode(cell,Right.Node);
					NT_MULT:
						EvalNode:=EvalNode(cell,Left.Node)*EvalNode(cell,Right.Node);
					NT_DIV:
						begin
							dummy:=EvalNode(cell,Right.Node);
							dummy2:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_DIVBYZERO;
										fnecell:=cell
									end
								else
									EvalNode:=dummy2/dummy
						end;
					NT_POWER:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								begin
									dummy2:=EvalNode(cell,Right.Node);
									if fnerror<>FE_OK then EvalNode:=0.0
									else
										if (dummy<>0.0) or (dummy2<>0.0) then
											begin
												if dummy>0.0 then EvalNode:=exp(dummy2*ln(dummy))
												else
													if dummy=0.0 then EvalNode:=0.0
													else
														if frac(dummy2)<>0 then
															begin
																EvalNode:=0.0;
																fnerror:=FE_UNDEFINED;
																fnecell:=cell
															end
														else
															if odd(round(dummy2)) then EvalNode:=-exp(dummy2*ln(abs(dummy)))
															else
																EvalNode:=exp(dummy2*ln(abs(dummy)))
											end
										else
											begin
												EvalNode:=0.0;
												fnerror:=FE_UNDEFINED;
												fnecell:=cell
											end
								end
						end;
					NT_SUMME:
						EvalNode:=summe;
					NT_PRODUKT:
						EvalNode:=produkt;
					NT_MIN:
						EvalNode:=minimum;
					NT_MAX:
						EvalNode:=maximum;
					NT_UND:
						EvalNode:=und;
					NT_ODER:
						EvalNode:=oder;
					NT_VARIANZ:
						EvalNode:=varianz;
					NT_VARIANZN:
						EvalNode:=varianzn;
					NT_STDABW:
						EvalNode:=sqrt(varianz);
					NT_STDABWN:
						EvalNode:=sqrt(varianzn);
					NT_MITTELABW:
						EvalNode:=mittelabw;
					NT_SUMQUADABW:
						EvalNode:=sumquadabw;
					NT_MITTEL:
						EvalNode:=mittelwert;
					NT_HARMITTEL:
						EvalNode:=harmittel;
					NT_QUADMITTEL:
						EvalNode:=quadmittel;
					NT_GEOMITTEL:
						EvalNode:=geomittel;
					NT_MEDIAN:
						begin
							getandsortarray(false);
							EvalNode:=quantil(0.5);
							freearray
						end;
					NT_QUANTIL:
						begin
							dummy:=getandsortarray(true);
							EvalNode:=quantil(dummy);
							freearray
						end;
					NT_QUARTILUNTEN:
						begin
							getandsortarray(false);
							EvalNode:=quantil(0.25);
							freearray
						end;
					NT_QUARTILOBEN:
						begin
							getandsortarray(false);
							EvalNode:=quantil(0.75);
							freearray
						end;
					NT_QUARTILSABST:
						begin
							getandsortarray(false);
							EvalNode:=quantil(0.75)-quantil(0.25);
							freearray
						end;
					NT_SPANNWEITE:
						begin
							getandsortarray(false);
							if marray<>nil then EvalNode:=marray^[manz-1]-marray^[0]
							else
								EvalNode:=0.0;
							freearray
						end;
					NT_NEGATE:
						EvalNode:=-EvalNode(cell,Left.Node);
					NT_RND:
						EvalNode:=system.random;
					NT_FEHLER:
						begin
							EvalNode:=0.0;
							fnerror:=FE_ERROR;
							fnecell:=cell
						end;
					NT_SIN:
						EvalNode:=sin(EvalNode(cell,Left.Node));
					NT_COS:
						EvalNode:=cos(EvalNode(cell,Left.Node));
					NT_ARCTAN:
						EvalNode:=arctan(EvalNode(cell,Left.Node));
					NT_ARCTAN2:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								begin
									dummy2:=EvalNode(cell,Right.Node);
									if fnerror<>FE_OK then EvalNode:=0.0
									else
										if (dummy=0.0) then
											begin
												if dummy2=0.0 then
													begin
														EvalNode:=0.0;
														fnerror:=FE_UNDEFINED;
														fnecell:=cell
													end
												else
													begin
														if dummy2<0.0 then EvalNode:=-ev_pihalbe
														else
															EvalNode:=ev_pihalbe
													end
											end
										else
											if dummy>0.0 then EvalNode:=arctan(dummy2/dummy)
											else
												if dummy2>=0.0 then EvalNode:=arctan(dummy2/dummy)+pi
												else
													EvalNode:=arctan(-dummy/dummy2)-ev_pihalbe
								end
						end;
					NT_ARCCOT:
						EvalNode:=ev_pihalbe-arctan(EvalNode(cell,Left.Node));
					NT_ARCSIN:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if abs(dummy)>1.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=arcsin(dummy)
						end;
					NT_ARCCOS:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if abs(dummy)>1.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=ev_pihalbe-arcsin(dummy)
						end;
					NT_TAN:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if cos(dummy)=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=sin(dummy)/cos(dummy)
						end;
					NT_COT:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if sin(dummy)=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=cos(dummy)/sin(dummy)
						end;
					NT_ABS:
						EvalNode:=abs(EvalNode(cell,Left.Node));
					NT_FRAC:
						EvalNode:=frac(EvalNode(cell,Left.Node));
					NT_INT:
						EvalNode:=int(EvalNode(cell,Left.Node));
					NT_ROUND:
						EvalNode:=round(EvalNode(cell,Left.Node));
					NT_TRUNC:
						EvalNode:=trunc(EvalNode(cell,Left.Node));
					NT_GERADE:
						begin
							dummy:=abs(EvalNode(cell,Left.Node));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy)) then EvalNode:=0.0
								else
									if odd(trunc(dummy)) then EvalNode:=0.0
									else
										EvalNode:=1.0
						end;
					NT_UNGERADE:
						begin
							dummy:=abs(EvalNode(cell,Left.Node));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy)) then EvalNode:=0.0
								else
									if odd(trunc(dummy)) then EvalNode:=1.0
									else
										EvalNode:=0.0
						end;
					NT_EXP:
						EvalNode:=exp(EvalNode(cell,Left.Node));
					NT_SQR:
						EvalNode:=sqr(EvalNode(cell,Left.Node));
					NT_SQRT:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy<0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=sqrt(dummy)
						end;
					NT_LN:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy<=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=ln(dummy)
						end;
					NT_LOG10:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy<=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=ln(dummy)/ev_ln10
						end;
					NT_LD:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy<=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=ln(dummy)/ev_ln2
						end;
					NT_SINH:
						begin
							dummy:=EvalNode(cell,Left.Node);
							EvalNode:=(exp(dummy)-exp(-dummy))/2
						end;
					NT_COSH:
						begin
							dummy:=EvalNode(cell,Left.Node);
							EvalNode:=(exp(dummy)+exp(-dummy))/2
						end;
					NT_TANH:
						begin
							dummy:=EvalNode(cell,Left.Node);
							EvalNode:=(exp(dummy)-exp(-dummy))/(exp(dummy)+exp(-dummy))
						end;
					NT_COTH:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=(exp(dummy)+exp(-dummy))/(exp(dummy)-exp(-dummy))
						end;
					NT_ARTANH:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if abs(dummy)>=1.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=ln((1+dummy)/(1-dummy))/2
						end;
					NT_ARCOTH:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if abs(dummy)<=1.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=ln((dummy+1)/(dummy-1))/2
						end;
					NT_ARCOSH:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if abs(dummy)<1.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=ln(dummy+sqrt(sqr(dummy)-1))
						end;
					NT_ARSINH:
						begin
							dummy:=EvalNode(cell,Left.Node);
							EvalNode:=ln(dummy+sqrt(sqr(dummy)+1))
						end;
					NT_LOG:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if Right.Node=nil then dummy2:=10.0
							else
								dummy2:=EvalNode(cell,Right.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if (dummy<=0.0) or (dummy2<=0.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=ln(dummy)/ln(dummy2)
						end;
					NT_GRAD:
						EvalNode:=EvalNode(cell,Left.Node)*ev_rad2grad;
					NT_RAD:
						EvalNode:=EvalNode(cell,Left.Node)*ev_grad2rad;
					NT_SCRIPTNO:
						EvalNode:=scriptno(cell^.Data.Formula^.Value,0);
					NT_BALMER:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy)) or (dummy<3.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=3.288e15*(0.25-1/sqr(dummy))
						end;
					NT_STUNDE:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								EvalNode:=Num2Hour(dummy)
						end;
					NT_STUNDEN:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								EvalNode:=Num2Hour(dummy)+24*trunc(dummy)
						end;
					NT_MINUTE:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								EvalNode:=Num2Minute(dummy)
						end;
					NT_SEKUNDE:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								EvalNode:=Num2Second(dummy)
						end;
					NT_JAHR:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								EvalNode:=Num2Year(dummy)
						end;
					NT_MONAT:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								EvalNode:=Num2Month(dummy)
						end;
					NT_TAG:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								EvalNode:=Num2Day(dummy)
						end;
					NT_DATUM:
						begin
							dummy:=EvalNode(cell,PNode(knoten^.Left.List^[0]));
							dummy2:=EvalNode(cell,PNode(knoten^.Left.List^[1]));
							dummy3:=EvalNode(cell,PNode(knoten^.Left.List^[2]));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								begin
									if (dummy>=80.0) and (dummy<=99.0) then dummy:=dummy+1900.0
									else
										if (dummy>=0) and (dummy<=79.0) then dummy:=dummy+2000.0;
									if not(isint(dummy)) or not(isint(dummy2)) or not(isint(dummy3))
									   or (dummy<1900.0) or (dummy>2199.0) or (dummy2<1.0) or (dummy2>12.0) or (dummy3<1.0) or (dummy3>31.0) then
										begin
											EvalNode:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell
										end
									else
										EvalNode:=Date(trunc(dummy),trunc(dummy2),trunc(dummy3))
								end
						end;
					NT_HEUTE:
						EvalNode:=Today;
					NT_JETZT:
						EvalNode:=Now;
					NT_STD1:
						EvalNode:=std1;
					NT_MIN1:
						EvalNode:=min1;
					NT_SEK1:
						EvalNode:=sek1;
					NT_ZEIT:
						begin
							dummy:=EvalNode(cell,PNode(knoten^.Left.List^[0]));
							dummy2:=EvalNode(cell,PNode(knoten^.Left.List^[1]));
							dummy3:=EvalNode(cell,PNode(knoten^.Left.List^[2]));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy)) or not(isint(dummy2)) or not(isint(dummy3))
								   or (dummy<0.0) or (dummy>23.0) or (dummy2<0.0) or (dummy2>59.0) or (dummy3<0.0) or (dummy3>59.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=Time(trunc(dummy),trunc(dummy2),trunc(dummy3))
						end;
					NT_WOCHENTAG:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if Right.Node=nil then dummy2:=1.0
							else
								dummy2:=EvalNode(cell,Right.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy2)) or (dummy2<1.0) or (dummy2>3.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=Weekday(dummy,trunc(dummy2))
						end;
					NT_TAGE:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								begin
									if (dummy>=80.0) and (dummy<=99.0) then dummy:=dummy+1900.0
									else
										if (dummy>=0) and (dummy<=79.0) then dummy:=dummy+2000.0;
									if not(isint(dummy)) or (dummy<1900.0) or (dummy>2199.0) then
										begin
											EvalNode:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell
										end
									else
										EvalNode:=Days(trunc(dummy))
								end
						end;
					NT_SCHALTJAHR:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								begin
									if (dummy>=80.0) and (dummy<=99.0) then dummy:=dummy+1900.0
									else
										if (dummy>=0) and (dummy<=79.0) then dummy:=dummy+2000.0;
									if not(isint(dummy)) or (dummy<1900.0) or (dummy>2199.0) then
										begin
											EvalNode:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell
										end
									else
										if Days(trunc(dummy))=366 then EvalNode:=1.0
										else
											EvalNode:=0.0
								end
						end;
					NT_OSTERN:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								begin
									if (dummy>=80.0) and (dummy<=99.0) then dummy:=dummy+1900.0
									else
										if (dummy>=0) and (dummy<=79.0) then dummy:=dummy+2000.0;
									if not(isint(dummy)) or (dummy<1900.0) or (dummy>2199.0) then
										begin
											EvalNode:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell
										end
									else
										EvalNode:=ostern(trunc(dummy))
								end
						end;
					NT_FAK:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy)) or (dummy<0.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									if (dummy>1748.0) then
										begin
											EvalNode:=0.0;
											fnerror:=FE_OVERFLOW;
											fnecell:=cell
										end
									else
										begin
											l1:=trunc(dummy);
											dummy:=1.0;
											while l1>1 do
												begin
													dummy:=int(dummy)*l1;
													dec(l1)
												end;
											EvalNode:=dummy
										end
						end;
					NT_SGN:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if dummy<0.0 then EvalNode:=-1.0
							else
								if dummy>0.0 then EvalNode:=1.0
								else
									EvalNode:=0.0
						end;
					NT_STDNORMVERT:
						EvalNode:=ev_normalfaktor*exp(-sqr(EvalNode(cell,Left.Node))/2.0);
					NT_NORMVERT:
						begin
							dummy2:=EvalNode(cell,PNode(Left.List^[1]));
							dummy3:=EvalNode(cell,PNode(Left.List^[2]));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy3<=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=ev_normalfaktor*exp(-sqr(EvalNode(cell,PNode(Left.List^[0]))-dummy2)/(2.0*dummy3))/sqrt(dummy3)
						end;
					NT_EXPVERT:
						begin
							dummy:=EvalNode(cell,Left.Node);
							dummy2:=EvalNode(cell,Right.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if (dummy<=0.0) or (dummy2<=0.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=dummy2*exp(-dummy2*dummy)
						end;
					NT_WENN:
						begin
							if EvalNode(cell,PNode(Left.List^[0]))=1.0 then
								begin
									if Count<2 then EvalNode:=1.0
									else
										EvalNode:=EvalNode(cell,PNode(Left.List^[1]))
								end
							else
								begin
									if Count<3 then EvalNode:=0.0
									else
										EvalNode:=EvalNode(cell,PNode(Left.List^[2]))
								end
						end;
					NT_WAHL:
						begin
							dummy:=EvalNode(cell,PNode(Left.List^[0]));
							if not(isint(dummy)) then
								begin
									EvalNode:=0.0;
									fnerror:=FE_UNDEFINED;
									fnecell:=cell
								end
							else
								begin
									l1:=trunc(dummy);
									if (l1>0) and (l1<Count) then EvalNode:=EvalNode(cell,PNode(Left.List^[l1]))
									else
										begin
											EvalNode:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell
										end
								end
						end;
					NT_GLEICHVERT:
						begin
							dummy2:=EvalNode(cell,PNode(Left.List^[1]));
							dummy3:=EvalNode(cell,PNode(Left.List^[2]));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy2=dummy3 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									begin
										if dummy2>dummy3 then
											begin
												dummy:=dummy2;
												dummy2:=dummy3;
												dummy3:=dummy
											end;
										dummy:=EvalNode(cell,PNode(Left.List^[0]));
										if (dummy>dummy2) and (dummy<dummy3) then EvalNode:=1/(dummy3-dummy2)
										else
											EvalNode:=0.0
									end
						end;
					NT_INTDIV:
						begin
							dummy:=EvalNode(cell,Left.Node);
							dummy2:=EvalNode(cell,Right.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy2=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_DIVBYZERO;
										fnecell:=cell
									end
								else
									if not(isint(dummy)) or not(isint(dummy2)) then
										begin
											EvalNode:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell
										end
									else
										EvalNode:=trunc(dummy) div trunc(dummy2)
						end;
					NT_MOD:
						begin
							dummy:=EvalNode(cell,Left.Node);
							dummy2:=EvalNode(cell,Right.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy2=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_DIVBYZERO;
										fnecell:=cell
									end
								else
									if not(isint(dummy)) or not(isint(dummy2)) then
										begin
											EvalNode:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell
										end
									else
										EvalNode:=trunc(dummy) mod trunc(dummy2)
						end;
					NT_ROOT:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if Right.Node=nil then dummy2:=2.0
							else
								dummy2:=EvalNode(cell,Right.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy2=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									begin
										dummy2:=1/dummy2;
										if dummy>0.0 then EvalNode:=exp(dummy2*ln(dummy))
										else
											if dummy=0.0 then EvalNode:=0.0
											else
												if frac(dummy2)<>0 then
													begin
														EvalNode:=0.0;
														fnerror:=FE_UNDEFINED;
														fnecell:=cell
													end
												else
													if dummy2=1.0 then EvalNode:=dummy
													else
														EvalNode:=1/dummy
									end
						end;
					NT_RANDOM:
						begin
							dummy:=EvalNode(cell,Left.Node);
							dummy2:=EvalNode(cell,Right.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy)) or (dummy<0) or not(isint(dummy2)) or (dummy2<0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									begin
										l1:=Min(round(dummy),round(dummy2));
										l2:=Max(round(dummy),round(dummy2));
										EvalNode:=system.random(l2+1-l1)+l1
									end
						end;
					NT_SEC:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if cos(dummy)=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=1.0/cos(dummy)
						end;
					NT_COSEC:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if sin(dummy)=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=1.0/sin(dummy)
						end;
					NT_ISTZAHL:
						EvalNode:=istzahl;
					NT_ISTTEXT:
						EvalNode:=isttext;
					NT_ISTLEER:
						EvalNode:=istleer;
					NT_ISTFEHLER:
						EvalNode:=istfehler;
					NT_ANZAHL:
						EvalNode:=anzahl(false);
					NT_ANZAHL2:
						EvalNode:=anzahl(true);
					NT_SPALTEN:
						if knoten^.Left.Node^.Typ=NT_CELL then EvalNode:=1.0
						else
							begin
								Cell2RC(cell,ar,ac);
								if not(getrange(knoten^.Left.Node)) then EvalNode:=xbis+1.0-xvon
							end;
					NT_ZEILEN:
						if knoten^.Left.Node^.Typ=NT_CELL then EvalNode:=1.0
						else
							begin
								Cell2RC(cell,ar,ac);
								if not(getrange(knoten^.Left.Node)) then EvalNode:=ybis+1.0-yvon
							end;
					NT_MDET:
						if knoten^.Left.Node^.Typ=NT_CELL then EvalNode:=EvalNode(cell,knoten^.Left.Node)
						else
							begin
								Cell2RC(cell,ar,ac);
								if getrange(knoten^.Left.Node) then EvalNode:=0.0
								else
									if (ybis-yvon)<>(xbis-xvon) then
										begin
											EvalNode:=0.0;
											fnerror:=FE_UNDEFINED;
											fnecell:=cell
										end
									else
										begin
											getmem(pna,(ybis+1-yvon) shl 1);
											if pna<>nil then
												for l1:=xvon to xbis do pna^[l1-xvon]:=l1;
											EvalNode:=mdet(yvon,ybis-yvon,pna)
										end
							end;
					NT_LIA:
						begin
							dummy:=EvalNode(cell,PNode(knoten^.Left.List^[0]));
							dummy2:=EvalNode(cell,PNode(knoten^.Left.List^[1]));
							dummy3:=EvalNode(cell,PNode(knoten^.Left.List^[2]));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy3)) or (dummy3<1.0) or (dummy<0.0) or (dummy<dummy2) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=(dummy-dummy2)/dummy3
						end;
					NT_DIGA:
						begin
							dummy:=EvalNode(cell,PNode(knoten^.Left.List^[0]));
							dummy3:=EvalNode(cell,PNode(knoten^.Left.List^[1]));
							dummy4:=EvalNode(cell,PNode(knoten^.Left.List^[2]));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy3)) or not(isint(dummy4)) or (dummy3<1.0) or (dummy<0.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									if (dummy4<1.0) or (dummy4>dummy3) then EvalNode:=0.0
									else
										EvalNode:=(dummy3+1.0-dummy4)*2.0*dummy/(dummy3*(dummy3+1.0))
						end;
					NT_ADA:
						begin
							dummy:=EvalNode(cell,PNode(knoten^.Left.List^[0]));
							dummy2:=EvalNode(cell,PNode(knoten^.Left.List^[1]));
							dummy3:=EvalNode(cell,PNode(knoten^.Left.List^[2]));
							dummy4:=EvalNode(cell,PNode(knoten^.Left.List^[3]));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy3)) or not(isint(dummy4)) or (dummy3<1.0) or (dummy<0.0) or (dummy<dummy2) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									if (dummy4<1.0) or (dummy4>dummy3) then EvalNode:=0.0
									else
										EvalNode:=(dummy3+1.0-dummy4)*2.0*(dummy-dummy2)/(dummy3*(dummy3+1.0))
						end;
					NT_GDA:
						EvalNode:=gda;
					NT_DDA:
						EvalNode:=dda;
					NT_RMZ:
						begin
							dummy:=EvalNode(cell,PNode(knoten^.Left.List^[0]));
							dummy2:=EvalNode(cell,PNode(knoten^.Left.List^[1]));
							dummy3:=EvalNode(cell,PNode(knoten^.Left.List^[2]));
							if knoten^.Count<4 then dummy4:=0
							else
								dummy4:=-EvalNode(cell,PNode(knoten^.Left.List^[3]));
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if (dummy<=0.0) or not(isint(dummy2)) or (dummy2<1.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									begin
										dummy2:=1.0/exp(dummy2*ln(dummy+1.0));
										EvalNode:=(dummy4*dummy2-dummy3)*dummy/(1-dummy2)
									end
						end;
					NT_BUND:
						EvalNode:=bund;
					NT_BODER:
						EvalNode:=boder;
					NT_BEOR:
						EvalNode:=beor;
					NT_BSCHIEBR:
						begin
							dummy:=EvalNode(cell,Left.Node);
							dummy2:=EvalNode(cell,Right.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy)) or not(isint(dummy2)) or (dummy2<0.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=trunc(dummy) shr trunc(dummy2)
						end;
					NT_BSCHIEBL:
						begin
							dummy:=EvalNode(cell,Left.Node);
							dummy2:=EvalNode(cell,Right.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy)) or not(isint(dummy2)) or (dummy2<0.0) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=trunc(dummy) shl trunc(dummy2)
						end;
					NT_BNICHT:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if not(isint(dummy)) then
									begin
										EvalNode:=0.0;
										fnerror:=FE_UNDEFINED;
										fnecell:=cell
									end
								else
									EvalNode:=not(trunc(dummy))
						end;
					NT_KEHRWERT:
						begin
							dummy:=EvalNode(cell,Left.Node);
							if fnerror<>FE_OK then EvalNode:=0.0
							else
								if dummy=0.0 then
									begin
										EvalNode:=0.0;
										fnerror:=FE_DIVBYZERO;
										fnecell:=cell
									end
								else
									EvalNode:=1/dummy
						end;
					NT_NICHT:
						if EvalNode(cell,Left.Node)=0.0 then EvalNode:=1.0
						else
							EvalNode:=0.0;
					else
						begin
							if (Typ>=NT_EXTMIN) and (Typ<=NT_EXTMAX) then
								EvalNode:=scriptno(cell^.Data.Formula^.Value,Typ)
							else
								begin
									EvalNode:=0.0;
									fnerror:=FE_OPUNKNOWN;
									fneOp:=Typ;
									fnecell:=cell
								end
						end
					end
				end
	end;


function TCalcWindow.Evaluate(cell: PCell): TNumber;
	var oldval: TNumber;
	    r,c   : integer;

	begin
		if fnerror<>FE_OK then Evaluate:=0.0
		else
			begin
				if bTst(cell^.Flags,CELL_USED) then
					begin
						Evaluate:=0.0;
						fnerror:=FE_CIRCREF;
						fnecell:=cell
					end
				else
					begin
						cell^.Flags:=cell^.Flags or CELL_USED;
						case cell^.Typ of
						CTYPE_FORMULA:
							begin
								if bTst(cell^.Flags,CELL_CALCULATED) then
									begin
										if cell^.Data.Formula^.Error<>FE_OK then
											begin
												Evaluate:=0.0;
												fnerror:=FE_UNDEFINED;
												fnecell:=cell
											end
										else
											Evaluate:=cell^.Data.Formula^.Value
									end
								else
									begin
										oldval:=cell^.Data.Formula^.Value;
										cell^.Data.Formula^.Value:=EvalNode(cell,cell^.Data.Formula^.Func);
										cell^.Flags:=cell^.Flags or CELL_CALCULATED;
										if fnerror=FE_OK then
											begin
												Evaluate:=cell^.Data.Formula^.Value;
												if (cell^.Data.Formula^.Value<>oldval) or (cell^.Data.Formula^.Error<>FE_OK) then
													begin
														cell^.Data.Formula^.Error:=FE_OK;
														Cell2RC(cell,r,c);
														DrawCells(r,c,r,c)
													end
												else
													cell^.Data.Formula^.Error:=FE_OK
											end
										else
											begin
												Evaluate:=0.0;
												cell^.Data.Formula^.Value:=0.0;
												if fnerror<>cell^.Data.Formula^.Error then
													begin
														cell^.Data.Formula^.Error:=shortint(fnerror);
														Cell2RC(cell,r,c);
														DrawCells(r,c,r,c)
													end
												else
													cell^.Data.Formula^.Error:=shortint(fnerror)
											end
									end
							end;
						CTYPE_CONST:
							Evaluate:=cell^.Data.Konst^.Value
						else
							Evaluate:=0.0
						end;
						cell^.Flags:=cell^.Flags and not(CELL_USED)
					end
			end
	end;


function TCalcWindow.GetCellValue(cell: PCell; clr: boolean): TNumber;

	begin
		fnerror:=FE_OK;
		fnecell:=nil;
		if clr then ClearCalcFlags;
		GetCellValue:=Evaluate(cell);
		if fnerror<>FE_OK then
			begin
				if fnecell=nil then fnecell:=cell;
				GetCellValue:=0.0
			end
	end;


function TCalcWindow.Error2Txt(err: shortint): string;

	begin
		case err of
		FE_DIVBYZERO:
			Error2Txt:='#DIV/0';
		FE_UNDEFINED:
			Error2Txt:='#UNDEF';
		FE_CIRCREF:
			Error2Txt:='#CIRCREF';
		FE_CELLOUTOFRANGE:
			Error2Txt:='#CELLRANGE';
		FE_OPUNKNOWN:
			Error2Txt:='#OPCODE?';
		FE_ERROR:
			Error2Txt:='#'+STRING_ERR_ERROR;
		FE_OVERFLOW:
			Error2Txt:='#'+STRING_ERR_OVERFLOW;
		FE_EXTERN:
			Error2Txt:='#EXTERN?';
		FE_OK:
			Error2Txt:='#OK!'
		else
			Error2Txt:='#???'
		end
	end;


procedure TCalcWindow.ChangeCell(cell: PCell; intxt: string; r,c: integer; chgval: boolean);
	label _weiter;

	var vrnd,cclr: boolean;
	    oldfpts  : byte;
	    cmin,cmax,
	    oldctyp,q: integer;
	    vars,otxt: string;
	    pc       : PConst;
	    pf       : PFormula;
	    pn       : PNode;
	    fres     : TNumber;

	function IsDate(const s: string; var sz: TNumber; var ret: string; var frm: integer): boolean;
		var l,t,m,j,p1,p2: integer;

		begin
			IsDate:=false;
			ret:=StrPTrimF(s);
			l:=length(ret);
			if (l<6) or (l>10) then exit;
			p1:=pos('.',ret);
			if (p1<2) or (p1>3) then exit;
			p2:=RPos('.',ret);
			if (p2<>l-2) and (p2<>l-4) then exit;
			t:=p2-p1;
			if (t<2) or (t>3) then exit;
			if not(TexelApp.IsInteger(StrPLeft(ret,p1-1))) then exit;
			if not(TexelApp.IsInteger(StrPMid(ret,p1+1,t-1))) then exit;
			if not(TexelApp.IsInteger(StrPRight(ret,l-p2))) then exit;
			m:=atol(StrPMid(ret,p1+1,t-1));
			if (m<1) or (m>12) then exit;
			t:=atol(StrPLeft(ret,p1-1));
			if (t<1) or (t>31) then exit;
			j:=atol(StrPRight(ret,l-p2));
			if (j>=80) and (j<=99) then inc(j,1900)
			else
				if (j>=0) and (j<=79) then inc(j,2000);
			if (j<1900) or (j>2199) then exit;
			sz:=Date(j,m,t);
			if p2=l-4 then frm:=TexelApp.FormStart[3]
			else
				frm:=TexelApp.FormStart[3]+1;
			IsDate:=true
		end;

	function IsTime(const s: string; var sz: TNumber; var ret: string; var frm: integer): boolean;
		var l,h,m,sec: integer;

		begin
			IsTime:=false;
			ret:=StrPTrimF(s);
			l:=length(ret);
			if (l=4) or (l=7) then
				begin
					if ret[2]<>':' then exit;
					if l=7 then
						begin
							if ret[5]<>':' then exit;
							if not(TexelApp.IsInteger(StrPRight(ret,2))) then exit;
							sec:=atol(StrPRight(ret,2));
							frm:=20
						end
					else
						begin
							sec:=0;
							frm:=19
						end;
					if (sec<0) or (sec>59) then exit;
					if not(TexelApp.IsInteger(StrPLeft(ret,1))) then exit;
					if not(TexelApp.IsInteger(StrPMid(ret,3,2))) then exit;
					h:=atol(StrPLeft(ret,1));
					if (h<0) or (h>23) then exit;
					m:=atol(StrPMid(ret,3,2))
				end
			else
				if (l=5) or (l=8) then
					begin
						if ret[3]<>':' then exit;
						if l=8 then
							begin
								if ret[6]<>':' then exit;
								if not(TexelApp.IsInteger(StrPRight(ret,2))) then exit;
								sec:=atol(StrPRight(ret,2));
								frm:=20
							end
						else
							begin
								sec:=0;
								frm:=19
							end;
						if (sec<0) or (sec>59) then exit;
						if not(TexelApp.IsInteger(StrPLeft(ret,2))) then exit;
						if not(TexelApp.IsInteger(StrPMid(ret,4,2))) then exit;
						h:=atol(StrPLeft(ret,2));
						if (h<0) or (h>23) then exit;
						m:=atol(StrPMid(ret,4,2))
					end
				else
					exit;
			if (m<0) or (m>59) then exit;
			sz:=Time(h,m,sec);
			IsTime:=true
		end;

	begin
		cclr:=true;
		cmin:=c;
		cmax:=c;
		RowsClearOverflow(r,r,cmin,cmax);
		oldctyp:=cell^.Typ;
		case oldctyp of
		CTYPE_CONST:
			oldfpts:=cell^.Data.Konst^.FPts;
		CTYPE_FORMULA:
			oldfpts:=cell^.Data.Formula^.FPts
		else
			begin
				oldfpts:=atol(TexelApp.setupbuffer.floatpoint);
				if oldctyp<>CTYPE_TEXT then chgval:=true
			end
		end;
		vrnd:=FreeCell(cell,false);
		if cell^.Data.Value=0 then
			if length(intxt)>0 then
				begin
					if Parse(intxt,vars,pn,cell,0,0,true) then
						begin
							new(pf);
							if pf<>nil then
								begin
									pf^.Func:=pn;
									pf^.VarDef:=NewStr(vars);
									if chgval then
										with cell^.TxtVal do
											begin
												Font:=GetFontIndex;
												Size:=GetFontSize;
												if (oldctyp<>CTYPE_CONST) and (oldctyp<>CTYPE_FORMULA) then Align:=(Align and $f0) or TA_RIGHT;
												Flags:=0
											end;
									cell^.Data.Formula:=pf;
									cell^.Typ:=CTYPE_FORMULA;
									pf^.FPts:=oldfpts;
									pf^.Error:=FE_OK;
									GetCellValue(cell,true);
									vrnd:=true;
									cclr:=false
								end
						end
					else
						if TexelApp.IsNumber(intxt,fres,otxt,true,'.') then
							begin
								new(pc);
								if pc<>nil then
									begin
										pc^.Value:=fres;
										pc^.FPts:=oldfpts;
										pc^.Txt:=NewStr(otxt);
										if chgval then
											with cell^.TxtVal do
												begin
													Font:=GetFontIndex;
													Size:=GetFontSize;
													if (oldctyp<>CTYPE_CONST) and (oldctyp<>CTYPE_FORMULA) then Align:=(Align and $f0) or TA_RIGHT;
													Flags:=0
												end;
										cell^.Data.Konst:=pc;
										cell^.Typ:=CTYPE_CONST;
										vrnd:=true
									end
							end
						else
							if IsDate(intxt,fres,otxt,q) then
								begin
									new(pc);
									if pc<>nil then
										begin
											pc^.Value:=fres;
											pc^.FPts:=oldfpts;
											pc^.Txt:=NewStr(otxt);
											if chgval then
												with cell^.TxtVal do
													begin
														Font:=GetFontIndex;
														Size:=GetFontSize;
														Flags:=0
													end;
											cell^.Format:=q;
											cell^.Data.Konst:=pc;
											cell^.Typ:=CTYPE_CONST;
											vrnd:=true
										end
								end
							else
								if IsTime(intxt,fres,otxt,q) then
									begin
										new(pc);
										if pc<>nil then
											begin
												pc^.Value:=fres;
												pc^.FPts:=oldfpts;
												pc^.Txt:=NewStr(otxt);
												if chgval then
													with cell^.TxtVal do
														begin
															Font:=GetFontIndex;
															Size:=GetFontSize;
															Flags:=0
														end;
												cell^.Format:=q;
												cell^.Data.Konst:=pc;
												cell^.Typ:=CTYPE_CONST;
												vrnd:=true
											end
									end
								else
									begin
										if chgval then
											with cell^.TxtVal do
												begin
													case intxt[1] of
													'''':
														begin
															Align:=(Align and $f0) or TA_LEFT;
															intxt:=StrPRight(intxt,length(intxt)-1);
															if length(intxt)=0 then goto _weiter
														end;
													'^':
														begin
															Align:=(Align and $f0) or TA_CENTER;
															intxt:=StrPRight(intxt,length(intxt)-1);
															if length(intxt)=0 then goto _weiter
														end;
													'"':
														begin
															Align:=(Align and $f0) or TA_RIGHT;
															intxt:=StrPRight(intxt,length(intxt)-1);
															if length(intxt)=0 then goto _weiter
														end
													end;
													Font:=GetFontIndex;
													Size:=GetFontSize;
													Flags:=0
												end;
										cell^.Data.Txt:=NewStr(intxt);
										cell^.Typ:=CTYPE_TEXT;
										_weiter:
										vrnd:=true
									end
				end;
		if inpcancel<>nil then inpcancel^.Hide(true);
		if inpok<>nil then inpok^.Hide(true);
		inpline^.Disable;
		RowsCheckOverflow(r,r,cmin,cmax);
		DrawCells(r,cmin,r,cmax);
		if vrnd then
			begin
				SetDirty;
				AutoCalculate(cclr)
			end
	end;


procedure TCalcWindow.CheckToolbarTextFX(cell: PCell);

	begin
		with cell^ do
			begin
				if pfett<>nil then
					begin
						if bTst(TxtVal.Effects,TF_THICKENED) then pfett^.Check
						else
							pfett^.Uncheck
					end;
				if pkursiv<>nil then
					begin
						if bTst(TxtVal.Effects,TF_SLANTED) then pkursiv^.Check
						else
							pkursiv^.Uncheck
					end;
				if punter<>nil then
					begin
						if bTst(TxtVal.Effects,TF_UNDERLINED) then punter^.Check
						else
							punter^.Uncheck
					end;
				case (TxtVal.Align and $0f) of
				TA_CENTER:
					begin
						if palignleft<>nil then palignleft^.Uncheck;
						if paligncenter<>nil then paligncenter^.Check;
						if palignright<>nil then palignright^.Uncheck
					end;
				TA_RIGHT:
					begin
						if palignleft<>nil then palignleft^.Uncheck;
						if paligncenter<>nil then paligncenter^.Uncheck;
						if palignright<>nil then palignright^.Check
					end
				else
					begin
						if palignleft<>nil then palignleft^.Check;
						if paligncenter<>nil then paligncenter^.Uncheck;
						if palignright<>nil then palignright^.Uncheck
					end
				end
			end
	end;


procedure TCalcWindow.SetCursorPos(r,c: integer; scrl: boolean);
	var cell : PCell;
	    r1   : LGRECT;
	    sr   : GRECT;
	    nx,ny: longint;

	begin
		DrawCursor;
		DeselectAll;
		DeselectAllObjects;
		if inpstat then
			begin
				inpstat:=false;
				ChangeCell(GetCell(Parms.Cursor.Row,Parms.Cursor.Col),inpline^.GetText,Parms.Cursor.Row,Parms.Cursor.Col,true)
			end;
		with Parms.Cursor do
			begin
				Block:=false;
				OldRow:=Row;
				OldCol:=Col;
				Row:=r;
				Col:=c
			end;
		SetBlock;
		cell:=GetCell(r,c);
		with cell^ do
			begin
				if TxtVal.Size>0 then
					if pfbox<>nil then
						with pfbox^ do
							begin
								newsize:=TxtVal.Size;
								SetSelection(FontID2Index(TxtVal.Font),true);
								if newsize>=0 then
									begin
										if fsizebox<>nil then fsizebox^.SetSelection(FontSize2Index(newsize),false);
										newsize:=-1
									end
							end;
				if pcbox<>nil then
					begin
						if Interior=FIS_HOLLOW then pcbox^.SetSelection(White,false)
						else
							pcbox^.SetSelection(Color,false)
					end;
				if ptcbox<>nil then ptcbox^.SetSelection(TxtVal.Color,false);
				if ppbox<>nil then
					begin
						if Interior=FIS_SOLID then ppbox^.SetSelection(7,false)
						else
							if Interior=FIS_HOLLOW then ppbox^.SetSelection(0,false)
							else
								if Style=8 then ppbox^.SetSelection(7,false)
								else
									ppbox^.SetSelection(Style,false)
					end
			end;
		CheckToolbarTextFX(cell);
		SetInpline(cell);
		if scrl then
			begin
				nx:=Scroller^.XPos;
				ny:=Scroller^.YPos;
				Cell2Rect(r,c,r1);
				GetSheetRect(sr);
				lrc_intersect(r1,sr);
				if r1.W<>sr.W then
					begin
						if r1.X=sr.X then inc(nx,r1.W+1-sr.W)
						else
							inc(nx,r1.X-LeftColWidth-Work.X)
					end;
				if r1.H<>sr.H then
					begin
						if r1.Y=sr.Y then inc(ny,r1.H+1-sr.H)
						else
							inc(ny,r1.Y-PaintOffs-TopRowHeight-Work.Y-1)
					end;
				Scroller^.ScrollTo(nx,ny)
			end;
		with cell^ do Flags:=Flags or CELL_SELECTED;
		DrawCursor
	end;


procedure TCalcWindow.SetBlock;
	var s : string;
	    pw: PWindow;

	begin
		with Parms.Cursor do
			if Block then
				begin
					s:=GetColumnIndex(ColStart)+GetRowIndex(RowStart)+':'+GetColumnIndex(ColEnd)+GetRowIndex(RowEnd);
					if (ColStart=0) and (ColEnd=Parms.Columns) then inscol^.Disable
					else
						inscol^.Enable;
					if (RowStart=0) and (RowEnd=Parms.Rows) then insrow^.Disable
					else
						insrow^.Enable
				end
			else
				begin
					s:=GetColumnIndex(Col)+GetRowIndex(Row);
					inscol^.Enable;
					insrow^.Enable
				end;
		dblock^.SetText(s);
		pw:=ChildList;
		while pw<>nil do
			begin
				if pw^.GetClassName=BLOCKWINDCLASS then
					if pw^.Attr.Status=ws_Open then PBlockChangeDialog(pw)^.BlockChanged(s);
				pw:=pw^.Next
			end
	end;


procedure TCalcWindow.ClearCalcFlags;
	var cell: PCell;
	    q,w : integer;

	begin
		cell:=Sheet;
		for q:=0 to Parms.Rows do
			for w:=0 to Parms.Columns do
				begin
					cell^.Flags:=cell^.Flags and not(CELL_CALCULATED);
					inc(longint(cell),CELLSIZE)
				end
	end;


procedure TCalcWindow.Print;

	begin
		if prnt<>nil then prnt^.Work
	end;


procedure TCalcWindow.SetBorderSize;

	begin
		LeftColWidth:=numWidth*trunc(ln(Parms.Rows+2)/ln(10))+((3*numWidth) shr 1);
		with Attr do
			begin
				TopRowHeight:=boxHeight-1;
				VWork.X1:=LeftColWidth+1;
				VWork.Y1:=TopRowHeight+PaintOffs+1
			end;
		SetScrollerRange
	end;


procedure TCalcWindow.SetScrollerRange;
	var q,w,h: longint;

	begin
		if (Scroller=nil) or (PRow=nil) or (PCol=nil) then exit;
		Scroller^.XLine:=wWidth*atol(TexelApp.setupbuffer.stdcolwidth)+1; { ... }
		Scroller^.YLine:=Attr.boxHeight+1; { ... }
		w:=0;
		for q:=0 to Parms.Columns do inc(w,GetColWidth(q));
		h:=1;
		for q:=0 to Parms.Rows do inc(h,GetRowHeight(q));
		Scroller^.SetPageSize;
		Scroller^.SetRange(w,h)
	end;


procedure TCalcWindow.SetPercentSize(pct: integer);

	begin
		Parms.Percent:=pct;
		PercentSize:=pct/100;
		SetFont(GetStdFontIndex,GetStdFontSize);
		SetBorderSize;
		ForceVRedraw
	end;


function TCalcWindow.ColIndex2Nr(indx: string; clip: boolean): integer;
	var q,c: integer;

	begin
		q:=1;
		while (indx[q] in ['A'..'Z']) and (q<=length(indx)) do inc(q);
		if q=2 then c:=ord(indx[1])-65
		else
			if q=3 then c:=ord(indx[1])*26+ord(indx[2])-1729
			else
				if clip then
					begin
						if q=1 then c:=0
						else
							c:=Parms.Columns
					end
				else
					c:=-1;
		if clip then c:=Min(Max(c,0),Parms.Columns);
		ColIndex2Nr:=c
	end;


function TCalcWindow.GetColumnIndex(Nr: integer): string;

	begin
		if Nr<0 then GetColumnIndex:='?'
		else
			if Nr<26 then GetColumnIndex:=chr(65+Nr)
			else
				GetColumnIndex:=chr(64+(Nr div 26))+chr(65+(Nr mod 26))
	end;


function TCalcWindow.GetColumnName(Nr: integer): string;

	begin
		if PColNames<>nil then
			if PColNames^[Nr]<>nil then
				begin
					GetColumnName:=PString(PColNames^[Nr])^;
					exit
				end;
		GetColumnName:=GetColumnIndex(Nr)
	end;


function TCalcWindow.GetRowIndex(Nr: integer): string;

	begin
		if Nr<0 then GetRowIndex:='0'
		else
			GetRowIndex:=ltoa(Nr+1)
	end;


function TCalcWindow.GetWindowFileName: string;

	begin
		GetWindowFileName:=longfile
	end;


procedure TCalcWindow.SetWindowFileName(s: string);
	var p1,p2: pointer;
      pipe : Pipearray;

	begin
		SetTitle(CompressPath(s,76));
		if TexelApp.abruf<>nil then TexelApp.abruf^.Add(s,true);
		if (s<>longfile) and (length(longfile)>0) then
			if Application^.OLGAManager>=0 then
				begin
					GlobalAlloc(p1,256);
					GlobalAlloc(p2,256);
					if (p1=nil) or (p2=nil) then
						begin
							GlobalFree(p1,256);
							GlobalFree(p2,256)
						end
					else
						begin
							StrPCopy(p1,longfile);
							StrPCopy(p2,s);
							pipe[0]:=OLGA_RENAME;
							pipe[1]:=Application^.apID;
							pipe[2]:=0;
							pipe[3]:=integer(HiWord(p1));
							pipe[4]:=integer(LoWord(p1));
							pipe[5]:=integer(HiWord(p2));
							pipe[6]:=integer(LoWord(p2));
							pipe[7]:=0;
							appl_write(Application^.OLGAManager,16,@pipe);
							TexelApp.UpdateFile(s,-GetOLGAGroup-1)
						end
				end;
		longfile:=s
	end;


procedure TCalcWindow.SetDirty;

	begin
		if not(Dirty) then
			begin
				SetTitle('* '+GetTitle);
				Dirty:=true;
				if abandon<>nil then
					if length(GetWindowFileName)>0 then abandon^.Enable
			end;
		if pagepreview<>nil then pagepreview^.Update(false)
	end;


procedure TCalcWindow.ClearDirty;
	var s: string;

	begin
		if Dirty then
			begin
				Dirty:=false;
				s:=GetTitle;
				if StrPLeft(s,2)='* ' then SetTitle(StrPRight(s,length(s)-2));
				if abandon<>nil then abandon^.Disable
			end
	end;


procedure TCalcWindow.SetFont(fIndex,fSize: integer);
	var cw,dummy: integer;

	begin
		actFont:=vst_font(vdiHandle,fIndex);
		if Speedo then actPoint:=vst_arbpt(vdiHandle,round(fSize*PercentSize),Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
		else
			actPoint:=vst_point(vdiHandle,round(fSize*PercentSize),Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight);
		if vqt_width(vdiHandle,ord('W'),cw,dummy,dummy)=ord('W') then wWidth:=cw
		else
			wWidth:=Attr.charWidth;
		if vqt_width(vdiHandle,ord('9'),cw,dummy,dummy)=ord('9') then numWidth:=cw
		else
			numWidth:=Attr.charWidth
	end;


function TCalcWindow.GetStdFontIndex: integer;
	var dummy: string;

	begin
		if Fonts=nil then GetStdFontIndex:=vqt_name(vdiHandle,1,dummy)
		else
			if (sheetbuffer.font>=0) and (sheetbuffer.font<Fonts^.Count) then GetStdFontIndex:=PFont(Fonts^.At(sheetbuffer.font))^.index
			else
				GetStdFontIndex:=vqt_name(vdiHandle,1,dummy)
	end;


function TCalcWindow.GetStdFontSize: integer;
	var pf: PFont;

	begin
		if Fonts=nil then GetStdFontSize:=10
		else
			if (sheetbuffer.font<0) or (sheetbuffer.font>=Fonts^.Count) then GetStdFontSize:=10
			else
				begin
					pf:=Fonts^.At(sheetbuffer.font);
					if pf^.SizeCount=0 then GetStdFontSize:=4+sheetbuffer.size
					else
						if (sheetbuffer.size<0) or (sheetbuffer.size>=pf^.SizeCount) then GetStdFontSize:=10
						else
							GetStdFontSize:=pf^.Sizes^[pf^.SizeCount-sheetbuffer.size-1]
				end
	end;


function TCalcWindow.GetFontIndex: integer;

	begin
		TransferData(tf_GetData);
		if Fonts=nil then GetFontIndex:=GetStdFontIndex
		else
			if (dtbuffer.font>=0) and (dtbuffer.font<Fonts^.Count) then GetFontIndex:=PFont(Fonts^.At(dtbuffer.font))^.index
			else
				GetFontIndex:=GetStdFontIndex
	end;


function TCalcWindow.GetFontSize: integer;
	var pf: PFont;

	begin
		TransferData(tf_GetData);
		if Fonts=nil then GetFontSize:=GetStdFontSize
		else
			if (dtbuffer.font<0) or (dtbuffer.font>=Fonts^.Count) then GetFontSize:=GetStdFontSize
			else
				begin
					pf:=Fonts^.At(dtbuffer.font);
					if pf^.SizeCount=0 then GetFontSize:=4+dtbuffer.size
					else
						if (dtbuffer.size<0) or (dtbuffer.size>=pf^.SizeCount) then GetFontSize:=GetStdFontSize
						else
							GetFontSize:=pf^.Sizes^[pf^.SizeCount-dtbuffer.size-1]
				end
	end;


function TCalcWindow.FontID2Index(anid: integer): integer;
	var q: integer;

	begin
		FontID2Index:=0;
		if pfbox=nil then exit;
		if pfbox^.List^.Count>0 then
			begin
				anid:=vst_font(vdiHandle,anid);
				for q:=0 to pfbox^.List^.Count-1 do
					with PFont(pfbox^.List^.At(q))^ do
						if Index=anid then
							begin
								FontID2Index:=q;
								break
							end;
				actFont:=vst_font(vdiHandle,GetStdFontIndex)
			end
	end;


function TCalcWindow.FontSize2Index(asize: integer): integer;
	var pf: PFont;
	    q : integer;

	begin
		FontSize2Index:=0;
		if pfbox=nil then exit;
		pf:=PFont(pfbox^.List^.At(pfbox^.GetSelection));
		if pf^.SizeCount=0 then
			begin
				if asize>127 then asize:=127;
				if asize<4 then asize:=4;
				FontSize2Index:=asize-4
			end
		else
			begin
				for q:=pf^.SizeCount-1 downto 0 do
					if asize<=pf^.Sizes^[q] then
						begin
							if asize=pf^.Sizes^[q] then FontSize2Index:=pf^.SizeCount-q-1
							else
								if q<pf^.SizeCount-1 then FontSize2Index:=pf^.SizeCount-q-2;
							exit
						end;
				FontSize2Index:=pf^.SizeCount-1
			end
	end;


function TCalcWindow.FontChanged(OrgID,AnID,ASize,AColor,BackColor,TheEffects,ARotation,ASkew,HorAlign,VertAlign,AWidth,TrackKern: integer; Size31: fix31; PairKern,cWnd: boolean): boolean;
	var rs,cs,re,ce,
	    cmin,cmax,
	    x,y        : integer;
	    cell       : PCell;

	begin
		inherited FontChanged(OrgID,AnID,ASize,AColor,BackColor,TheEffects,ARotation,ASkew,HorAlign,VertAlign,AWidth,TrackKern,Size31,PairKern,cWnd);
		FontChanged:=true;
		if pfbox=nil then exit;
		pfbox^.SetSelection(FontID2Index(AnID),false);
		if pfbox^.fsizebox<>nil then pfbox^.fsizebox^.SetSelection(FontSize2Index(ASize),false);
		with Parms.Cursor do
			if Block then
				begin
					rs:=RowStart;
					re:=RowEnd;
					cs:=ColStart;
					ce:=ColEnd
				end
			else
				begin
					rs:=Row;
					re:=Row;
					cs:=Col;
					ce:=Col
				end;
		if VertAlign>=0 then
			case VertAlign of
			TVA_TOP:
				VertAlign:=TA_OBEN;
			TVA_CENTER:
				VertAlign:=TA_MITTE;
			TVA_BOTTOM:
				VertAlign:=TA_UNTEN
			end;
		cmin:=cs;
		cmax:=ce;
		RowsClearOverflow(rs,re,cmin,cmax);
		for y:=rs to re do
			begin
				cell:=GetCell(y,cs);
				for x:=cs to ce do
					begin
						if BackColor>=0 then
							begin
								if BackColor=White then
									begin
										cell^.Color:=Black;
										cell^.Style:=8;
										cell^.Interior:=FIS_HOLLOW
									end
								else
									begin
										cell^.Color:=BackColor;
										if cell^.Interior=FIS_HOLLOW then cell^.Interior:=FIS_SOLID
									end
							end;
						with cell^.TxtVal do
							begin
								if AnID<>0 then Font:=AnID;
								if ASize>0 then Size:=Min(Max(ASize,4),127);
								if AColor>=0 then Color:=AColor;
								if TheEffects>=0 then Effects:=TheEffects;
								if ARotation>=0 then Rotat:=ARotation;
								if ASkew>=-1800 then Skew:=ASkew;
								if HorAlign>=0 then Align:=(Align and $f0) or HorAlign;
								if VertAlign>=0 then Align:=(Align and $0f) or VertAlign
							end;
						inc(longint(cell),CELLSIZE)
					end
			end;
		RowsCheckOverflow(rs,re,cmin,cmax);
		SetDirty;
		DrawCells(rs,cmin,re,cmax)
	end;


function clearufsl: longint;

	begin
		callufsl^.dialtyp:=0;
		callufsl^.helpbutton:=0;
		callufsl^.helpfunc:=0;
		clearufsl:=0
	end;


procedure TCalcWindow.FontSelect;
	var fid,fsize,
	    xhandle,
	    vhandle,
	    dummy,
	    ret       : integer;
	    cell      : PCell;
	    titel     : string;
	    xpar      : xFSL_PAR;
	    fntinf    : FONTINFO;
	    fontname  : array [0..39] of char;

	begin
		cell:=GetCell(Parms.Cursor.Row,Parms.Cursor.Col);
		fid:=cell^.TxtVal.Font;
		fsize:=cell^.TxtVal.Size;
		if fid=0 then fid:=PFont(pfbox^.List^.At(pfbox^.GetSelection))^.Index;
		if fsize=0 then fsize:=atol(pfbox^.fsizebox^.GetText);
		if fsize<4 then fsize:=10;
		if GetCookie('xFSL',longint(callxfsl)) then
			begin
				if callxfsl=nil then exit;
				titel:=TEXELWINDPREFIX+TITLE_FONTSELECTOR+#0;
				with callxfsl^ do
					begin
						if id='xFSL' then
							if revision>=4 then
								begin
									if IsEmptyCell(cell) then vhandle:=vdiHandle
									else
										vhandle:=0;
									fillchar(xpar,sizeof(xFSL_PAR),0);
									fillchar(fntinf,sizeof(FONTINFO),0);
									with fntinf do
										begin
											fontid:=fid;
											fontsize.size:=fsize;
											fontattr:=cell^.TxtVal.Effects;
											fontskew:=cell^.TxtVal.Skew;
											rotation:=cell^.TxtVal.Rotat;
											fontcol:=cell^.TxtVal.Color;
											if cell^.Interior=FIS_HOLLOW then backcol:=White
											else
												backcol:=cell^.Color;
											halign:=cell^.TxtVal.Align and $0f;
											case (cell^.TxtVal.Align and $f0) of
											TA_OBEN:
												valign:=TVA_TOP;
											TA_UNTEN:
												valign:=TVA_BOTTOM
											else
												valign:=TVA_CENTER
											end
										end;
									xpar.par_size:=sizeof(xFSL_PAR);
									xpar.pfi_size:=sizeof(FONTINFO);
									xpar.control:=CC_FAKESTYLE or CC_NOWIDTH or CC_NOKERN;
									xpar.headline:=@titel[1];
									xpar.fontflags:=FF_ALL;
									fontname[0]:=#0;
									fntinf.fontname:=fontname;
									xpar.font:=@fntinf;
							    xhandle:=xfsl_init(nil,nil,0,0,0,vhandle,@xpar);
							    if xhandle>=0 then
							    	begin
							    		repeat
												ret:=xfsl_event(nil,nil,0,0,0,xhandle,nil)
											until (ret=xFS_OK) or (ret=xFS_STOP);
											xfsl_exit(nil,nil,0,0,0,xhandle);
											if ret=xFS_OK then
												with xpar.font^ do
													FontChanged(Application^.apID,fontid,fontsize.size,fontcol,backcol,fontattr,rotation,fontskew,halign,valign,0,0,0,false,false)
										end
									else
										if xfsl_input(nil,nil,0,0,0,vdiHandle,FF_ALL,@titel[1],fid,fsize)=1 then
											FontChanged(Application^.apID,fid,fsize,-1,-1,-1,-1,-32768,-1,-1,0,0,0,false,false);
									exit
								end
					end
			end;
		if TexelApp.fnt_dialog<>nil then
			with AES_pb do
				begin
					control^[0]:=187;
					control^[1]:=7;
					control^[2]:=8;
					control^[3]:=1;
					control^[4]:=0;
					intin^[0]:=FNTS_SNAME or FNTS_SSTYLE or FNTS_SSIZE or FNTS_CHNAME or FNTS_CHSTYLE or FNTS_CHSIZE;
					intin^[1]:=0;
					intin^[2]:=fid;
					intin^[3]:=fsize;
					intin^[4]:=0;
					intin^[5]:=1;
					intin^[6]:=0;
					addrin^[0]:=TexelApp.fnt_dialog;
					_crystal(@AES_pb);
					if intout^[0]=FNTS_OK then
						begin
							if (intout^[1] and (FNTS_SNAME or FNTS_SSTYLE))>0 then fid:=intout^[3];
							if bTst(intout^[1],FNTS_SSIZE) then fsize:=intout^[4];
							FontChanged(Application^.apID,fid,fsize,-1,-1,-1,-1,-32768,-1,-1,0,0,0,false,false)
						end;
					with Application^ do
						begin
							SetSystemFont(vdiHandle,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight);
							vst_alignment(vdiHandle,TA_LEFT,TA_BASELINE,dummy,dummy);
							vswr_mode(vdiHandle,MD_REPLACE);
							vsl_type(vdihandle,LT_SOLID);
							vsf_perimeter(vdiHandle,PER_ON);
							vsl_color(vdiHandle,Black);
							vsl_ends(vdiHandle,LE_SQUARED,LE_SQUARED);
							vsm_type(vdiHandle,MT_DOT);
							vsm_color(vdiHandle,Black);
							vst_rotation(vdiHandle,0);
							vsf_color(vdiHandle,Black);
							vst_color(vdiHandle,Black);
							vst_effects(vdiHandle,TF_NORMAL);
							vsl_udsty(vdiHandle,$5555);
							vsf_interior(vdiHandle,FIS_HOLLOW);
							vsf_style(vdiHandle,4);
							vsm_height(vdiHandle,1);
							if SpeedoActive then vst_skew(vdiHandle,0);
							vs_clip(vdiHandle,CLIP_ON,SysInfo.Desktop.A2)
						end;
					exit
				end;
		if GetCookie('UFSL',longint(callufsl)) then
			if callufsl<>nil then
				begin
					supexec(clearufsl);
					with callufsl^ do
						begin
							font_selinit(nil,nil,0,0,0);
							if font_selinput(nil,nil,0,0,0,vdiHandle,Attr.sysFonts+Attr.addFonts,nil,0,fid,fsize)=1 then
								FontChanged(Application^.apID,fid,fsize,-1,-1,-1,-1,-32768,-1,-1,0,0,0,false,false)
						end
				end
	end;


procedure TCalcWindow.Cut;
	var p: PEmbedded;
	    q: integer;

	begin
		if inpstat then inherited Cut
		else
			begin
				p:=FirstSelectedObject;
				if p<>nil then
					begin
						q:=Application^.Alert(@self,1,WAIT,MESSAGE_WINDOW_CUT,BUTTON_OBJCELLCANCEL);
						if q=1 then p^.Cut;
						if q<>2 then exit
					end;
				CutCells
			end
	end;


procedure TCalcWindow.Copy;
	var p: PEmbedded;
	    q: integer;

	begin
		if inpstat then inherited Copy
		else
			begin
				p:=FirstSelectedObject;
				if p<>nil then
					begin
						q:=Application^.Alert(@self,1,WAIT,MESSAGE_WINDOW_COPY,BUTTON_OBJCELLCANCEL);
						if q=1 then p^.Copy;
						if q<>2 then exit
					end;
				CopyCells
			end
	end;


procedure TCalcWindow.Paste;

	begin
		if inpstat then inherited Paste
		else
			if not(PasteObject) then PasteCells
	end;


procedure TCalcWindow.Delete;
	var p: PEmbedded;
	    q: integer;

	begin
		if inpstat then inherited Delete
		else
			begin
				p:=FirstSelectedObject;
				if p<>nil then
					begin
						q:=Application^.Alert(@self,1,WAIT,MESSAGE_WINDOW_DELETE,BUTTON_OBJCELLCANCEL);
						if q=1 then p^.Destroy;
						if q<>2 then exit
					end;
				if clrinh<>nil then clrinh^.HandleMenu(2)
			end
	end;


procedure TCalcWindow.CutCells;

	begin
		CopyCells;
		DeleteCells
	end;


procedure TCalcWindow.CopyCells;
	label _raus,_fehler;

	var header : TTexelHeader;
	    bheader: TBlockHeader;
      buf    : PByteArray;
      res,q,
      dummy,
      bufsize,
      bufcnt : longint;
      rs,cs,
      re,ce,
      x,y,
      hdl    : integer;
      rval   : real;
      fn2    : string;
      oldflg,
      l      : byte;
      ret,
      werror : boolean;
      coffs  : word;
      pp     : PParameter;
      pfm    : PFormat;
      cell   : PCell;

	function bwrite(var buffer; count: longint): boolean;
		var rlen: longint;

		begin
			if count>bufsize then
				begin
					werror:=true;
					bwrite:=true;
					exit
				end;
			bwrite:=false;
			if count<1 then
				begin
					if count=0 then exit;
					if bufcnt>0 then
						begin
							rlen:=fwrite(hdl,bufcnt,buf);
							if rlen<>bufcnt then
								begin
									werror:=true;
									bwrite:=true
								end;
							bufcnt:=0
						end;
					exit
				end;
			if bufcnt+count>bufsize then
				begin
					rlen:=fwrite(hdl,bufcnt,buf);
					if rlen<>bufcnt then
						begin
							werror:=true;
							bwrite:=true
						end;
					bufcnt:=0
				end;
			system.move(buffer,buf^[bufcnt],count);
			inc(bufcnt,count)
		end;

	function writecell: boolean;
	
		begin
			writecell:=true;
			if bwrite(cell^.Flags,CELLSIZE-4) then exit;
			case cell^.Typ of
			CTYPE_TEXT:
				if bwrite(cell^.Data.Txt^,length(cell^.Data.Txt^)+1) then exit;
			CTYPE_CONST:
				with cell^.Data.Konst^ do
					begin
						rval:=Value;
						if bwrite(rval,sizeof(real)) then exit;
						if bwrite(Txt^,length(Txt^)+1) then exit;
						if bwrite(FPts,1) then exit
					end;
			CTYPE_FORMULA:
				with cell^.Data.Formula^ do
					begin
						rval:=Value;
						if bwrite(rval,sizeof(real)) then exit;
						fn2:=BuildFunction(cell,false);
						if bwrite(fn2,length(fn2)+1) then exit;
						if bwrite(FPts,1) then exit;
						if bwrite(Error,1) then exit
					end
			end;
			writecell:=false
		end;

	begin
		if Clipboard=nil then exit;
		with Clipboard^ do
			begin
				if not(KeyCorrect(regname,regkey)) then
					begin
						DemoAlert(@self);
						exit
					end;
				if not(OpenClipboard(true)) then exit;
				buf:=GetMemBuffer(131072,512,bufsize);
				if buf=nil then goto _raus;
				werror:=false;
				res:=fcreate(GetClipboardFilename+TEXELEXTENSION,0);
				if res<0 then goto _raus;
				hdl:=integer(res);
				if not(KeyCorrect(regname,regkey)) then
					begin
						DemoAlert(@self);
						goto _fehler
					end;
				{$IFNDEF DEMO}
				bufcnt:=0;
				with header do
					begin
						Magic:=TEXELMAGIC;
						Version:=TEXELVER;
						Compatible:=TEXELCOMPAT;
						PackAlgo:=PA_BLOCK;
						Resvd1:=0;
						Resvd2:=0;
						Resvd3:=0;
						Resvd4:=0
					end;
				header.Release:=RELEASE;
				if bwrite(header,sizeof(TTexelHeader)) then goto _fehler;
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				with bheader do
					begin
						Width:=ce-cs;
						Height:=re-rs;
						ColOffs:=cs;
						RowOffs:=rs;
						Resvd0:=0;
						Resvd1:=0;
						Resvd2:=0;
						Resvd3:=0;
						Resvd4:=0
					end;
				if bwrite(bheader,sizeof(TBlockHeader)) then goto _fehler;
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								oldflg:=cell^.Flags;
								cell^.Flags:=cell^.Flags and CELL_EMPTYMASK;
								ret:=writecell;
								cell^.Flags:=oldflg;
								if ret then goto _fehler;
								inc(longint(cell),CELLSIZE)
							end
					end;
				if Parameter<>nil then coffs:=Parameter^.Count
				else
					coffs:=0;
				if bwrite(coffs,2) then goto _fehler;
				l:=0;
				if coffs>0 then
					for q:=0 to coffs-1 do
						begin
							pp:=Parameter^.At(q);
							if pp^.Name<>nil then
								begin
									if bwrite(pp^.Name^,length(pp^.Name^)+1) then goto _fehler
								end
							else
								if bwrite(l,1) then goto _fehler;
							if pp^.Txt<>nil then
								begin
									if bwrite(pp^.Txt^,length(pp^.Txt^)+1) then goto _fehler
								end
							else
								if bwrite(l,1) then goto _fehler;
							if pp^.Descr<>nil then
								begin
									if bwrite(pp^.Descr^,length(pp^.Descr^)+1) then goto _fehler
								end
							else
								if bwrite(l,1) then goto _fehler
						end;
				if UsrFormats<>nil then coffs:=UsrFormats^.Count
				else
					coffs:=0;
				if bwrite(coffs,2) then goto _fehler;
				l:=0;
				if coffs>0 then
					for q:=0 to coffs-1 do
						begin
							pfm:=UsrFormats^.At(q);
							if bwrite(pfm^.Index,2) then goto _fehler;
							if pfm^.Name<>nil then
								begin
									if bwrite(pfm^.Name^,length(pfm^.Name^)+1) then goto _fehler
								end
							else
								if bwrite(l,1) then goto _fehler
						end;
				coffs:=0;
				if bwrite(coffs,2) then goto _fehler;
				if bwrite(coffs,2) then goto _fehler;
				bwrite(dummy,-1);
				{$ENDIF}
				_fehler:
				fclose(hdl);
				if werror then fdelete(GetClipboardFilename+TEXELEXTENSION)
				else
					SetClipboardFormat(SCF_SHEET,'.'+TEXELEXTENSION);
				_raus:
				{ andere Formate? ... }
				if buf<>nil then freemem(buf,bufsize);
				CloseClipboard
			end
	end;


procedure TCalcWindow.PasteCells;

	begin
		InsertFromClipboard(INS_FORMULA,INS_OP_NONE,false,false,false,true)
	end;


procedure TCalcWindow.InsertFromClipboard(what,op: integer; empty,transpose,report,copyalign: boolean);
	label _raus,_fehler;

	var ttxt,
	    utxt,
	    tname,
	    tdescr  : string;
	    header  : TTexelHeader;
	    bheader : TBlockHeader;
	    oldfpos,
	    res,q   : longint;
	    cmin,
	    cmax,
	    x,y,i,
	    rs,cs,
	    re,ce,
	    crr,crc,
	    xo,yo,e,
	    xo2,yo2,
	    hdl,w   : integer;
	    coffs   : word;
	    cell    : PCell;
	    dcell   : TCell;
	    ocleared,
	    lossy,
	    vrnd,
	    vorh,
	    rerror  : boolean;
	    l,fpt,
	    err     : byte;
	    rval    : real;
	    pp      : PParameter;

	function bread(var buffer; count: longint): boolean;
		var len: longint;

		begin
			if fread(hdl,count,@buffer)=count then bread:=false
			else
				begin
					rerror:=true;
					bread:=true
				end
		end;

	function readcell(xo,yo: integer; alloc: boolean): boolean;
		label _novar;

		procedure changecell;

			begin
				vrnd:=true;
				FreeCell(cell,false);
				cell^.Flags:=dcell.Flags or CELL_CHANGED;
				cell^.Format:=dcell.Format
			end;

		procedure constcell(rval: TNumber; ttxt: string);

			begin
				changecell;
				new(cell^.Data.Konst);
				if cell^.Data.Konst<>nil then
					begin
						cell^.Typ:=CTYPE_CONST;
						with cell^.Data.Konst^ do
							begin
								Value:=rval;
								if length(ttxt)=0 then Val2Txt(rval,ttxt,MAXCIPHERS,0,nil);
								Txt:=NewStr(ttxt);
								FPts:=fpt
							end
					end
			end;

		procedure checkfont;

			begin
				if not(bTst(what,INS_FORMAT)) then
					with cell^.TxtVal do
						begin
							if Font=0 then Font:=GetFontIndex;
							if Size=0 then Size:=GetFontSize
						end;
			end;

		procedure formcell(ttxt: string);

			begin
				changecell;
				new(cell^.Data.Formula);
				if cell^.Data.Formula<>nil then
					with cell^.Data.Formula^ do
						begin
							Value:=rval;
							FPts:=fpt;
							Error:=FE_OK;
							Func:=nil;
							{ Baum kopieren !!! }
							if Parse(ttxt,utxt,Func,cell,yo,xo,false) then
								begin
									VarDef:=NewStr(utxt);
									cell^.Typ:=CTYPE_FORMULA
								end
							else
								begin
									dispose(cell^.Data.Formula);
									cell^.Data.Txt:=NewStr(ttxt);
									if cell^.Data.Txt<>nil then cell^.Typ:=CTYPE_TEXT
								end
						end
			end;

		begin
			readcell:=true;
			if bread(dcell.Flags,CELLSIZE-4) then exit;
			if alloc then
				begin
					dcell.Flags:=(dcell.Flags and CELL_EMPTYMASK) or (cell^.Flags and CELL_SELECTED);
					dcell.TxtVal.Flags:=dcell.TxtVal.Flags and not(TFL_OVERFLOWMASK);
					if bTst(what,INS_FORMAT) then
						begin
							vrnd:=true;
							cell^.Color:=dcell.Color;
							cell^.Style:=dcell.Style;
							cell^.Interior:=dcell.Interior;
							cell^.Resvd:=dcell.Resvd;
							cell^.Border:=dcell.Border;
							cell^.TxtVal:=dcell.TxtVal
						end
					else
						if copyalign then cell^.TxtVal.Align:=dcell.TxtVal.Align
				end;
			case dcell.Typ of
			CTYPE_TEXT:
				begin
					if bread(l,1) then exit;
					if l>0 then
						begin
							if bread(ttxt[1],l) then exit;
							ttxt[0]:=chr(l);
							if alloc then
								if (what and (INS_FORMULA or INS_VALUE))>0 then
									if (op=INS_OP_NONE) or (cell^.Typ=CTYPE_EMPTY) or (cell^.Typ=CTYPE_TEXT) then
										begin
											if cell^.Typ=CTYPE_EMPTY then checkfont;
											changecell;
											cell^.Data.Txt:=NewStr(ttxt);
											if cell^.Data.Txt<>nil then cell^.Typ:=CTYPE_TEXT
										end
						end
				end;
			CTYPE_CONST:
				begin
					if bread(rval,sizeof(real)) then exit;
					if bread(l,1) then exit;
					if l>0 then
						if bread(ttxt[1],l) then exit;
					ttxt[0]:=chr(l);
					if bread(fpt,1) then exit;
					if alloc then
						if (what and (INS_FORMULA or INS_VALUE))>0 then
							begin
								if op=INS_OP_NONE then
									begin
										if cell^.Typ=CTYPE_EMPTY then checkfont;
										constcell(rval,ttxt)
									end
								else
									case cell^.Typ of
									CTYPE_EMPTY:
										begin
											checkfont;
											if op=INS_OP_ADD then constcell(rval,ttxt)
											else
												if op=INS_OP_SUB then constcell(-rval,'')
										end;
									CTYPE_CONST:
										case op of
										INS_OP_ADD:
											constcell(cell^.Data.Konst^.Value+rval,'');
										INS_OP_SUB:
											constcell(cell^.Data.Konst^.Value-rval,'');
										INS_OP_MUL:
											constcell(cell^.Data.Konst^.Value*rval,'');
										INS_OP_DIV:
											if rval=0.0 then formcell('='+cell^.Data.Konst^.Txt^+'/0')
											else
												constcell(cell^.Data.Konst^.Value/rval,'')
										end;
									CTYPE_FORMULA:
										case op of
										INS_OP_ADD:
											begin
												ttxt:='='+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+'+'+ttxt;
												if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
												formcell(ttxt)
											end;
										INS_OP_SUB:
											begin
												ttxt:='='+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+'-'+ttxt;
												if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
												formcell(ttxt)
											end;
										INS_OP_MUL:
											begin
												ttxt:='=('+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+')*'+ttxt;
												if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
												formcell(ttxt)
											end;
										INS_OP_DIV:
											begin
												ttxt:='=('+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+')/'+ttxt;
												if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
												formcell(ttxt)
											end
										end
									end
							end
				end;
			CTYPE_FORMULA:
				begin
					if bread(rval,sizeof(real)) then exit;
					if bread(l,1) then exit;
					if l>0 then
						if bread(ttxt[1],l) then exit;
					ttxt[0]:=chr(l);
					if bread(fpt,1) then exit;
					if bread(err,1) then exit;
					if alloc then
						begin
							if bTst(what,INS_FORMULA) then
								begin
									ttxt:=TexelApp.EscText2Formula(ttxt);
									if op=INS_OP_NONE then
										begin
											if cell^.Typ=CTYPE_EMPTY then checkfont;
											formcell(ttxt)
										end
									else
										begin
											ttxt:=StrPRight(ttxt,length(ttxt)-1);
											l:=pos('=',ttxt);
											if l>0 then
												begin
													if ttxt[1] in ['0'..'9'] then goto _novar;
													e:=1;
													while e<l do
														begin
															if not(ttxt[e] in VarNameSet) then goto _novar;
															inc(e)
														end;
													ttxt:=StrPRight(ttxt,length(ttxt)-l)
												end;
											_novar:
											case cell^.Typ of
											CTYPE_EMPTY:
												begin
													checkfont;
													if op=INS_OP_ADD then formcell('='+ttxt)
													else
														if op=INS_OP_SUB then formcell('=-('+ttxt+')')
												end;
											CTYPE_CONST:
												case op of
												INS_OP_ADD:
													formcell('='+cell^.Data.Konst^.Txt^+'+('+ttxt+')');
												INS_OP_SUB:
													formcell('='+cell^.Data.Konst^.Txt^+'-('+ttxt+')');
												INS_OP_MUL:
													formcell('='+cell^.Data.Konst^.Txt^+'*('+ttxt+')');
												INS_OP_DIV:
													formcell('='+cell^.Data.Konst^.Txt^+'/('+ttxt+')')
												end;
											CTYPE_FORMULA:
												case op of
												INS_OP_ADD:
													begin
														ttxt:='='+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+'+('+ttxt+')';
														if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
														formcell(ttxt)
													end;
												INS_OP_SUB:
													begin
														ttxt:='='+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+'-('+ttxt+')';
														if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
														formcell(ttxt)
													end;
												INS_OP_MUL:
													begin
														ttxt:='=('+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+')*('+ttxt+')';
														if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
														formcell(ttxt)
													end;
												INS_OP_DIV:
													begin
														ttxt:='=('+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+')/('+ttxt+')';
														if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
														formcell(ttxt)
													end
												end
											end
										end
								end
							else
								if bTst(what,INS_VALUE) then
									begin
										if op=INS_OP_NONE then
											begin
												if cell^.Typ=CTYPE_EMPTY then checkfont;
												constcell(rval,'')
											end
										else
											case cell^.Typ of
											CTYPE_EMPTY:
												begin
													checkfont;
													if op=INS_OP_ADD then constcell(rval,'')
													else
														if op=INS_OP_SUB then constcell(-rval,'')
												end;
											CTYPE_CONST:
												case op of
												INS_OP_ADD:
													constcell(cell^.Data.Konst^.Value+rval,'');
												INS_OP_SUB:
													constcell(cell^.Data.Konst^.Value-rval,'');
												INS_OP_MUL:
													constcell(cell^.Data.Konst^.Value*rval,'');
												INS_OP_DIV:
													if rval=0.0 then formcell('='+cell^.Data.Konst^.Txt^+'/0')
													else
														constcell(cell^.Data.Konst^.Value/rval,'')
												end;
											CTYPE_FORMULA:
												case op of
												INS_OP_ADD:
													begin
														Val2Txt(rval,ttxt,MAXCIPHERS,0,nil);
														ttxt:='='+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+'+'+ttxt;
														if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
														formcell(ttxt)
													end;
												INS_OP_SUB:
													begin
														Val2Txt(rval,ttxt,MAXCIPHERS,0,nil);
														ttxt:='='+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+'-'+ttxt;
														if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
														formcell(ttxt)
													end;
												INS_OP_MUL:
													begin
														Val2Txt(rval,ttxt,MAXCIPHERS,0,nil);
														ttxt:='=('+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+')*'+ttxt;
														if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
														formcell(ttxt)
													end;
												INS_OP_DIV:
													begin
														Val2Txt(rval,ttxt,MAXCIPHERS,0,nil);
														ttxt:='=('+BuildTree(cell,cell^.Data.Formula^.Func,true,0,0)+')/'+ttxt;
														if cell^.Data.Formula^.VarDef<>nil then ttxt:='='+cell^.Data.Formula^.VarDef^+ttxt;
														formcell(ttxt)
													end
												end
											end
									end
						end
				end
			else
				if not(empty) then
					if alloc then
						if (op=INS_OP_NONE) or (cell^.Typ=CTYPE_EMPTY) or (cell^.Typ=CTYPE_TEXT) then changecell
			end;
			readcell:=false
		end;

	procedure XChangeFormat(alt,neu: integer);
		var x,y : integer;
		    cell: PCell;

		begin
			if alt<>neu then
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								if bTst(cell^.Flags,CELL_CHANGED) then
									if cell^.Format=alt then cell^.Format:=neu;
								inc(longint(cell),CELLSIZE)
							end
					end
		end;

	begin
		if Clipboard=nil then exit;
		vrnd:=false;
		ocleared:=false;
		with Clipboard^ do
			begin
				if not(OpenClipboard(false)) then exit;
				ttxt:=GetPriorityClipboardFormat(TEXELEXTENSION+'.dif.csv');
				if ttxt=TEXELEXTENSION then
					begin
						rerror:=false;
						res:=fopen(GetClipboardFilename+TEXELEXTENSION,FO_READ);
						if res<0 then goto _raus;
						hdl:=integer(res);
						if bread(header,sizeof(TTexelHeader)) then goto _fehler;
						with header do
							if Magic<>TEXELMAGIC then goto _fehler
							else
								if Compatible<>TEXELCOMPAT then goto _fehler
								else
									if PackAlgo<>PA_BLOCK then goto _fehler;
						if bread(bheader,sizeof(TBlockHeader)) then goto _fehler;
						lossy:=false;
						with Parms.Cursor do
							if Block then
								begin
									rs:=RowStart;
									re:=RowEnd;
									cs:=ColStart;
									ce:=ColEnd
								end
							else
								begin
									rs:=Row;
									re:=Row;
									cs:=Col;
									ce:=Col;
									if transpose then
										begin
											if bheader.Width>0 then
												begin
													re:=Min(rs+bheader.Width,Parms.Rows);
													if rs+bheader.Width>Parms.Rows then lossy:=true
												end;
											if bheader.Height>0 then
												begin
													ce:=Min(cs+bheader.Height,Parms.Columns);
													if cs+bheader.Height>Parms.Columns then lossy:=true
												end
										end
									else
										begin
											if bheader.Width>0 then
												begin
													ce:=Min(cs+bheader.Width,Parms.Columns);
													if cs+bheader.Width>Parms.Columns then lossy:=true
												end;
											if bheader.Height>0 then
												begin
													re:=Min(rs+bheader.Height,Parms.Rows);
													if rs+bheader.Height>Parms.Rows then lossy:=true
												end
										end
								end;
						if lossy then
							if Application^.Alert(@self,1,WAIT,MESSAGE_WINDOW_CCPCOPY,BUTTON_GOCANCEL)<>1 then goto _fehler;
						if op=INS_OP_NONE then
							if IsBlockUsed(rs,cs,re,ce,1) then goto _fehler;
						cmin:=cs;
						cmax:=ce;
						RowsClearOverflow(rs,re,cmin,cmax);
						ocleared:=true;
						xo:=cs-bheader.ColOffs;
						yo:=rs-bheader.RowOffs;
						if transpose then
							for x:=cs to cs+bheader.Height do
								begin
									if x>ce then
										begin
											for y:=0 to bheader.Width do if readcell(0,0,false) then goto _fehler
										end
									else
										begin
											for y:=rs to rs+bheader.Width do
												if y>re then
													begin
														if readcell(0,0,false) then goto _fehler
													end
												else
													begin
														oldfpos:=fseek(0,hdl,1);
														if oldfpos<0 then goto _fehler;
														crc:=x;
														xo2:=xo;
														while crc<=ce do
															begin
																crr:=y;
																yo2:=yo;
																while crr<=re do
																	begin
																		if fseek(oldfpos,hdl,0)<0 then goto _fehler;
																		cell:=GetCell(crr,crc);
																		if readcell(xo2,yo2,true) then goto _fehler;
																		inc(crr,bheader.Width+1);
																		inc(yo2,bheader.Width+1)
																	end;
																inc(crc,bheader.Height+1);
																inc(xo2,bheader.Height+1)
															end
													end
										end
								end
						else
							for y:=rs to rs+bheader.Height do
								begin
									if y>re then
										begin
											for x:=0 to bheader.Width do if readcell(0,0,false) then goto _fehler
										end
									else
										begin
											for x:=cs to cs+bheader.Width do
												if x>ce then
													begin
														if readcell(0,0,false) then goto _fehler
													end
												else
													begin
														oldfpos:=fseek(0,hdl,1);
														if oldfpos<0 then goto _fehler;
														crr:=y;
														yo2:=yo;
														while crr<=re do
															begin
																crc:=x;
																xo2:=xo;
																while crc<=ce do
																	begin
																		if fseek(oldfpos,hdl,0)<0 then goto _fehler;
																		cell:=GetCell(crr,crc);
																		if readcell(xo2,yo2,true) then goto _fehler;
																		inc(crc,bheader.Width+1);
																		inc(xo2,bheader.Width+1)
																	end;
																inc(crr,bheader.Height+1);
																inc(yo2,bheader.Height+1)
															end
													end
										end
								end;
						if bread(coffs,2) then goto _fehler;
						if coffs>0 then
							begin
								for w:=0 to coffs-1 do
									begin
										if bread(l,1) then goto _fehler;
										if l>0 then
											if bread(tname[1],l) then goto _fehler;
										tname[0]:=chr(l);
										if bread(l,1) then goto _fehler;
										if l>0 then
											if bread(ttxt[1],l) then goto _fehler;
										ttxt[0]:=chr(l);
										if bread(l,1) then goto _fehler;
										if l>0 then
											if bread(tdescr[1],l) then goto _fehler;
										tdescr[0]:=chr(l);
										if bTst(what,INS_FORMULA) then
											begin
												vorh:=false;
												if Parameter^.Count>0 then
													begin
														utxt:=StrPUpper(tname);
														for q:=0 to Parameter^.Count-1 do
															if StrPUpper(PParameter(Parameter^.At(q))^.Name^)=utxt then
																begin
																	vorh:=true;
																	break
																end
													end;
												if not(vorh) then
													begin
														new(pp);
														if pp<>nil then
															begin
																pp^.Value:=atof(ttxt);
																pp^.Name:=NewStr(tname);
																pp^.ListName:=NewStr('  '+tname+' '#0);
																pp^.Txt:=NewStr(ttxt);
																pp^.Descr:=NewStr(tdescr);
																pp^.Predef:=false;
																if (pp^.Name=nil) or (pp^.Txt=nil) then
																	begin
																		DisposeStr(pp^.Name);
																		DisposeStr(pp^.ListName);
																		DisposeStr(pp^.Txt);
																		DisposeStr(pp^.Descr);
																		dispose(pp)
																	end
																else
																	Parameter^.Insert(pp)
															end
													end
											end
									end;
								if konstanten<>nil then konstanten^.UpdateList(true)
							end;
						if bread(coffs,2) then goto _fehler;
						if coffs>0 then
							if (what and (INS_FORMULA or INS_VALUE))>0 then
								for w:=0 to coffs-1 do
									begin
										if bread(i,2) then goto _fehler;
										if bread(l,1) then goto _fehler;
										if l>0 then
											if bread(ttxt[1],l) then goto _fehler;
										ttxt[0]:=chr(l);
										crr:=0;
										if UsrFormats^.Count>0 then
											for q:=0 to UsrFormats^.Count-1 do
												if PFormat(UsrFormats^.At(q))^.Name^=ttxt then
													begin
														crr:=PFormat(UsrFormats^.At(q))^.Index;
														break
													end;
										if crr=0 then crr:=NewNumFormat(ttxt);
										XChangeFormat(i,crr)
									end;
						_fehler:
						fclose(hdl)
					end
				else
					begin
						{ andere Formate... }
						if report then Application^.Alert(@self,1,NOTE,MESSAGE_CLIP_PASTE,BUTTON_OK)
						else
							Application^.Bing
					end;
				_raus:
				CloseClipboard
			end;
		if ocleared then RowsCheckOverflow(rs,re,cmin,cmax);
		if vrnd then
			begin
				SetDirty;
				DrawCells(rs,cmin,re,cmax);
				AutoCalculate(true);
				if not(Parms.Cursor.Block) then
					begin
						cell:=GetCell(Parms.Cursor.Row,Parms.Cursor.Col);
						CheckToolbarTextFX(cell);
						SetInpline(cell)
					end
			end
	end;


procedure TCalcWindow.DeleteCells;
	var x,y,
	    cmin,
	    cmax,
	    rs,re,
	    cs,ce : integer;
	    cell  : PCell;
	    vrnd  : boolean;

	begin
		vrnd:=false;
		with Parms.Cursor do
			if Block then
				begin
					rs:=RowStart;
					re:=RowEnd;
					cs:=ColStart;
					ce:=ColEnd
				end
			else
				begin
					rs:=Row;
					re:=Row;
					cs:=Col;
					ce:=Col
				end;
		cmin:=cs;
		cmax:=ce;
		RowsClearOverflow(rs,re,cmin,cmax);
		for y:=rs to re do
			begin
				cell:=GetCell(y,cs);
				for x:=cs to ce do
					begin
						if not(IsEmptyCell(cell)) then
							begin
								FreeCell(cell,true);
								vrnd:=true
							end;
						inc(longint(cell),CELLSIZE)
					end
			end;
		RowsCheckOverflow(rs,re,cmin,cmax);
		if vrnd then
			begin
				SetDirty;
				DrawCells(rs,cmin,re,cmax);
				AutoCalculate(true)
			end
		else
			Application^.Bing
	end;


procedure TCalcWindow.InsertCells(rs,cs,re,ce,dir: integer);
	label _raus;

	var x,y,
	    von,
	    anz,
	    cmin,cmax,
	    rmin,rmax,
	    rdif,
	    cdif     : integer;
	    cell,
	    ocell    : PCell;
	    oldsel   : byte;
	    movesize : boolean;

	procedure blockclear;
	
		begin
			RowsClearOverflow(rmin,rmax,cmin,cmax)
		end;

	begin
		BusyMouse;
		case dir of
		CRS_LEFT:
			begin
				if IsBlockUsed(rs,0,re,ce-cs,0) then goto _raus;
				rmin:=rs;
				rmax:=re;
				cmin:=0;
				cmax:=ce;
				blockclear;
				movesize:=(rs=0) and (re=Parms.Rows);
				FreeBlock(rs,0,re,ce-cs,false);
				if cs>0 then
					begin
						von:=ce+1-cs;
						if movesize then
							for x:=0 to cs-1 do PCol^[x]:=PCol^[von+x];
						for y:=rs to re do
							begin
								cell:=GetCell(y,0);
								ocell:=GetCell(y,von);
								for x:=1 to cs do
									begin
										oldsel:=cell^.Flags and CELL_SELECTED;
										cell^:=ocell^;
										cell^.Flags:=(cell^.Flags and CELL_EMPTYMASK) or oldsel;
										inc(longint(cell),CELLSIZE);
										inc(longint(ocell),CELLSIZE)
									end
							end
					end;
				rdif:=0;
				cdif:=cs-ce-1;
				ClearBlock(rs,cs,re,ce);
				if movesize then
					if ce>cs then
						for x:=cs to ce-1 do PCol^[x]:=PCol^[ce];
				cs:=0
			end;
		CRS_RIGHT:
			begin
				if IsBlockUsed(rs,Parms.Columns+cs-ce,re,Parms.Columns,0) then goto _raus;
				rmin:=rs;
				rmax:=re;
				cmin:=cs;
				cmax:=Parms.Columns;
				blockclear;
				movesize:=(rs=0) and (re=Parms.Rows);
				FreeBlock(rs,Parms.Columns+cs-ce,re,Parms.Columns,false);
				anz:=Parms.Columns-ce;
				if anz>0 then
					begin
						von:=Parms.Columns+cs-ce-1;
						if movesize then
							for x:=0 to anz-1 do PCol^[Parms.Columns-x]:=PCol^[von-x];
						for y:=rs to re do
							begin
								cell:=GetCell(y,Parms.Columns);
								ocell:=GetCell(y,von);
								for x:=1 to anz do
									begin
										oldsel:=cell^.Flags and CELL_SELECTED;
										cell^:=ocell^;
										cell^.Flags:=(cell^.Flags and CELL_EMPTYMASK) or oldsel;
										dec(longint(cell),CELLSIZE);
										dec(longint(ocell),CELLSIZE)
									end
							end
					end;
				rdif:=0;
				cdif:=ce+1-cs;
				ClearBlock(rs,cs,re,ce);
				if movesize then
					if ce>cs then
						for x:=cs+1 to ce do PCol^[x]:=PCol^[cs];
				ce:=Parms.Columns
			end;
		CRS_UP:
			begin
				if IsBlockUsed(0,cs,re-rs,ce,0) then goto _raus;
				rmin:=0;
				rmax:=re;
				cmin:=cs;
				cmax:=ce;
				blockclear;
				movesize:=(cs=0) and (ce=Parms.Columns);
				FreeBlock(0,cs,re-rs,ce,false);
				if rs>0 then
					begin
						von:=re+1-rs;
						for y:=0 to rs-1 do
							begin
								cell:=GetCell(y,cs);
								ocell:=GetCell(von+y,cs);
								if movesize then PRow^[y]:=PRow^[von+y];
								for x:=cs to ce do
									begin
										oldsel:=cell^.Flags and CELL_SELECTED;
										cell^:=ocell^;
										cell^.Flags:=(cell^.Flags and CELL_EMPTYMASK) or oldsel;
										inc(longint(cell),CELLSIZE);
										inc(longint(ocell),CELLSIZE)
									end
							end
					end;
				rdif:=rs-re-1;
				cdif:=0;
				ClearBlock(rs,cs,re,ce);
				if movesize then
					if re>rs then
						for y:=rs to re-1 do PRow^[y]:=PRow^[re];
				rs:=0
			end;
		CRS_DOWN:
			begin
				if IsBlockUsed(Parms.Rows+rs-re,cs,Parms.Rows,ce,0) then goto _raus;
				rmin:=rs;
				rmax:=Parms.Rows;
				cmin:=cs;
				cmax:=ce;
				blockclear;
				movesize:=(cs=0) and (ce=Parms.Columns);
				FreeBlock(Parms.Rows+rs-re,cs,Parms.Rows,ce,false);
				anz:=Parms.Rows-re;
				if anz>0 then
					begin
						von:=Parms.Rows+rs-re-1;
						for y:=0 to anz-1 do
							begin
								cell:=GetCell(Parms.Rows-y,cs);
								ocell:=GetCell(von-y,cs);
								if movesize then PRow^[Parms.Rows-y]:=PRow^[von-y];
								for x:=cs to ce do
									begin
										oldsel:=cell^.Flags and CELL_SELECTED;
										cell^:=ocell^;
										cell^.Flags:=(cell^.Flags and CELL_EMPTYMASK) or oldsel;
										inc(longint(cell),CELLSIZE);
										inc(longint(ocell),CELLSIZE)
									end
							end
					end;
				rdif:=re+1-rs;
				cdif:=0;
				ClearBlock(rs,cs,re,ce);
				if movesize then
					if re>rs then
						for y:=rs+1 to re do PRow^[y]:=PRow^[rs];
				re:=Parms.Rows
			end
		end;
		TranslateCells(rs,cs,re,ce,rdif,cdif,false);
		RowsCheckOverflow(rmin,rmax,cmin,cmax);
		SetDirty;
		if movesize then
			begin
				SetScrollerRange;
				ForceVRedraw
			end
		else
			DrawCells(rmin,cmin,rmax,cmax);
		AutoCalculate(true);
		_raus:
		ArrowMouse
	end;


function TCalcWindow.FreeCell(cell: PCell; clr: boolean): boolean;
	var otxt  : string;
	    q     : longint;
	    oldsel: byte;

	begin
		case cell^.Typ of
		CTYPE_TEXT:
			begin
				DisposeStr(cell^.Data.Txt);
				cell^.Data.Value:=0;
				cell^.Typ:=CTYPE_EMPTY;
				FreeCell:=true
			end;
		CTYPE_CONST:
			begin
				DisposeStr(cell^.Data.Konst^.Txt);
				dispose(cell^.Data.Konst);
				cell^.Data.Value:=0;
				cell^.Typ:=CTYPE_EMPTY;
				FreeCell:=true
			end;
		CTYPE_FORMULA:
			begin
				if cell^.Data.Formula^.VarDef<>nil then
					if Variables<>nil then
						if Variables^.Count>0 then
							begin
								otxt:=StrPUpper(cell^.Data.Formula^.VarDef^);
								for q:=0 to Variables^.Count-1 do
									if otxt=StrPUpper(PVariable(Variables^.At(q))^.Name^) then
										begin
											Variables^.AtFree(q);
											break
										end
							end;
				DisposeStr(cell^.Data.Formula^.VarDef);
				DeleteNode(cell^.Data.Formula^.Func);
				dispose(cell^.Data.Formula);
				cell^.Data.Value:=0;
				cell^.Typ:=CTYPE_EMPTY;
				FreeCell:=true
			end
		else
			FreeCell:=false
		end;
		if clr then
			begin
				oldsel:=cell^.Flags and CELL_SELECTED;
				fillchar(cell^,CELLSIZE,0);
				with cell^ do
					begin
						Flags:=oldsel;
						Color:=Black;
						Style:=8;
						TxtVal.Color:=Black
					end
			end
	end;


function TCalcWindow.FreeBlock(rs,cs,re,ce: integer; clr: boolean): boolean;
	var x,y : integer;
	    vrnd: boolean;
	    cell: PCell;

	begin
		vrnd:=false;
		for y:=rs to re do
			begin
				cell:=GetCell(y,cs);
				for x:=cs to ce do
					begin
						if FreeCell(cell,clr) then vrnd:=true;
						inc(longint(cell),CELLSIZE)
					end
			end;
		FreeBlock:=vrnd
	end;


procedure TCalcWindow.ClearBlock(rs,cs,re,ce: integer);
	var x,y   : integer;
	    cell  : PCell;
	    oldsel: byte;

	begin
		for y:=rs to re do
			begin
				cell:=GetCell(y,cs);
				for x:=cs to ce do
					begin
						oldsel:=cell^.Flags and CELL_SELECTED;
						fillchar(cell^,CELLSIZE,0);
						with cell^ do
							begin
								Flags:=oldsel;
								Color:=Black;
								Style:=8;
								TxtVal.Color:=Black
							end;
						inc(longint(cell),CELLSIZE)
					end
			end
	end;


function TCalcWindow.IsBlockUsed(rs,cs,re,ce,tnum: integer): boolean;
	var x,y : integer;
	    cell: PCell;

	begin
		IsBlockUsed:=false;
		for y:=rs to re do
			begin
				cell:=GetCell(y,cs);
				for x:=cs to ce do
					begin
						if cell^.Data.Value<>0 then
							begin
								if tnum=0 then
									begin
										if Application^.Alert(@self,1,WAIT,MESSAGE_WINDOW_BLOCK1,BUTTON_GOCANCEL)<>1 then IsBlockUsed:=true
									end
								else
									begin
										if Application^.Alert(@self,1,WAIT,MESSAGE_WINDOW_BLOCK2,BUTTON_GOCANCEL)<>1 then IsBlockUsed:=true
									end;
								exit
							end;
						inc(longint(cell),CELLSIZE)
					end
			end
	end;


function TCalcWindow.IsEmptyCell(cell: PCell): boolean;

	begin
		IsEmptyCell:=false;
		with cell^ do
			if Typ=0 then
				if Data.Value=0 then
					if Color=Black then
						if Style=8 then
							if Interior=0 then
								if Border.Val1=0 then
									if Border.Val2=0 then
										if Format=0 then
											if (Flags and CELL_EMPTYMASK)=0 then
												with TxtVal do
													if Size=0 then
														if Rotat=0 then
															if Skew=0 then
																if Color=Black then
																	if Effects=0 then
																		if Align=0 then
																			if Flags=0 then IsEmptyCell:=true
	end;


procedure TCalcWindow.Sort(n1,n2,n3,nrs: integer; n1up,n2up,n3up,rows,cse,ebeg,lex,absl,noattr: boolean);
	label _raus,_cweiter,_rweiter;

	var rs,cs,
	    re,ce,
	    anz,q,
	    x,y,w,
	    i,h,
	    v,j,
	    cmin,
	    cmax,
	    dummy : integer;
	    n2offs,
	    n3offs,
	    offs  : longint;
	    p     : PIntegerArray;
	    valid : boolean;
	    acell : TCell;
	    cell2,
	    qcell2,
	    cell,
	    qcell : PCell;
	    qtxt,
	    vtxt  : string;
	    rval,
	    qval,
	    vval  : TNumber;

	procedure check_cellvars(cr,cc,qr,qc: integer);
		var i: integer;

		begin
			if cell^.Typ=CTYPE_FORMULA then
				if cell^.Data.Formula^.VarDef<>nil then
					if Variables<>nil then
						if Variables^.Count>0 then
							begin
								vtxt:=StrPUpper(cell^.Data.Formula^.VarDef^);
								for i:=0 to Variables^.Count-1 do
									with PVariable(Variables^.At(i))^ do
										if vtxt=StrPUpper(Name^) then
											begin
												RefRow:=cr;
												RefCol:=cc;
												break
											end
							end;
			if qcell^.Typ=CTYPE_FORMULA then
				if qcell^.Data.Formula^.VarDef<>nil then
					if Variables<>nil then
						if Variables^.Count>0 then
							begin
								vtxt:=StrPUpper(qcell^.Data.Formula^.VarDef^);
								for i:=0 to Variables^.Count-1 do
									with PVariable(Variables^.At(i))^ do
										if vtxt=StrPUpper(Name^) then
											begin
												RefRow:=qr;
												RefCol:=qc;
												break
											end
							end
		end;

	procedure cellstr(cell: PCell; var txt: string);
		type str2 = string[2];

		procedure subst(s1: char; s2: str2);

			begin
				w:=pos(s1,txt);
				while w>0 do
					begin
						txt:=StrPLeft(txt,w-1)+s2+StrPRight(txt,length(txt)-w);
						w:=pos(s1,txt)
					end
			end;

		begin
			with cell^ do
				case Typ of
				CTYPE_TEXT:
					txt:=Data.Txt^;
				CTYPE_CONST:
					Val2Txt(Data.Konst^.Value,txt,Data.Konst^.FPts,Format,nil);
				CTYPE_FORMULA:
					if Data.Formula^.Error=FE_OK then
						Val2Txt(Data.Formula^.Value,txt,Data.Formula^.FPts,Format,nil)
					else
						txt:=Error2Txt(Data.Formula^.Error);
				else
					txt:=''
				end;
			if lex then
				begin
					subst('„','ae');
					subst('”','oe');
					subst('','ue');
					subst('Ž','Ae');
					subst('™','Oe');
					subst('š','Ue');
					subst('ž','ss');
					subst(' ','a');
					subst('…','a');
					subst('ƒ','a');
					subst('†','a');
					subst('‘','„');
					subst('‚','e');
					subst('Š','e');
					subst('ˆ','e');
					subst('‰','e');
					subst('¡','i');
					subst('','i');
					subst('Œ','i');
					subst('‹','i');
					subst('¢','o');
					subst('•','o');
					subst('“','o');
					subst('£','u');
					subst('—','u');
					subst('–','u');
					subst('¤','n');
					subst('‡','c');
					subst('˜','y');
					subst('’','Ž');
					subst('','E');
					subst('¥','N');
					subst('¶','A')
				end;
			if not(cse) then txt:=StrPUpper(txt)
		end;

	function cellval(cell: PCell; pnum: PNumber): TNumber;

		begin
			with cell^ do
				case Typ of
				CTYPE_CONST:
					rval:=Data.Konst^.Value;
				CTYPE_FORMULA:
					if Data.Formula^.Error=FE_OK then rval:=Data.Formula^.Value
					else
						rval:=0.0;
				else
					rval:=0.0
				end;
			if absl then
				if pnum<>nil then
					if abs(rval)<>abs(pnum^) then
						begin
							rval:=abs(rval);
							pnum^:=abs(pnum^)
						end;
			cellval:=rval
		end;

	function compare: boolean;
		label _equal1,_equal2;

		begin
			compare:=false;
			if cell^.Data.Value=0 then
				begin
					if qcell^.Data.Value=0 then goto _equal1;
					if not(ebeg) then compare:=true
				end
			else
				if qcell^.Data.Value=0 then
					begin
						if ebeg then compare:=true
					end
				else
					begin
						if (cell^.Typ<>CTYPE_TEXT) and (qcell^.Typ<>CTYPE_TEXT) then
							begin
								vval:=cellval(cell,nil);
								qval:=cellval(qcell,@vval);
								if n1up then
									begin
										if qval<vval then
											begin
												compare:=true;
												exit
											end
										else
											if qval>vval then exit
									end
								else
									begin
										if vval<qval then
											begin
												compare:=true;
												exit
											end
										else
											if vval>qval then exit
									end;
								goto _equal1
							end;
						if (nrs>0) then
							begin
								if cell^.Typ<>CTYPE_TEXT then
									begin
										if nrs=2 then compare:=true;
										exit
									end
								else
									if qcell^.Typ<>CTYPE_TEXT then
										begin
											if nrs=1 then compare:=true;
											exit
										end
							end;
						cellstr(cell,vtxt);
						cellstr(qcell,qtxt);
						if n1up then
							begin
								if qtxt<vtxt then
									begin
										compare:=true;
										exit
									end
								else
									if qtxt>vtxt then exit
							end
						else
							begin
								if vtxt<qtxt then
									begin
										compare:=true;
										exit
									end
								else
									if vtxt>qtxt then exit
							end;
						{ erste strings gleich }
						_equal1:
						if n2<0 then exit;
						cell2:=PCell(longint(cell)+n2offs);
						qcell2:=PCell(longint(qcell)+n2offs);
						if cell2^.Data.Value=0 then
							begin
								if qcell2^.Data.Value=0 then goto _equal2;
								if not(ebeg) then compare:=true;
								exit
							end
						else
							if qcell2^.Data.Value=0 then
								begin
									if ebeg then compare:=true;
									exit
								end;
						if (cell2^.Typ<>CTYPE_TEXT) and (qcell2^.Typ<>CTYPE_TEXT) then
							begin
								vval:=cellval(cell2,nil);
								qval:=cellval(qcell2,@vval);
								if n2up then
									begin
										if qval<vval then
											begin
												compare:=true;
												exit
											end
										else
											if qval>vval then exit
									end
								else
									begin
										if vval<qval then
											begin
												compare:=true;
												exit
											end
										else
											if vval>qval then exit
									end;
								goto _equal2
							end;
						if (nrs>0) then
							begin
								if cell2^.Typ<>CTYPE_TEXT then
									begin
										if nrs=2 then compare:=true;
										exit
									end
								else
									if qcell2^.Typ<>CTYPE_TEXT then
										begin
											if nrs=1 then compare:=true;
											exit
										end
							end;
						cellstr(cell2,vtxt);
						cellstr(qcell2,qtxt);
						if n2up then
							begin
								if qtxt<vtxt then
									begin
										compare:=true;
										exit
									end
								else
									if qtxt>vtxt then exit
							end
						else
							begin
								if vtxt<qtxt then
									begin
										compare:=true;
										exit
									end
								else
									if vtxt>qtxt then exit
							end;
						{ zweite strings gleich }
						_equal2:
						if n3<0 then exit;
						cell2:=PCell(longint(cell)+n3offs);
						qcell2:=PCell(longint(qcell)+n3offs);
						if cell2^.Data.Value=0 then
							begin
								if qcell2^.Data.Value=0 then exit;
								if not(ebeg) then compare:=true;
								exit
							end
						else
							if qcell2^.Data.Value=0 then
								begin
									if ebeg then compare:=true;
									exit
								end;
						if (cell2^.Typ<>CTYPE_TEXT) and (qcell2^.Typ<>CTYPE_TEXT) then
							begin
								vval:=cellval(cell2,nil);
								qval:=cellval(qcell2,@vval);
								if n3up then
									begin
										if qval<vval then compare:=true
									end
								else
									if vval<qval then compare:=true;
								exit
							end;
						if (nrs>0) then
							begin
								if cell2^.Typ<>CTYPE_TEXT then
									begin
										if nrs=2 then compare:=true;
										exit
									end
								else
									if qcell2^.Typ<>CTYPE_TEXT then
										begin
											if nrs=1 then compare:=true;
											exit
										end
							end;
						cellstr(cell2,vtxt);
						cellstr(qcell2,qtxt);
						if n3up then
							begin
								if qtxt<vtxt then compare:=true
							end
						else
							if vtxt<qtxt then compare:=true
					end
		end;

	begin
		if n2<0 then
			begin
				n2:=n3;
				n2up:=n3up;
				n3:=-1
			end;
		if n1<0 then
			begin
				n1:=n2;
				n1up:=n2up;
				n2:=n3;
				n2up:=n3up;
				n3:=-1
			end;
		GetBlock(dblock^.GetText,false,rs,cs,re,ce,dummy,dummy);
		if (rows and (cs=ce)) or (not(rows) and (rs=re)) or (n1<0) then
			begin
				Application^.Bing;
				exit
			end;
		BusyMouse;
		if rows then anz:=ce-cs
		else
			anz:=re-rs;
		getmem(p,(anz+1) shl 1);
		if p=nil then goto _raus;
		cmin:=cs;
		cmax:=ce;
		RowsClearOverflow(rs,re,cmin,cmax);
		if rows then
			for q:=0 to anz do p^[q]:=cs+q
		else
			for q:=0 to anz do p^[q]:=rs+q;
		offs:=CELLSIZE*longint(Parms.Columns+1);
		valid:=false;
		if rows then
			begin
				cell:=GetCell(n1,cs);
				if n2>=0 then
					begin
						qcell:=GetCell(n2,cs);
						n2offs:=longint(qcell)-longint(cell)
					end;
				if n3>=0 then
					begin
						qcell:=GetCell(n3,cs);
						n3offs:=longint(qcell)-longint(cell)
					end;
				h:=1;
				repeat
					h:=h*3+1
				until h>(anz+1);
				repeat
					h:=h div 3;
					for i:=h to anz do
						begin
							v:=p^[i];
							j:=i;
							cell:=GetCell(n1,p^[j-h]);
							qcell:=GetCell(n1,v);
							while compare do
								begin
									p^[j]:=p^[j-h];
									dec(j,h);
									if j<h then goto _rweiter;
									cell:=GetCell(n1,p^[j-h])
								end;
							_rweiter:
							p^[j]:=v
						end
				until h=1;
				for x:=0 to anz do
					begin
						q:=p^[x];
						if q<>x+cs then
							begin
								cell:=GetCell(rs,x+cs);
								qcell:=GetCell(rs,q);
								for y:=rs to re do
									begin
										acell:=cell^;
										if noattr then
											begin
												cell^.Data:=qcell^.Data;
												cell^.Flags:=qcell^.Flags;
												cell^.Typ:=qcell^.Typ;
												cell^.Resvd:=qcell^.Resvd;
												cell^.Format:=qcell^.Format;
												qcell^.Data:=acell.Data;
												qcell^.Flags:=acell.Flags;
												qcell^.Typ:=acell.Typ;
												qcell^.Resvd:=acell.Resvd;
												qcell^.Format:=acell.Format;
											end
										else
											begin
												cell^:=qcell^;
												qcell^:=acell
											end;
										check_cellvars(y,x+cs,y,q);
										inc(longint(cell),offs);
										inc(longint(qcell),offs)
									end;
								for w:=x+1 to anz do
									if p^[w]=x+cs then
										begin
											p^[w]:=q;
											break
										end;
								valid:=true
							end
					end
			end
		else
			begin
				cell:=GetCell(rs,n1);
				if n2>=0 then
					begin
						qcell:=GetCell(rs,n2);
						n2offs:=longint(qcell)-longint(cell)
					end;
				if n3>=0 then
					begin
						qcell:=GetCell(rs,n3);
						n3offs:=longint(qcell)-longint(cell)
					end;
				h:=1;
				repeat
					h:=h*3+1
				until h>(anz+1);
				repeat
					h:=h div 3;
					for i:=h to anz do
						begin
							v:=p^[i];
							j:=i;
							cell:=GetCell(p^[j-h],n1);
							qcell:=GetCell(v,n1);
							while compare do
								begin
									p^[j]:=p^[j-h];
									dec(j,h);
									if j<h then goto _cweiter;
									cell:=GetCell(p^[j-h],n1)
								end;
							_cweiter:
							p^[j]:=v
						end
				until h=1;
				for y:=0 to anz do
					begin
						q:=p^[y];
						if q<>y+rs then
							begin
								cell:=GetCell(y+rs,cs);
								qcell:=GetCell(q,cs);
								for x:=cs to ce do
									begin
										acell:=cell^;
										if noattr then
											begin
												cell^.Data:=qcell^.Data;
												cell^.Flags:=qcell^.Flags;
												cell^.Typ:=qcell^.Typ;
												cell^.Resvd:=qcell^.Resvd;
												cell^.Format:=qcell^.Format;
												qcell^.Data:=acell.Data;
												qcell^.Flags:=acell.Flags;
												qcell^.Typ:=acell.Typ;
												qcell^.Resvd:=acell.Resvd;
												qcell^.Format:=acell.Format;
											end
										else
											begin
												cell^:=qcell^;
												qcell^:=acell
											end;
										check_cellvars(y+rs,x,q,x);
										inc(longint(cell),CELLSIZE);
										inc(longint(qcell),CELLSIZE)
									end;
								for w:=y+1 to anz do
									if p^[w]=y+rs then
										begin
											p^[w]:=q;
											break
										end;
								valid:=true
							end
					end
			end;
		freemem(p,(anz+1) shl 1);
		RowsCheckOverflow(rs,re,cmin,cmax);
		if valid then
			begin
				SetDirty;
				DrawCells(rs,cmin,re,cmax);
				AutoCalculate(true)
			end;
		Application^.Bing;
		_raus:
		ArrowMouse
	end;


procedure TCalcWindow.SetBorder(ltyp,lcol,rtyp,rcol,otyp,ocol,utyp,ucol,htyp,hcol,vtyp,vcol,gtyp,gcol: integer);
	var cell : PCell;
	    x,y,
	    rs,re,
	    cs,ce: integer;
	    offs : longint;

	procedure SetCell(cell: PCell; x,y,ltyp,lcol,rtyp,rcol,otyp,ocol,utyp,ucol,htyp,hcol,vtyp,vcol: integer);

		begin
			with cell^.Border do
				begin
					if ltyp>=0 then
						begin
							Left:=(ltyp shl 4) or lcol;
							if (x>0) and ((x=cs) or (rtyp<1)) then
								PCell(longint(cell)-CELLSIZE)^.Border.Right:=(PCell(longint(cell)-CELLSIZE)^.Border.Right and $f0) or lcol
						end;
					if rtyp>=0 then
						begin
							Right:=(rtyp shl 4) or rcol;
							if x<Parms.Columns then
								PCell(longint(cell)+CELLSIZE)^.Border.Left:=(PCell(longint(cell)+CELLSIZE)^.Border.Left and $f0) or rcol
						end;
					if otyp>=0 then
						begin
							Top:=(otyp shl 4) or ocol;
							if (y>0) and ((y=rs) or (utyp<1)) then
								PCell(longint(cell)-offs)^.Border.Bottom:=(PCell(longint(cell)-offs)^.Border.Bottom and $f0) or ocol
						end;
					if utyp>=0 then
						begin
							Bottom:=(utyp shl 4) or ucol;
							if y<Parms.Rows then
								PCell(longint(cell)+offs)^.Border.Top:=(PCell(longint(cell)+offs)^.Border.Top and $f0) or ucol
						end;
					if htyp>=0 then Hor:=(htyp shl 4) or hcol;
					if vtyp>=0 then Vert:=(vtyp shl 4) or vcol
				end
		end;

	begin
		with Parms.Cursor do
			if Block then
				begin
					rs:=RowStart;
					re:=RowEnd;
					cs:=ColStart;
					ce:=ColEnd
				end
			else
				begin
					rs:=Row;
					re:=Row;
					cs:=Col;
					ce:=Col
				end;
		offs:=CELLSIZE*longint(Parms.Columns+1);
		for y:=rs to re do
			begin
				cell:=GetCell(y,cs);
				for x:=cs to ce do
					begin
						SetCell(cell,x,y,ltyp,lcol,rtyp,rcol,otyp,ocol,utyp,ucol,htyp,hcol,vtyp,vcol);
						inc(longint(cell),CELLSIZE)
					end
			end;
		cell:=GetCell(rs,cs);
		for y:=rs to re do
			begin
				SetCell(cell,cs,y,gtyp,gcol,-1,0,-1,0,-1,0,-1,0,-1,0);
				inc(longint(cell),offs)
			end;
		cell:=GetCell(rs,ce);
		for y:=rs to re do
			begin
				SetCell(cell,ce,y,-1,0,gtyp,gcol,-1,0,-1,0,-1,0,-1,0);
				inc(longint(cell),offs)
			end;
		cell:=GetCell(rs,cs);
		for x:=cs to ce do
			begin
				SetCell(cell,x,rs,-1,0,-1,0,gtyp,gcol,-1,0,-1,0,-1,0);
				inc(longint(cell),CELLSIZE)
			end;
		cell:=GetCell(re,cs);
		for x:=cs to ce do
			begin
				SetCell(cell,x,re,-1,0,-1,0,-1,0,gtyp,gcol,-1,0,-1,0);
				inc(longint(cell),CELLSIZE)
			end;
		SetDirty;
		DrawCells(Max(rs-1,0),Max(cs-1,0),Min(re+1,Parms.Rows),Min(ce+1,Parms.Columns))
	end;


function TCalcWindow.Num2Hour(num: TNumber): integer;

	begin
		if (num<=0.0) or (num>=109573.0) then Num2Hour:=0
		else
			Num2Hour:=trunc(frac(num)*24.0)
	end;


function TCalcWindow.Num2Minute(num: TNumber): integer;

	begin
		if (num<=0.0) or (num>=109573.0) then Num2Minute:=0
		else
			Num2Minute:=trunc(frac(frac(num+TIMEROUND)*24.0)*60.0)
	end;


function TCalcWindow.Num2Second(num: TNumber): integer;

	begin
		if (num<=0.0) or (num>=109573.0) then Num2Second:=0
		else
			Num2Second:=trunc(frac(frac(frac(num+TIMEROUND)*24.0)*60.0)*60.0)
	end;


function TCalcWindow.IsSchaltjahr(year: integer): boolean;

	begin
		if (year mod 4)=0 then
			begin
				if (year mod 100)=0 then
					begin
						if (year mod 400)=0 then IsSchaltjahr:=true
						else
							IsSchaltjahr:=false
					end
				else
					IsSchaltjahr:=true
			end
		else
			IsSchaltjahr:=false
	end;


function TCalcWindow.Days(year: integer): integer;

	begin
		if IsSchaltjahr(year) then Days:=366
		else
			Days:=365
	end;


function TCalcWindow.Num2Year(num: TNumber): longint;
	var q,y: longint;
	    d  : integer;

	begin
		y:=1900;
		if (num>0.0) and (num<109573.0) then
			begin
				q:=trunc(num);
				d:=Days(y);
				while q>=d do
					begin
						dec(q,d);
						inc(y);
						d:=Days(y)
					end
			end;
		Num2Year:=y
	end;


function TCalcWindow.Num2Month(num: TNumber): integer;
	var q,y: longint;
	    d,m: integer;
	    p  : PIntegerArray;

	begin
		if (num<=0.0) or (num>=109573.0) then Num2Month:=1
		else
			begin
				y:=1900;
				q:=trunc(num);
				d:=Days(y);
				while q>=d do
					begin
						dec(q,d);
						inc(y);
						d:=Days(y)
					end;
				if d=366 then p:=@months366
				else
					p:=@months365;
				m:=0;
				while q>=p^[m] do
					begin
						dec(q,p^[m]);
						inc(m)
					end;
				Num2Month:=m+1
			end
	end;


function TCalcWindow.Num2Day(num: TNumber): integer;
	var q,y: longint;
	    d,
	    m,t: integer;
	    p  : PIntegerArray;

	begin
		if (num<=0.0) or (num>=109573.0) then Num2Day:=1
		else
			begin
				y:=1900;
				q:=trunc(num);
				d:=Days(y);
				while q>=d do
					begin
						dec(q,d);
						inc(y);
						d:=Days(y)
					end;
				if d=366 then p:=@months366
				else
					p:=@months365;
				m:=0;
				while q>=p^[m] do
					begin
						dec(q,p^[m]);
						inc(m)
					end;
				Num2Day:=q+1
			end
	end;


function TCalcWindow.Today: TNumber;
	var t: longint;

	begin
		t:=gettime;
		Today:=Date(((t shr 25) and $7f)+1980,(t shr 21) and $f,(t shr 16) and $1f)
	end;


function TCalcWindow.Now: TNumber;
	var t: longint;

	begin
		t:=gettime;
		Now:=Today+Time((t shr 11) and $1f,(t shr 5) and $3f,(t and $1f) shl 1)
	end;


function TCalcWindow.CountDays(Year: longint; Month,Day: integer): longint;
	var ret,y: longint;
	    m,d  : integer;
	    p    : PIntegerArray;

	begin
		if Year<=1900 then Year:=1900;
		if Month<1 then Month:=1;
		if Month>12 then Month:=12;
		if Day<1 then Day:=1;
		ret:=-1;
		y:=1900;
		while y<Year do
			begin
				inc(ret,Days(y));
				inc(y)
			end;
		if IsSchaltjahr(Year) then p:=@months366
		else
			p:=@months365;
		m:=1;
		while m<Month do
			begin
				inc(ret,p^[m-1]);
				inc(m)
			end;
		if Day>p^[m-1] then CountDays:=ret+p^[m-1]
		else
			CountDays:=ret+Day
	end;


function TCalcWindow.Weekday(num: TNumber; typ: integer): integer;
	var l: longint;

	begin
		if num>=109573.0 then
			begin
				Weekday:=0;
				exit
			end;
		l:=CountDays(Num2Year(num),Num2Month(num),Num2Day(num)) mod 7;
		case typ of
		1:
			if l=6 then Weekday:=1
			else
				Weekday:=l+2;
		2:
			Weekday:=l+1
		else
			Weekday:=l
		end
	end;


function TCalcWindow.Date(Year: longint; Month,Day: integer): TNumber;

	begin
		Date:=CountDays(Year,Month,Day)
	end;


function TCalcWindow.Time(Hour,Minute,Second: integer): TNumber;

	begin
		Time:=std1*Hour+min1*Minute+sek1*Second
	end;


function TCalcWindow.DDGetPath: string;

	begin
		DDGetPath:=GetWindowFilename
	end;


procedure TCalcWindow.OLGAGetInfo(OrgID,InfoNr: integer);
	label _fehler,_ende;

	var p    : pointer;
	    pipe : Pipearray;
	    s,t,a: string;
	    hdl,q: integer;
	    dlen,
	    res,l: longint;
	    err  : boolean;
	    hdr  : TOLGAInfHeader;
	    blck : TOLGABlockHeader;
	    dt   : DOSTIME;
	    icn  : ICONBLK;
	    picn : ICONBLKPtr;
	    tp   : PTree;
	    obj  : PObj;

	function bwrite(var buffer; count: longint): boolean;

		begin
			if fwrite(hdl,count,@buffer)<>count then
				begin
					bwrite:=true;
					err:=true
				end
			else
				bwrite:=false
		end;

	function blckwrite: boolean;

		begin
			blckwrite:=bwrite(blck,sizeof(blck))
		end;

	begin
		err:=false;
		s:=CreateUniqueTempFilename(GetTexelTempDir);
		res:=fcreate(s,0);
		if res<0 then exit;
		hdl:=integer(res);
		with hdr do
			begin
				Magic:='OLGA';
				Version:=$0100;
				Skip:=0
			end;
		if bwrite(hdr,sizeof(hdr)) then goto _fehler;
		t:=infobuf.Autor+#0;
		blck.ID:='AUTH';
		blck.Length:=length(t);
		if blckwrite then goto _fehler;
		if bwrite(t[1],length(t)) then goto _fehler;
		blck.ID:='REM ';
		with infobuf do blck.Length:=length(Rem1)+length(Rem2)+length(Rem3)+length(Rem4)+4;
		if blckwrite then goto _fehler;
		t:=infobuf.Rem1+#0;
		if bwrite(t[1],length(t)) then goto _fehler;
		t:=infobuf.Rem2+#0;
		if bwrite(t[1],length(t)) then goto _fehler;
		t:=infobuf.Rem3+#0;
		if bwrite(t[1],length(t)) then goto _fehler;
		t:=infobuf.Rem4+#0;
		if bwrite(t[1],length(t)) then goto _fehler;
		a:=StrPTrimF(infobuf.Stichwort);
		t:='';
		q:=pos(',',a);
		while q>0 do
			begin
				t:=t+StrPLeft(a,q-1)+',';
				a:=StrPTrimF(StrPRight(a,length(a)-q));
				q:=pos(',',a)
			end;
		t:=t+a+#0;
		blck.ID:='KEYW';
		blck.Length:=length(t);
		if blckwrite then goto _fehler;
		if bwrite(t[1],length(t)) then goto _fehler;
		blck.ID:='DATE';
		blck.length:=sizeof(DOSTIME);
		if blckwrite then goto _fehler;
		dt.time:=word(infobuf.Last and $ffff);
		dt.date:=word(infobuf.Last shr 16);
		if bwrite(dt,sizeof(DOSTIME)) then goto _fehler;
		tp:=Application^.GetAddr(RTSTART);
		if tp=nil then goto _ende;
		obj:=@tp^[RTSTICON];
		if obj=nil then goto _ende;
		picn:=obj^.ob_spec.icon_blk;
		if picn^.ib_ptext=nil then l:=0
		else
			l:=strlen(picn^.ib_ptext);
		dlen:=((picn^.ib_wicon+7) shr 3)*picn^.ib_hicon;
		blck.ID:='ICON';
		blck.Length:=sizeof(ICONBLK)+(dlen shl 1)+l+1;
		if blckwrite then goto _fehler;
		icn:=picn^;
		icn.ib_pmask:=nil;
		icn.ib_pdata:=nil;
		icn.ib_ptext:=nil;
		if bwrite(icn,sizeof(ICONBLK)) then goto _fehler;
		if bwrite(picn^.ib_pmask^,dlen) then goto _fehler;
		if bwrite(picn^.ib_pdata^,dlen) then goto _fehler;
		if l=0 then
			begin
				if bwrite(l,1) then goto _fehler
			end
		else
			if bwrite(picn^.ib_ptext^,l+1) then goto _fehler;
		_ende:
		blck.ID:=#0#0#0#0;
		blck.Length:=0;
		blckwrite;
		_fehler:
		fclose(hdl);
		if err then exit;
		GlobalAlloc(p,256);
		if p=nil then
			begin
				fdelete(s);
				exit
			end;
		StrPCopy(p,s);
		pipe[0]:=OLGA_INFO;
		pipe[1]:=Application^.apID;
		pipe[2]:=0;
		pipe[3]:=integer(HiWord(p));
		pipe[4]:=integer(LoWord(p));
		pipe[5]:=InfoNr;
		pipe[6]:=0;
		pipe[7]:=0;
		appl_write(OrgID,16,@pipe)
	end;


procedure TCalcWindow.OLGAUpdated(OrgID,SrvID,InfoNr: integer; Link: string);
	var pe: PEmbedded;

	begin
		pe:=Embedded;
		while pe<>nil do
			begin
				if pe^.GetFile=Link then pe^.Update;
				pe:=pe^.Next
			end;
		SetDirty
	end;


procedure TCalcWindow.OLGARenameLink(OrgID: integer; OldLink,NewLink: string);
	var pe: PEmbedded;

	begin
		pe:=Embedded;
		while pe<>nil do
			begin
				if pe^.GetFile=OldLink then pe^.SetFile(NewLink);
				pe:=pe^.Next
			end;
		SetDirty
	end;


procedure TCalcWindow.OLGALinkBroken(OrgID: integer; Link: string);
	var pe: PEmbedded;

	begin
		pe:=Embedded;
		while pe<>nil do
			begin
				if pe^.GetFile=Link then pe^.BreakLink;
				pe:=pe^.Next
			end;
		SetDirty
	end;


procedure TCalcWindow.PRNChanged(Device,Action: integer);

	begin
		if Action<>1 then exit; { ... }
		if prnt=nil then exit;
		if not(prnt^.IsAvailable(false)) then exit;
		if prnt^.GetDevice=Device then
			if pagepreview<>nil then pagepreview^.Update(true)
	end;


function TCalcWindow.NewNumFormat(s: string): integer;
	var pfm: PFormat;
	    sel: integer;

	begin
		NewNumFormat:=0;
		new(pfm);
		if pfm<>nil then
			begin
				pfm^.Name:=NewStr(s);
				pfm^.Group:=1;
				pfm^.Index:=1000+UsrFormats^.Count;
				UsrFormats^.Insert(pfm);
				NewNumFormat:=pfm^.Index;
				SetDirty;
				if numformats=nil then exit;
				if numformats^.pfcb=nil then exit;
				if numformats^.Attr.Status<>ws_Open then exit;
				sel:=numformats^.pfcb^.GetSelection;
				if (sel<0) or (sel>1) then
					begin
						numformats^.pfcb^.SetSelection(1);
						numformats^.pfcb^.ScrollBar^.SetPosition(0)
					end
				else
					numformats^.pfcb^.Work;
				numformats^.pfcb^.fbox^.SetSelection(numformats^.pfcb^.fbox^.List^.Count-1);
				numformats^.pfcb^.fbox^.ScrollBar^.SetPosition(numformats^.pfcb^.fbox^.List^.Count)
			end
	end;


procedure TCalcWindow.DeselectAllObjects;
	var p: PEmbedded;

	begin
		p:=Embedded;
		while p<>nil do
			begin
				p^.Deselect;
				p:=p^.Next
			end
	end;


function TCalcWindow.FirstSelectedObject: PEmbedded;
	var p: PEmbedded;

	begin
		FirstSelectedObject:=nil;
		p:=Embedded;
		while p<>nil do
			begin
				if p^.IsSelected then FirstSelectedObject:=p;
				p:=p^.Next
			end
	end;


procedure TCalcWindow.Embed(poi: POLGAObjectInfo; srvid: integer; ow,oh,x100,y100,dlen: longint; dat: pointer; poabuf: PEmbedBuf; pdb: PDiagrammBuf; xyvalid,prop,embd,drty,istad,prntflg,lckflg: boolean);
	var pe: PEmbedded;
	    r : GRECT;
	    s : string;

	begin
		poi^.ClientData:=0;
		GetSheetRect(r);
		s:=StrPPas(poi^.Filename);
		if (StrPUpper(StrPRight(s,4))='.TAD') or istad then pe:=new(PEmbeddedTAD,Init(@self,poi,s,srvid,r.X,r.Y,0,0,ow,oh,x100,y100,dlen,dat,xyvalid,true,prop,embd,prntflg,lckflg,poabuf,pdb))
		else
			new(pe,Init(@self,poi,s,srvid,r.X,r.Y,0,0,ow,oh,x100,y100,dlen,dat,xyvalid,true,prop,embd,prntflg,lckflg,poabuf));
		if pe<>nil then
			if drty then SetDirty;
		Top
	end;


procedure TCalcWindow.CallID4Server(fname: string);

	begin
		{ ... }
	end;


procedure TCalcWindow.Unembed(srvID: integer);
	var p: PEmbedded;

	begin
		if srvID<0 then exit;
		p:=Embedded;
		while p<>nil do
			begin
				if p^.ServerID=srvID then p^.Unembed;
				p:=p^.Next
			end
	end;


function TCalcWindow.PasteObject: boolean;
	label _raus,_fehler;

	var res,dummy,
	    w100,h100: longint;
	    hdl,typ,q: integer;
	    fname    : string;
	    flen     : byte;
	    tci      : TCookieID;
	    oabuf    : TEmbedBuf;
	    tdb      : TDiagrammBuf;
	    dbvalid,
	    skal,umbr,
	    prntflg,
	    prop,embd: boolean;
	    r        : GRECT;
	    pet      : PEmbeddedText;
	    pei      : PEmbeddedIMG;

	function bread(var buffer; count: longint): boolean;

		begin
			bread:=(fread(hdl,count,@buffer)<>count)
		end;

	begin
		PasteObject:=false;
		if Clipboard=nil then exit;
		if not(Clipboard^.OpenClipboard(false)) then exit;
		if not(Clipboard^.IsClipboardFormatAvailable('tob')) then
			begin
				{ sofort tempor„re Dateien verwenden !!! }
{				if Clipboard^.IsClipboardFormatAvailable('img') then
					begin
						if grafik<>nil then grafik^.Load(Clipboard^.GetClipboardFilename+'img');
						PasteObject:=true
					end
				else if Clipboard^.IsClipboardFormatAvailable('txt') then
					begin
						if textobj<>nil then textobj^.Load(Clipboard^.GetClipboardFilename+'txt');
						PasteObject:=true
					end
				else if Clipboard^.IsClipboardFormatAvailable('asc') then
					begin
						if textobj<>nil then textobj^.Load(Clipboard^.GetClipboardFilename+'asc');
						PasteObject:=true
					end
				else
					begin
						if TexelApp.OLETypes<>nil then
							if TexelApp.OLETypes^.Count>0 then
								for q:=0 to TexelApp.OLETypes^.Count-1 do
									if StrPUpper(POLEType(TexelApp.OLETypes^.At(q))^.Ext)<>'.TXL' then
										if Clipboard^.IsClipboardFormatAvailable(POLEType(TexelApp.OLETypes^.At(q))^.Ext) then
											begin
												EmbedNewObject(CutRightF(Clipboard^.GetClipboardFilename,1)+StrPLower(POLEType(TexelApp.OLETypes^.At(q))^.Ext),0,0,0,0,0,nil,nil,nil,false,false,false,true,false);
												PasteObject:=true;
												exit
											end
					end; !!! }
				goto _raus
			end;
		res:=fopen(Clipboard^.GetClipboardFilename+'tob',FO_READ);
		if res<0 then goto _raus;
		hdl:=integer(res);
		if bread(tci,4) then goto _fehler;
		if tci<>'TXLO' then goto _fehler;
		if bread(typ,2) then goto _fehler;
		if bread(flen,1) then goto _fehler;
		if flen>0 then
			if bread(fname[1],flen) then goto _fehler;
		fname[0]:=chr(flen);
		if bread(dummy,4) then goto _fehler;
		GetSheetRect(r);
		if bread(oabuf,sizeof(oabuf)) then goto _fehler;
		if bread(w100,4) then goto _fehler;
		if bread(h100,4) then goto _fehler;
		if bread(prop,sizeof(boolean)) then goto _fehler;
		if bread(embd,sizeof(boolean)) then goto _fehler;
		if bread(prntflg,sizeof(boolean)) then goto _fehler;
		case typ of
		0:
			EmbedNewObject(fname,w100,h100,0,0,0,nil,@oabuf,nil,false,prop,embd,true,false,prntflg,false);
		1:
			begin
				if bread(skal,sizeof(boolean)) then goto _fehler;
				new(pei,Init(@self,fname,r.X,r.Y,0,0,w100,h100,0,0,0,nil,false,true,prop,embd,skal,prntflg,false,@oabuf));
				if pei<>nil then SetDirty
			end;
		2:
			begin
				if bread(umbr,sizeof(boolean)) then goto _fehler;
				new(pet,Init(@self,fname,r.X,r.Y,0,0,w100,h100,0,0,0,nil,false,true,prop,embd,umbr,prntflg,false,@oabuf));
				if pet<>nil then SetDirty
			end;
		3:
			begin
				if bread(dbvalid,sizeof(boolean)) then goto _fehler;
				if dbvalid then
					begin
						if bread(tdb,sizeof(TDiagrammBuf)) then goto _fehler;
						EmbedNewObject(fname,w100,h100,0,0,0,nil,@oabuf,@tdb,false,prop,embd,true,true,prntflg,false)
					end
				else
					EmbedNewObject(fname,w100,h100,0,0,0,nil,@oabuf,nil,false,prop,embd,true,true,prntflg,false)
			end
		end;
		PasteObject:=true;
		_fehler:
		fclose(hdl);
		_raus:
		Clipboard^.CloseClipboard
	end;


procedure TCalcWindow.EmbedNewObject(fname: string; w100,h100,x100,y100,dlen: longint; dat: pointer; poabuf: PEmbedBuf; pdb: PDiagrammBuf; xyvalid,prop,embd,drty,istad,prntflg,lckflg: boolean);
	var exts,s: string;
	    ret   : longint;
	    q,hdl : integer;
	    P     : PEmbedded;
	    pipe  : Pipearray;
	    pc    : pointer;
	    pc2   : PChar;
	    toi   : PTexelObjectInfo;

	begin
		if Application^.OLGAManager<0 then exit;
		if length(fname)=0 then exit;
		exts:=StrPLeft(GetExtension(fname),4);
		if length(exts)=0 then exit;
		while length(exts)<4 do exts:=exts+#0;
		p:=Embedded;
		while p<>nil do
			begin
				exts:=exts+p^.GetExt(true,false);
				p:=p^.Next
			end;
		GlobalAlloc(pc,256);
		if pc=nil then exit;
		StrPCopy(pc,StrPUpper(exts));
		pipe[0]:=OLGA_ACTIVATE;
		pipe[1]:=Application^.apID;
		pipe[2]:=0;
		pipe[3]:=integer(HiWord(pc));
		pipe[4]:=integer(LoWord(pc));
		pipe[5]:=length(exts) shr 2;
		pipe[6]:=0;
		pipe[7]:=0;
		appl_write(Application^.OLGAManager,16,@pipe);
		evnt_timer(200,0);
		if not(Exist(fname)) then
			if (dlen>0) and (dat<>nil) then
				begin
					s:=GetTexelTempDir+GetFilename(fname,true);
					while Exist(s) do
						s:=GetTexelTempDir+GetFilename(GetTempFilename,false)+GetExtension(fname);
					ret:=fcreate(s,0);
					if ret>=0 then
						begin
							hdl:=integer(ret);
							if fwrite(hdl,dlen,dat)=dlen then fname:=s;
							fclose(hdl)
						end
				end;
		GlobalAlloc(pointer(toi),sizeof(TTexelObjectInfo));
		if toi=nil then exit;
		fillchar(toi^,sizeof(TTexelObjectInfo),0);
		toi^.oi.Filename:=@toi^.fname;
		StrPCopy(toi^.oi.Filename,fname);
		toi^.oi.ClientGEMPB:=@AES_pb;
		toi^.oi.ClientData:=longint(@self);
		toi^.oi.CBLock:=-16000;
		toi^.oi.CBCount:=5;
		toi^.oi.cbColorTable:=@TexelApp.ColorTable;
		toi^.oi.cbClientID:=Application^.apID;
		toi^.oi.cbServerID:=-1;
		toi^.x100:=x100;
		toi^.y100:=y100;
		toi^.w100:=w100;
		toi^.h100:=h100;
		toi^.DataLen:=dlen;
		toi^.Data:=dat;
		if poabuf<>nil then toi^.oabuf:=poabuf^;
		toi^.prop:=prop;
		toi^.embd:=embd;
		toi^.dirty:=drty;
		toi^.xyvalid:=xyvalid;
		toi^.istad:=istad;
		if pdb<>nil then toi^.diabuf:=pdb^
		else
			toi^.diabuf.rb1:=0;
		toi^.prntflg:=prntflg;
		toi^.lckflg:=lckflg;
		pipe[0]:=OLGA_EMBED;
		pipe[1]:=Application^.apID;
		pipe[2]:=0;
		pipe[3]:=GetOLGAGroup;
		pipe[4]:=integer(HiWord(toi));
		pipe[5]:=integer(LoWord(toi));
		pc2:=PChar(@pipe[6]);
		for q:=1 to 4 do
			begin
				pc2^:=upchar(exts[q]);
				inc(longint(pc2))
			end;
		appl_write(Application^.OLGAManager,16,@pipe)
	end;


procedure TCalcWindow.SetPercent(prc: real);
	var lp: longint;

	begin
		if prc<(655.36*MINPERCENT) then prc:=655.36*MINPERCENT;
		if prc>(655.36*MAXPERCENT) then prc:=655.36*MAXPERCENT;
		if TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set) then
			begin
				wnd_prnt_set^.scale:=round(prc);
				with AES_pb do
					begin
						control^[0]:=205;
						control^[1]:=1;
						control^[2]:=1;
						control^[3]:=2;
						control^[4]:=0;
						intin^[0]:=8;
						addrin^[0]:=TexelApp.prnt_dialog;
						addrin^[1]:=wnd_prnt_set;
						_crystal(@AES_pb)
					end
			end
		else
			begin
				lp:=round(prc/655.36);
				prnbuffer.percent:=ltoa(lp);
				if prnt<>nil then
					if prnt^.ppcb<>nil then
						if prnt^.ppcb^.Edit<>nil then prnt^.ppcb^.Edit^.SetText(ltoa(lp))
			end;
		SetDirty
	end;


function TCalcWindow.GetPercent: real;

	begin
		if TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set) then GetPercent:=wnd_prnt_set^.scale
		else
			GetPercent:=atol(prnbuffer.percent)*655.36
	end;


function TCalcWindow.IsNormalPrintArea: boolean;

	begin
		if TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set) then
			IsNormalPrintArea:=((prnRangeFlag=1) or ((prnRangeFlag=0) and (length(StrPTrimF(Parms.psbuffer.bereich))=0)))
		else
			IsNormalPrintArea:=((prnbuffer.alles=bf_Checked) or ((prnbuffer.pblock=bf_Checked) and (length(StrPTrimF(Parms.psbuffer.bereich))=0)))
	end;


function TCalcWindow.IsBlockPrintArea: boolean;

	begin
		if TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set) then
			IsBlockPrintArea:=(prnRangeFlag=0)
		else
			IsBlockPrintArea:=(prnbuffer.pblock=bf_Checked)
	end;


function TCalcWindow.GetPageFrom: integer;

	begin
		if TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set) then GetPageFrom:=wnd_prnt_set^.first_page
		else
			GetPageFrom:=atol(prnbuffer.von)
	end;


function TCalcWindow.GetPageTo: integer;

	begin
		if TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set) then GetPageTo:=wnd_prnt_set^.last_page
		else
			GetPageTo:=atol(prnbuffer.bis)
	end;


function TCalcWindow.GetCopies(hdl: integer): integer;

	begin
		if TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set) then
			begin
				GetCopies:=wnd_prnt_set^.no_copies;
				if hdl<>0 then
					if vCopies(hdl,-1)>1 then GetCopies:=1
			end
		else
			GetCopies:=atol(prnbuffer.copies)
	end;


function TCalcWindow.DoFeed: boolean;

	begin
		if TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set) then DoFeed:=true
		else
			DoFeed:=(prnbuffer.feed=bf_Checked)
	end;


function TCalcWindow.DoSheet: boolean;

	begin
		if TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set) then DoSheet:=true
		else
			DoSheet:=(prnbuffer.sheet=bf_Checked)
	end;


function TCalcWindow.ClearDispList: boolean;
	var num: integer;

	begin
		if not(TexelApp.ExtPrnSel(wnd_prnt_set,TexelApp.app_prnt_set)) then
			num:=prnbuffer.device
		else
			case wnd_prnt_set^.driver_id of
			11..20:
				num:=DEV_PLOTTER;
			21..30:
				num:=DEV_PRINTER;
			31..40:
				num:=DEV_META;
			41..50:
				num:=DEV_CAMERA;
			51..60:
				num:=DEV_TABLET;
			61..80:
				num:=DEV_MEMORY;
			81..90:
				num:=DEV_FAX;
			91..99:
				num:=DEV_IMG;
			else
				num:=-1
			end;
		ClearDispList:=((num=DEV_PRINTER) or (num=DEV_META) or (num=DEV_PLOTTER) or (num=DEV_CAMERA))
	end;


procedure TCalcWindow.SetTextColor(ntc: integer);
	var cell : PCell;
	    x,y,
	    rs,cs,
	    cmin,
	    cmax,
	    re,ce: integer;

	begin
		if Attr.Status<>ws_Open then exit;
		if (ntc<0) or (ntc>15) then ntc:=Black;
		with Parms.Cursor do
			if Block then
				begin
					rs:=RowStart;
					re:=RowEnd;
					cs:=ColStart;
					ce:=ColEnd
				end
			else
				begin
					rs:=Row;
					re:=Row;
					cs:=Col;
					ce:=Col
				end;
		cmin:=cs;
		cmax:=ce;
		RowsClearOverflow(rs,re,cmin,cmax);
		for y:=rs to re do
			begin
				cell:=GetCell(y,cs);
				for x:=cs to ce do
					begin
						cell^.TxtVal.Color:=ntc;
						inc(longint(cell),CELLSIZE)
					end
			end;
		RowsCheckOverflow(rs,re,cmin,cmax);
		SetDirty;
		DrawCells(rs,cmin,re,cmax)
	end;


procedure TCalcWindow.SetCellColor(nc: integer);
	var x,y : integer;
	    cell: PCell;

	begin
		if Attr.Status<>ws_Open then exit;
		if (nc<0) or (nc>15) then nc:=Black;
		with Parms.Cursor do
			if Block then
				begin
					for y:=RowStart to RowEnd do
						begin
							cell:=GetCell(y,ColStart);
							for x:=ColStart to ColEnd do
								begin
									if nc=White then
										begin
											cell^.Color:=Black;
											cell^.Interior:=FIS_HOLLOW;
											cell^.Style:=8
										end
									else
										begin
											cell^.Color:=nc;
											if cell^.Interior=FIS_HOLLOW then cell^.Interior:=FIS_SOLID
										end;
									inc(longint(cell),CELLSIZE)
								end
						end;
					DrawCells(RowStart,ColStart,RowEnd,ColEnd)
				end
			else
				begin
					cell:=GetCell(Row,Col);
					if nc=White then
						begin
							cell^.Color:=Black;
							cell^.Interior:=FIS_HOLLOW;
							cell^.Style:=8
						end
					else
						begin
							cell^.Color:=nc;
							if cell^.Interior=FIS_HOLLOW then cell^.Interior:=FIS_SOLID
						end;
					DrawCells(Row,Col,Row,Col);
					if ppbox<>nil then
						begin
							if nc=White then ppbox^.SetSelection(0,false)
							else
								if cell^.Interior=FIS_SOLID then ppbox^.SetSelection(7,false)
						end
				end;
		SetDirty
	end;


procedure TBlockBox.Work;
	var s  : string;
	    sel: integer;

	begin
		if List=nil then exit;
		if List^.Count=0 then exit;
		if ed<>nil then
			begin
				sel:=GetSelection;
				if sel<0 then exit;
				s:=StrPTrimF(PString(List^.At(sel))^);
				sel:=RPos(' ',s);
				if sel>0 then s:=StrPRight(s,length(s)-sel);
				ed^.SetText(s)
			end
	end;


procedure TBlockDialog.EndDlg(Indx: integer; DblClick: boolean);

	begin
		inherited EndDlg(Indx,DblClick);
		if DblClick then
			if pbb^.TestIndex(Indx) then
				begin
					OK;
					Cont:=false;
					Result:=RTBOK
				end
	end;


procedure TCalcScroller.RedrawParent(XDif,YDif: longint);
	var p    : PCalcWindow;
	    r    : GRECT;
	    valid: boolean;

	begin
		p:=PCalcWindow(Window);
		HideMouse;
		valid:=p^.FirstWorkRect(r);
		while valid do
			begin
				if XDif<>0 then p^.PaintNames(r);
				if YDif<>0 then p^.PaintNumbers(r);
				valid:=p^.NextWorkRect(r)
			end;
		vs_clip(Application^.vdiHandle,CLIP_ON,SysInfo.Desktop.A2);
		ShowMouse
	end;


procedure TTexelApplication.SetupVDI;
	var dummy: integer;

	begin
		inherited SetupVDI;
		if SpeedoActive then vst_kern(vdiHandle,0,1,dummy,dummy)
	end;


procedure TTexelApplication.FontID2Index(var index: integer);
	label _weiter;

	var w: integer;

	begin
		index:=vst_font(vdiHandle,index);
		if Fonts<>nil then
			if Fonts^.Count>0 then
				for w:=0 to Fonts^.Count-1 do
					if PFont(Fonts^.At(w))^.index=index then
						begin
							index:=w;
							goto _weiter
						end;
		index:=0;
		_weiter:
		SetSystemFont(vdiHandle,w,w,w,w)
	end;


procedure TTexelApplication.FontSize2Index(fntindx: integer; var index: integer);
	var pf: PFont;
	    q : integer;

	begin
		if Fonts=nil then index:=0
		else
			begin
				pf:=PFont(Fonts^.At(fntindx));
				if pf^.SizeCount=0 then
					begin
						if index>127 then index:=123
						else
							if index<4 then index:=0
							else
								dec(index,4)
					end
				else
					begin
						for q:=pf^.SizeCount-1 downto 0 do
							if index<=pf^.Sizes^[q] then
								begin
									if index=pf^.Sizes^[q] then index:=pf^.SizeCount-q-1
									else
										if q<pf^.SizeCount-1 then index:=pf^.SizeCount-q-2
										else
											index:=0;
									exit
								end;
						index:=pf^.SizeCount-1
					end
			end
	end;


procedure TTexelApplication.InitInstance;
	label _fehler,_palerr,_pfehler,_pfadgefunden;

	type PRGBArray = ^TRGBArray;
	     TRGBArray = array [0..511] of ARRAY_3;

	var txt,fname,
	    fparm,
	    fdescr1,
	    fdescr2  : string;
	    q,opc,gr,
	    level,
	    hdl,e    : integer;
	    bufsize,
	    dummy,
	    aret,
	    res,w    : longint;
	    palbuf   : PRGBArray;
	    buf      : PByteArray;
	    pf       : PFunction;
	    pcg      : PCategory;
	    pfm      : PFormat;
	    opp      : boolean;
	    tp       : PTree;
	    startup  : PDialog;
	    st,sta   : PStatic;
	    ewrkout  : workout_ARRAY;
	    pipe     : Pipearray;

	procedure SetAction(s: string);
	
		begin
			if sta<>nil then sta^.SetText(s+'...')
		end;

	begin
		startup:=nil;
		sccsid:='@(#)Spreadsheet/Texel '+VtoS(TEXELVER)+' ('+TEXELDATE+'), Copyright 1994-97 Thomas Much.'#0;
		{$IFDEF ENGLISH}
		Attr.Country:=UK;
		{$ELSE}
		{$IFDEF FRENCH}
		Attr.Country:=FRA;
		{$ELSE}
		Attr.Country:=FRG;
		{$ENDIF}
		{$ENDIF}
		{$IFNDEF BETA}
		if not(KeyCorrect('','')) then
			begin
				Alert(nil,1,STOP,MESSAGE_STARTUP_UNREG,BUTTON_OK);
				Quit;
				exit
			end;
		{$ENDIF}
		if ((Attr.MaxPX+1) div Attr.charSWidth<80) or ((Attr.MaxPY+1) div Attr.charSHeight<25) then
			begin
				Alert(nil,1,STOP,MESSAGE_STARTUP_SCREEN,BUTTON_OK);
				Quit;
				exit
			end;
		randomize;
		{$IFNDEF DEMO}
		{$IFDEF BETA}
		if gettime>EXPIRE then
			begin
				Alert(nil,1,STOP,MESSAGE_STARTUP_BETA,BUTTON_OK);
				Quit;
				exit
			end;
		{$ENDIF}
		{$ENDIF}
		txt:=GetEnv('BROWSER');
		if length(txt)>0 then
			begin
				txt:=StrPUpper(GetFilename(txt,false));
				Browser:=txt+StrPSpace(8-length(txt))
			end
		else
			Browser:='CAB     ';
		ColFX:=(Attr.Colors>LWhite);
		NVDIVersion:=0;
		if GetCookie('NVDI',w) then
			if w<>0 then
				NVDIVersion:=PNVDIStruct(w)^.version;
		vq_extnd(vdiHandle,1,ewrkout);
		ScaleIMG:=bTst(ewrkout[30],1);
		fnerror:=FE_OK;
		SheetCount:=0;
		mstimer:=TEXELTIMER;
		ExtResource:=false;
		GSActive:=false;
		ddfiles:=nil;
		importscrap:=nil;
		specialchars:=nil;
		BusyMouse;
		opp:=OpenPrivateProfile(TEXELINF);
		if opp then level:=GetPrivateProfileInt('Texel','Level',7,TEXELINF)
		else
			level:=8;
		DataPath:=GetPrivateProfileString('Setup','DataPath','',TEXELINF);
		if length(DataPath)=0 then
			begin
				txt:=TEXELAPPNAME;
				if shel_find(txt)<>0 then
					begin
						txt:=GetPath(txt);
						if length(txt)>0 then
							begin
								DataPath:=txt;
								goto _pfadgefunden
							end
					end;
				if apPath<>nil then DataPath:=apPath^;
				_pfadgefunden:
				if PathExist(DataPath+TEXELDATAPATH) then DataPath:=DataPath+TEXELDATAPATH
			end;
		LoadResource(DataPath+TEXELRSC,'');
		if Status=em_RscNotFound then
			begin
				Quit;
				exit
			end;
		if not(LoadExtResource(DataPath+TEXELRSC2)) then
			begin
				Error(em_RscNotFound);
				Quit;
				exit
			end;
		if Exist(DataPath+TEXELPALETTE) then
			begin
				res:=fopen(DataPath+TEXELPALETTE,FO_READ);
				if res>=0 then
					begin
						palbuf:=nil;
						hdl:=integer(res);
						w:=fseek(0,hdl,2);
						if w<6 then goto _palerr;
						if (w mod 6)<>0 then goto _palerr;
						getmem(palbuf,w);
						if palbuf=nil then goto _palerr;
						if fseek(0,hdl,0)<0 then goto _palerr;
						if fread(hdl,w,palbuf)<>w then goto _palerr;
						for q:=0 to Min(Attr.Colors,w div 6)-1 do vs_color(vdiHandle,q,palbuf^[q]);
						_palerr:
						fclose(hdl);
						if palbuf<>nil then freemem(palbuf,w)
					end
			end;
		ColorTable.Count:=Attr.Colors;
		for q:=0 to ColorTable.Count do vq_color(vdiHandle,q,1,ColorTable.Colors[q].RGB);
		{$IFDEF ENGLISH}
		BubbleHelpActive:=false;
		{$ELSE}
		{$IFDEF FRENCH}
		BubbleHelpActive:=false;
		{$ENDIF}
		{$ENDIF}
		ArrowMouse;
		{$IFDEF DEMO}
		ActivateExtResource;
		new(startup,Init(nil,'',RTDEMO));
		if startup<>nil then
			begin
				new(PButton,Init(startup,RTDOK,id_OK,true,BUBBLE_EASTEREGG));
				ExecDialog(startup)
			end;
		DeactivateExtResource;
		{$ENDIF}
		sta:=nil;
		new(startup,Init(nil,'',RTSTART));
		if startup<>nil then
			begin
				new(st,Init(startup,RTSTVERSION,13,false,''));
				if st<>nil then st^.SetText('Version '+VtoS(TEXELVER));
				new(sta,Init(startup,RTSTACTION,30,false,''));
				SetAction('');
				with startup^ do
					begin
						Attr.Style:=0;
						MakeWindow;
						WMRedraw(Work.X,Work.Y,Work.W,Work.H)
					end
			end;
		SetAction(STARTUP_INF);
		SliceMouse;
		setupbuffer.opennew:=GetPrivateProfileInt('Setup','OpenNew',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		setupbuffer.loaddoc:=GetPrivateProfileInt('Setup','LoadDoc',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		setupbuffer.nothing:=GetPrivateProfileInt('Setup','Nothing',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		setupbuffer.fullsize:=GetPrivateProfileInt('Setup','FullSize',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		setupbuffer.wysiwyg:=GetPrivateProfileInt('Setup','WYSIWYG',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		setupbuffer.recalc:=GetPrivateProfileInt('Setup','Recalc',bf_Checked,TEXELINF);
		SliceMouseNext;
		setupbuffer.online:=GetPrivateProfileInt('Setup','Online',bf_Checked,TEXELINF);
		SliceMouseNext;
		setupbuffer.bak:=GetPrivateProfileInt('Setup','Backup',bf_Checked,TEXELINF);
		SliceMouseNext;
		setupbuffer.toolbar:=GetPrivateProfileInt('Setup','Toolbar',bf_Checked,TEXELINF);
		SliceMouseNext;
		{$IFDEF FRENCH}
		setupbuffer.currency:=GetPrivateProfileInt('Setup','Currency',3,TEXELINF);
		{$ELSE}
		{$IFDEF ENGLISH}
		setupbuffer.currency:=GetPrivateProfileInt('Setup','Currency',1,TEXELINF);
		{$ELSE}
		setupbuffer.currency:=GetPrivateProfileInt('Setup','Currency',0,TEXELINF);
		{$ENDIF}
		{$ENDIF}
		SliceMouseNext;
		setupbuffer.overflow:=GetPrivateProfileInt('Setup','Overflow',bf_Checked,TEXELINF);
		SliceMouseNext;
		setupbuffer.bottomline:=GetPrivateProfileInt('Setup','BottomLine',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		setupbuffer.pixw:=GetPrivateProfileInt('Setup','WYSIWYG.PixW',282,TEXELINF);
		SliceMouseNext;
		setupbuffer.pixh:=GetPrivateProfileInt('Setup','WYSIWYG.PixH',282,TEXELINF);
		SliceMouseNext;
		setupbuffer.cursorwrap:=GetPrivateProfileInt('Setup','CursorWrap',bf_Checked,TEXELINF);
		SliceMouseNext;
		setupbuffer.xinputmode:=GetPrivateProfileInt('Setup','XInputMode',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		setupbuffer.closercancel:=GetPrivateProfileInt('Setup','CancelOnClose',bf_Checked,TEXELINF);
		SliceMouseNext;
		setupbuffer.sizerrange:=GetPrivateProfileString('Setup','SizerRange','1',TEXELINF);
		SliceMouseNext;
		setupbuffer.floatpoint:=GetPrivateProfileString('Setup','FloatingPoint','2',TEXELINF);
		SliceMouseNext;
		setupbuffer.history:=GetPrivateProfileString('Setup','History','4',TEXELINF);
		SliceMouseNext;
		UseExtPrn:=(GetPrivateProfileInt('Setup','ExtPrnSel',bf_Checked,TEXELINF)=bf_Checked);
		SliceMouseNext;
		UseNewToolbar:=(GetPrivateProfileInt('Setup','NewToolbar',bf_Checked,TEXELINF)=bf_Checked);
		SliceMouseNext;
		CheckHistory:=(GetPrivateProfileInt('Setup','CheckHistory',bf_Checked,TEXELINF)=bf_Checked);
		SliceMouseNext;
		setupbuffer.stdrows:=GetPrivateProfileString('CalcWindowDefaults','Rows','64',TEXELINF);
		SliceMouseNext;
		setupbuffer.stdcolumns:=GetPrivateProfileString('CalcWindowDefaults','Columns','32',TEXELINF);
		SliceMouseNext;
		setupbuffer.stdcolwidth:=GetPrivateProfileString('CalcWindowDefaults','StdColWidth','10',TEXELINF);
		SliceMouseNext;
		setupbuffer.stdfsize:=GetPrivateProfileInt('CalcWindowDefaults','StdFontSize',10,TEXELINF);
		SliceMouseNext;
		setupbuffer.stdfont:=GetPrivateProfileInt('CalcWindowDefaults','StdFont',0,TEXELINF);
		SliceMouseNext;
		setupbuffer.autocalc:=GetPrivateProfileInt('CalcWindowDefaults','AutoCalc',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdprnbuffer.sheet:=GetPrivateProfileInt('Printer','Sheet',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdprnbuffer.sw:=GetPrivateProfileInt('Printer','BlackWhite',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		stdprnbuffer.feed:=GetPrivateProfileInt('Printer','Feed',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdprnbuffer.driver:=GetPrivateProfileInt('Printer','Driver',0,TEXELINF);
		SliceMouseNext;
		stdprnbuffer.device:=GetPrivateProfileInt('Printer','Device',1,TEXELINF);
		SliceMouseNext;
		stdprnbuffer.copies:=ltoa(GetPrivateProfileIntRange('Printer','Copies',1,1,99,TEXELINF));
		SliceMouseNext;
		stdprnbuffer.von:=ltoa(GetPrivateProfileIntRange('Printer','Von',1,MINPAGES,MAXPAGESOLD,TEXELINF));
		SliceMouseNext;
		stdprnbuffer.bis:=ltoa(GetPrivateProfileIntRange('Printer','Bis',999,MINPAGES,MAXPAGESOLD,TEXELINF));
		SliceMouseNext;
		stdprnbuffer.percent:=ltoa(GetPrivateProfileIntRange('Printer','Percent',100,MINPERCENT,MAXPERCENT,TEXELINF));
		stdprnbuffer.prcindx:=0;
		SliceMouseNext;
		stdprnbuffer.pblock:=GetPrivateProfileInt('Printer','PBlock',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdprnbuffer.alles:=GetPrivateProfileInt('Printer','Alles',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		stdprnbuffer.block:=GetPrivateProfileInt('Printer','Block',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		stdprnbuffer.papier:=GetPrivateProfileInt('Printer','Papier',0,TEXELINF);
		SliceMouseNext;
		ascbuf.hor:=GetPrivateProfileInt('Import','Hor',bf_Checked,TEXELINF);
		SliceMouseNext;
		ascbuf.vert:=GetPrivateProfileInt('Import','Vert',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		ascbuf.rcTxt:=GetPrivateProfileString('Import','rcTxt','"13,10"',TEXELINF);
		SliceMouseNext;
		ascbuf.rcval:=GetPrivateProfileInt('Import','rcVal',0,TEXELINF);
		SliceMouseNext;
		ascbuf.cellTxt:=GetPrivateProfileString('Import','cellTxt','"9"',TEXELINF);
		SliceMouseNext;
		ascbuf.cellval:=GetPrivateProfileInt('Import','cellVal',0,TEXELINF);
		SliceMouseNext;
		ascbuf.textTxt:=GetPrivateProfileString('Import','textTxt','"34"',TEXELINF);
		SliceMouseNext;
		ascbuf.textval:=GetPrivateProfileInt('Import','textVal',0,TEXELINF);
		SliceMouseNext;
		ascbuf.quote:=GetPrivateProfileInt('Import','Quote',bf_Checked,TEXELINF);
		SliceMouseNext;
		ascbuf.numbers:=GetPrivateProfileInt('Import','Numbers',0,TEXELINF);
		SliceMouseNext;
		ascbuf.filter:=GetPrivateProfileInt('Import','Filter',0,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.oben:=GetPrivateProfileString('Page Setup','Oben','0',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.unten:=GetPrivateProfileString('Page Setup','Unten','0',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.links:=GetPrivateProfileString('Page Setup','Links','0',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.rechts:=GetPrivateProfileString('Page Setup','Rechts','0',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.kopf:=GetPrivateProfileString('Page Setup','Kopf','0',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.fuss:=GetPrivateProfileString('Page Setup','Fuss','0',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.bereich:=GetPrivateProfileString('Page Setup','Bereich','',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.hleft:=GetPrivateProfileString('Page Setup','hLeft','""',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.hmid:=GetPrivateProfileString('Page Setup','hMid','""',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.hright:=GetPrivateProfileString('Page Setup','hRight','""',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.fleft:=GetPrivateProfileString('Page Setup','fLeft','""',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.fmid:=GetPrivateProfileString('Page Setup','fMid','""',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.fright:=GetPrivateProfileString('Page Setup','fRight','""',TEXELINF);
		SliceMouseNext;
		stdpsbuffer.hcenter:=GetPrivateProfileInt('Page Setup','hCenter',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.vcenter:=GetPrivateProfileInt('Page Setup','vCenter',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.gitter:=GetPrivateProfileInt('Page Setup','Gitter',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.rows:=GetPrivateProfileInt('Page Setup','Rows',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.columns:=GetPrivateProfileInt('Page Setup','Columns',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.num1:=GetPrivateProfileInt('Page Setup','Num1',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.num2:=GetPrivateProfileInt('Page Setup','Num2',bf_Unchecked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.hlefton:=GetPrivateProfileInt('Page Setup','hLeftOn',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.hcenteron:=GetPrivateProfileInt('Page Setup','hCenterOn',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.hrighton:=GetPrivateProfileInt('Page Setup','hRightOn',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.flefton:=GetPrivateProfileInt('Page Setup','fLeftOn',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.fcenteron:=GetPrivateProfileInt('Page Setup','fCenterOn',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.frighton:=GetPrivateProfileInt('Page Setup','fRightOn',bf_Checked,TEXELINF);
		SliceMouseNext;
		stdpsbuffer.images:=GetPrivateProfileInt('Page Setup','Images',bf_Checked,TEXELINF);
		SliceMouseNext;
		WebASH:=GetPrivateProfileString('Web','ASH',STRING_WEB_HOMEPAGE,TEXELINF);
		SliceMouseNext;
		WebMail:=GetPrivateProfileString('Web','Support',STRING_WEB_SUPPORT,TEXELINF);
		SliceMouseNext;
		regname:=GetPrivateProfileString('Beta','Name','',TEXELINF);
		SliceMouseNext;
		regkey:=GetPrivateProfileString('Beta','Key','',TEXELINF);
		ArrowMouse;
		SetAction(STARTUP_PATHS);
		BusyMouse;
		for q:=0 to PFMAX do
			begin
				LastPath[q]:='';
				LastFile[q]:=''
			end;
		res:=fopen(GetHomeDir(false)+'defaults\'+TEXELPATHS,0);
		if res<0 then res:=fopen(GetHomeDir(false)+TEXELPATHS,0);
		if res>=0 then
			begin
				hdl:=integer(res);
				if fread(hdl,2,@q)<>2 then goto _pfehler;
				for w:=0 to Min(q,PFMAX) do
					begin
						if fread(hdl,1,@txt[0])<>1 then goto _pfehler;
						if ord(txt[0])>0 then
							if fread(hdl,ord(txt[0]),@txt[1])<>ord(txt[0]) then goto _pfehler;
						CorrectPath(txt);
						LastPath[w]:=txt;
						if fread(hdl,1,@txt[0])<>1 then goto _pfehler;
						if ord(txt[0])>0 then
							if fread(hdl,ord(txt[0]),@txt[1])<>ord(txt[0]) then goto _pfehler;
						LastFile[w]:=txt
					end;
				_pfehler:
				fclose(hdl)
			end;
		ArrowMouse;
		if length(LastPath[11])=0 then LastPath[11]:=GetTempDir;
		if length(LastFile[11])=0 then LastFile[11]:='gemfile.gem';
		if length(LastPath[14])=0 then LastPath[14]:=GetTempDir;
		if length(LastFile[14])=0 then LastFile[14]:='page0001.img';
		SetAction(STARTUP_STRUCTS);
		with ascbuf do
			begin
				rcTxt:=StrPMid(rcTxt,2,length(rcTxt)-2);
				cellTxt:=StrPMid(cellTxt,2,length(cellTxt)-2);
				textTxt:=StrPMid(textTxt,2,length(textTxt)-2)
			end;
		with stdpsbuffer do
			begin
				hleft:=StrPMid(hleft,2,length(hleft)-2);
				hmid:=StrPMid(hmid,2,length(hmid)-2);
				hright:=StrPMid(hright,2,length(hright)-2);
				fleft:=StrPMid(fleft,2,length(fleft)-2);
				fmid:=StrPMid(fmid,2,length(fmid)-2);
				fright:=StrPMid(fright,2,length(fright)-2)
			end;
		if setupbuffer.wysiwyg=bf_Checked then
			begin
				Attr.PixW:=setupbuffer.pixw;
				Attr.PixH:=setupbuffer.pixh
			end;
		if (length(regname)<5) or (length(regkey)<6) or not(KeyCorrect(regname,regkey)) then
			begin
				regname:='';
				regkey:=''
			end;
		{$IFNDEF BETA}
		regname:='';
		regkey:='';
		{$ENDIF}
		{$IFDEF DEMO}
		regname:='';
		regkey:='';
		{$ENDIF}
		LoadIcon(RTICONS,RTICALC);
		LoadMenu(RTMENU);
		prnt_dialog:=nil;
		fnt_dialog:=nil;
		app_prnt_set:=nil;
		if NoFontSel then
			begin
				tp:=GetAddr(RTPOPUPS);
				if tp<>nil then
					with tp^[tp^[RTPFORMCELL].ob_head] do ob_state:=ob_state or DISABLED
			end;
		with setupbuffer do
			if (opennew=bf_Unchecked) and (loaddoc=bf_Unchecked) and (nothing=bf_Unchecked) then nothing:=bf_Checked;
		if setupbuffer.xinputmode=bf_Checked then Attr.Style:=Attr.Style or as_XInputMode;
		if setupbuffer.closercancel=bf_Checked then Attr.Style:=Attr.Style or as_CancelOnClose;
		GEMScriptID:=-1;
		GlobalAlloc(helpbuf,768+sizeof(TGSInfo));
		if helpbuf=nil then
			begin
				filebuf:=nil;
				mailbuf:=nil;
				HelpID:=-1;
				WebID:=-1;
				GSInfo:=nil
			end
		else
			begin
				mailbuf:=pointer(longint(helpbuf)+256);
				filebuf:=pointer(longint(helpbuf)+512);
				HelpID:=appl_find('ST-GUIDE');
				WebID:=appl_find(Browser);
				if WebID>=0 then
					begin
						pipe[0]:=CAB_SUPPORT;
						pipe[1]:=apID;
						pipe[2]:=0;
						pipe[3]:=0;
						pipe[4]:=0;
						pipe[5]:=0;
						pipe[6]:=0;
						pipe[7]:=0;
						appl_write(WebID,16,@pipe);
						WebID:=-1
					end;
				GSInfo:=PGSInfo(longint(helpbuf)+768);
				with GSInfo^ do
					begin
						Len:=sizeof(TGSInfo);
						Version:=$0100;
						Msgs:=GSM_COMMAND;
						Ext:=#0#0#0#0
					end
			end;
		new(about,Init(@self,RTMABOUT,nil,false));
		new(PNew,Init(@self,K_CTRL,Ctrl_N,RTMNEW,RTM2));
		new(opennewdoc,Init(@self,K_CTRL,Ctrl_O,RTMOPEN,RTM2));
		ActivateExtResource;
		new(abruf,Init(@self,RTMABRUF,RTPOPUPS2,RTP2ABRUF));
		DeactivateExtResource;
		if abruf<>nil then
			begin
				SetAction(STARTUP_HISTORY);
				res:=fopen(GetHomeDir(false)+'defaults\'+TEXELHISTORY,0);
				if res<0 then res:=fopen(GetHomeDir(false)+TEXELHISTORY,0);
				if res>=0 then
					begin
						hdl:=integer(res);
						if fread(hdl,2,@q)<>2 then goto _fehler;
						if q>0 then
							for w:=0 to q-1 do
								begin
									if fread(hdl,1,@txt[0])<>1 then goto _fehler;
									if ord(txt[0])>0 then
										if fread(hdl,ord(txt[0]),@txt[1])<>ord(txt[0]) then goto _fehler;
									if not(CheckHistory) then abruf^.Add(txt,false)
									else
										begin
											aret:=fopen(txt,FO_READ);
											if aret>=0 then
												begin
													fclose(integer(aret));
													abruf^.Add(txt,false)
												end
										end
								end;
						_fehler:
						fclose(hdl)
					end;
				abruf^.Dirty:=false
			end;
		SetAction(STARTUP_MENUS);
		new(openurl,Init(@self,K_ALT,Alt_U,RTMURLOPEN,RTM2));
		if openurl<>nil then openurl^.Disable;
		new(import,Init(@self,RTMIMPORT,RTPOPUPS,RTPIMPORT));
		if import<>nil then
			begin
				import^.ascii:=nil;
				import^.gdbc:=nil;
				import^.quelle:=''
			end;
		new(PSpecialChars,Init(@self,K_SHIFT,Shift_Ins,RTMSPECIALCHARS,RTM4));
		new(POptions,Init(@self,K_CTRL+K_SHIFT,Ctrl_E,RTMOPTIONS,RTM4));
		new(PSaveOpt,Init(@self,K_CTRL+K_SHIFT,Ctrl_S,RTMSAVEOPTIONS,RTM4));
		new(PSaveWork,Init(@self,RTMSAVEWORK,nil,false));
		new(webhelp,Init(@self,RTMHELPASH,nil,false));
		if webhelp<>nil then webhelp^.Disable;
		new(websupport,Init(@self,RTMHELPSUPPORT,nil,false));
		if websupport<>nil then websupport^.Disable;
		new(help1,Init(@self,RTMHELPONHELP,nil,false));
		if help1<>nil then
			if not(HelpAvailable(false)) then help1^.Disable;
		new(help2,Init(@self,RTMHELPCONTEXT,nil,false));
		if help2<>nil then
			if not(HelpAvailable(false)) then help2^.Disable;
		new(help3,Init(@self,RTMHELPCONTENTS,nil,false));
		if help3<>nil then
			if not(HelpAvailable(false)) then help3^.Disable;
		new(help4,Init(@self,RTMHELPINDEX,nil,false));
		if help4<>nil then
			if not(HelpAvailable(false)) then help4^.Disable;
		new(help5,Init(@self,K_CTRL,Ctrl_Help,RTMHELPITEM,RTM5));
		if help5<>nil then
			if not(HelpAvailable(false)) then help5^.Disable;
		ScanFonts(vdiHandle,Attr.sysFonts+Attr.addFonts,Fonts);
		if level>=8 then
			begin
				FontID2Index(setupbuffer.stdfont);
				FontSize2Index(setupbuffer.stdfont,setupbuffer.stdfsize)
			end;
		OLETypes:=nil;
		new(Functions,Init(50,10));
		new(Categories,Init(20,5));
		new(FormCategories,Init(15,5));
		new(Formats,Init(50,10));
		new(UsrForm,Init(30,20));
		if (Functions=nil) or (Categories=nil) or (FormCategories=nil) or (Formats=nil) or (UsrForm=nil) then
			begin
				Alert(nil,1,STOP,MESSAGE_GENERAL_MEMORY,BUTTON_OK);
				Quit;
				exit
			end;
		if not(Exist(DataPath+TEXELDAT)) then
			begin
				Alert(nil,1,STOP,MESSAGE_STARTUP_FOUND1+CompressPath(DataPath+TEXELDAT,78)+MESSAGE_STARTUP_FOUND2,BUTTON_OK);
				Quit;
				exit
			end;
		buf:=GetMemBuffer(16384,128,bufsize);
		if buf=nil then
			begin
				Alert(nil,1,STOP,MESSAGE_STARTUP_LOAD1+TEXELDAT+MESSAGE_STARTUP_LOAD2,BUTTON_OK);
				Quit;
				exit
			end;
		Functions^.Sort:=true;
		Functions^.CaseSensitive:=false;
		Categories^.Sort:=false;
		FormCategories^.Sort:=false;
		Formats^.Sort:=false;
		UsrForm^.Sort:=false;
		new(pcg);
		if pcg<>nil then
			begin
				pcg^.Group:=0;
				pcg^.Name:=NewStr('  '+STRING_ALL+' '#0);
				Categories^.Insert(pcg)
			end;
		SetAction(STARTUP_DAT);
		BusyMouse;
		res:=fopen(TexelApp.DataPath+TEXELDAT,FO_READ);
		if res<0 then
			begin
				Alert(nil,1,STOP,MESSAGE_STARTUP_LOAD1+TEXELDAT+MESSAGE_STARTUP_LOAD2,BUTTON_OK);
				Quit;
				exit
			end;
		hdl:=integer(res);
		txt:='';
		repeat
			res:=fread(hdl,bufsize,buf);
			if res>0 then
				for w:=0 to res-1 do
					if buf^[w]=CR then
						begin
							StrPTrim(txt);
							if length(txt)>0 then
								begin
									if txt[1]='#' then
										begin
											q:=pos(' ',txt);
											if q>0 then
												begin
													new(pcg);
													if pcg<>nil then
														begin
															pcg^.Group:=atol(StrPMid(txt,2,q-2));
															pcg^.Name:=NewStr('  '+StrPLeft(StrPTrimF(StrPRight(txt,length(txt)-q)),20)+' '#0);
															Categories^.Insert(pcg)
														end
												end
										end
									else
										if txt[1]<>';' then
											begin
												q:=pos(';',txt);
												if q>0 then
													begin
														fdescr1:=StrPTrimF(StrPRight(txt,length(txt)-q));
														txt:=StrPTrimF(StrPLeft(txt,q-1));
														q:=pos('|',fdescr1);
														if q>0 then
															begin
																fdescr2:=StrPTrimF(StrPRight(fdescr1,length(fdescr1)-q));
																fdescr1:=StrPTrimF(StrPLeft(fdescr1,q-1))
															end
														else
															fdescr2:=''
													end
												else
													begin
														fdescr1:='';
														fdescr2:=''
													end;
												q:=pos(' ',txt);
												if q=0 then continue;
												fname:=StrPLeft(txt,q-1);
												txt:=StrPTrimF(StrPRight(txt,length(txt)-q));
												q:=pos(' ',txt);
												if q=0 then continue;
												fparm:=StrPLeft(txt,q-1);
												txt:=StrPTrimF(StrPRight(txt,length(txt)-q));
												q:=pos(' ',txt);
												if q>0 then
													begin
														gr:=atol(StrPRight(txt,length(txt)-q));
														opc:=atol(StrPLeft(txt,q-1))
													end
												else
													begin
														gr:=0;
														opc:=atol(txt)
													end;
												if opc<1000 then continue;
												new(pf);
												if pf<>nil then
													begin
														pf^.Opcode:=opc;
														pf^.Group:=gr;
														pf^.Name:=NewStr(fname);
														if pf^.Name=nil then dispose(pf)
														else
															begin
																pf^.Parms:=NewStr(fparm);
																if pf^.Parms=nil then
																	begin
																		DisposeStr(pf^.Name);
																		dispose(pf)
																	end
																else
																	begin
																		pf^.Descr1:=NewStr(fdescr1);
																		pf^.Descr2:=NewStr(fdescr2);
																		Functions^.Insert(pf);
																		if opc=NT_SUMME then SumName:=fname
																	end
															end
													end
											end
								end;
							txt:=''
						end
					else
						if buf^[w]>=32 then txt:=txt+chr(buf^[w])
		until res<>bufsize;
		fclose(hdl);
		SetAction(STARTUP_USRDAT);
		res:=fopen(TexelApp.DataPath+TEXELUSRDAT,FO_READ);
		if res>=0 then
			begin
				txt:='';
				hdl:=integer(res);
				repeat
					res:=fread(hdl,bufsize,buf);
					if res>0 then
						for w:=0 to res-1 do
							if buf^[w]=CR then
								begin
									StrPTrim(txt);
									if length(txt)>0 then
										if txt[1]<>';' then
											begin
												q:=pos(';',txt);
												if q>0 then
													begin
														fdescr1:=StrPTrimF(StrPRight(txt,length(txt)-q));
														txt:=StrPTrimF(StrPLeft(txt,q-1));
														q:=pos('|',fdescr1);
														if q>0 then
															begin
																fdescr2:=StrPTrimF(StrPRight(fdescr1,length(fdescr1)-q));
																fdescr1:=StrPTrimF(StrPLeft(fdescr1,q-1))
															end
														else
															fdescr2:=''
													end
												else
													begin
														fdescr1:='';
														fdescr2:=''
													end;
												q:=pos(' ',txt);
												if q=0 then continue;
												fname:=StrPLeft(txt,q-1);
												opc:=atol(StrPTrimF(StrPRight(txt,length(txt)-q)));
												if not(Between(opc,0,22000)) then continue;
												new(pf);
												if pf<>nil then
													begin
														pf^.Opcode:=10000+opc;
														pf^.Group:=12;
														pf^.Name:=NewStr(fname);
														if pf^.Name=nil then dispose(pf)
														else
															begin
																pf^.Parms:=NewStr('#*');
																if pf^.Parms=nil then
																	begin
																		DisposeStr(pf^.Name);
																		dispose(pf)
																	end
																else
																	begin
																		pf^.Descr1:=NewStr(fdescr1);
																		pf^.Descr2:=NewStr(fdescr2);
																		Functions^.Insert(pf)
																	end
															end
													end
											end;
									txt:=''
								end
							else
								if buf^[w]>=32 then txt:=txt+chr(buf^[w])
				until res<>bufsize;
				fclose(hdl)
			end;
		SetAction(STARTUP_FRM);
		res:=fopen(TexelApp.DataPath+TEXELFRM,FO_READ);
		if res<0 then
			begin
				Alert(nil,1,STOP,MESSAGE_STARTUP_LOAD1+TEXELFRM+MESSAGE_STARTUP_LOAD2,BUTTON_OK);
				Quit;
				exit
			end;
		hdl:=integer(res);
		txt:='';
		FormPredef:=-2;
		fillchar(FormStart,sizeof(FormStart),0);
		new(pfm);
		if pfm<>nil then
			begin
				pfm^.Name:=NewStr(STRING_STANDARD);
				pfm^.Group:=0;
				pfm^.Index:=0;
				Formats^.Insert(pfm)
			end;
		repeat
			res:=fread(hdl,bufsize,buf);
			if res>0 then
				for w:=0 to res-1 do
					if buf^[w]=CR then
						begin
							StrPTrim(txt);
							if length(txt)>0 then
								if txt[1]='#' then
									begin
										q:=pos(' ',txt);
										if q>0 then
											FormCategories^.Insert(NewStr('  '+StrPLeft(StrPTrimF(StrPRight(txt,length(txt)-q)),17)+' '#0))
									end
								else
									if txt[1]='=' then FormPredef:=atol(StrPTrimF(StrPRight(txt,length(txt)-1)))
									else
										if txt[1]='c' then
											begin
												txt:=StrPTrimF(StrPRight(txt,length(txt)-1));
												for q:=0 to 14 do
													begin
														e:=pos(' ',txt);
														Farben[q]:=StrPLeft(txt,e-1);
														txt:=StrPTrimF(StrPRight(txt,length(txt)-e))
													end;
												Farben[15]:=txt
											end
										else
											if txt[1]='m' then
												begin
													if txt[2]='1' then
														begin
															txt:=StrPTrimF(StrPRight(txt,length(txt)-2));
															for q:=1 to 11 do
																begin
																	e:=pos(' ',txt);
																	Monate[q]:=StrPLeft(txt,e-1);
																	txt:=StrPTrimF(StrPRight(txt,length(txt)-e))
																end;
															Monate[12]:=txt
														end
													else
														begin
															txt:=StrPTrimF(StrPRight(txt,length(txt)-2));
															for q:=1 to 11 do
																begin
																	e:=pos(' ',txt);
																	Monate3[q]:=StrPLeft(txt,e-1);
																	txt:=StrPTrimF(StrPRight(txt,length(txt)-e))
																end;
															Monate3[12]:=txt
														end
												end
											else
												if txt[1]='d' then
													begin
														if txt[2]='1' then
															begin
																txt:=StrPTrimF(StrPRight(txt,length(txt)-2));
																for q:=0 to 5 do
																	begin
																		e:=pos(' ',txt);
																		Tage[q]:=StrPLeft(txt,e-1);
																		txt:=StrPTrimF(StrPRight(txt,length(txt)-e))
																	end;
																Tage[6]:=txt
															end
														else
															begin
																txt:=StrPTrimF(StrPRight(txt,length(txt)-2));
																for q:=0 to 5 do
																	begin
																		e:=pos(' ',txt);
																		Tage2[q]:=StrPLeft(txt,e-1);
																		txt:=StrPTrimF(StrPRight(txt,length(txt)-e))
																	end;
																Tage2[6]:=txt
															end
													end
												else
													if txt[1]<>';' then
														begin
															q:=pos(' ',txt);
															if q>0 then
																begin
																	opc:=atol(StrPLeft(txt,q-1));
																	txt:=StrPTrimF(StrPRight(txt,length(txt)-q));
																	if opc=1 then
																		begin
																			new(pfm);
																			if pfm<>nil then
																				begin
																					pfm^.Group:=1;
																					pfm^.Index:=1000+UsrForm^.Count;
																					pfm^.Name:=NewStr(txt);
																					UsrForm^.Insert(pfm)
																				end
																		end
																	else
																		begin
																			q:=pos(' ',txt);
																			if q>0 then
																				begin
																					new(pfm);
																					if pfm<>nil then
																						begin
																							pfm^.Group:=opc;
																							pfm^.Index:=atol(StrPLeft(txt,q-1));
																							pfm^.Name:=NewStr(StrPTrimF(StrPRight(txt,length(txt)-q)));
																							Formats^.Insert(pfm);
																							if FormStart[opc]=0 then FormStart[opc]:=pfm^.Index
																						end
																				end
																		end
																end
														end;
							txt:=''
						end
					else
						if buf^[w]>=32 then txt:=txt+chr(buf^[w])
		until res<>bufsize;
		fclose(hdl);
		if Formats^.Count<>FormPredef+1 then
			begin
				Alert(nil,1,STOP,MESSAGE_STARTUP_FRM1+TEXELFRM+MESSAGE_STARTUP_FRM2+' ('+ltoa(Formats^.Count)+'/'+ltoa(FormPredef)+').',BUTTON_OK);
				Quit;
				exit
			end;
		SetAction(STARTUP_USRFRM);
		res:=fopen(TexelApp.DataPath+TEXELUSRFRM,FO_READ);
		if res>=0 then
			begin
				txt:='';
				hdl:=integer(res);
				repeat
					res:=fread(hdl,bufsize,buf);
					if res>0 then
						for w:=0 to res-1 do
							if buf^[w]=CR then
								begin
									StrPTrim(txt);
									if length(txt)>0 then
										if txt[1]<>';' then
											begin
												new(pfm);
												if pfm<>nil then
													begin
														pfm^.Group:=1;
														pfm^.Index:=1000+UsrForm^.Count;
														pfm^.Name:=NewStr(txt);
														UsrForm^.Insert(pfm)
													end
											end;
									txt:=''
								end
							else
								if buf^[w]>=32 then txt:=txt+chr(buf^[w])
				until res<>bufsize;
				fclose(hdl)
			end;
		freemem(buf,bufsize);
		SetAction(STARTUP_PRINTDIAL);
		if ExtPrnSel(app_prnt_set,nil) then
			if app_prnt_set^.magic='pset' then
				begin
					res:=fopen(GetHomeDir(false)+'defaults\'+TEXELPRNSET,0);
					if res<0 then res:=fopen(GetHomeDir(false)+TEXELPRNSET,0);
					if res>=0 then
						begin
							hdl:=integer(res);
							fread(hdl,app_prnt_set^.len,app_prnt_set);
							fclose(hdl);
							with AES_pb do
								begin
									control^[0]:=205;
									control^[1]:=1;
									control^[2]:=1;
									control^[3]:=2;
									control^[4]:=0;
									intin^[0]:=8;
									addrin^[0]:=prnt_dialog;
									addrin^[1]:=app_prnt_set;
									_crystal(@AES_pb)
								end
						end
				end;
		ArrowMouse;
		SetAction(STARTUP_FINISH);
		inherited InitInstance;
		if startup<>nil then dispose(startup,Done);
		SetQuit(RTMQUIT,RTM2)
	end;


procedure TTexelApplication.LoadFile(p: PCalcWindow; s: string);
	var ext: string;
	    q  : integer;

	begin
		ext:=StrPUpper(GetExtension(s));
		if ext='.DIF' then
			begin
				if import<>nil then import^.LoadDIF(s)
			end
		else if ext='.CSV' then
			begin
				if import<>nil then import^.LoadCSV(s)
			end
		else if ext='.XLS' then
			begin
				if import<>nil then import^.LoadXLS(s)
			end
		else if ext='.DBF' then
			begin
				if import<>nil then import^.ImportDBF(s,nil)
			end
		else if ext='.LDP' then
			begin
				if import<>nil then import^.LoadLDW(s)
			end
		else if StrPLeft(ext,3)='.WK' then
			begin
				if import<>nil then import^.Load123(s)
			end
		else
			begin
				if (p<>nil) and (ext<>'.TXL') and (OLETypes<>nil) then
					if OLETypes^.Count>0 then
						for q:=0 to OLETypes^.Count-1 do
							if StrPLeft(ext,4)=POLEType(OLETypes^.At(q))^.Ext then
								begin
									p^.EmbedNewObject(s,0,0,0,0,0,nil,nil,nil,false,false,false,true,false,true,false);
									exit
								end;
				if opennewdoc<>nil then opennewdoc^.Load(s)
			end
	end;


procedure TTexelApplication.InitMainWindow;
	var q,hdl,
	    anz  : integer;
	    ret  : longint;
	    s,s2 : string;

	function dequote(sq: string): string;
		var i: integer;
	
		begin
			i:=1;
			while i<length(sq) do
				begin
					if sq[i]='''' then
						if sq[i+1]='''' then sq:=StrPLeft(sq,i)+StrPRight(sq,length(sq)-i-1);
					inc(i)
				end;
			dequote:=sq
		end;

	begin
		anz:=0;
		ret:=fopen(GetHomeDir(false)+'defaults\'+TEXELWORK,0);
		if ret<0 then ret:=fopen(GetHomeDir(false)+TEXELWORK,0);
		if ret>=0 then
			begin
				hdl:=integer(ret);
				if fread(hdl,2,@anz)<>2 then anz:=0;
				if anz>0 then
					for q:=1 to anz do
						if fread(hdl,256,@s[0])=256 then LoadFile(nil,s);
				fclose(hdl)
			end;
		if paramcount>0 then
			begin
				q:=1;
				while q<=paramcount do
					begin
						s:=paramstr(q);
						inc(q);
						if length(s)>0 then
							begin
								if s[1]='''' then
									begin
										CutLeft(s,1);
										while q<=paramcount do
											begin
												s2:=paramstr(q);
												inc(q);
												if StrPRight(s2,1)='''' then
													begin
														s:=s+' '+dequote(CutRightF(s2,1));
														LoadFile(nil,s);
														break
													end
												else
													s:=s+' '+dequote(s2);
											end
									end
								else
									LoadFile(nil,s)
							end
					end;
				exit
			end;
		if anz=0 then
			begin
				if setupbuffer.opennew=bf_Checked then new(PCalcWindow,Init)
				else
					if setupbuffer.loaddoc=bf_Checked then
						if opennewdoc<>nil then opennewdoc^.Work
			end
	end;


procedure TTexelApplication.Terminate;
	var pipe : Pipearray;
	    ret  : longint;
	    hdl,q: integer;

	begin
		if abruf<>nil then
			if abruf^.Dirty then
				begin
					ret:=fcreate(GetHomeDir(false)+'defaults\'+TEXELHISTORY,0);
					if ret<0 then ret:=fcreate(GetHomeDir(false)+TEXELHISTORY,0);
					if ret>=0 then
						begin
							hdl:=integer(ret);
							fwrite(hdl,2,@abruf^.Count);
							if abruf^.Count>0 then
								for q:=abruf^.Count-1 downto 0 do
									fwrite(hdl,length(abruf^.Files[q]^)+1,abruf^.Files[q]);
							fclose(hdl)
						end
				end;
		if WebID>=0 then
			if bTst(CABFlags5,4) then
				begin
					pipe[0]:=CAB_RELEASESTATUS;
					pipe[1]:=apID;
					pipe[2]:=0;
					pipe[3]:=0;
					pipe[4]:=0;
					pipe[5]:=0;
					pipe[6]:=0;
					pipe[7]:=0;
					appl_write(WebID,16,@pipe)
				end;
		if GEMScriptID>=0 then
			begin
				pipe[0]:=GS_QUIT;
				pipe[1]:=apID;
				pipe[2]:=0;
				pipe[3]:=0;
				pipe[4]:=0;
				pipe[5]:=0;
				pipe[6]:=0;
				pipe[7]:=0;
				appl_write(GEMScriptID,16,@pipe)
			end;
		if Fonts<>nil then dispose(Fonts,Done);
		if Functions<>nil then dispose(Functions,Done);
		if Categories<>nil then dispose(Categories,Done);
		if FormCategories<>nil then dispose(FormCategories,Done);
		if Formats<>nil then dispose(Formats,Done);
		if UsrForm<>nil then dispose(UsrForm,Done);
		if app_prnt_set<>nil then
			with AES_pb do
				begin
					control^[0]:=205;
					control^[1]:=1;
					control^[2]:=1;
					control^[3]:=1;
					control^[4]:=0;
					intin^[0]:=6;
					addrin^[0]:=app_prnt_set;
					_crystal(@AES_pb)
				end;
		if prnt_dialog<>nil then
			with AES_pb do
				begin
					control^[0]:=201;
					control^[1]:=0;
					control^[2]:=1;
					control^[3]:=1;
					control^[4]:=0;
					addrin^[0]:=prnt_dialog;
					_crystal(@AES_pb)
				end;
		if fnt_dialog<>nil then
			with AES_pb do
				begin
					control^[0]:=181;
					control^[1]:=1;
					control^[2]:=1;
					control^[3]:=1;
					control^[4]:=0;
					intin^[0]:=0;
					addrin^[0]:=fnt_dialog;
					_crystal(@AES_pb)
				end;
		FreeExtResource
	end;


procedure TTexelApplication.VAStart(OrgID: integer; Cmd: PChar);

	begin
		inherited VAStart(OrgID,Cmd);
		while Cmd<>nil do LoadFile(nil,GetQuotedName(Cmd))
	end;


procedure TTexelApplication.FileSelected(Window: PWindow; OrgID: integer; Group: byte; Path: string; Files: PChar);
	var p: PChar;

	function getxfname(nr: integer; const extn: string): string;
		var ret: string;

		begin
			ret:=GetQuotedName(Files);
			if length(ret)>0 then
				begin
					LastPath[nr]:=GetPath(ret);
					if length(GetExtension(ret))>1 then ret:=LastPath[nr]+GetFilename(ret,true)
					else
						if length(extn)=0 then ret:=LastPath[nr]+GetFilename(ret,false)
						else
							if ret=StrPUpper(ret) then ret:=LastPath[nr]+GetFilename(ret,false)+'.'+StrPUpper(extn)
							else
								ret:=LastPath[nr]+GetFilename(ret,false)+'.'+extn;
					LastFile[nr]:=GetFilename(ret,true)
				end;
			getxfname:=ret
		end;

	begin
		case Group of
		FSEL_OPEN:
			if opennewdoc<>nil then
				while Files<>nil do opennewdoc^.Load(getxfname(0,TEXELEXTENSION));
		FSEL_SAVE:
			if Window<>nil then
				with PCalcWindow(Window)^ do
					if saveas<>nil then saveas^.SaveAs(getxfname(0,TEXELEXTENSION),0);
		FSEL_SAVE2:
			if Window<>nil then
				with PCalcWindow(Window)^ do
					if saveas<>nil then saveas^.SaveAs(getxfname(0,TEXELEXTENSION),1);
		FSEL_EMBED:
			if Window<>nil then
				with PCalcWindow(Window)^ do
					while Files<>nil do EmbedNewObject(getxfname(17,''),0,0,0,0,0,nil,nil,nil,false,false,false,true,false,true,false);
		FSEL_EXPORT:
			if Window<>nil then
				with PCalcWindow(Window)^ do
					if export<>nil then export^.SetFile(getxfname(15,''));
		FSEL_DIAGRAM:
			if Window<>nil then
				with PCalcWindow(Window)^ do
					if diagramm<>nil then
						begin
							if Application^.Multitasking then diagramm^.SetFile(getxfname(19,'cwg'))
							else
								diagramm^.SetFile(getxfname(19,'tad'))
						end;
		FSEL_LOADIMG:
			if Window<>nil then
				with PCalcWindow(Window)^ do
					if grafik<>nil then
						while Files<>nil do grafik^.Load(getxfname(14,'img'));
		FSEL_LOADTEXT:
			if Window<>nil then
				with PCalcWindow(Window)^ do
					if textobj<>nil then
						while Files<>nil do textobj^.Load(getxfname(18,'txt'));
		FSEL_LOADCSV:
			if import<>nil then
				while Files<>nil do import^.LoadCSV(getxfname(4,'csv'));
		FSEL_LOADASCII:
			if import<>nil then
				if Files<>nil then import^.LoadASCII(getxfname(6,'txt'));
		FSEL_LOADXLS:
			if import<>nil then
				while Files<>nil do import^.LoadXLS(getxfname(7,'xls'));
		FSEL_LOADDBF:
			if import<>nil then
				while Files<>nil do import^.LoadGDBC(getxfname(12,'dbf'));
		FSEL_LOAD123:
			if import<>nil then
				while Files<>nil do import^.Load123(getxfname(10,'wk1'));
		FSEL_LOADLDW:
			if import<>nil then
				while Files<>nil do import^.LoadLDW(getxfname(9,'ldp'));
		FSEL_LOADDIF:
			if import<>nil then
				while Files<>nil do import^.LoadDIF(getxfname(2,'dif'))
		end
	end;


procedure TTexelApplication.GetXAccAttr(var XAccAttr: TXAccAttr);
	var feat: string;

	begin
		inherited GetXAccAttr(XAccAttr);
		with XAccAttr do
			begin
				AppTypeMR:='SS';
				if ExtFeatures=nil then feat:=''
				else
					begin
						feat:=ExtFeatures^+#0'X';
						DisposeStr(ExtFeatures)
					end;
				ExtFeatures:=NewStr(feat+'VA'#0'X.TXL'#0'X.CSV'#0'X.TXT'#0'X.XLS'#0'X.DIF'#0'X.DBF'#0'X.ASC');
				GenericName:=NewStr('ASHTEXEL')
			end
	end;


procedure TTexelApplication.GetMenuEntries(var Entries: TMenuEntries);

	begin
		inherited GetMenuEntries(Entries);
		with Entries do
			begin
				Quit.Entry:=RTMQUIT;
				Quit.Title:=RTM2;
				Close.Entry:=RTMCLOSE;
				Close.Title:=RTM2;
				Cut.Entry:=RTMCUT;
				Cut.Title:=RTM3;
				Copy.Entry:=RTMCOPY;
				Copy.Title:=RTM3;
				Paste.Entry:=RTMPASTE;
				Paste.Title:=RTM3;
				Delete.Entry:=RTMDELETE;
				Delete.Title:=RTM3;
				SelectAll.Entry:=RTMSELALL;
				SelectAll.Title:=RTM3
			end
	end;


function TTexelApplication.GetIconTitle: string;

	begin
		GetIconTitle:=StrPUpper(TEXELNAME)
	end;


function TTexelApplication.EscText2Formula(txt: string): string;
	var q,w,c,nr: integer;
	    fkt     : string;
	    pf      : PFunction;

	begin
		q:=pos(#27,txt);
		while q>0 do
			begin
				w:=q+1;
				while txt[w]<>#27 do inc(w);
				nr:=atol(StrPMid(txt,q+1,w-q-1));
				fkt:='@';
				c:=Functions^.Count-1;
				while c>=0 do
					begin
						pf:=PFunction(Functions^.At(c));
						if pf^.Opcode=nr then
							begin
								fkt:=pf^.Name^;
								break
							end;
						dec(c)
					end;
				txt:=StrPLeft(txt,q-1)+fkt+StrPRight(txt,length(txt)-w);
				q:=pos(#27,txt)
			end;
		EscText2Formula:=txt
	end;


function TTexelApplication.Num2Txt(fval: TNumber; fp: byte; cut0: boolean): string;
	label _fertig;

	var vtxt: string;
	    expn: string[7];
	    q   : integer;

	begin
		if fval=0.0 then vtxt:='0'
		else
			begin
				if frac(fval*1e20)=0.0 then str(fval:0:fp,vtxt)
				else
					str(fval,vtxt);
				StrPTrim(vtxt);
				if vtxt='NaN' then goto _fertig;
				q:=pos('E',StrPUpper(vtxt));
				if q>0 then
					begin
						if vtxt[q+1] in ['+','-'] then
							begin
								expn:=StrPRight(vtxt,length(vtxt)-q-1);
								vtxt:=StrPLeft(vtxt,q+1)
							end
						else
							begin
								expn:=StrPRight(vtxt,length(vtxt)-q);
								vtxt:=StrPLeft(vtxt,q)
							end;
						while StrPLeft(expn,1)='0' do expn:=StrPRight(expn,length(expn)-1);
						if length(expn)>0 then expn:=StrPUpper(StrPRight(vtxt,length(vtxt)+1-q))+expn;
						vtxt:=StrPLeft(vtxt,q-1)
					end
				else
					expn:='';
				if pos('.',vtxt)>0 then while StrPRight(vtxt,1)='0' do dec(byte(vtxt[0]));
				if StrPRight(vtxt,1)='.' then dec(byte(vtxt[0]));
				vtxt:=vtxt+expn;
				if length(vtxt)=0 then vtxt:='0'
				else
					if vtxt='-0' then vtxt:='0'
			end;
		if fp>0 then
			if pos('E',vtxt)=0 then
				begin
					q:=pos('.',vtxt);
					if q=0 then vtxt:=vtxt+'.'+StrPFill(fp,'0')
					else
						if length(vtxt)-q<fp then vtxt:=vtxt+StrPFill(fp+q-length(vtxt),'0')
				end;
		if cut0 then
			begin
				while StrPRight(vtxt,1)='0' do vtxt:=StrPLeft(vtxt,length(vtxt)-1);
				if StrPRight(vtxt,1)='.' then vtxt:=StrPLeft(vtxt,length(vtxt)-1);
				if length(vtxt)=0 then vtxt:='0'
			end;
		_fertig:
		Num2Txt:=vtxt
	end;


procedure TTexelApplication.HandleKeybd(Stat,Key: integer);
	label _aufruf;

	var pipe: Pipearray;
	    p   : PWindow;

	begin
		if (Key=S_Help) or (Key=F1) then
			if Stat=K_NORMAL then
				begin
					if HelpAvailable(true) then
						begin
							p:=GetPTopWindow;
							if p<>nil then
								begin
									if p^.IsDialog then
										begin
											PDialog(p)^.Help;
											exit
										end
									else
										if p^.GetClassName='SpecialCharactersWindow' then
											begin
												if Exist(DataPath+TEXELHELP) then StrPCopy(helpbuf,DataPath+TEXELHELP+' '+STG_SPECIALCHARS)
												else
													StrPCopy(helpbuf,GUIDES+TEXELHELP+' '+STG_SPECIALCHARS);
												goto _aufruf
											end
								end;
							if Exist(DataPath+TEXELHELP) then StrPCopy(helpbuf,DataPath+TEXELHELP)
							else
								StrPCopy(helpbuf,GUIDES+TEXELHELP);
							_aufruf:
							pipe[0]:=VA_START;
							pipe[1]:=apID;
							pipe[2]:=0;
							pipe[3]:=integer(HiWord(helpbuf));
							pipe[4]:=integer(LoWord(helpbuf));
							pipe[5]:=0;
							pipe[6]:=0;
							pipe[7]:=0;
							appl_write(HelpID,16,@pipe)
						end;
					exit
				end;
		inherited HandleKeybd(Stat,Key)
	end;


procedure TTexelApplication.Unembed(srvID: integer);
	var p: PWindow;

	begin
		p:=MainWindow;
		while p<>nil do
			begin
				PCalcWindow(p)^.Unembed(srvID);
				p:=p^.Next
			end
	end;


function TTexelApplication.ScriptByNumber(nr: longint; datei,zelle,prm: string): boolean;
	var script,
	    scrapp,
	    scripter: string;
	    scrid,q : integer;
	    len     : longint;
	    answ    : ARRAY_8;
	    pc,pc2  : PChar;

	begin
		ScriptByNumber:=false;
		if length(zelle)=0 then exit;
		scripter:=GetEnv('GEMSCRIPT');
		if length(scripter)=0 then exit;
		script:=DataPath+TEXELSCRIPTPATH+ltoa(nr)+'.'+TEXELSCRIPTEXT;
		if not(Exist(script)) then exit;
		scrapp:=StrPUpper(GetFilename(scripter,false));
		if length(scrapp)=0 then exit;
		scrid:=appl_find(scrapp+StrPSpace(8-length(scrapp)));
		if scrid<0 then scrid:=StartApp(scripter,'');
		if scrid>=0 then
			begin
				if length(datei)=0 then datei:=#1;
				len:=4+1+length(script)+1+length(datei)+1+length(zelle)+1+length(prm)+1;
				GlobalAlloc(pointer(pc),len);
				if pc=nil then exit;
				ScriptByNumber:=true;
				if GEMScriptID<>scrid then
					begin
						answ[0]:=GS_REQUEST;
						answ[1]:=apID;
						answ[2]:=0;
						answ[3]:=integer(HiWord(GSInfo));
						answ[4]:=integer(LoWord(GSInfo));
						answ[5]:=0;
						answ[6]:=0;
						answ[7]:=0;
						appl_write(scrid,16,@answ)
					end;
				pc2:=pc;
				StrPCopy(pc2,'Exec');
				inc(longint(pc2),5);
				StrPCopy(pc2,script);
				inc(longint(pc2),length(script)+1);
				StrPCopy(pc2,datei);
				inc(longint(pc2),length(datei)+1);
				StrPCopy(pc2,zelle);
				inc(longint(pc2),length(zelle)+1);
				if length(prm)>0 then
					begin
						StrPTrim(prm);
						q:=pos(' ',prm);
						while q>0 do
							begin
								StrPCopy(pc2,StrPLeft(prm,q-1));
								inc(longint(pc2),q);
								prm:=StrPRight(prm,length(prm)-q);
								q:=pos(' ',prm)
							end;
						StrPCopy(pc2,prm);
						inc(longint(pc2),length(prm)+1)
					end;
				pc2^:=#0;
				answ[0]:=GS_COMMAND;
				answ[1]:=apID;
				answ[2]:=0;
				answ[3]:=integer(HiWord(pc));
				answ[4]:=integer(LoWord(pc));
				answ[5]:=0;
				answ[6]:=0;
				answ[7]:=0;
				appl_write(scrid,16,@answ)
			end
	end;


function TTexelApplication.InterpreteScript(pcmd: PChar; var answ: Pipearray): integer;
	label _error;
	
	var pw   : PCalcWindow;
	    txt,
	    txt2 : string;
	    pbuf : pointer;
	    pn   : PChar;
	    ibuf,
	    rs,cs,
	    re,ce,
	    f1,f2: integer;
	    cell : PCell;
	    nval : TNumber;
	    isrc : boolean;

	function IsCmd(cmd: PChar): boolean;
	
		begin
			if stricomp(pcmd,cmd)=0 then
				begin
					inc(longint(pcmd),StrLen(cmd)+1);
					IsCmd:=true
				end
			else
				IsCmd:=false
		end;

	function NextToken: boolean;
		label _again;
	
		begin
			NextToken:=false;
			if pcmd=nil then exit;
			_again:
			if pcmd^=#0 then
				begin
					pn:=pcmd;
					exit
				end;
			if pcmd^ in [#2..#6] then
				begin
					inc(longint(pcmd),StrLen(pcmd)+1);
					goto _again
				end;
			if pcmd^=#1 then
				begin
					inc(longint(pcmd),StrLen(pcmd)+1);
					pn:=PChar(longint(pcmd)-1)
				end
			else
				begin
					pn:=pcmd;
					inc(longint(pcmd),StrLen(pcmd)+1)
				end;
			NextToken:=true
		end;

	function findtopsheet: PCalcWindow;
		var pfw  : PWindow;
		    o1,g1,
		    u1,
		    dummy: integer;

		begin
			wind_update(BEG_UPDATE);
			u1:=DESK;
			wind_get(DESK,WF_TOP,o1,dummy,u1,dummy);
			if o1<0 then o1:=u1;
			pfw:=nil;
			if not(appl_xgetinfo(11,g1,dummy,dummy,dummy)) then g1:=0;
			repeat
				pfw:=GetGPWindow(o1);
				if pfw<>nil then
					if pfw^.GetClassName<>TEXELWINDCLASS then pfw:=nil;
				if pfw=nil then
					if bTst(g1,16) then wind_get(o1,WF_OWNER,dummy,dummy,dummy,o1);
			until (pfw<>nil) or (o1<=DESK) or not(bTst(g1,16));
			wind_update(END_UPDATE);
			findtopsheet:=PCalcWindow(pfw)
		end;

	function getwindow(p: PChar; usetop: boolean): PCalcWindow;
		var ptw: PWindow;
		    s  : string;
	
		begin
			getwindow:=nil;
			if p=nil then exit;
			if p^=#0 then
				begin
					if usetop then getwindow:=findtopsheet
				end
			else
				begin
					s:=StrPUpper(StrPPas(p));
					ptw:=MainWindow;
					while ptw<>nil do
						begin
							if ptw^.GetClassName=TEXELWINDCLASS then
								if StrPUpper(PCalcWindow(ptw)^.GetWindowFilename)=s then
									begin
										getwindow:=PCalcWindow(ptw);
										exit
									end;
							ptw:=ptw^.Next
						end;
					if pos('\',s)>0 then exit;
					s:=GetFilename(s,true);
					ptw:=MainWindow;
					while ptw<>nil do
						begin
							if ptw^.GetClassName=TEXELWINDCLASS then
								if GetFilename(StrPUpper(PCalcWindow(ptw)^.GetWindowFilename),true)=s then
									begin
										getwindow:=PCalcWindow(ptw);
										exit
									end;
							ptw:=ptw^.Next
						end;
					if pos('.',s)>0 then exit;
					s:=GetFilename(s,false);
					ptw:=MainWindow;
					while ptw<>nil do
						begin
							if ptw^.GetClassName=TEXELWINDCLASS then
								if GetFilename(StrPUpper(PCalcWindow(ptw)^.GetWindowFilename),false)=s then
									begin
										getwindow:=PCalcWindow(ptw);
										exit
									end;
							ptw:=ptw^.Next
						end
				end
		end;
	
	procedure answer(s: string);
	
		begin
			s:=s+#0#0;
			GlobalAlloc(pbuf,length(s));
			if pbuf=nil then exit;
			move(s[1],pbuf^,length(s));
			answ[5]:=integer(HiWord(pbuf));
			answ[6]:=integer(LoWord(pbuf))
		end;

	function exportfile: boolean;
		var texbuf: TExportBuf;

		begin
			exportfile:=false;
			if pw^.export=nil then exit;
			with texbuf do
				begin
					exporttype:=-1;
					if length(txt2)=0 then clipboard:=bf_Checked
					else
						clipboard:=bf_Unchecked;
					bereich:=bf_Unchecked;
					htmldoctype:=1;
					htmlsavedt:=bf_Checked;
					htmlcolor:=bf_Checked;
					csvformula:=bf_Unchecked;
					csvvalue:=bf_Checked;
					difformula:=bf_Unchecked;
					difvalue:=bf_Checked;
					difstandard:=bf_Checked;
					difexcel:=bf_Unchecked;
					with ascii do
						begin
							hor:=bf_Checked;
							vert:=bf_Unchecked;
							rctxt:='13,10';
							rcval:=0;
							celltxt:='9';
							cellval:=0;
							texttxt:='34';
							textval:=0;
							quote:=bf_Checked;
							numbers:=0;
							formula:=bf_Unchecked;
							value:=bf_Checked
						end;
					difformat:=bf_Checked;
					csvformat:=bf_Checked;
					asciiformat:=bf_Checked;
					htmlembed:=bf_Unchecked;
					filter:=0;
					if (txt='SYLK') or (txt='SLK') then exporttype:=2
					else if txt='DIF' then exporttype:=3
					else if txt='CSV' then exporttype:=4
					else if (txt='ASCII') or (txt='ASC') then exporttype:=5
					else if txt='TXT' then exporttype:=6
					else if txt='TEX' then exporttype:=7
					else if (txt='HTML') or (txt='HTML-32') then exporttype:=8
					else if txt='UDO' then exporttype:=9
					else if txt='HTML-30' then
						begin
							exporttype:=8;
							htmldoctype:=0
						end
					else if txt='HTML-40' then
						begin
							exporttype:=8;
							htmldoctype:=2
						end;
				end;
			exportfile:=pw^.export^.Export(texbuf,txt2)
		end;

	procedure getvariable;
		var ret: real;
		    w  : longint;
	
		begin
			ret:=0.0;
			with pw^ do
				begin
					if Variables<>nil then
						if Variables^.Count>0 then
							for w:=Variables^.Count-1 downto 0 do
								with PVariable(Variables^.At(w))^ do
									if txt=StrPUpper(Name^) then
										if (RefRow>=0) and (RefRow<=Parms.Rows) and (RefCol>=0) and (RefCol<=Parms.Columns) then
											begin
												ret:=Evaluate(GetCell(RefRow,RefCol));
												break
											end
				end;
			answer(ftoa(ret))
		end;

	begin
		InterpreteScript:=2;
		if pcmd=nil then exit;
		if pcmd^=#0 then exit;
		InterpreteScript:=0;
		if IsCmd('ReturnCellValue') then
			begin
				if not(NextToken) then goto _error;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(NextToken) then goto _error;
				if not(pw^.GetBlock(StrPPas(pn),false,rs,cs,re,ce,f1,f2)) then goto _error;
				cell:=pw^.GetCell(rs,cs);
				if cell^.Typ<>CTYPE_FORMULA then goto _error;
				with cell^.Data.Formula^.Func^ do
					if (Typ<>NT_SCRIPTNO) and not(Between(Typ,NT_EXTMIN,NT_EXTMAX)) then goto _error;
				if not(NextToken) then goto _error;
				nval:=atof(StrPPas(pn));
				if nval<>cell^.Data.Formula^.Value then
					begin
						cell^.Data.Formula^.Value:=nval;
						pw^.DrawCells(rs,cs,rs,cs);
						pw^.AutoCalculate(true)
					end;
				exit
			end;
		if IsCmd('GetVariable') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPUpper(StrPPas(pn));
				if length(txt)=0 then goto _error;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				getvariable;
				exit
			end;
		if IsCmd('Select') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.GotoBlock(txt);
				exit
			end;
		if IsCmd('SetCell') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				if (txt[1] in ['0'..'9']) then
					begin
						rs:=atol(txt);
						if not(NextToken) then goto _error;
						cs:=atol(StrPPas(pn));
						isrc:=true
					end
				else
					isrc:=false;
				if not(NextToken) then goto _error;
				txt2:=StrPPas(pn);
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(isrc) then
					if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				ibuf:=pw^.sheetbuffer.autocalc;
				pw^.sheetbuffer.autocalc:=bf_Unchecked;
				pw^.ChangeCell(pw^.GetCell(rs,cs),txt2,rs,cs,true);
				pw^.sheetbuffer.autocalc:=ibuf;
				exit
			end;
		if IsCmd('GetRange') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				answer(ltoa(rs)+#0+ltoa(cs)+#0+ltoa(re)+#0+ltoa(ce));
				exit
			end;
		if IsCmd('Cell') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				if not(NextToken) then goto _error;
				txt2:=StrPPas(pn);
				if length(txt2)=0 then goto _error;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				answer(pw^.GetColumnName(atol(txt2))+pw^.GetRowIndex(atol(txt)));
				exit
			end;
		if IsCmd('SetColor') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.SetCellColor(atol(txt));
				exit
			end;
		if IsCmd('SetTextColor') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.SetTextColor(atol(txt));
				exit
			end;
		if IsCmd('IsBlockUsed') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				if pw^.IsBlockUsed(rs,cs,re,ce,1) then answer('1')
				else
					answer('0');
				exit
			end;
		if IsCmd('Cut') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.Cut;
				exit
			end;
		if IsCmd('Copy') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.Copy;
				exit
			end;
		if IsCmd('Paste') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.Paste;
				exit
			end;
		if IsCmd('Delete') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.Delete;
				exit
			end;
		if IsCmd('SelectAll') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.SelectAll;
				exit
			end;
		if IsCmd('Print') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.Print;
				exit
			end;
		if IsCmd('Save') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.save^.Work;
				exit
			end;
		if IsCmd('SaveAs') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.saveas^.SaveAs(txt,0);
				exit
			end;
		if IsCmd('ToFront') then
			begin
				if not(NextToken) then goto _error;
				pw:=getwindow(pn,false);
				if pw=nil then goto _error;
				pw^.Top;
				exit
			end;
		if IsCmd('GetFront') then
			begin
				pw:=findtopsheet;
				if pw=nil then goto _error;
				txt:=pw^.GetWindowFilename;
				if length(txt)=0 then goto _error;
				answer(txt);
				exit
			end;
		if IsCmd('GetSelection') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				txt:=StrPTrimF(pw^.dblock^.GetText);
				if length(txt)=0 then goto _error;
				answer(txt);
				exit
			end;
		if IsCmd('GetCell') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				if (txt[1] in ['0'..'9']) then
					begin
						rs:=atol(txt);
						if not(NextToken) then goto _error;
						cs:=atol(StrPPas(pn));
						isrc:=true
					end
				else
					isrc:=false;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(isrc) then
					if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				cell:=pw^.GetCell(rs,cs);
				case cell^.Typ of
				CTYPE_TEXT:
					txt:=cell^.Data.Txt^;
				CTYPE_CONST:
					txt:=pw^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil);
				CTYPE_FORMULA:
					txt:=pw^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil);
				else
					txt:=''
				end;
				if length(txt)=0 then txt:=#1;
				answer(txt);
				exit
			end;
		if IsCmd('GetCellFormula') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				if (txt[1] in ['0'..'9']) then
					begin
						rs:=atol(txt);
						if not(NextToken) then goto _error;
						cs:=atol(StrPPas(pn));
						isrc:=true
					end
				else
					isrc:=false;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(isrc) then
					if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				cell:=pw^.GetCell(rs,cs);
				case cell^.Typ of
				CTYPE_TEXT:
					txt:=cell^.Data.Txt^;
				CTYPE_CONST:
					begin
						if cell^.Data.Konst^.Txt=nil then txt:=pw^.Val2TxtF(cell^.Data.Konst^.Value,15,0,nil)
						else
							txt:=cell^.Data.Konst^.Txt^
					end;
				CTYPE_FORMULA:
					txt:=pw^.BuildFunction(cell,true);
				else
					txt:=''
				end;
				if length(txt)=0 then txt:=#1;
				answer(txt);
				exit
			end;
		if IsCmd('IsCellEmpty') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				if (txt[1] in ['0'..'9']) then
					begin
						rs:=atol(txt);
						if not(NextToken) then goto _error;
						cs:=atol(StrPPas(pn));
						isrc:=true
					end
				else
					isrc:=false;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(isrc) then
					if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				cell:=pw^.GetCell(rs,cs);
				if cell^.Typ=CTYPE_EMPTY then answer('1')
				else
					answer('0');
				exit
			end;
		if IsCmd('IsCellText') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				if (txt[1] in ['0'..'9']) then
					begin
						rs:=atol(txt);
						if not(NextToken) then goto _error;
						cs:=atol(StrPPas(pn));
						isrc:=true
					end
				else
					isrc:=false;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(isrc) then
					if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				cell:=pw^.GetCell(rs,cs);
				if cell^.Typ=CTYPE_TEXT then answer('1')
				else
					answer('0');
				exit
			end;
		if IsCmd('IsCellConst') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				if (txt[1] in ['0'..'9']) then
					begin
						rs:=atol(txt);
						if not(NextToken) then goto _error;
						cs:=atol(StrPPas(pn));
						isrc:=true
					end
				else
					isrc:=false;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(isrc) then
					if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				cell:=pw^.GetCell(rs,cs);
				if cell^.Typ=CTYPE_CONST then answer('1')
				else
					answer('0');
				exit
			end;
		if IsCmd('IsCellFormula') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then goto _error;
				if (txt[1] in ['0'..'9']) then
					begin
						rs:=atol(txt);
						if not(NextToken) then goto _error;
						cs:=atol(StrPPas(pn));
						isrc:=true
					end
				else
					isrc:=false;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(isrc) then
					if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				cell:=pw^.GetCell(rs,cs);
				if cell^.Typ=CTYPE_FORMULA then answer('1')
				else
					answer('0');
				exit
			end;
		if IsCmd('GetRows') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				answer(ltoa(pw^.Parms.Rows+1));
				exit
			end;
		if IsCmd('GetColumns') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				answer(ltoa(pw^.Parms.Columns+1));
				exit
			end;
		if IsCmd('Goto') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPPas(pn);
				if length(txt)=0 then
					begin
						rs:=0;
						cs:=0;
						isrc:=true
					end
				else
					if (txt[1] in ['0'..'9']) then
						begin
							rs:=atol(txt);
							if not(NextToken) then goto _error;
							cs:=atol(StrPPas(pn));
							isrc:=true
						end
					else
						isrc:=false;
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(isrc) then
					if not(pw^.GetBlock(txt,false,rs,cs,re,ce,f1,f2)) then goto _error;
				pw^.SetCursorPos(rs,cs,true);
				exit
			end;
		if IsCmd('Recalc') then
			begin
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				pw^.Calculate(true);
				exit
			end;
		if IsCmd('Close') then
			begin
				while NextToken do
					begin
						pw:=getwindow(pn,true);
						if pw<>nil then pw^.WMClosed
					end;
				exit
			end;
		if IsCmd('Open') then
			begin
				if pcmd^=#0 then opennewdoc^.Work
				else
					while NextToken do
						begin
							if pn^=#0 then opennewdoc^.Work
							else
								LoadFile(nil,StrPPas(pn))
						end;
				exit
			end;
		if IsCmd('Export') then
			begin
				if not(NextToken) then goto _error;
				txt:=StrPUpper(StrPPas(pn));
				if length(txt)=0 then goto _error;
				if not(NextToken) then goto _error;
				txt2:=StrPPas(pn);
				NextToken;
				pw:=getwindow(pn,true);
				if pw=nil then goto _error;
				if not(exportfile) then goto _error;
				exit
			end;
		if IsCmd('New') then
			begin
				new(PCalcWindow,Init);
				exit
			end;
		if IsCmd('Quit') then
			begin
				Quit;
				exit
			end;
		InterpreteScript:=1;
		exit;
		_error:
		InterpreteScript:=2
	end;


procedure TTexelApplication.HandleMesag(Pipe: Pipearray);
	var answ  : Pipearray;
	    poi   : PTexelObjectInfo;
	    err   : boolean;
	    pc,pc2: PChar;
	    plen,
	    len2  : longint;

	begin
		case pipe[0] of
		OLGA_INPLACEUPDATE:
			begin
				poi:=Ptr(word(pipe[4]),word(pipe[5]));
				if poi<>nil then
					if poi^.oi.ClientData<>0 then
						with PEmbedded(poi^.oi.ClientData)^ do
							begin
								SetDirty;
								Redraw
							end
			end;
		OLGA_EMBEDDED:
			begin
				poi:=Ptr(word(pipe[4]),word(pipe[5]));
				if poi<>nil then
					begin
						if (pipe[6]=0) and (pipe[7]=0) then err:=true
						else
							if longint(GetPWindow(pipe[3]))<>poi^.oi.ClientData then err:=true
							else
								err:=false;
						if err then
							begin
								Alert(nil,1,NOTE,MESSAGE_WINDOW_EMBED1+StrPPas(poi^.oi.Filename)+MESSAGE_WINDOW_EMBED2,BUTTON_OK);
								GlobalFree(pointer(poi),sizeof(TTexelObjectInfo))
							end
						else
							begin
								if (poi^.w100>0) and (poi^.h100>0) then
									PCalcWindow(poi^.oi.ClientData)^.Embed(@poi^.oi,pipe[1],poi^.w100,poi^.h100,poi^.x100,poi^.y100,poi^.DataLen,poi^.Data,@poi^.oabuf,@poi^.diabuf,poi^.xyvalid,poi^.prop,poi^.embd,poi^.dirty,poi^.istad,poi^.prntflg,poi^.lckflg)
								else
									PCalcWindow(poi^.oi.ClientData)^.Embed(@poi^.oi,pipe[1],word(pipe[6]),word(pipe[7]),0,0,0,nil,nil,@poi^.diabuf,false,false,false,poi^.dirty,poi^.istad,poi^.prntflg,poi^.lckflg)
							end
					end
			end;
		OLGA_UNEMBED:
			begin
				poi:=Ptr(word(pipe[4]),word(pipe[5]));
				if poi=nil then Unembed(pipe[1])
				else
					if poi^.oi.ClientData<>0 then PEmbedded(poi^.oi.ClientData)^.Unembed
			end;
		OLGA_SERVERTERMINATED:
			Unembed(pipe[3]);
		OLGA_SETTINGS:
			{ ... };
		GS_REQUEST:
			begin
				answ[0]:=GS_REPLY;
				answ[1]:=apID;
				answ[2]:=0;
				answ[3]:=integer(HiWord(GSInfo));
				answ[4]:=integer(LoWord(GSInfo));
				answ[5]:=0;
				answ[6]:=1;
				if (pipe[3]<>0) or (pipe[4]<>0) then
					if PGSInfo(Ptr(word(pipe[3]),word(pipe[4])))^.Version>=$0070 then answ[6]:=0;
				answ[7]:=Pipe[7];
				appl_write(Pipe[1],16,@answ)
			end;
		GS_REPLY:
			GEMScriptID:=pipe[1];
		GS_QUIT:
			begin
				if pipe[1]=GEMScriptID then GEMScriptID:=-1
			end;
		GS_COMMAND:
			begin
				GSActive:=true;
				answ[0]:=GS_ACK;
				answ[1]:=apID;
				answ[2]:=0;
				answ[3]:=Pipe[3];
				answ[4]:=Pipe[4];
				answ[5]:=0;
				answ[6]:=0;
				answ[7]:=InterpreteScript(Ptr(word(pipe[3]),word(pipe[4])),answ);
				GSActive:=false;
				appl_write(Pipe[1],16,@answ)
			end;
		GS_ACK:
			begin
				pc:=Ptr(word(pipe[3]),word(pipe[4]));
				if pc<>nil then
					begin
						if (Pipe[5]<>0) or (Pipe[6]<>0) then
							begin
								{ Ergebnis auswerten... }
								answ[0]:=GS_ACK;
								answ[1]:=apID;
								answ[2]:=0;
								answ[3]:=0;
								answ[4]:=0;
								answ[5]:=Pipe[5];
								answ[6]:=Pipe[6];
								answ[7]:=0;
								appl_write(Pipe[1],16,@answ)
							end;
						pc2:=pc;
						plen:=1;
						repeat
							len2:=StrLen(pc2)+1;
							inc(plen,len2);
							inc(longint(pc2),len2)
						until pc2^=#0;
						GlobalFree(pointer(pc),plen)
					end
				else
					begin
						pc:=Ptr(word(pipe[5]),word(pipe[6]));
						if pc<>nil then
							begin
								pc2:=pc;
								plen:=1;
								repeat
									len2:=StrLen(pc2)+1;
									inc(plen,len2);
									inc(longint(pc2),len2)
								until pc2^=#0;
								GlobalFree(pointer(pc),plen)
							end
					end
			end;
		GS_MACRO:
			{ ... };
		GO_PRIVATE:
			if Pipe[3]=GOP_ABANDON then AbandonFile(PCalcWindow(Ptr(word(Pipe[4]),word(Pipe[5]))));
		DHST_ACK:
			begin
				pc:=Ptr(word(Pipe[3]),word(Pipe[4]));
				GlobalFree(pointer(pc),1024+sizeof(TDHSTInfo))
			end;
		CAB_HELLO:
			begin
				WebID:=Pipe[1];
				CABVersion:=Pipe[3];
				CABFlags4:=Pipe[4];
				CABFlags5:=Pipe[5];
				if bTst(CABFlags5,4) then
					begin
						answ[0]:=CAB_REQUESTSTATUS;
						answ[1]:=apID;
						answ[2]:=0;
						answ[3]:=0;
						answ[4]:=0;
						answ[5]:=0;
						answ[6]:=0;
						answ[7]:=0;
						appl_write(WebID,16,@answ)
					end
			end;
		CAB_EXIT:
			begin
				WebID:=-1;
				if webhelp<>nil then webhelp^.Disable;
				if websupport<>nil then websupport^.Disable;
				if openurl<>nil then
					begin
						openurl^.Disable;
						if openurl^.ADialog<>nil then openurl^.ADialog^.WMClosed
					end
			end;
		CAB_STATUS:
			begin
				if Pipe[3]<>0 then
					begin
						if webhelp<>nil then
							begin
								if bTst(CABFlags4,1) and bTst(CABFlags5,1) then webhelp^.Enable
								else
									webhelp^.Disable
							end;
						if websupport<>nil then
							begin
								if bTst(CABFlags4,16) and bTst(CABFlags5,2) then websupport^.Enable
								else
									websupport^.Disable
							end;
						if openurl<>nil then
							begin
								if bTst(CABFlags5,1) then openurl^.Enable
								else
									begin
										openurl^.Disable;
										if openurl^.ADialog<>nil then openurl^.ADialog^.WMClosed
									end
							end
					end
				else
					begin
						if webhelp<>nil then webhelp^.Disable;
						if websupport<>nil then websupport^.Disable;
						if openurl<>nil then
							begin
								openurl^.Disable;
								if openurl^.ADialog<>nil then openurl^.ADialog^.WMClosed
							end
					end
			end;
		CAB_MAILSENT:
			if Pipe[3]=0 then
				if Pipe[4]<>2 then
					Alert(nil,1,NOTE,MESSAGE_WINDOW_EMAIL,BUTTON_OK);
		end
	end;


procedure TTexelApplication.HandleTimer;
	label _aus;

	var stgid: integer;

	begin
		stgid:=appl_find('ST-GUIDE');
		if stgid<>HelpID then
			begin
				HelpID:=stgid;
				if not(HelpAvailable(false)) then
					begin
						if help1<>nil then help1^.Disable;
						if help2<>nil then help2^.Disable;
						if help3<>nil then help3^.Disable;
						if help4<>nil then help4^.Disable;
						if help5<>nil then help5^.Disable
					end
				else
					begin
						if help1<>nil then help1^.Enable;
						if help2<>nil then help2^.Enable;
						if help3<>nil then help3^.Enable;
						if help4<>nil then help4^.Enable;
						if help5<>nil then help5^.Enable
					end
			end;
		if about=nil then exit;
		with about^ do
			if ADialog<>nil then
				if ADialog^.Attr.Status=ws_Open then
					if serst<>nil then
						begin
							if mstimer<TEXELTIMER then
								begin
									serst^.SetText(StrPLeft(serscroll,40));
									serscroll:=StrPRight(serscroll,length(serscroll)-1);
									if length(serscroll)<40 then
										begin
											if arraycount<DANKMAX then
												begin
													inc(arraycount);
													serscroll:=serscroll+dank[arraycount]
												end
											else
												goto _aus
										end
								end
							else
								begin
									if tstart=0 then tstart:=((tgettime shr 5)+4+system.random(5)) shl 5
									else
										if tgettime>tstart then mstimer:=200
								end;
							exit
						end;
		if mstimer<>TEXELTIMER then
			begin
				_aus:
				with about^ do
					begin
						serscroll:=dank[0];
						arraycount:=0;
						if ADialog<>nil then
							if serst<>nil then
								serst^.SetText(sertxt);
						tstart:=0
					end;
				mstimer:=TEXELTIMER
			end
	end;


function TTexelApplication.GetMsTimer: longint;

	begin
		GetMsTimer:=mstimer
	end;


function TTexelApplication.GetStdFontIndex: integer;
	var dummy: string;

	begin
		if Fonts=nil then GetStdFontIndex:=vqt_name(vdiHandle,1,dummy)
		else
			if (setupbuffer.stdfont>=0) and (setupbuffer.stdfont<Fonts^.Count) then GetStdFontIndex:=PFont(Fonts^.At(setupbuffer.stdfont))^.index
			else
				GetStdFontIndex:=vqt_name(vdiHandle,1,dummy)
	end;


function TTexelApplication.GetStdFontSize: integer;
	var pf: PFont;

	begin
		if Fonts=nil then GetStdFontSize:=10
		else
			if (setupbuffer.stdfont<0) or (setupbuffer.stdfont>=Fonts^.Count) then GetStdFontSize:=10
			else
				begin
					pf:=Fonts^.At(setupbuffer.stdfont);
					if pf^.SizeCount=0 then GetStdFontSize:=4+setupbuffer.stdfsize
					else
						if (setupbuffer.stdfsize<0) or (setupbuffer.stdfsize>=pf^.SizeCount) then GetStdFontSize:=10
						else
							GetStdFontSize:=pf^.Sizes^[pf^.SizeCount-setupbuffer.stdfsize-1]
				end
	end;


function TTexelApplication.DDReadArgs(dSize: longint; PipeHnd,OrgID,WindID,mX,mY,KStat: integer): boolean;

	begin
		DDReadArgs:=false;
		if ddfiles<>nil then freemem(ddfiles,StrLen(ddfiles)+1);
		getmem(ddfiles,dSize+1);
		if ddfiles<>nil then
			begin
				if fread(PipeHnd,dSize,ddfiles)<>dSize then
					begin
						freemem(ddfiles,dSize+1);
						ddfiles:=nil
					end
				else
					begin
						PChar(longint(ddfiles)+dSize)^:=#0;
						DDReadArgs:=true
					end
			end
		else
			inherited DDReadArgs(dSize,PipeHnd,OrgID,WindID,mX,mY,KStat)
	end;


procedure TTexelApplication.DDFinished(OrgID,WindID,mX,mY,KStat: integer);
	var p: PChar;

	begin
		if ddfiles=nil then exit;
		p:=ddfiles;
		while p<>nil do LoadFile(nil,GetQuotedName(p));
		freemem(ddfiles,StrLen(ddfiles)+1);
		ddfiles:=nil
	end;


function TTexelApplication.DDGetPreferredTypes(WindID: integer): string;

	begin
		DDGetPreferredTypes:='.txt.txl.dif.dbf.csv.asc.img.FLT'
	end;


function TTexelApplication.IsInteger(s: string): boolean;
	var q: integer;

	begin
		if length(s)>0 then
			begin
				IsInteger:=true;
				for q:=1 to length(s) do
					if not(s[q] in ['0'..'9']) then
						begin
							IsInteger:=false;
							exit
						end
			end
		else
			IsInteger:=false
	end;


function TTexelApplication.IsNumber(s: string; var num: TNumber; var nums: string; vorz: boolean; trenn: char): boolean;
	var q : integer;
	    s2: string;
	    vz: string[1];

	begin
		IsNumber:=false;
		StrPTrim(s);
		vz:='';
		if vorz then
			if (StrPLeft(s,1)='+') or (StrPLeft(s,1)='-') then
				begin
					vz:=s[1];
					s:=StrPRight(s,length(s)-1)
				end;
		if trenn<>'.' then
			begin
				q:=pos(trenn,s);
				while q>0 do
					begin
						s[q]:='.';
						q:=pos(trenn,s)
					end
			end;
		s2:=StrPUpper(s);
		q:=pos('.',s2);
		if q>0 then
			begin
				if q=1 then s:='0'+s
				else
					if not(IsInteger(StrPLeft(s2,q-1))) then exit;
				s2:=StrPRight(s2,length(s2)-q)
			end;
		q:=pos('E',s2);
		if q>0 then
			begin
				if not(IsInteger(StrPLeft(s2,q-1))) then exit;
				s2:=StrPRight(s2,length(s2)-q);
				if (StrPLeft(s2,1)='+') or (StrPLeft(s2,1)='-') then s2:=StrPRight(s2,length(s2)-1)
			end;
		if IsInteger(s2) then
			begin
				IsNumber:=true;
				nums:=vz+s;
				num:=atof(vz+s)
			end
	end;


procedure TScrapDialog.GetWindowClass(var AWndClass: TWndClass);

	begin
		inherited GetWindowClass(AWndClass);
		with AWndClass do Style:=Style or cs_CancelOnClose
	end;


function TScrapDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then TexelApp.import^.ImportFromClipboard;
		OK:=valid
	end;


function TScrapDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		if AnIndx=RTSCIMPORT then
			with TexelApp do
				if import<>nil then
					if Clipboard^.OpenClipboard(false) then
						begin
							import^.LoadASCII(Clipboard^.GetClipboardFilename+ext);
							Clipboard^.CloseClipboard
						end;
		ExitDlg:=true
	end;


procedure TTexelApplication.SCChanged(OrgID: integer; Bits: word; Ext: string);
	var pb: PButton;

	begin
		if not(bTst(Bits,SCF_SHEET)) then
			begin
				if importscrap<>nil then importscrap^.Destroy;
				exit
			end;
		if importscrap=nil then
			begin
				new(importscrap,Init(nil,TEXELNAME,STG_CLIPBOARD,ICNTITLE_CLIPBOARD,RTSCRAP));
				new(pb,Init(importscrap,RTSCHELP,id_Help,false,BUBBLE_GENERAL_HELP));
				if pb<>nil then
					if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
				new(PButton,Init(importscrap,RTSCIMPORT,id_No,true,BUBBLE_CLIP_IMPORT));
				new(PButton,Init(importscrap,RTSCLOAD,id_OK,true,BUBBLE_CLIP_OK))
			end;
		if importscrap<>nil then
			begin
				if StrPLeft(Ext,1)='.' then importscrap^.ext:=StrPRight(Ext,length(Ext)-1)
				else
					importscrap^.ext:=Ext;
				importscrap^.MakeWindow
			end
	end;


procedure TTexelApplication.PRNChanged(OrgID,Device,Action: integer);
	var p: PWindow;

	begin
		{ Optionen - Einstellungen - Drucker... }
		p:=MainWindow;
		while p<>nil do
			begin
				if p^.GetClassName=TEXELWINDCLASS then PCalcWindow(p)^.PRNChanged(Device,Action);
				p:=p^.Next
			end
	end;


procedure TTexelApplication.FNTChanged(OrgID: integer);

	begin
		{ ... }
	end;


function TTexelApplication.ExtPrnSel(var prnt_set: PPRN_SETTINGS; pcopyps: PPRN_SETTINGS): boolean;
	var dummy,out: integer;

	begin
		ExtPrnSel:=false;
		if not(UseExtPrn) then exit;
		if appl_xgetinfo(7,out,dummy,dummy,dummy) then
			if bTst(out,16) then
				begin
					if prnt_dialog=nil then
						begin
							BusyMouse;
							with AES_pb do
								begin
									control^[0]:=200;
									control^[1]:=1;
									control^[2]:=0;
									control^[3]:=0;
									control^[4]:=1;
									intin^[0]:=PDLG_3D;
									_crystal(@AES_pb);
									prnt_dialog:=addrout^[0]
								end;
							ArrowMouse
						end;
					if (prnt_set=nil) and (prnt_dialog<>nil) then
						begin
							BusyMouse;
							with AES_pb do
								begin
									control^[0]:=205;
									control^[1]:=1;
									control^[2]:=0;
									control^[3]:=1;
									control^[4]:=1;
									intin^[0]:=5;
									addrin^[0]:=prnt_dialog;
									_crystal(@AES_pb);
									prnt_set:=addrout^[0]
								end;
							if (prnt_set<>nil) and (pcopyps<>nil) then
								if pcopyps^.magic='pset' then
									begin
										move(pcopyps^,prnt_set^,pcopyps^.len);
										with AES_pb do
											begin
												control^[0]:=205;
												control^[1]:=1;
												control^[2]:=1;
												control^[3]:=2;
												control^[4]:=0;
												intin^[0]:=8;
												addrin^[0]:=prnt_dialog;
												addrin^[1]:=prnt_set;
												_crystal(@AES_pb)
											end
									end;
							ArrowMouse
						end;
					if (prnt_dialog<>nil) and (prnt_set<>nil) then ExtPrnSel:=true
				end
	end;


function TTexelApplication.NoFontSel: boolean;
	var dummy,out: integer;

	begin
		nofontsel:=true;
		if GetCookie('xFSL',longint(callxfsl)) then
			begin
				if callxfsl=nil then exit;
				with callxfsl^ do
					if id='xFSL' then
						if revision>=4 then
							begin
								nofontsel:=false;
								exit
							end
			end;
		if appl_xgetinfo(7,out,dummy,dummy,dummy) then
			if bTst(out,4) then
				begin
					if fnt_dialog=nil then
						begin
							fnt_titel:=TEXELNAME+' '+VtoS(TEXELVER)+' '+STRING_FONTSELECTION+#0;
							BusyMouse;
							with AES_pb do
								begin
									control^[0]:=180;
									control^[1]:=4;
									control^[2]:=0;
									control^[3]:=2;
									control^[4]:=1;
									intin^[0]:=vdiHandle;
									intin^[1]:=Attr.sysFonts+Attr.addFonts;
									intin^[2]:=FNTS_ALL;
									intin^[3]:=FNTS_3D;
									addrin^[0]:=@fnt_titel[1];
									addrin^[1]:=nil;
									_crystal(@AES_pb);
									fnt_dialog:=addrout^[0]
								end;
							ArrowMouse
						end;
					if fnt_dialog<>nil then
						begin
							NoFontSel:=false;
							exit
						end
				end;
		if GetCookie('UFSL',longint(callufsl)) then
			if callufsl<>nil then nofontsel:=false
	end;


function TTexelApplication.Time2Str(time: longint): string;
	var ret,dummy: string;

	begin
		dummy:=ltoa((time shr 16) and $1f);
		if length(dummy)=1 then ret:='0'+dummy
		else
			ret:=dummy;
		dummy:=ltoa((time shr 21) and $f);
		if length(dummy)=1 then dummy:='0'+dummy;
		ret:=ret+'.'+dummy+'.';
		dummy:=ltoa((((time shr 25) and $7f)+80) mod 100);
		if length(dummy)=1 then dummy:='0'+dummy;
		ret:=ret+dummy+'  '+STRING_INFO_TIMEAT+'  ';
		dummy:=ltoa((time shr 11) and $1f);
		if length(dummy)=1 then dummy:='0'+dummy;
		ret:=ret+dummy+':';
		dummy:=ltoa((time shr 5) and $3f);
		if length(dummy)=1 then dummy:='0'+dummy;
		Time2Str:=ret+dummy
	end;


procedure TTexelApplication.FileChanged(const s: string);
	var pipe: Pipearray;

	begin
		if length(s)=0 then exit;
		pipe[1]:=apID;
		pipe[2]:=0;
		pipe[5]:=0;
		pipe[6]:=0;
		pipe[7]:=0;
		if length(s)>2 then
			if s[2]=':' then
				begin
					pipe[0]:=SH_WDRAW;
					pipe[3]:=ord(s[1])-65;
					pipe[4]:=0;
					Broadcast(@pipe,true)
				end;
		if AVServer>=0 then
			if filebuf<>nil then
				begin
					StrPCopy(filebuf,GetPath(s));
					pipe[0]:=AV_PATH_UPDATE;
					pipe[3]:=integer(HiWord(filebuf));
					pipe[4]:=integer(LoWord(filebuf));
					appl_write(AVServer,16,@pipe)
				end
	end;


procedure TTexelApplication.UpdateFile(const s: string; info: integer);
	label _raus;

	var p   : pointer;
	    pipe: Pipearray;

	begin
		if length(s)=0 then exit;
		if OLGAManager<0 then goto _raus;
		GlobalAlloc(p,256);
		if p=nil then goto _raus;
		StrPCopy(p,s);
		pipe[0]:=OLGA_UPDATE;
		pipe[1]:=apID;
		pipe[2]:=0;
		pipe[3]:=integer(HiWord(p));
		pipe[4]:=integer(LoWord(p));
		pipe[5]:=info;
		pipe[6]:=0;
		pipe[7]:=0;
		appl_write(OLGAManager,16,@pipe);
		_raus:
		FileChanged(s)
	end;


procedure TTexelApplication.OLGAGetInfo(OrgID,InfoNr: integer);
	var p: PCalcWindow;

	begin
		p:=PCalcWindow(GetPWindow(-InfoNr-1));
		if p<>nil then p^.OLGAGetInfo(OrgID,InfoNr)
	end;


procedure TTexelApplication.OLGAAck(Pipe: Pipearray);
	var p: pointer;

	begin
		case Pipe[7] of
		OLGA_LINK,
		OLGA_UNLINK,
		OLGA_UPDATE,
		OLGA_ACTIVATE:
			begin
				p:=Ptr(word(Pipe[3]),word(Pipe[4]));
				GlobalFree(p,256)
			end;
		OLGA_INFO:
			begin
				p:=Ptr(word(Pipe[3]),word(Pipe[4]));
				fdelete(StrPPas(p));
				GlobalFree(p,256)
			end;
		OLGA_RENAME:
			begin
				p:=Ptr(word(Pipe[3]),word(Pipe[4]));
				GlobalFree(p,256);
				p:=Ptr(word(Pipe[5]),word(Pipe[6]));
				GlobalFree(p,256)
			end;
		OLGA_START:
			begin
				if pipe[3]=0 then
					begin
						p:=Ptr(word(Pipe[4]),word(Pipe[5]));
						if pipe[6]=0 then
							if StrPUpper(StrPRight(StrPPas(p),4))='.TAD' then fdelete(StrPPas(p));
						GlobalFree(p,256)
					end
				else
					if pipe[6]=0 then
						begin
							if PCookieID(@pipe[4])^='.TAD' then Application^.Alert(nil,1,NOTE,MESSAGE_EMBED_ARTWORX,BUTTON_OK)
							else
								Application^.Alert(nil,1,NOTE,MESSAGE_EMBED_OLGA1+StrPTrimF(PCookieID(@pipe[4])^)+MESSAGE_EMBED_OLGA2,BUTTON_OK)
						end
			end
		end
	end;


procedure TTexelApplication.OLGAInit(OrgID,Msg,Ver,eFlag: integer);
	var pipe: Pipearray;

	begin
		inherited OLGAInit(OrgID,Msg,Ver,eFlag);
		if OLGAManager>=0 then
			begin
				pipe[0]:=OLGA_GETSETTINGS;
				pipe[1]:=apID;
				pipe[2]:=0;
				pipe[3]:=0;
				pipe[4]:=0;
				pipe[5]:=0;
				pipe[6]:=0;
				pipe[7]:=0;
				appl_write(OLGAManager,16,@pipe);
				if OLETypes=nil then
					begin
						new(OLETypes,Init(20,10));
						pipe[0]:=OLGA_GETOBJECTS;
						appl_write(OLGAManager,16,@pipe)
					end
			end
	end;


procedure TTexelApplication.OLEExit(OrgID: integer);
	var p: PWindow;

	begin
		inherited OLEExit(OrgID);
		if OLETypes<>nil then
			begin
				p:=MainWindow;
				while p<>nil do
					begin
						if p^.GetClassName=TEXELWINDCLASS then
							with PCalcWindow(p)^ do
								if oleobject<>nil then
									begin
										oleobject^.Disable;
										if oleobject^.ADialog<>nil then
											begin
												dispose(oleobject^.ADialog,Done);
												oleobject^.ADialog:=nil
											end
									end;
						p:=p^.Next
					end;
				dispose(OLETypes,Done);
				OLETypes:=nil;
			end
	end;


procedure TTexelApplication.OLGAObjects(OrgID,Rest: integer; Ext,Descr: string);
	var pipe: Pipearray;
	    p   : PWindow;
	    pole: POLEType;

	begin
		if OLETypes=nil then
			begin
				new(OLETypes,Init(Rest+10,10));
				if OLETypes=nil then exit
			end;
		if OLETypes^.Count=0 then
			begin
				p:=MainWindow;
				while p<>nil do
					begin
						if p^.GetClassName=TEXELWINDCLASS then
							if PCalcWindow(p)^.oleobject<>nil then PCalcWindow(p)^.oleobject^.Enable;
						p:=p^.Next
					end
			end;
		new(pole);
		if pole<>nil then
			begin
				pole^.Descr:=NewStr('  '+StrPLeft(Descr,38)+#0);
				if pole^.Descr=nil then dispose(pole)
				else
					begin
						pole^.Ext:=Ext;
						OLETypes^.Insert(pole)
					end
			end;
		if Rest>0 then
			begin
				pipe[0]:=OLGA_GETOBJECTS;
				pipe[1]:=apID;
				pipe[2]:=0;
				pipe[3]:=1;
				pipe[4]:=0;
				pipe[5]:=0;
				pipe[6]:=0;
				pipe[7]:=0;
				appl_write(OLGAManager,16,@pipe)
			end
		else
			begin
				new(pole);
				if pole<>nil then
					begin
						pole^.Descr:=NewStr('  '+STRING_ANY+#0);
						if pole^.Descr=nil then dispose(pole)
						else
							begin
								pole^.Ext:='';
								OLETypes^.AtInsert(0,pole)
							end
					end
			end
	end;


function TTexelApplication.LoadExtResource(fnam: string): boolean;

	begin
		LoadExtResource:=false;
		if RscPtr<>RSC_LOADED then exit;
		saveglobal:=GEM_pb.global;
		if rsrc_load(fnam)<>0 then
			begin
				FixResource(Ptr(word(GEM_pb.global[7]),word(GEM_pb.global[8])),FIXRSC,FIX_BBONLY);
				extglobal:=GEM_pb.global;
				LoadExtResource:=true
			end;
		GEM_pb.global:=saveglobal
	end;


procedure TTexelApplication.FreeExtResource;

	begin
		saveglobal:=GEM_pb.global;
		GEM_pb.global:=extglobal;
		rsrc_free;
		GEM_pb.global:=saveglobal
	end;


procedure TTexelApplication.ActivateExtResource;

	begin
		saveglobal:=GEM_pb.global;
		GEM_pb.global:=extglobal;
		ExtResource:=true
	end;


procedure TTexelApplication.DeactivateExtResource;

	begin
		GEM_pb.global:=saveglobal;
		ExtResource:=false
	end;


function TTexelApplication.num2str(s: string): string;
	var ret: string;
	    p  : integer;

	begin
		ret:='';
		StrPTrimF(s);
		while length(s)>0 do
			begin
				p:=pos(',',s);
				if p=0 then
					begin
						ret:=ret+chr(atol(s));
						s:=''
					end
				else
					begin
						ret:=ret+chr(atol(StrPLeft(s,p-1)));
						s:=StrPRight(s,length(s)-p)
					end;
				StrPTrimF(s)
			end;
		num2str:=ret
	end;


function TTexelApplication.XAccText(OrgID: integer; pText: pointer): boolean;
	var pw : PWindow;
	    cnt: integer;

	begin
		XAccText:=false;
		if pText=nil then exit;
		pw:=GetPTopWindow;
		if pw=nil then exit;
		if not(pw^.IsDialog) then exit;
		if PDialog(pw)^.GetClassName=TEXELWINDCLASS then
			with PCalcWindow(pw)^ do
				if (inpline<>nil) and not(inpstat) then
					begin
						if Parms.Cursor.Block then SetCursorPos(Parms.Cursor.Row,Parms.Cursor.Col,true);
						inpline^.Clear;
						EnableInpline
					end;
		cnt:=0;
		while not(PChar(pText)^ in [#0,#10,#13]) and (cnt<255) do
			begin
				PDialog(pw)^.InsertChar(PChar(pText)^);
				inc(cnt);
				inc(longint(pText))
			end;
		XAccText:=true
	end;


function TTexelApplication.HelpAvailable(loadstg: boolean): boolean;
	var s: string;

	begin
		HelpAvailable:=true;
		HelpID:=appl_find('ST-GUIDE');
		if HelpID>=0 then exit;
		s:=GetEnv('STGUIDE');
		if length(s)>0 then
			if Exist(s) then
				begin
					if loadstg then
						begin
							BusyMouse;
							if Exist(DataPath+TEXELHELP) then Application^.StartApp(s,DataPath+TEXELHELP)
							else
								Application^.StartApp(s,GUIDES+TEXELHELP);
							evnt_timer(250,0);
							ArrowMouse;
							HelpID:=appl_find('ST-GUIDE');
							if HelpID>=0 then exit
						end
					else
						exit
				end;
		HelpAvailable:=false
	end;


procedure TTexelApplication.ErrorWindowMemory(p: PWindow);

	begin
		Alert(p,1,STOP,MESSAGE_WINDOW_MEMORY,BUTTON_OK)
	end;


procedure TTexelApplication.InitSheetStructs(var parms: TTexelParms; var shbuf: TSheetBuffer; var dgbuf: TDialogBuffer; var zwbuf: TZielBuf; var dibuf: TDiagrammBuf; var exbuf: TExportBuf;
                                             var srbuf: TSortBuf; var inbuf: TInfoBuf; var fibuf: TFindBuf; var rebuf: TReplaceBuf; var flbuf: TFillBuffer);

	begin
		with parms do
			begin
				Percent:=100;
				psbuffer:=stdpsbuffer;
				Toolbar:=setupbuffer.toolbar;
				with Cursor do
					begin
						Block:=false;
						OldRow:=0;
						OldCol:=0;
						Row:=0;
						Col:=0
					end
			end;
		with shbuf do
			begin
				size:=setupbuffer.stdfsize;
				font:=setupbuffer.stdfont;
				gitter:=bf_Checked;
				autocalc:=setupbuffer.autocalc;
				vorlage:=bf_Unchecked;
				lhor:=bf_Unchecked;
				lvert:=bf_Unchecked;
				lmouse:=bf_Checked;
				llayout:=bf_Checked;
				images:=bf_Checked;
				protect:=bf_Unchecked;
				umbruch:=bf_Checked
			end;
		with dgbuf do
			begin
				font:=setupbuffer.stdfont;
				size:=setupbuffer.stdfsize;
				percent:=3;
				color:=White;
				pattern:=0;
				direction:=CRS_DOWN;
				input:='';
				txtcolor:=Black;
				border:=0;
				resvd1:=0;
				resvd2:=0;
				resvd3:=0;
				resvd4:=0
			end;
		with zwbuf do
			begin
				zzelle:='';
				vzelle:='';
				wert:='0';
				iterationen:='100'
			end;
		with dibuf do
			begin
				rb1:=bf_Checked;
				rb2:=bf_Unchecked;
				rb3:=bf_Unchecked;
				rb4:=bf_Unchecked;
				rb5:=bf_Unchecked;
				typLinie:=bf_Checked;
				typBalken:=bf_Unchecked;
				typKreis:=bf_Unchecked;
				Farbe:=bf_Checked;
				Absolut:=bf_Checked;
				xyLinear:=bf_Checked;
				xyFirst:=bf_Unchecked;
				xyAlternate:=bf_Unchecked;
				xyLine:=bf_Unchecked;
				xyPt:=bf_Unchecked;
				xyLinept:=bf_Checked;
				Stapeln:=bf_Unchecked;
				DreiD:=bf_Unchecked;
				Neben:=bf_Checked;
				stilLinie:=0;
				stilPunkt:=5;
				Titel:='';
				Legende:=bf_Checked;
				Border:=bf_Checked;
				nRow:=bf_Unchecked;
				nColumn:=bf_Unchecked;
				Size:=setupbuffer.stdfsize;
				Font:=setupbuffer.stdfont;
				dRows:=bf_Checked;
				dColumns:=bf_Unchecked;
				Ticks:=bf_Checked;
				numTicks:='4';
				alName:='Y';
				alTicks:=bf_Checked;
				alNum:='3';
				alMin:='';
				alMax:='';
				auName:='X';
				auTicks:=bf_Checked;
				auNum:='3';
				auMin:='';
				auMax:='';
				szWidth:='50.0';
				szHeight:='50.0';
				objFilename:=''
			end;
		with exbuf do
			begin
				exporttype:=0;
				clipboard:=bf_Unchecked;
				bereich:=bf_Unchecked;
				htmldoctype:=0;
				htmlsavedt:=bf_Checked;
				htmlcolor:=bf_Checked;
				csvformula:=bf_Unchecked;
				csvvalue:=bf_Checked;
				difformula:=bf_Unchecked;
				difvalue:=bf_Checked;
				difstandard:=bf_Checked;
				difexcel:=bf_Unchecked;
				with ascii do
					begin
						hor:=bf_Checked;
						vert:=bf_Unchecked;
						rctxt:='13,10';
						rcval:=0;
						celltxt:='9';
						cellval:=0;
						texttxt:='34';
						textval:=0;
						quote:=bf_Checked;
						numbers:=0;
						formula:=bf_Unchecked;
						value:=bf_Checked
					end;
				difformat:=bf_Checked;
				csvformat:=bf_Checked;
				asciiformat:=bf_Checked;
				htmlembed:=bf_Unchecked;
				filter:=0
			end;
		with srbuf do
			begin
				Pop1:=0;
				Up1:=bf_Checked;
				Down1:=bf_Unchecked;
				Pop2:=0;
				Up2:=bf_Checked;
				Down2:=bf_Unchecked;
				Pop3:=0;
				Up3:=bf_Checked;
				Down3:=bf_Unchecked;
				Columns:=bf_Checked;
				Rows:=bf_Unchecked;
				Ins:=bf_Checked;
				Pre:=bf_Unchecked;
				Post:=bf_Unchecked;
				Chars:=bf_Unchecked;
				EmptyPre:=bf_Unchecked;
				EmptyPost:=bf_Checked;
				Lexikal:=bf_Checked;
				Absolut:=bf_Unchecked;
				Attribute:=bf_Unchecked
			end;
		with inbuf do
			begin
				Autor:='';
				Stichwort:='';
				Rem1:='';
				Rem2:='';
				Rem3:='';
				Rem4:='';
				Encrypt:=bf_Checked;
				Resvd:=0;
				Created:=gettime;
				Last:=gettime;
				Resvd0:=0;
				Used:=1;
				Printed:=0;
				Version:=0;
				Release:=0
			end;
		with fibuf do
			begin
				search:='';
				rows:=bf_Checked;
				columns:=bf_Unchecked;
				cse:=bf_Unchecked;
				complete:=bf_Unchecked;
				formula:=bf_Checked;
				value:=bf_Checked;
				txt:=bf_Checked;
				iform:=bf_Unchecked;
				ival:=bf_Checked;
				vor:=bf_Checked;
				zurueck:=bf_Unchecked;
				resvd:=0
			end;
		with rebuf do
			begin
				search:='';
				replace:='';
				rows:=bf_Checked;
				columns:=bf_Unchecked;
				cse:=bf_Unchecked;
				complete:=bf_Unchecked;
				formula:=bf_Checked;
				value:=bf_Checked;
				txt:=bf_Checked;
				vor:=bf_Checked;
				zurueck:=bf_Unchecked;
				resvd:=0
			end;
		with flbuf do
			begin
				rows:=bf_Checked;
				columns:=bf_Unchecked;
				arithm:=bf_Checked;
				geom:=bf_Unchecked;
				date:=bf_Unchecked;
				cpy:=bf_Unchecked;
				trend:=bf_Unchecked;
				day:=bf_Checked;
				wday:=bf_Unchecked;
				month:=bf_Unchecked;
				year:=bf_Unchecked;
				stepval:='1';
				endval:=''
			end
	end;


procedure TTexelApplication.FilterString(id: integer; var s: string);
	var i,nr: integer;

	begin
		if length(s)>0 then
			begin
				nr:=pkt^.GetImportFilter(nil,nil,0,0,0,id);
				for i:=1 to length(s) do s[i]:=pkt^.ImportChar(nil,nil,0,0,0,nr,s[i])
			end
	end;


function TTexelApplication.dosmask(s: string): string;
	var i: integer;

	procedure replace(alt,neu: char);
	
		begin
			i:=pos(alt,s);
			while i>0 do
				begin
					s[i]:=neu;
					i:=pos(alt,s)
				end
		end;
	
	begin
		if InitKeyTab then FilterString(KEYTAB_ID_ANSI,s)
		else
			begin
				replace(#228,'„');
				replace(#246,'”');
				replace(#252,'');
				replace(#223,'ž');
				replace(#196,'Ž');
				replace(#214,'™');
				replace(#220,'š');
				replace(#178,#253);
				replace(#179,#254);
				replace(#181,#230)
			end;
		dosmask:=s
	end;


function TTexelApplication.macmask(s: string): string;
	var i: integer;

	procedure replace(alt,neu: char);
	
		begin
			i:=pos(alt,s);
			while i>0 do
				begin
					s[i]:=neu;
					i:=pos(alt,s)
				end
		end;
	
	begin
		if InitKeyTab then FilterString(KEYTAB_ID_MAC,s)
		else
			begin
				replace(#138,'„');
				replace('š','”');
				replace(#159,'');
				replace('€','Ž');
				replace(#133,'™');
				replace('†','š');
				replace(#167,'ž')
			end;
		macmask:=s
	end;


function TTexelApplication.IsLongFileName(fname: string): boolean;
	var maxmode: longint;

	begin
		fname:=GetPath(fname);
		if length(fname)=0 then IsLongFileName:=false
		else
			begin
				maxmode:=dpathconf(fname,-1);
				if maxmode<3 then IsLongFileName:=false
				else
					IsLongFileName:=(dpathconf(fname,3)>12)
			end
	end;


procedure TTexelApplication.AbandonFile(p: PCalcWindow);
	var s: string;

	begin
		if (p=nil) or (opennewdoc=nil) then exit;
		s:=p^.GetWindowFileName;
		if length(s)=0 then exit;
		if not(Exist(s)) then exit;
		if Alert(p,1,WAIT,MESSAGE_WINDOW_ABANDON1+CompressPath(s,78)+MESSAGE_WINDOW_ABANDON2,BUTTON_YESNO)=1 then
			begin
				p^.ClearDirty;
				dispose(p,Done);
				opennewdoc^.Load(s)
			end
	end;


procedure TTexelApplication.InitCells(cell: PCell; rmax,cmax: integer);
	var w,q: integer;

	begin
		for q:=0 to rmax-1 do
			for w:=0 to cmax-1 do
				begin
					with cell^ do
						begin
							Color:=Black;
							Style:=8;
							TxtVal.Color:=Black
						end;
					inc(longint(cell),CELLSIZE)
				end
	end;


procedure TAboutDialog.EndDlg(Indx: integer; DblClick: boolean);
	var s: string;

	begin
		if (Indx=RTAASH) and DblClick then
			begin
				s:=GetEnv('GEMJINGPATH');
				if length(s)=0 then s:=TexelApp.DataPath+GEMJING;
				if Exist(s) then
					if Exist(TexelApp.DataPath+TEXELSOUND) then
						begin
							BusyMouse;
							Application^.StartApp(s,'-q '+TexelApp.DataPath+TEXELSOUND);
							ArrowMouse
						end
			end;
		inherited EndDlg(Indx,DblClick)
	end;


procedure TAbout.Work;
	var p : PStatic;
	    pc: PControl;
	    s : string;

	begin
		if ADialog=nil then
			begin
				TexelApp.ActivateExtResource;
				ADialog:=new(PAboutDialog,Init(nil,TITLE_ABOUT,STG_ABOUT,ICNTITLE_ABOUT,RTABOUT));
				if ADialog<>nil then
					begin
						new(p,Init(ADialog,RTAVERSION,26,false,BUBBLE_EASTEREGG));
						if p<>nil then
							begin
								s:=StrPSpace(2-length(ltoa(RELEASE)));
								{$IFDEF BETA}
								{$IFDEF DEMO}
								if RELEASE=0 then p^.SetText('   ASH-TEXEL Version '+VtoS(TEXELVER))
								else
									p^.SetText(s+'ASH-TEXEL Version '+VtoS(TEXELVER)+'r'+ltoa(RELEASE))
								{$ELSE}
								if RELEASE=0 then p^.SetText('   ASH-TEXEL  v '+VtoS(TEXELVER)+'-beta')
								else
									p^.SetText(s+'ASH-TEXEL  v '+VtoS(TEXELVER)+'r'+ltoa(RELEASE)+'-beta')
								{$ENDIF}
								{$ELSE}
								if RELEASE=0 then p^.SetText('   ASH-TEXEL Version '+VtoS(TEXELVER))
								else
									p^.SetText(s+'ASH-TEXEL Version '+VtoS(TEXELVER)+'r'+ltoa(RELEASE))
								{$ENDIF}
							end;
						new(p,Init(ADialog,RTADATE,13,false,BUBBLE_EASTEREGG));
						if p<>nil then p^.SetText('('+TEXELDATE+')');
						new(p,Init(ADialog,RTANAME,41,false,''));
						if p<>nil then
							begin
								{$IFDEF DEMO}
								p^.Clear
								{$ELSE}
								{$IFDEF BETA}
								if length(regname)=0 then p^.SetText('Name:     - unregistrierte Version -')
								else
									p^.SetText('Name:     '+regname)
								{$ELSE}
								p^.SetText('Name:     '+decode_name(ash_name))
								{$ENDIF}
								{$ENDIF}
							end;
						new(serst,Init(ADialog,RTASERNO,41,false,''));
						sertxt:='';
						serscroll:=dank[0];
						arraycount:=0;
						tstart:=0;
						if serst<>nil then
							begin
								{$IFDEF DEMO}
								sertxt:='      -- D E M O V E R S I O N --';
								{$ELSE}
								{$IFDEF BETA}
								if length(regkey)>0 then sertxt:='   Betaversion! Gltig bis '+EXPIRESTR+'.';
								{$ELSE}
								sertxt:='Reg.-Nr.: '+decode_name(ash_serno);
								{$ENDIF}
								{$ENDIF}
								serst^.SetText(sertxt)
							end;
						if Application^.Attr.Colors<16 then
							begin
								new(pc,Init(ADialog,RTAKREIS,''));
								if pc<>nil then pc^.Hide(false);
								new(pc,Init(ADialog,RTASCHATTEN,''));
								if pc<>nil then pc^.SetColor(White)
							end;
						new(pc,Init(ADialog,RTAASH,''));
						if pc<>nil then pc^.ID:=id_NoExit;
						new(PButton,Init(ADialog,RTAOK,id_OK,true,BUBBLE_ABOUT_OK))
					end;
				TexelApp.DeactivateExtResource
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


procedure TNew.Work;

	begin
		new(PCalcWindow,Init)
	end;


constructor TMinMaxValidator.Init(mnv,mxv: real);

	begin
		if not(inherited Init) then fail;
		MinVal:=mnv;
		MaxVal:=mxv
	end;


procedure TMinMaxValidator.Error;

	begin
		if Application<>nil then
			with Application^ do
				begin
					if (Attr.Country=FRG) or (Attr.Country=SWG) then
						Alert(Window,1,NOTE,' Wert nicht im Bereich von ('+ftoa(MinVal)+','+ftoa(MaxVal)+')',BUTTON_OK)
					else
						Alert(Window,1,NOTE,' Value not in range ('+ftoa(MinVal)+','+ftoa(MaxVal)+')',BUTTON_OK)
			end
	end;


function TMinMaxValidator.IsValid(s: string): boolean;
	var r: real;

	begin
		StrPTrim(s);
		if inherited IsValid(s) then
			begin
				r:=atof(s);
				IsValid:=(r>MinVal) and (r<MaxVal)
			end
		else
			IsValid:=false
	end;


function TMinMaxValidator.IsValidInput(var s: string; SuppressFill: boolean): boolean;
	var r: real;

	begin
		if inherited IsValidInput(s,SuppressFill) then
			begin
				r:=atof(s);
				IsValidInput:=(r>MinVal) and (r<MaxVal)
			end
		else
			IsValidInput:=false
	end;


constructor TPosMaxValidator.Init(mxv: real);

	begin
		if not(inherited Init(0.0,mxv)) then fail
	end;


procedure TPosRealValidator.Error;

	begin
		if Application<>nil then
			with Application^ do
				begin
					if (Attr.Country=FRG) or (Attr.Country=SWG) then
						Alert(Window,1,NOTE,' Wert darf nicht negativ sein.',BUTTON_OK)
					else
						Alert(Window,1,NOTE,' Value must not be negative.',BUTTON_OK)
			end
	end;


function TPosRealValidator.IsValid(s: string): boolean;

	begin
		StrPTrim(s);
		if inherited IsValid(s) then IsValid:=(atof(s)>=0.0)
		else
			IsValid:=false
	end;


function TPosRealValidator.IsValidInput(var s: string; SuppressFill: boolean): boolean;

	begin
		if inherited IsValidInput(s,SuppressFill) then IsValidInput:=(atof(s)>=0.0)
		else
			IsValidInput:=false
	end;


function TPSDialog.OK: boolean;
	var psd: TPSBuffer;
	    ops: PPSBuffer;
	    but: integer;

	function BlockCorrect(blck: string): boolean;
		var c: integer;

		function cellcorrect(cl: string; nr: integer): boolean;
			var q,w: integer;

			begin
				cellcorrect:=false;
				StrPTrim(cl);
				if length(cl)=0 then exit;
				q:=1;
				while (cl[q] in ['A'..'Z']) and (q<=length(cl)) do inc(q);
				w:=q;
				while (cl[w] in ['0'..'9']) and (w<=length(cl)) do inc(w);
				if w=q then
					if w=1 then exit;
				if w=length(cl)+1 then cellcorrect:=true
			end;

		begin
			blck:=StrPUpper(StrPTrimF(blck));
			if length(blck)=0 then
				begin
					BlockCorrect:=true;
					exit
				end
			else
				BlockCorrect:=false;
			c:=pos(':',blck);
			if c>0 then
				begin
					if cellcorrect(StrPLeft(blck,c-1),1) then
						if cellcorrect(StrPRight(blck,length(blck)-c),2) then BlockCorrect:=true
				end
			else
				if cellcorrect(blck,0) then BlockCorrect:=true
		end;

	begin
		ops:=TransferBuffer;
		TransferBuffer:=@psd;
		TransferData(tf_GetData);
		TransferBuffer:=ops;
		if not(BlockCorrect(psd.bereich)) then
			begin
				Application^.Alert(@self,1,NOTE,MESSAGE_LAYOUT_RANGE,BUTTON_OK);
				OK:=false
			end
		else
			begin
				if ((atof(psd.kopf)<=0.0) and (((psd.hlefton=bf_Checked) and (length(psd.hleft)>0)) or ((psd.hcenteron=bf_Checked) and (length(psd.hmid)>0)) or ((psd.hrighton=bf_Checked) and (length(psd.hright)>0)))) or
				   ((atof(psd.fuss)<=0.0) and (((psd.flefton=bf_Checked) and (length(psd.fleft)>0)) or ((psd.fcenteron=bf_Checked) and (length(psd.fmid)>0)) or ((psd.frighton=bf_Checked) and (length(psd.fright)>0)))) then
					begin
						but:=Application^.Alert(@self,2,NOTE,MESSAGE_LAYOUT_HEADFOOT,BUTTON_OKMINIMALCANCEL);
						if but=2 then MinimalHeadFoot
						else
							if but<>1 then
								begin
									OK:=false;
									exit
								end
					end;
				if inherited OK then
					begin
						OK:=true;
						if Parent^.GetClassName=TEXELWINDCLASS then PCalcWindow(Parent)^.SetDirty
					end
				else
					OK:=false
			end
	end;


procedure TPSDialog.MinimalHeadFoot;
	label _fertig;

	var p         : PCalcWindow;
	    hcell,
	    num,q,hndl: integer;
	    ewrkout,
	    wrkout    : workout_ARRAY;
	    hmin,fmin,
	    yfak      : real;
	    psd       : TPSBuffer;
	    ops       : PPSBuffer;

	begin
		BusyMouse;
		p:=PCalcWindow(Parent);
		ops:=TransferBuffer;
		TransferBuffer:=@psd;
		TransferData(tf_GetData);
		TransferBuffer:=ops;
		hmin:=0.0;
		fmin:=0.0;
		if not(Application^.GDOSActive) then goto _fertig;
		if ((psd.hlefton=bf_Unchecked) or (length(psd.hleft)=0)) and ((psd.hcenteron=bf_Unchecked) or (length(psd.hmid)=0)) and ((psd.hrighton=bf_Unchecked) or (length(psd.hright)=0)) and
		   ((psd.flefton=bf_Unchecked) or (length(psd.fleft)=0)) and ((psd.fcenteron=bf_Unchecked) or (length(psd.fmid)=0)) and ((psd.frighton=bf_Unchecked) or (length(psd.fright)=0)) then goto _fertig;
		if p^.prnt=nil then goto _fertig;
		if not(p^.prnt^.IsAvailable(true)) then goto _fertig;
		num:=p^.prnt^.GetDevice;
		if (num<11) or (num>99) then goto _fertig;
		vOpnwk(num,hndl,wrkout,p^.prnt^.GetPaperSize,'',p^.wnd_prnt_set);
		if hndl<>0 then
			begin
				inc(wrkout[10],vst_load_fonts(hndl,0));
				vq_extnd(hndl,1,ewrkout);
				vst_font(hndl,p^.GetStdFontIndex);
				if p^.Speedo then vst_arbpt(hndl,p^.GetStdFontSize,q,q,q,hcell)
				else
					vst_point(hndl,p^.GetStdFontSize,q,q,q,hcell);
				vst_unload_fonts(hndl,0);
				v_clswk(hndl);
				case ewrkout[20] of
				1:
					yfak:=longint(ewrkout[22])/longint(100);
				2:
					yfak:=longint(ewrkout[22])/longint(1000);
				3:
					yfak:=longint(ewrkout[22])/longint(10000)
				else
					yfak:=longint(wrkout[4])/longint(10)
				end;
				yfak:=round(yfak*(hcell+1))/100.0;
				if (((psd.hlefton=bf_Checked) and (length(psd.hleft)>0)) or ((psd.hcenteron=bf_Checked) and (length(psd.hmid)>0)) or ((psd.hrighton=bf_Checked) and (length(psd.hright)>0))) then hmin:=yfak;
				if (((psd.flefton=bf_Checked) and (length(psd.fleft)>0)) or ((psd.fcenteron=bf_Checked) and (length(psd.fmid)>0)) or ((psd.frighton=bf_Checked) and (length(psd.fright)>0))) then fmin:=yfak
			end;
		_fertig:
		ed1^.SetText(ftoa(hmin));
		ed2^.SetText(ftoa(fmin));
		ArrowMouse
	end;


function TPSDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		case AnIndx of
		RTPSSET:
			OK;
		RTPSMINIMAL:
			MinimalHeadFoot
		end
	end;


procedure TPageSetup.Work;
	var pe: PEdit;
	    pc: PCheckBox;
	    pb: PButton;

	begin
		if ADialog=nil then
			begin
				ADialog:=new(PPSDialog,Init(PCalcWindow(Parent),TEXELWINDPREFIX+TITLE_LAYOUT,STG_LAYOUT,ICNTITLE_LAYOUT,RTPAGESETUP));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTPSMARGINS,GROUP_LAYOUT_MARGINS,''));
						new(PGroupBox,Init(ADialog,RTPSCENTER,GROUP_LAYOUT_CENTER,''));
						new(PGroupBox,Init(ADialog,RTPSPRINT,GROUP_LAYOUT_PRINTWITH,''));
						new(PGroupBox,Init(ADialog,RTPSBEREICH,GROUP_LAYOUT_PRINTRANGE,''));
						new(PGroupBox,Init(ADialog,RTPSHEAD,GROUP_LAYOUT_HEAD,''));
						new(PGroupBox,Init(ADialog,RTPSFOOT,GROUP_LAYOUT_FOOT,''));
						new(PGroupBox,Init(ADialog,RTPSNUM,GROUP_LAYOUT_NUM,''));
						new(pe,Init(ADialog,RTPSTOP,9,BUBBLE_LAYOUT_TMARGIN));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(pe,Init(ADialog,RTPSBOTTOM,9,BUBBLE_LAYOUT_BMARGIN));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(pe,Init(ADialog,RTPSLEFT,9,BUBBLE_LAYOUT_LMARGIN));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(pe,Init(ADialog,RTPSRIGHT,9,BUBBLE_LAYOUT_RMARGIN));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(PCheckBox,Init(ADialog,RTPSHCENTER,true,BUBBLE_LAYOUT_HCENTER));
						new(PCheckBox,Init(ADialog,RTPSVCENTER,true,BUBBLE_LAYOUT_VCENTER));
						new(PCheckBox,Init(ADialog,RTPSGITTER,true,BUBBLE_LAYOUT_GRID));
						new(PCheckBox,Init(ADialog,RTPSROWS,true,BUBBLE_LAYOUT_NUMBERS));
						new(PCheckBox,Init(ADialog,RTPSCOLUMNS,true,BUBBLE_LAYOUT_NAMES));
						new(pe,Init(ADialog,RTPSBEDIT,16,BUBBLE_LAYOUT_PRNTRANGE));
						new(pe,Init(ADialog,RTPSHLEFT,42,BUBBLE_LAYOUT_LHEAD));
						new(pe,Init(ADialog,RTPSHMID,42,BUBBLE_LAYOUT_CHEAD));
						new(pe,Init(ADialog,RTPSHRIGHT,42,BUBBLE_LAYOUT_RHEAD));
						new(pe,Init(ADialog,RTPSFLEFT,42,BUBBLE_LAYOUT_LFOOT));
						new(pe,Init(ADialog,RTPSFMID,42,BUBBLE_LAYOUT_CFOOT));
						new(pe,Init(ADialog,RTPSFRIGHT,42,BUBBLE_LAYOUT_RFOOT));
						new(PRadioButton,Init(ADialog,RTPSNUM1,false,BUBBLE_LAYOUT_NUMHOR));
						new(PRadioButton,Init(ADialog,RTPSNUM2,false,BUBBLE_LAYOUT_NUMVERT));
						new(pc,Init(ADialog,RTPSHLEFTON,true,BUBBLE_LAYOUT_PLHEAD));
						new(pc,Init(ADialog,RTPSHCENTERON,true,BUBBLE_LAYOUT_PCHEAD));
						new(pc,Init(ADialog,RTPSHRIGHTON,true,BUBBLE_LAYOUT_PRHEAD));
						new(pc,Init(ADialog,RTPSFLEFTON,true,BUBBLE_LAYOUT_PLFOOT));
						new(pc,Init(ADialog,RTPSFCENTERON,true,BUBBLE_LAYOUT_PCFOOT));
						new(pc,Init(ADialog,RTPSFRIGHTON,true,BUBBLE_LAYOUT_PRFOOT));
						new(PCheckBox,Init(ADialog,RTPSOBJECTS,true,BUBBLE_LAYOUT_POBJECTS));
						new(pe,Init(ADialog,RTPSKOPF,9,BUBBLE_LAYOUT_MHEAD));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						PPSDialog(ADialog)^.ed1:=pe;
						new(pe,Init(ADialog,RTPSFUSS,9,BUBBLE_LAYOUT_MFOOT));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						PPSDialog(ADialog)^.ed2:=pe;
						new(pb,Init(ADialog,RTPSHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTPSMINIMAL,id_No,true,BUBBLE_LAYOUT_MINIMAL));
						new(PButton,Init(ADialog,RTPSCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTPSSET,id_No,true,BUBBLE_GENERAL_SET2));
						new(PButton,Init(ADialog,RTPSOK,id_OK,true,BUBBLE_GENERAL_OK));
						ADialog^.TransferBuffer:=@PCalcWindow(Parent)^.Parms.psbuffer
					end
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


procedure TFormCategoryBox.Work;
	var q,sel: integer;
	    pfm  : PFormat;
	    pfc  : PFormatCollection;

	begin
		if TexelApp.Formats^.Count=0 then exit;
		sel:=GetSelection;
		if sel<0 then exit;
		flist^.FreeAll;
		flist^.Sort:=false;
		if sel<>1 then
			for q:=0 to TexelApp.Formats^.Count-1 do
				if (sel=0) or (PFormat(TexelApp.Formats^.At(q))^.Group=sel) then
					begin
						new(pfm);
						if pfm<>nil then
							begin
								pfm^.Name:=NewStr('  '+StrPLeft(PFormat(TexelApp.Formats^.At(q))^.Name^,30)+' '#0);
								pfm^.Group:=PFormat(TexelApp.Formats^.At(q))^.Group;
								pfm^.Index:=PFormat(TexelApp.Formats^.At(q))^.Index;
								flist^.Insert(pfm)
							end
					end;
		if (sel=0) or (sel=1) then
			begin
				pfc:=PCalcWindow(Parent^.Parent)^.UsrFormats;
				if pfc<>nil then
					if pfc^.Count>0 then
						for q:=0 to pfc^.Count-1 do
							begin
								new(pfm);
								if pfm<>nil then
									begin
										pfm^.Name:=NewStr('  '+StrPLeft(PFormat(pfc^.At(q))^.Name^,30)+' '#0);
										pfm^.Group:=PFormat(pfc^.At(q))^.Group;
										pfm^.Index:=PFormat(pfc^.At(q))^.Index;
										flist^.Insert(pfm)
									end
							end
			end;
		fbox^.SetCollection(flist);
		if (flist^.Count=0) or (sel<>1) then
			begin
				delbtn^.Disable;
				chgbtn^.Disable
			end
		else
			begin
				delbtn^.Enable;
				chgbtn^.Enable
			end;
		if flist^.Count=0 then
			begin
				okbtn^.Disable;
				setbtn^.Disable;
				format^.Clear;
				preview^.Clear
			end
		else
			begin
				okbtn^.Enable;
				setbtn^.Enable
			end
	end;


procedure TCatFormBox.Work;
	var pfm : PFormat;
	    p   : PCalcWindow;
	    cell: PCell;
	    idx : integer;

	begin
		if List=nil then exit;
		if List^.Count=0 then exit;
		p:=PCalcWindow(Parent^.Parent);
		with p^.Parms.Cursor do
			if Block then cell:=p^.GetCell(RowStart,ColStart)
			else
				cell:=p^.GetCell(Row,Col);
		idx:=PFormat(List^.At(GetSelection))^.Index;
		if idx>=1000 then pfm:=PFormat(PCalcWindow(Parent^.Parent)^.UsrFormats^.At(idx-1000))
		else
			pfm:=PFormat(TexelApp.Formats^.At(idx));
		pfcb^.format^.SetText(StrPTrimF(pfm^.Name^));
		case cell^.Typ of
		CTYPE_TEXT:
			pfcb^.preview^.SetText(cell^.Data.Txt^);
		CTYPE_CONST:
			with cell^.Data.Konst^ do pfcb^.preview^.SetText(p^.Val2TxtF(Value,FPts,pfm^.Index,nil));
		CTYPE_FORMULA:
			with cell^.Data.Formula^ do pfcb^.preview^.SetText(p^.Val2TxtF(Value,FPts,pfm^.Index,nil))
		else
			pfcb^.preview^.Clear
		end;
		if pfm^.Group=1 then
			begin
				pfcb^.delbtn^.Enable;
				pfcb^.chgbtn^.Enable
			end
		else
			begin
				pfcb^.delbtn^.Disable;
				pfcb^.chgbtn^.Disable
			end
	end;


procedure TCategoryBox.Work;
	var grp,q,sel: integer;

	begin
		if TexelApp.Functions^.Count=0 then exit;
		sel:=GetSelection;
		if sel<0 then exit;
		flist^.FreeAll;
		grp:=PCategory(TexelApp.Categories^.At(sel))^.Group;
		flist^.Sort:=true;
		flist^.CaseSensitive:=false;
		for q:=0 to TexelApp.Functions^.Count-1 do
			if (grp=0) or (PFunction(TexelApp.Functions^.At(q))^.Group=grp) then
				flist^.Insert(NewStr('  '+StrPLeft(PFunction(TexelApp.Functions^.At(q))^.Name^,30)+' '#0));
		fbox^.SetCollection(flist);
		if flist^.Count=0 then
			begin
				hlpbtn^.Disable;
				PFunktionDialog(Parent)^.descr1^.SetText('');
				PFunktionDialog(Parent)^.descr2^.SetText('')
			end
		else
			if not(TexelApp.HelpAvailable(false)) then hlpbtn^.Disable
			else
				hlpbtn^.Enable
	end;


procedure TCatFuncBox.Work;
	var grp,sel,bis,q: integer;

	begin
		if TexelApp.Functions^.Count=0 then exit;
		sel:=pcb^.GetSelection;
		if sel<0 then exit;
		grp:=PCategory(TexelApp.Categories^.At(sel))^.Group;
		bis:=GetSelection;
		for q:=0 to TexelApp.Functions^.Count-1 do
			if (grp=0) or (PFunction(TexelApp.Functions^.At(q))^.Group=grp) then
				begin
					if bis=0 then
						begin
							if PFunction(TexelApp.Functions^.At(q))^.Descr1=nil then PFunktionDialog(Parent)^.descr1^.SetText('')
							else
								PFunktionDialog(Parent)^.descr1^.SetText(PFunction(TexelApp.Functions^.At(q))^.Descr1^);
							if PFunction(TexelApp.Functions^.At(q))^.Descr2=nil then PFunktionDialog(Parent)^.descr2^.SetText('')
							else
								PFunktionDialog(Parent)^.descr2^.SetText(PFunction(TexelApp.Functions^.At(q))^.Descr2^);
							break
						end;
					dec(bis)
				end
	end;


function TFunktionDialog.Help: boolean;
	var hlp : string;
	    pipe: Pipearray;

	begin
		Help:=false;
		hlp:=StrPTrimF(PString(fbox^.List^.At(fbox^.GetSelection))^);
		if (length(hlp)=0) or not(TexelApp.HelpAvailable(true)) then exit;
		if Exist(TexelApp.DataPath+TEXELHELPREF) then StrPCopy(helpbuf,TexelApp.DataPath+TEXELHELPREF+' '''+hlp+'''')
		else
			StrPCopy(helpbuf,GUIDES+TEXELHELPREF+' '''+hlp+'''');
		pipe[0]:=VA_START;
		pipe[1]:=Application^.apID;
		pipe[2]:=0;
		pipe[3]:=integer(HiWord(helpbuf));
		pipe[4]:=integer(LoWord(helpbuf));
		pipe[5]:=0;
		pipe[6]:=0;
		pipe[7]:=0;
		appl_write(TexelApp.HelpID,16,@pipe)
	end;


function TFunktionDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTFNINSERT);
		OK:=valid
	end;


function TFunktionDialog.ExitDlg(AnIndx: integer): boolean;
	var p      : PCalcWindow;
	    txt,inp: string;
	    q,i,w  : integer;
	    tl,tr  : char;

	begin
		ExitDlg:=false;
		if AnIndx=RTFNINSERT then
			begin
				p:=PCalcWindow(Parent);
				if p^.inpline=nil then exit;
				txt:=StrPTrimF(descr1^.GetText);
				q:=pos('(',txt);
				if q>0 then
					begin
						txt:=StrPLeft(txt,q)+')';
						i:=length(txt)-1
					end
				else
					i:=length(txt);
				if p^.inpstat then
					begin
						inp:=StrPTrimF(p^.inpline^.GetText);
						if length(inp)>0 then
							if inp[1]<>'=' then
								begin
									Application^.Bing;
									exit
								end;
						if (length(inp)=0) or (inp='=') then
							begin
								inp:='='+txt;
								p^.inpline^.SetText(inp);
								p^.inpline^.SetCursor(i+1)
							end
						else
							begin
								w:=p^.inpline^.GetCursor;
								if w<1 then Application^.Bing
								else
									begin
										inp:=p^.inpline^.GetText;
										tl:=inp[w];
										if w<length(inp) then tr:=inp[w+1]
										else
											tr:=#0;
										if (tl in [' ','(','+','-','*','/','^',',','=']) and (tr in [#0,' ',')','+','-','*','/','^',',']) then
											begin
												inp:=StrPTrimF(StrPLeft(inp,w)+txt+StrPRight(inp,length(inp)-w));
												p^.inpline^.SetText(inp);
												p^.inpline^.SetCursor(w+i)
											end
										else
											Application^.Bing
									end
							end
					end
				else
					begin
						with p^.Parms.Cursor do if Block then p^.SetCursorPos(Row,Col,true);
						p^.inpline^.SetText('='+txt);
						p^.inpline^.SetCursor(i+1);
						p^.EnableInpline
					end
			end
	end;


function TFunktionDialog.GetIconTitle: string;

	begin
		GetIconTitle:='FUNKTION'
	end;


procedure TFunktion.Work;
	var pcb: PCategoryBox;

	begin
		if ADialog=nil then
			begin
				ADialog:=new(PFunktionDialog,Init(PCalcWindow(Parent),TEXELWINDPREFIX+TITLE_FUNCTION,RTFUNCTION));
				if ADialog<>nil then
					begin
						new(pcb,Init(ADialog,RTFNCATEGORY,RTFNCATSLID,RTFNCATDEC,RTFNCATINC,TexelApp.Categories,false,BUBBLE_FN_GROUPS));
						if pcb<>nil then
							begin
								new(pcb^.flist,Init(50,20));
								new(pcb^.fbox,Init(ADialog,RTFNFUNCTION,RTFNFUNCSLID,RTFNFUNCDEC,RTFNFUNCINC,pcb^.flist,true,BUBBLE_FN_FUNCTIONS));
								if pcb^.fbox<>nil then pcb^.fbox^.pcb:=pcb;
								new(pcb^.hlpbtn,Init(ADialog,RTFNHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								PFunktionDialog(ADialog)^.fbox:=pcb^.fbox
							end
						else
							PFunktionDialog(ADialog)^.fbox:=nil;
						new(PFunktionDialog(ADialog)^.descr1,Init(ADialog,RTFNDESCR1,64,false,BUBBLE_FN_SYNTAX));
						new(PFunktionDialog(ADialog)^.descr2,Init(ADialog,RTFNDESCR2,85,false,BUBBLE_FN_DESCR));
						new(PButton,Init(ADialog,RTFNCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTFNINSERT,id_No,true,BUBBLE_FN_INSERT));
						new(PButton,Init(ADialog,RTFNOK,id_OK,true,BUBBLE_FN_OK));
						if pcb<>nil then pcb^.Work
					end
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


procedure TDiagrammBox.SetValue(Sel: integer);
	var p: PTree;

	begin
		if not(Between(Sel,0,5)) or (Popup=nil) then inherited SetValue(Sel)
		else
			if Popup^.PopTree=nil then inherited SetValue(Sel)
			else
				begin
					with PDiagrammDialog(Parent)^.DlgTree^[ObjAddr^.ob_head] do
						ob_spec.bit_blk^.bi_pdata:=Popup^.PopTree^[Popup^.PopTree^[0].ob_head+Sel].ob_spec.bit_blk^.bi_pdata;
					SetText('')
				end
	end;


function TDiagrammDialog.CreateDiagram(tadname: string; emb: boolean): boolean;
	label _raus,_error;
	
	var fname,
	    sd,
	    s    : string;
	    l1,l2,
	    lofs,
	    anz,
	    fsize,
	    res  : longint;
	    pf   : PFont;
	    cs,rs,
	    ce,re,
	    dummy,
	    q,w,
	    coll,
	    rowl,
	    rof,
	    cof,
	    findx,
	    hdl  : integer;
	    pc   : pointer;
	    tag  : TTAG;
	    lr   : LRECT;
	    p    : PCalcWindow;
	    cell2,
	    cell : PCell;
	    almin,
	    almax,
	    aumin,
	    aumax,
	    xcmp,
	    xmin,
	    xmax,
	    vcmp,
	    vmin,
	    vmax : real;
	    xy   : array [0..4] of integer;
	    pt   : record
	    	x,y: real
	    end;
	    achse: record
	    	amin,
	    	amax    : real;
	    	ticks,
	    	subticks: longint
	    end;

	function bwrite(buf: pointer; count: longint): boolean;

		begin
			if fwrite(hdl,count,buf)=count then bwrite:=false
			else
				begin
					res:=-1;
					bwrite:=true
				end
		end;

	function cell2txt: string;

		begin
			case cell^.Typ of
			CTYPE_TEXT:
				cell2txt:=cell^.Data.Txt^+#0;
			CTYPE_CONST:
				cell2txt:=p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil)+#0;
			CTYPE_FORMULA:
				cell2txt:=p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil)+#0
			else
				cell2txt:=#0
			end
		end;

	function GetCellValue: real;

		begin
			if (cell^.Typ<>CTYPE_FORMULA) and (cell^.Typ<>CTYPE_CONST) then GetCellValue:=HUGE_VAL
			else
				GetCellValue:=p^.GetCellValue(cell,false)
		end;

	begin
		CreateDiagram:=false;
		if Application^.Multitasking and emb then
			if Application^.OLGAManager<0 then
				begin
					Application^.Alert(@self,1,NOTE,MESSAGE_GENERAL_OLGA,BUTTON_OK);
					exit
				end;
		p:=PCalcWindow(Parent);
		lr.x:=20000;
		lr.y:=20000;
		lr.w:=round(atof(p^.diagrammbuf.szWidth)*1000.0);
		lr.h:=round(atof(p^.diagrammbuf.szHeight)*1000.0);
		if not(p^.GetBlock(p^.dblock^.GetText,false,rs,cs,re,ce,dummy,dummy)) then exit;
		almin:=atof(p^.diagrammbuf.AlMin);
		almax:=atof(p^.diagrammbuf.AlMax);
		aumin:=atof(p^.diagrammbuf.AuMin);
		aumax:=atof(p^.diagrammbuf.AuMax);
		if p^.diagrammbuf.nRow=bf_Checked then
			begin
				if re<=rs then
					begin
						Application^.Alert(@self,1,NOTE,MESSAGE_DIAGRAM_ROWS,BUTTON_OK);
						exit
					end;
				rowl:=1
			end
		else
			rowl:=0;
		if p^.diagrammbuf.nColumn=bf_Checked then
			begin
				if ce<=cs then
					begin
						Application^.Alert(@self,1,NOTE,MESSAGE_DIAGRAM_COLUMNS,BUTTON_OK);
						exit
					end;
				coll:=1
			end
		else
			coll:=0;
		if p^.diagrammbuf.typKreis=bf_Checked then anz:=0
		else
			anz:=1;
		if (ce+1-cs-coll)*(re+1-rs-rowl)<=anz then
			begin
				Application^.Alert(@self,1,NOTE,MESSAGE_DIAGRAM_CELLS,BUTTON_OK);
				exit
			end;
		if (p^.diagrammbuf.typLinie=bf_Checked) and (p^.diagrammbuf.xyLinear=bf_Unchecked) then
			begin
				if (p^.diagrammbuf.dRows=bf_Checked) and (re-rs-rowl<1) then
					begin
						Application^.Alert(@self,1,NOTE,MESSAGE_DIAGRAM_ROWS,BUTTON_OK);
						exit
					end;
				if (p^.diagrammbuf.dColumns=bf_Checked) and (ce-cs-coll<1) then
					begin
						Application^.Alert(@self,1,NOTE,MESSAGE_DIAGRAM_COLUMNS,BUTTON_OK);
						exit
					end;
				if p^.diagrammbuf.xyAlternate=bf_Checked then
					begin
						if (p^.diagrammbuf.dRows=bf_Checked) and (((re+1-rs-rowl) mod 2)<>0) then
							begin
								Application^.Alert(@self,1,NOTE,MESSAGE_DIAGRAM_ROWEVEN,BUTTON_OK);
								exit
							end;
						if (p^.diagrammbuf.dColumns=bf_Checked) and (((ce+1-cs-coll) mod 2)<>0) then
							begin
								Application^.Alert(@self,1,NOTE,MESSAGE_DIAGRAM_COLEVEN,BUTTON_OK);
								exit
							end
					end
			end;
		BusyMouse;
		lofs:=longint(p^.Parms.Columns+1)*CELLSIZE;
		if (p^.diagrammbuf.typBalken=bf_Checked) and (p^.diagrammbuf.Stapeln=bf_Checked) then
			begin
				if p^.diagrammbuf.dColumns=bf_Checked then
					for q:=rs+rowl to re do
						begin
							cell:=p^.GetCell(q,cs+coll);
							vcmp:=0;
							for w:=cs+coll to ce do
								begin
									vcmp:=vcmp+p^.GetCellValue(cell,false);
									inc(longint(cell),CELLSIZE)
								end;
							if q=rs+rowl then
								begin
									vmin:=vcmp;
									vmax:=vcmp
								end
							else
								begin
									if vcmp>vmax then vmax:=vcmp;
									if vcmp<vmin then vmin:=vcmp
								end
						end
				else
					for w:=cs+coll to ce do
						begin
							cell:=p^.GetCell(rs+rowl,w);
							vcmp:=0;
							for q:=rs+rowl to re do
								begin
									vcmp:=vcmp+p^.GetCellValue(cell,false);
									inc(longint(cell),lofs)
								end;
							if w=cs+coll then
								begin
									vmin:=vcmp;
									vmax:=vcmp
								end
							else
								begin
									if vcmp>vmax then vmax:=vcmp;
									if vcmp<vmin then vmin:=vcmp
								end
						end
			end
		else
			if (p^.diagrammbuf.typLinie=bf_Checked) and (p^.diagrammbuf.xyFirst=bf_Checked) then
				begin
					xmin:=0;
					xmax:=0;
					if p^.diagrammbuf.dColumns=bf_Checked then
						begin
							cell:=p^.GetCell(rs+rowl,cs+coll);
							for q:=rs+rowl to re do
								begin
									if (cell^.Typ=CTYPE_FORMULA) or (cell^.Typ=CTYPE_CONST) then
										begin
											xcmp:=p^.GetCellValue(cell,false);
											if q=rs+rowl then
												begin
													xmin:=xcmp;
													xmax:=xcmp
												end
											else
												begin
													if xcmp>xmax then xmax:=xcmp;
													if xcmp<xmin then xmin:=xcmp
												end
										end;
									inc(longint(cell),lofs)
								end;
							cof:=1;
							rof:=0
						end
					else
						begin
							cell:=p^.GetCell(rs+rowl,cs+coll);
							for w:=cs+coll to ce do
								begin
									if (cell^.Typ=CTYPE_FORMULA) or (cell^.Typ=CTYPE_CONST) then
										begin
											xcmp:=p^.GetCellValue(cell,false);
											if w=cs+coll then
												begin
													xmin:=xcmp;
													xmax:=xcmp
												end
											else
												begin
													if xcmp>xmax then xmax:=xcmp;
													if xcmp<xmin then xmin:=xcmp
												end
										end;
									inc(longint(cell),CELLSIZE)
								end;
							cof:=0;
							rof:=1
						end;
					vmin:=p^.GetCellValue(p^.GetCell(rs+rowl+rof,cs+coll+cof),false);
					vmax:=vmin;
					for q:=rs+rowl+rof to re do
						begin
							cell:=p^.GetCell(q,cs+coll+cof);
							for w:=cs+coll+cof to ce do
								begin
									if (cell^.Typ=CTYPE_FORMULA) or (cell^.Typ=CTYPE_CONST) then
										begin
											vcmp:=p^.GetCellValue(cell,false);
											if vcmp>vmax then vmax:=vcmp;
											if vcmp<vmin then vmin:=vcmp
										end;
									inc(longint(cell),CELLSIZE)
								end
						end
				end
			else
				if (p^.diagrammbuf.typLinie=bf_Checked) and (p^.diagrammbuf.xyAlternate=bf_Checked) then
					begin
						if p^.diagrammbuf.dColumns=bf_Checked then
							begin
								{ !!! }
							end
						else
							begin
								q:=rs+rowl;
								vmin:=p^.GetCellValue(p^.GetCell(rs+rowl+1,cs+coll),false);
								vmax:=vmin;
								xmin:=p^.GetCellValue(p^.GetCell(rs+rowl,cs+coll),false);
								xmax:=xmin;
								while q<=re do
									begin
										cell:=p^.GetCell(q,cs+coll);
										cell2:=PCell(longint(cell)+lofs);
										for w:=cs+coll to ce do
											begin
												if (cell2^.Typ=CTYPE_FORMULA) or (cell2^.Typ=CTYPE_CONST) then
													begin
														vcmp:=p^.GetCellValue(cell2,false);
														if vcmp>vmax then vmax:=vcmp;
														if vcmp<vmin then vmin:=vcmp
													end;
												if (cell^.Typ=CTYPE_FORMULA) or (cell^.Typ=CTYPE_CONST) then
													begin
														xcmp:=p^.GetCellValue(cell,false);
														if xcmp>xmax then xmax:=xcmp;
														if xcmp<xmin then xmin:=xcmp
													end;
												inc(longint(cell),CELLSIZE);
												inc(longint(cell2),CELLSIZE)
											end;
										inc(q,2)
									end
							end
					end
				else
					if p^.diagrammbuf.typKreis=bf_Unchecked then
						begin
							vmin:=p^.GetCellValue(p^.GetCell(rs+rowl,cs+coll),false);
							vmax:=vmin;
							for q:=rs+rowl to re do
								begin
									cell:=p^.GetCell(q,cs+coll);
									for w:=cs+coll to ce do
										begin
											if (cell^.Typ=CTYPE_FORMULA) or (cell^.Typ=CTYPE_CONST) then
												begin
													vcmp:=p^.GetCellValue(cell,false);
													if vcmp>vmax then vmax:=vcmp;
													if vcmp<vmin then vmin:=vcmp
												end;
											inc(longint(cell),CELLSIZE)
										end
								end
						end;
		if length(tadname)>0 then fname:=tadname
		else
			if length(p^.diagrammbuf.objFilename)=0 then
				begin
					repeat
						fname:=GetTexelTempDir+GetTempFilename
					until not(Exist(GetPath(fname)+GetFilename(fname,false)+'.tad'))
				end
			else
				fname:=p^.diagrammbuf.objFilename;
		fname:=GetPath(fname)+GetFilename(fname,false)+'.tad';
		res:=fcreate(fname,0);
		if res<0 then goto _raus;
		hdl:=integer(res);
		tag.tag_id:='TXAW';
		tag.tag_len:=0;
		tag.tag_flags:=$00000100;
		if length(tadname)=0 then tag.tag_flags:=tag.tag_flags or $00030000;
		if bwrite(@tag,sizeof(TTAG)) then goto _error;
		tag.tag_id:='BBOX';
		tag.tag_len:=sizeof(LRECT);
		tag.tag_flags:=0;
		if bwrite(@tag,sizeof(TTAG)) then goto _error;
		if bwrite(@lr,sizeof(LRECT)) then goto _error;
		tag.tag_id:='BTYP';
		tag.tag_len:=0;
		if p^.diagrammbuf.Border=bf_Checked then tag.tag_flags:=1
		else
			tag.tag_flags:=0;
		if bwrite(@tag,sizeof(TTAG)) then goto _error;
		tag.tag_id:='FTYP';
		tag.tag_len:=0;
		if p^.diagrammbuf.Farbe=bf_Checked then tag.tag_flags:=1
		else
			tag.tag_flags:=2;
		if bwrite(@tag,sizeof(TTAG)) then goto _error;
		tag.tag_id:='DPNT';
		tag.tag_len:=0;
		tag.tag_flags:=ord(',');
		if bwrite(@tag,sizeof(TTAG)) then goto _error;
		s:=p^.diagrammbuf.Titel+#0;
		tag.tag_id:='TITL';
		tag.tag_len:=length(s);
		tag.tag_flags:=0;
		if bwrite(@tag,sizeof(TTAG)) then goto _error;
		if bwrite(@s[1],length(s)) then goto _error;
		if p^.Fonts=nil then findx:=vqt_name(p^.vdiHandle,1,sd)
		else
			if (p^.diagrammbuf.Font>=0) and (p^.diagrammbuf.Font<p^.Fonts^.Count) then findx:=PFont(p^.Fonts^.At(p^.diagrammbuf.Font))^.index
			else
				findx:=vqt_name(p^.vdiHandle,1,sd);
		if p^.Fonts=nil then fsize:=10
		else
			if (p^.diagrammbuf.Font<0) or (p^.diagrammbuf.Font>=p^.Fonts^.Count) then fsize:=10
			else
				begin
					pf:=p^.Fonts^.At(p^.diagrammbuf.Font);
					if pf^.SizeCount=0 then fsize:=4+p^.diagrammbuf.Size
					else
						if (p^.diagrammbuf.Size<0) or (p^.diagrammbuf.Size>=pf^.SizeCount) then fsize:=10
						else
							fsize:=pf^.Sizes^[pf^.SizeCount-p^.diagrammbuf.Size-1]
				end;
		fsize:=fsize shl 16;
		tag.tag_id:='FONT';
		tag.tag_len:=6;
		tag.tag_flags:=1;
		if bwrite(@tag,sizeof(TTAG)) then goto _error;
		if bwrite(@findx,2) then goto _error;
		if bwrite(@fsize,4) then goto _error;
		tag.tag_flags:=14;
		if bwrite(@tag,sizeof(TTAG)) then goto _error;
		if bwrite(@findx,2) then goto _error;
		anz:=0;
		if bwrite(@anz,4) then goto _error;
		if p^.diagrammbuf.typKreis=bf_Checked then
			begin
				vmax:=0.0;
				anz:=0;
				if p^.diagrammbuf.Absolut=bf_Checked then tag.tag_flags:=2
				else
					tag.tag_flags:=0;
				tag.tag_len:=sizeof(longint);
				if p^.diagrammbuf.dRows=bf_Checked then
					begin
						cell:=p^.GetCell(rs+rowl,cs+coll);
						for q:=cs+coll to ce do
							begin
								if (cell^.Typ=CTYPE_FORMULA) or (cell^.Typ=CTYPE_CONST) then
									begin
										vmax:=vmax+abs(p^.GetCellValue(cell,false));
										inc(anz)
									end;
								inc(longint(cell),CELLSIZE)
							end;
						if p^.diagrammbuf.nRow=bf_Checked then
							if p^.diagrammbuf.Legende=bf_Checked then
								begin
									tag.tag_flags:=tag.tag_flags or $0001;
									cell:=p^.GetCell(rs,cs+coll);
									for q:=cs+coll to ce do
										begin
											inc(tag.tag_len,length(cell2txt));
											inc(longint(cell),CELLSIZE)
										end
								end
					end
				else
					begin
						cell:=p^.GetCell(rs+rowl,cs+coll);
						for w:=rs+rowl to re do
							begin
								if (cell^.Typ=CTYPE_FORMULA) or (cell^.Typ=CTYPE_CONST) then
									begin
										vmax:=vmax+abs(p^.GetCellValue(cell,false));
										inc(anz)
									end;
								inc(longint(cell),lofs)
							end;
						if p^.diagrammbuf.nColumn=bf_Checked then
							if p^.diagrammbuf.Legende=bf_Checked then
								begin
									tag.tag_flags:=tag.tag_flags or $0001;
									cell:=p^.GetCell(rs+rowl,cs);
									for w:=rs+rowl to re do
										begin
											inc(tag.tag_len,length(cell2txt));
											inc(longint(cell),lofs)
										end
								end
					end;
				if vmax=0.0 then anz:=0;
				tag.tag_id:='PPIE';
				inc(tag.tag_len,(2*anz+1)*sizeof(real));
				if bwrite(@tag,sizeof(TTAG)) then goto _error;
				if bwrite(@anz,sizeof(longint)) then goto _error;
				vcmp:=0.0;
				if bwrite(@vcmp,sizeof(real)) then goto _error;
				if anz>0 then
					begin
						if p^.diagrammbuf.dRows=bf_Checked then
							begin
								cell:=p^.GetCell(rs+rowl,cs+coll);
								for q:=cs+coll to ce do
									begin
										if (cell^.Typ=CTYPE_FORMULA) or (cell^.Typ=CTYPE_CONST) then
											begin
												vcmp:=p^.GetCellValue(cell,false);
												vmin:=3600*abs(vcmp)/vmax;
												if bwrite(@vmin,sizeof(real)) then goto _error;
												if bwrite(@vcmp,sizeof(real)) then goto _error
											end;
										inc(longint(cell),CELLSIZE)
									end;
								if p^.diagrammbuf.nRow=bf_Checked then
									if p^.diagrammbuf.Legende=bf_Checked then
										begin
											cell:=p^.GetCell(rs,cs+coll);
											for q:=cs+coll to ce do
												begin
													s:=cell2txt;
													if bwrite(@s[1],length(s)) then goto _error;
													inc(longint(cell),CELLSIZE)
												end
										end
							end
						else
							begin
								cell:=p^.GetCell(rs+rowl,cs+coll);
								for w:=rs+rowl to re do
									begin
										if (cell^.Typ=CTYPE_FORMULA) or (cell^.Typ=CTYPE_CONST) then
											begin
												vcmp:=p^.GetCellValue(cell,false);
												vmin:=3600*abs(vcmp)/vmax;
												if bwrite(@vmin,sizeof(real)) then goto _error;
												if bwrite(@vcmp,sizeof(real)) then goto _error
											end;
										inc(longint(cell),lofs)
									end;
								if p^.diagrammbuf.nColumn=bf_Checked then
									if p^.diagrammbuf.Legende=bf_Checked then
										begin
											cell:=p^.GetCell(rs+rowl,cs);
											for w:=rs+rowl to re do
												begin
													s:=cell2txt;
													if bwrite(@s[1],length(s)) then goto _error;
													inc(longint(cell),lofs)
												end
										end
							end
					end
			end
		else
			begin
				{ linear/first/alternate !!! }
				s:=p^.diagrammbuf.alName+#0;
				tag.tag_id:='AXIS';
				tag.tag_len:=sizeof(achse)+length(s);
				tag.tag_flags:=$00030000;
				if bwrite(@tag,sizeof(TTAG)) then goto _error;
				if almin<>almax then
					begin
						if almin>almax then
							begin
								vmin:=almax;
								vmax:=almin
							end
						else
							begin
								vmin:=almin;
								vmax:=almax
							end
					end;
				if p^.diagrammbuf.typBalken=bf_Checked then
					begin
						if (vmin>0) and (vmax>0) then vmin:=0
						else
							if (vmin<0) and (vmax<0) then vmax:=0
					end;
				achse.amin:=vmin;
				achse.amax:=vmax;
				if p^.diagrammbuf.Ticks=bf_Checked then
					begin
						achse.ticks:=atol(p^.diagrammbuf.numTicks)+2;
						achse.amax:=achse.amin+int((achse.amax-achse.amin)/(achse.ticks-1.0)+0.999999999)*(achse.ticks-1.0)
					end
				else
					achse.ticks:=2;
				if p^.diagrammbuf.alTicks=bf_Checked then achse.subticks:=atol(p^.diagrammbuf.alNum)+2
				else
					achse.subticks:=2;
				if bwrite(@achse,sizeof(achse)) then goto _error;
				if bwrite(@s[1],length(s)) then goto _error;
				s:=p^.diagrammbuf.auName+#0;
				tag.tag_id:='AXIS';
				tag.tag_len:=sizeof(achse)+length(s);
				tag.tag_flags:=$00010000;
				if p^.diagrammbuf.dColumns=bf_Checked then
					begin
						if p^.diagrammbuf.nColumn=bf_Checked then
							begin
								tag.tag_flags:=tag.tag_flags or $0004;
								cell:=p^.GetCell(rs+rowl,cs);
								for q:=rs+rowl to re do
									begin
										inc(tag.tag_len,length(cell2txt));
										inc(longint(cell),lofs)
									end
							end;
						if bwrite(@tag,sizeof(TTAG)) then goto _error;
						if aumin<>aumax then
							begin
								if aumin>aumax then
									begin
										achse.amin:=aumax;
										achse.amax:=aumin
									end
								else
									begin
										achse.amin:=aumin;
										achse.amax:=aumax
									end
							end
						else
							begin
								achse.amin:=0.0;
								achse.amax:=re+2-rs-rowl
							end;
						achse.ticks:=re+3-rs-rowl;
						if p^.diagrammbuf.auTicks=bf_Checked then achse.subticks:=atol(p^.diagrammbuf.auNum)+2
						else
							achse.subticks:=2;
						if bwrite(@achse,sizeof(achse)) then goto _error;
						if bwrite(@s[1],length(s)) then goto _error;
						if p^.diagrammbuf.nColumn=bf_Checked then
							begin
								cell:=p^.GetCell(rs+rowl,cs);
								for q:=rs+rowl to re do
									begin
										s:=cell2txt;
										if bwrite(@s[1],length(s)) then goto _error;
										inc(longint(cell),lofs)
									end
							end;
						if p^.diagrammbuf.typBalken=bf_Checked then
							begin
								tag.tag_id:='PBAR';
								if p^.diagrammbuf.DreiD=bf_Checked then tag.tag_flags:=3
								else
									if p^.diagrammbuf.Neben=bf_Checked then tag.tag_flags:=2
									else
										tag.tag_flags:=1;
								l1:=ce+1-cs-coll;
								l2:=re+1-rs-rowl;
								tag.tag_len:=2*sizeof(longint)+l1*l2*sizeof(real);
								if p^.diagrammbuf.nRow=bf_Checked then
									begin
										cell:=p^.GetCell(rs,cs+coll);
										for q:=cs+coll to ce do
											begin
												inc(tag.tag_len,length(cell2txt));
												inc(longint(cell),CELLSIZE)
											end
									end
								else
									inc(tag.tag_len,l1);
								if bwrite(@tag,sizeof(TTAG)) then goto _error;
								if bwrite(@l1,sizeof(longint)) then goto _error;
								if bwrite(@l2,sizeof(longint)) then goto _error;
								for w:=rs+rowl to re do
									begin
										cell:=p^.GetCell(w,cs+coll);
										for q:=cs+coll to ce do
											begin
												pt.y:=GetCellValue;
												if bwrite(@pt.y,sizeof(real)) then goto _error;
												inc(longint(cell),CELLSIZE)
											end
									end;
								if p^.diagrammbuf.nRow=bf_Checked then
									begin
										cell:=p^.GetCell(rs,cs+coll);
										for q:=cs+coll to ce do
											begin
												s:=cell2txt;
												if bwrite(@s[1],length(s)) then goto _error;
												inc(longint(cell),CELLSIZE)
											end
									end
								else
									begin
										s:=#0;
										for q:=cs+coll to ce do
											if bwrite(@s[1],1) then goto _error
									end
							end
						else
							for q:=cs+coll to ce do
								begin
									cell:=p^.GetCell(rs,q);
									if p^.diagrammbuf.nRow=bf_Checked then
										begin
											s:=cell2txt;
											inc(longint(cell),lofs)
										end
									else
										s:=#0;
									tag.tag_id:='P_XY';
									tag.tag_flags:=re+1-rs-rowl;
									tag.tag_len:=2*tag.tag_flags*sizeof(real)+sizeof(xy)+length(s);
									if bwrite(@tag,sizeof(TTAG)) then goto _error;
									xy[0]:=1;
									xy[1]:=3;
									if p^.diagrammbuf.xyLine=bf_Checked then xy[2]:=1
									else
										if p^.diagrammbuf.xyPt=bf_Checked then xy[2]:=2
										else
											xy[2]:=3;
									xy[3]:=p^.diagrammbuf.stilLinie+1;
									xy[4]:=p^.diagrammbuf.stilPunkt+1;
									if bwrite(@xy,sizeof(xy)) then goto _error;
									for w:=rs+rowl to re do
										begin
											pt.x:=w+1-rs-rowl;
											pt.y:=GetCellValue;
											if bwrite(@pt,sizeof(pt)) then goto _error;
											inc(longint(cell),lofs)
										end;
									if bwrite(@s[1],length(s)) then goto _error
								end
					end
				else
					begin
						if p^.diagrammbuf.nRow=bf_Checked then
							begin
								tag.tag_flags:=tag.tag_flags or $0004;
								cell:=p^.GetCell(rs,cs+coll);
								for q:=cs+coll to ce do
									begin
										inc(tag.tag_len,length(cell2txt));
										inc(longint(cell),CELLSIZE)
									end
							end;
						if bwrite(@tag,sizeof(TTAG)) then goto _error;
						if aumin<>aumax then
							begin
								if aumin>aumax then
									begin
										achse.amin:=aumax;
										achse.amax:=aumin
									end
								else
									begin
										achse.amin:=aumin;
										achse.amax:=aumax
									end
							end
						else
							begin
								achse.amin:=0.0;
								achse.amax:=ce+2-cs-coll
							end;
						achse.ticks:=ce+3-cs-coll;
						if p^.diagrammbuf.auTicks=bf_Checked then achse.subticks:=atol(p^.diagrammbuf.auNum)+2
						else
							achse.subticks:=2;
						if bwrite(@achse,sizeof(achse)) then goto _error;
						if bwrite(@s[1],length(s)) then goto _error;
						if p^.diagrammbuf.nRow=bf_Checked then
							begin
								cell:=p^.GetCell(rs,cs+coll);
								for q:=cs+coll to ce do
									begin
										s:=cell2txt;
										if bwrite(@s[1],length(s)) then goto _error;
										inc(longint(cell),CELLSIZE)
									end
							end;
						if p^.diagrammbuf.typBalken=bf_Checked then
							begin
								tag.tag_id:='PBAR';
								if p^.diagrammbuf.DreiD=bf_Checked then tag.tag_flags:=3
								else
									if p^.diagrammbuf.Neben=bf_Checked then tag.tag_flags:=2
									else
										tag.tag_flags:=1;
								l1:=re+1-rs-rowl;
								l2:=ce+1-cs-coll;
								tag.tag_len:=2*sizeof(longint)+l1*l2*sizeof(real);
								if p^.diagrammbuf.nColumn=bf_Checked then
									begin
										cell:=p^.GetCell(rs+rowl,cs);
										for q:=rs+rowl to re do
											begin
												inc(tag.tag_len,length(cell2txt));
												inc(longint(cell),lofs)
											end
									end
								else
									inc(tag.tag_len,l1);
								if bwrite(@tag,sizeof(TTAG)) then goto _error;
								if bwrite(@l1,sizeof(longint)) then goto _error;
								if bwrite(@l2,sizeof(longint)) then goto _error;
								for w:=cs+coll to ce do
									begin
										cell:=p^.GetCell(rs+rowl,w);
										for q:=rs+rowl to re do
											begin
												pt.y:=GetCellValue;
												if bwrite(@pt.y,sizeof(real)) then goto _error;
												inc(longint(cell),lofs)
											end
									end;
								if p^.diagrammbuf.nColumn=bf_Checked then
									begin
										cell:=p^.GetCell(rs+rowl,cs);
										for q:=rs+rowl to re do
											begin
												s:=cell2txt;
												if bwrite(@s[1],length(s)) then goto _error;
												inc(longint(cell),lofs)
											end
									end
								else
									begin
										s:=#0;
										for q:=rs+rowl to re do
											if bwrite(@s[1],1) then goto _error
									end
							end
						else
							for q:=rs+rowl to re do
								begin
									cell:=p^.GetCell(q,cs);
									if p^.diagrammbuf.nColumn=bf_Checked then
										begin
											s:=cell2txt;
											inc(longint(cell),CELLSIZE)
										end
									else
										s:=#0;
									tag.tag_id:='P_XY';
									tag.tag_flags:=ce+1-cs-coll;
									tag.tag_len:=2*tag.tag_flags*sizeof(real)+sizeof(xy)+length(s);
									if bwrite(@tag,sizeof(TTAG)) then goto _error;
									xy[0]:=1;
									xy[1]:=3;
									if p^.diagrammbuf.xyLine=bf_Checked then xy[2]:=1
									else
										if p^.diagrammbuf.xyPt=bf_Checked then xy[2]:=2
										else
											xy[2]:=3;
									xy[3]:=p^.diagrammbuf.stilLinie+1;
									xy[4]:=p^.diagrammbuf.stilPunkt+1;
									if bwrite(@xy,sizeof(xy)) then goto _error;
									for w:=cs+coll to ce do
										begin
											pt.x:=w+1-cs-coll;
											pt.y:=GetCellValue;
											if bwrite(@pt,sizeof(pt)) then goto _error;
											inc(longint(cell),CELLSIZE)
										end;
									if bwrite(@s[1],length(s)) then goto _error
								end
					end
			end;
		tag.tag_id:='ENDE';
		tag.tag_len:=0;
		tag.tag_flags:=255;
		bwrite(@tag,sizeof(TTAG));
		_error:
		fclose(hdl);
		if res<0 then goto _raus;
		TexelApp.FileChanged(fname);
		if Application^.Multitasking and emb then p^.EmbedNewObject(fname,0,0,0,0,0,nil,nil,@p^.diagrammbuf,false,false,false,true,true,true,false);
		if length(tadname)=0 then
			if p^.diagramm<>nil then p^.diagramm^.SetFile('');
		CreateDiagram:=true;
		_raus:
		ArrowMouse
	end;


procedure TDiagrammRadio.Changed(AnIndx: integer; DblClick: boolean);

	begin
		PDiagrammDialog(Parent)^.CheckButtons
	end;


destructor TDiagrammDialog.Done;

	begin
		obic^.ob_spec.index:=obicspec;
		inherited Done
	end;


procedure TDiagrammDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk)
	end;


procedure TDiagrammDialog.CheckButtons;
	label _weiter;

	begin
		if rb1^.GetCheck=bf_Checked then
			begin
				if aendern=1 then goto _weiter;
				gb2^.Hide(false);
				gb3^.Hide(false);
				gb4^.Hide(false);
				gb5^.Hide(false);
				InitFocus;
				gb1^.Unhide;
				aendern:=1
			end
		else if rb2^.GetCheck=bf_Checked then
			begin
				if aendern=2 then goto _weiter;
				gb1^.Hide(false);
				gb3^.Hide(false);
				gb4^.Hide(false);
				gb5^.Hide(false);
				InitFocus;
				gb2^.Unhide;
				InitFocus;
				aendern:=2
			end
		else if rb3^.GetCheck=bf_Checked then
			begin
				if aendern=3 then goto _weiter;
				gb1^.Hide(false);
				gb2^.Hide(false);
				gb4^.Hide(false);
				gb5^.Hide(false);
				InitFocus;
				gb3^.Unhide;
				InitFocus;
				aendern:=3
			end
		else if rb4^.GetCheck=bf_Checked then
			begin
				if aendern=4 then goto _weiter;
				gb1^.Hide(false);
				gb2^.Hide(false);
				gb3^.Hide(false);
				gb5^.Hide(false);
				InitFocus;
				gb4^.Unhide;
				InitFocus;
				aendern:=4
			end
		else
			begin
				if aendern=5 then goto _weiter;
				gb1^.Hide(false);
				gb2^.Hide(false);
				gb3^.Hide(false);
				gb4^.Hide(false);
				InitFocus;
				gb5^.Unhide;
				InitFocus;
				aendern:=5
			end;
		_weiter:
		if rbt1^.GetCheck=bf_Checked then
			begin
				cb1^.Hide(true);
				pc3^.Hide(false);
				pc1^.Unhide;
				pc2^.Unhide;
				pdb1^.Unhide;
				pdb2^.Unhide;
				rb2^.Enable;
				obic^.ob_spec.icon_blk:=rbt1^.ObjAddr^.ob_spec.icon_blk
			end
		else if rbt2^.GetCheck=bf_Checked then
			begin
				cb1^.Disable;
				cb1^.Unhide;
				pc1^.Hide(false);
				pc2^.Hide(true);
				pdb1^.Hide(true);
				pdb2^.Hide(true);
				pc3^.Unhide;
				rb2^.Enable;
				obic^.ob_spec.icon_blk:=rbt2^.ObjAddr^.ob_spec.icon_blk
			end
		else
			begin
				cb1^.Enable;
				cb1^.Unhide;
				pc3^.Hide(true);
				pc1^.Hide(true);
				pc2^.Hide(true);
				pdb1^.Hide(true);
				pdb2^.Hide(true);
				rb2^.Disable;
				obic^.ob_spec.icon_blk:=rbt3^.ObjAddr^.ob_spec.icon_blk
			end;
		tc^.Paint
	end;


function TDiagrammDialog.ExitDlg(AnIndx: integer): boolean;
	var p: PCalcWindow;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTDITEMPDATEI:
			if p^.diagramm<>nil then p^.diagramm^.SetFile('');
		RTDIDATEI:
			if p^.diagramm<>nil then
				begin
					if Application^.Multitasking then
						begin
							if XFileSelect(p,FSELTITLE_DIAGRAM,'*.cwg',TexelApp.LastPath[19],TexelApp.LastFile[19],1,FSEL_DIAGRAM,false,false) then p^.diagramm^.SetFile(TexelApp.LastPath[19]+TexelApp.LastFile[19])
						end
					else
						begin
							if XFileSelect(p,FSELTITLE_TAD,'*.tad',TexelApp.LastPath[19],TexelApp.LastFile[19],1,FSEL_DIAGRAM,false,false) then p^.diagramm^.SetFile(TexelApp.LastPath[19]+TexelApp.LastFile[19])
						end
				end;
		RTDIBEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTDICREATETAD:
			begin
				if FileSelect(Parent,FSELTITLE_TADSAVEAS,'*.tad',TexelApp.LastPath[19],TexelApp.LastFile[19],false) then
					begin
						TransferData(tf_GetData);
						CreateDiagram(TexelApp.LastPath[19]+TexelApp.LastFile[19],false)
					end
			end;
		RTDIINSERT:
			begin
				TransferData(tf_GetData);
				CreateDiagram('',true)
			end
		end
	end;


function TDiagrammDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTDIINSERT);
		OK:=valid
	end;


procedure TDiagram.Work;
	var pb    : PButton;
	    p     : PCalcWindow;
	    pe    : PEdit;
	    pr    : PRadioButton;
	    pc    : PCheckBox;
	    fsizes: PStringCollection;
	    pfsb  : PFontSizeBox;
	    pfb   : PFontBox;

	begin
		p:=PCalcWindow(Parent);
		if ADialog=nil then
			begin
				TexelApp.ActivateExtResource;
				ADialog:=new(PDiagrammDialog,Init(p,TEXELWINDPREFIX+TITLE_DIAGRAM,STG_DIAGRAM,ICNTITLE_DIAGRAM,RTDIAGRAM));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTDIBEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
						new(PGroupBox,Init(ADialog,RTDICHANGE,GROUP_DIAGRAM_CHANGE,BUBBLE_DIAGRAM_CHANGE));
						new(PDiagrammDialog(ADialog)^.gb1,Init(ADialog,RTDIGRPTYP,'',BUBBLE_DIAGRAM_GRPTYPE));
						new(PDiagrammDialog(ADialog)^.gb2,Init(ADialog,RTDIGRPACHSE,'',BUBBLE_DIAGRAM_GRPAXIS));
						new(PDiagrammDialog(ADialog)^.gb3,Init(ADialog,RTDIGRPREIHE,'',BUBBLE_DIAGRAM_GRPDATA));
						new(PDiagrammDialog(ADialog)^.gb4,Init(ADialog,RTDIGRPLEGENDE,'',BUBBLE_DIAGRAM_GRPLEG));
						new(PDiagrammDialog(ADialog)^.gb5,Init(ADialog,RTDIGRPOBJEKT,'',BUBBLE_DIAGRAM_GRPOBJ));
						new(PDiagrammDialog(ADialog)^.bedt,Init(ADialog,RTDIBEDIT,16,false,BUBBLE_GENERAL_RANGE));
						new(PDiagrammDialog(ADialog)^.tc,Init(ADialog,RTDIPICON,''));
						new(PDiagrammDialog(ADialog)^.rb1,Init(ADialog,RTDITYP,true,BUBBLE_DIAGRAM_RTYPE));
						new(PDiagrammDialog(ADialog)^.rb2,Init(ADialog,RTDIACHSEN,true,BUBBLE_DIAGRAM_RAXIS));
						new(PDiagrammDialog(ADialog)^.rb3,Init(ADialog,RTDIREIHE,true,BUBBLE_DIAGRAM_RDATA));
						new(PDiagrammDialog(ADialog)^.rb4,Init(ADialog,RTDILEGENDE,true,BUBBLE_DIAGRAM_RLEG));
						new(PDiagrammDialog(ADialog)^.rb5,Init(ADialog,RTDIOBJEKT,true,BUBBLE_DIAGRAM_ROBJ));
						new(PDiagrammDialog(ADialog)^.rbt1,Init(ADialog,RTDILINIEN,false,BUBBLE_DIAGRAM_LINE));
						new(PDiagrammDialog(ADialog)^.rbt2,Init(ADialog,RTDIBALKEN,false,BUBBLE_DIAGRAM_BLOCK));
						new(PDiagrammDialog(ADialog)^.rbt3,Init(ADialog,RTDIKREIS,false,BUBBLE_DIAGRAM_CIRCLE));
						new(PCheckBox,Init(ADialog,RTDIFARBE,true,BUBBLE_DIAGRAM_COLOR));
						new(PDiagrammDialog(ADialog)^.cb1,Init(ADialog,RTDIVALUE,true,BUBBLE_DIAGRAM_VALUE));
						new(PDiagrammDialog(ADialog)^.pc1,Init(ADialog,RTDILGRP1,''));
						new(PDiagrammDialog(ADialog)^.pc2,Init(ADialog,RTDILGRP2,''));
						new(PDiagrammDialog(ADialog)^.pc3,Init(ADialog,RTDIBGRP,''));
						new(PRadioButton,Init(ADialog,RTDIXLINEAR,true,BUBBLE_DIAGRAM_XLINEAR));
						new(pr,Init(ADialog,RTDIX1REIHE,true,BUBBLE_DIAGRAM_X1DATA));
						if pr<>nil then pr^.Disable; { !!! }
						new(pr,Init(ADialog,RTDIXYABWECHS,true,BUBBLE_DIAGRAM_XYALT));
						if pr<>nil then pr^.Disable; { !!! }
						new(PRadioButton,Init(ADialog,RTDILLINES,true,BUBBLE_DIAGRAM_LLINES));
						new(PRadioButton,Init(ADialog,RTDILPOINTS,true,BUBBLE_DIAGRAM_LPOINTS));
						new(PRadioButton,Init(ADialog,RTDILBOTH,true,BUBBLE_DIAGRAM_LBOTH));
						new(PRadioButton,Init(ADialog,RTDISTAPELN,true,BUBBLE_DIAGRAM_STACK));
						new(PRadioButton,Init(ADialog,RTDIHINTEREIN,true,BUBBLE_DIAGRAM_BEHIND));
						new(PRadioButton,Init(ADialog,RTDINEBENEIN,true,BUBBLE_DIAGRAM_SIDE));
						new(PDiagrammDialog(ADialog)^.pdb1,Init(ADialog,RTDILINESTYLE,RTDILSCYC,RTDILSTITLE,RTPOPUPS2,RTP2LINIENSTIL,id_No,true,false,BUBBLE_DIAGRAM_LSTYLE));
						new(PDiagrammDialog(ADialog)^.pdb2,Init(ADialog,RTDIPOINTSTYLE,RTDIPSCYC,RTDIPSTITLE,RTPOPUPS2,RTP2PUNKTSTIL,id_No,true,false,BUBBLE_DIAGRAM_PSTYLE));
						new(PDiagrammDialog(ADialog)^.ed1,Init(ADialog,RTDITITEL,41,BUBBLE_DIAGRAM_TITLE));
						if PDiagrammDialog(ADialog)^.ed1<>nil then PDiagrammDialog(ADialog)^.ed1^.Clear;
						new(PCheckBox,Init(ADialog,RTDILEGENDEANZ,true,BUBBLE_DIAGRAM_LCOUNT));
						new(PCheckBox,Init(ADialog,RTDIUMRAHMEN,true,BUBBLE_DIAGRAM_BORDER));
						new(PGroupBox,Init(ADialog,RTDINAMES,GROUP_DIAGRAM_NAMESIN,BUBBLE_DIAGRAM_NAMES));
						new(PCheckBox,Init(ADialog,RTDINROW,true,BUBBLE_DIAGRAM_NROW));
						new(PCheckBox,Init(ADialog,RTDINCOL,true,BUBBLE_DIAGRAM_NCOL));
						new(pfb,InitCollection(ADialog,RTDIFONTPOP,RTDIFONTCYC,RTDIFONTTITLE,26,p^.Fonts,false,false,false,BUBBLE_DIAGRAM_FONTID));
						if pfb<>nil then
							begin
								pfb^.newsize:=-1;
								new(fsizes,Init(130,20));
								new(pfsb,InitCollection(ADialog,RTDISIZEPOP,RTDISIZECYC,RTDISIZETITLE,6,fsizes,true,false,false,BUBBLE_DIAGRAM_FONTSIZE));
								pfsb^.setsize:=true;
								pfb^.fsizebox:=pfsb;
								pfb^.Work
							end;
						new(PGroupBox,Init(ADialog,RTDIREIHEN,GROUP_DIAGRAM_DATA,BUBBLE_DIAGRAM_DATA));
						new(PRadioButton,Init(ADialog,RTDIDROWS,true,BUBBLE_DIAGRAM_DROWS));
						new(PRadioButton,Init(ADialog,RTDIDCOLUMNS,true,BUBBLE_DIAGRAM_DCOLUMNS));
						new(PGroupBox,Init(ADialog,RTDIRTICKS,'',BUBBLE_DIAGRAM_RTICKS));
						new(PCheckBox,Init(ADialog,RTDITICKS,true,BUBBLE_DIAGRAM_TICKS));
						new(PEdit,Init(ADialog,RTDINUMTICKS,3,BUBBLE_DIAGRAM_NUMTICKS));
						new(PGroupBox,Init(ADialog,RTDIAXISLEFT,GROUP_DIAGRAM_AXISLEFT,BUBBLE_DIAGRAM_AXISLEFT));
						new(PEdit,Init(ADialog,RTDIALNAME,41,BUBBLE_DIAGRAM_ALNAME));
						new(PCheckBox,Init(ADialog,RTDIALSUBTICKS,true,BUBBLE_DIAGRAM_ALSUBT));
						new(PEdit,Init(ADialog,RTDIALSUBNUM,3,BUBBLE_DIAGRAM_ALSUBNUM));
						new(PEdit,Init(ADialog,RTDIALMIN,13,BUBBLE_DIAGRAM_ALMIN));
						new(PEdit,Init(ADialog,RTDIALMAX,13,BUBBLE_DIAGRAM_ALMAX));
						new(PGroupBox,Init(ADialog,RTDIAXISBOTTOM,GROUP_DIAGRAM_AXISBOTM,BUBBLE_DIAGRAM_AXISBOTM));
						new(PEdit,Init(ADialog,RTDIAUNAME,41,BUBBLE_DIAGRAM_ABNAME));
						new(PCheckBox,Init(ADialog,RTDIAUSUBTICKS,true,BUBBLE_DIAGRAM_ABSUBT));
						new(PEdit,Init(ADialog,RTDIAUSUBNUM,3,BUBBLE_DIAGRAM_ABSUBNUM));
						new(PEdit,Init(ADialog,RTDIAUMIN,13,BUBBLE_DIAGRAM_ABMIN));
						new(PEdit,Init(ADialog,RTDIAUMAX,13,BUBBLE_DIAGRAM_ABMAX));
						new(PGroupBox,Init(ADialog,RTDISIZE,GROUP_DIAGRAM_SIZE,BUBBLE_DIAGRAM_SIZE));
						new(pe,Init(ADialog,RTDIWIDTH,7,BUBBLE_DIAGRAM_WIDTH));
						if pe<>nil then pe^.SetValidator(new(PMinMaxValidator,Init(4.0,999.99)));
						new(pe,Init(ADialog,RTDIHEIGHT,7,BUBBLE_DIAGRAM_HEIGHT));
						if pe<>nil then pe^.SetValidator(new(PMinMaxValidator,Init(4.0,999.99)));
						new(PButton,Init(ADialog,RTDIDATEI,id_No,true,BUBBLE_DIAGRAM_FILE));
						new(PDiagrammDialog(ADialog)^.pb1,Init(ADialog,RTDITEMPDATEI,id_No,true,BUBBLE_DIAGRAM_TEMPFILE));
						new(PDiagrammDialog(ADialog)^.ofname,Init(ADialog,RTDIDATEINAME,39,false,BUBBLE_DIAGRAM_FILENAME));
						new(pb,Init(ADialog,RTDIHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTDIABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTDICREATETAD,id_No,true,BUBBLE_DIAGRAM_CREATAD));
						new(pb,Init(ADialog,RTDIINSERT,id_No,true,BUBBLE_DIAGRAM_INSERT));
						if pb<>nil then
							if not(Application^.Multitasking) then pb^.Disable;
						new(pb,Init(ADialog,RTDIOK,id_OK,true,BUBBLE_DIAGRAM_OK));
						if pb<>nil then
							if not(Application^.Multitasking) then pb^.Disable;
						ADialog^.TransferBuffer:=@p^.diagrammbuf;
						PDiagrammDialog(ADialog)^.aendern:=-1;
						PDiagrammDialog(ADialog)^.obic:=@ADialog^.DlgTree^[RTDIICON];
						PDiagrammDialog(ADialog)^.obicspec:=PDiagrammDialog(ADialog)^.obic^.ob_spec.index
					end;
				TexelApp.DeactivateExtResource
			end;
		if ADialog<>nil then
			begin
				PDiagrammDialog(ADialog)^.bedt^.SetText(StrPTrimF(p^.dblock^.GetText));
				if (length(PDiagrammDialog(ADialog)^.ed1^.GetText)=0) and (length(p^.GetWindowFilename)>0) then p^.diagrammbuf.Titel:=p^.GetRawIconTitle;
				ADialog^.TransferData(tf_SetData);
				PDiagrammDialog(ADialog)^.CheckButtons;
				ADialog^.MakeWindow;
				SetFile(p^.diagrammbuf.objFilename)
			end
	end;


procedure TDiagram.SetFile(fname: string);

	begin
		PCalcWindow(Parent)^.diagrammbuf.objFilename:=fname;
		if ADialog<>nil then
			with PDiagrammDialog(ADialog)^ do
				if ofname<>nil then
					begin
						if length(fname)=0 then
							begin
								ofname^.SetText(' ['+STRING_TEMPORARYFILE+']');
								if pb1<>nil then pb1^.Disable
							end
						else
							begin
								ofname^.SetText(CompressPath(fname,38));
								if pb1<>nil then pb1^.Enable
							end
					end
	end;


constructor TObjSizeDialog.Init(AParent: PWindow; AEmbed: pointer; ATitle,HypHelp,hdTitle: string; Indx: integer);

	begin
		if not(inherited Init(AParent,ATitle,HypHelp,hdTitle,Indx)) then fail;
		embedobj:=AEmbed
	end;


function TObjSizeDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTOSSET);
		OK:=valid
	end;


function TObjSizeDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		if AnIndx=RTOSSET then
			if inherited OK then
				begin
					with PEmbedded(embedobj)^ do
						begin
							Redraw;
							if IsLocked then Application^.Bing
							else
								begin
									XPos_mm100:=round(atof(osbuf.x)*100.0);
									YPos_mm100:=round(atof(osbuf.y)*100.0);
									Width_mm100:=round(atof(osbuf.width)*100.0);
									Height_mm100:=round(atof(osbuf.height)*100.0);
									Redraw
								end
						end;
					PCalcWindow(Parent)^.SetDirty
				end
	end;


procedure TObjAttrBox.Changed(AnIndx: integer; DblClick: boolean);

	begin
		if GetCheck=bf_Checked then PObjAttrDialog(Parent)^.pbg^.Disable
		else
			PObjAttrDialog(Parent)^.pbg^.Enable
	end;


constructor TObjAttrDialog.Init(AParent: PWindow; AEmbed: pointer; ATitle,HypHelp,hdTitle: string; Indx,sbt: integer);

	begin
		if not(inherited Init(AParent,ATitle,HypHelp,hdTitle,Indx)) then fail;
		setbtn:=sbt;
		embedobj:=AEmbed
	end;


function TObjAttrDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(setbtn);
		OK:=valid
	end;


function TObjAttrDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		if AnIndx=setbtn then
			begin
				TransferData(tf_GetData);
				PEmbedded(embedobj)^.Redraw;
				PCalcWindow(Parent)^.SetDirty
			end
	end;


constructor TProtoEmbedded.Init(otyp: integer; fname: string; fdat: pointer; fdatlen,x,y,w100,h100: longint; const oab: TEmbedBuf; pdb: PDiagrammBuf; prp,emb,skl,umb,prnt,lck: boolean);

	begin
		if not(inherited Init) then fail;
		Next:=nil;
		ObjTyp:=otyp;
		FileName:=fname;
		Data:=fdat;
		DataLen:=fdatlen;
		X100:=x;
		Y100:=y;
		Width100:=w100;
		Height100:=h100;
		oabuf:=oab;
		diabuf:=pdb;
		prop:=prp;
		embd:=emb;
		skal:=skl;
		umbr:=umb;
		prntflg:=prnt;
		lckflg:=lck
	end;


destructor TProtoEmbedded.Done;

	begin
		if diabuf<>nil then freemem(diabuf,sizeof(TDiagrammBuf));
		inherited Done
	end;


procedure TProtoEmbedded.Realize(p: PCalcWindow);

	begin
		case ObjTyp of
		0:
			p^.EmbedNewObject(FileName,Width100,Height100,X100,Y100,DataLen,Data,@oabuf,nil,true,prop,embd,false,false,prntflg,lckflg);
		1:
			new(PEmbeddedIMG,Init(p,FileName,0,0,0,0,Width100,Height100,X100,Y100,DataLen,Data,true,true,prop,embd,skal,prntflg,lckflg,@oabuf));
		2:
			new(PEmbeddedText,Init(p,FileName,0,0,0,0,Width100,Height100,X100,Y100,DataLen,Data,true,true,prop,embd,umbr,prntflg,lckflg,@oabuf));
		3:
			p^.EmbedNewObject(FileName,Width100,Height100,X100,Y100,DataLen,Data,@oabuf,diabuf,true,prop,embd,false,true,prntflg,lckflg)
		end;
		if Next<>nil then Next^.Realize(p);
		Free
	end;


constructor TEmbedded.Init(AParent: PCalcWindow; poi: POLGAObjectInfo; fName: string; srvid,pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100,dlen: longint; dat: pointer; xyvalid,draw,prop,embd,prntflg,lckflg: boolean; poa: PEmbedBuf);
	var p: PEmbedded;

	begin
		if not(inherited Init) then fail;
		Parent:=AParent;
		if Parent=nil then fail;
		FileName:=NewStr(fName);
		if FileName=nil then fail;
		objectinfo:=poi;
		objsize:=nil;
		objattr:=nil;
		Data:=dat;
		DataLen:=dlen;
		Prev:=nil;
		Next:=nil;
		selected:=false;
		ServerID:=srvid;
		XPos_mm100:=0;
		YPos_mm100:=0;
		Width_mm100:=0;
		Height_mm100:=0;
		printflag:=true;
		with osbuf do
			begin
				x:='';
				y:='';
				width:='';
				height:='';
				prop:=bf_Unchecked;
				sperr:=bf_Unchecked
			end;
		if poa<>nil then
			begin
				oabuf:=poa^;
				embedflag:=embd;
				if prop then SetPropFlag
				else
					ClearPropFlag
			end
		else
			begin
				with oabuf do
					begin
						color:=White;
						trans:=bf_Unchecked;
						border:=bf_Checked
					end;
				embedflag:=false;
				SetPropFlag
			end;
		if Parent^.Embedded=nil then Parent^.Embedded:=@self
		else
			begin
				p:=Parent^.Embedded;
				while p^.Next<>nil do p:=p^.Next;
				p^.Next:=@self;
				Prev:=p
			end;
		if Parent^.objects<>nil then Parent^.objects^.Enable;
		if objectinfo<>nil then objectinfo^.ClientData:=longint(@self);
		ClearDirtyFlag;
		if prntflg then SetPrintFlag
		else
			ClearPrintFlag;
		if (Data=nil) or (DataLen=0) then CheckLink;
		Link;
		if draw then
			begin
				Parent^.DeselectAllObjects;
				selected:=true
			end;
		Resize(pixx,pixy,pixw,pixh,w100,h100,x100,y100,xyvalid,draw);
		if lckflg then Lock
		else
			Unlock;
		if Parent^.links<>nil then Parent^.links^.AddObject(@self)
	end;


destructor TEmbedded.Done;
	var answ: Pipearray;
	    tmd : string;

	begin
		if Parent^.links<>nil then Parent^.links^.RemoveObject(@self);
		if objectinfo<>nil then
			begin
				inc(objectinfo^.CBLock);
				if objectinfo^.CBLock>0 then
					if assigned(objectinfo^.CBUnembed) then objectinfo^.CBUnembed(nil,nil,0,0,0,objectinfo);
				dec(objectinfo^.CBLock);
				if ServerID>=0 then
					begin
						answ[0]:=OLGA_ID4UPDATE;
						answ[1]:=Application^.apID;
						answ[2]:=0;
						answ[3]:=0;
						answ[4]:=0;
						answ[5]:=0;
						answ[6]:=0;
						answ[7]:=0;
						appl_write(ServerID,16,@answ)
					end
			end;
		if (Prev=nil) and (Next=nil) then
			begin
				Parent^.Embedded:=nil;
				if Parent^.objects<>nil then Parent^.objects^.Disable
			end
		else
			begin
				if Prev=nil then Parent^.Embedded:=Next
					else Prev^.Next:=Next;
				if Next<>nil then Next^.Prev:=Prev
			end;
		if Data<>nil then freemem(Data,DataLen);
		GlobalFree(pointer(objectinfo),sizeof(TTexelObjectInfo));
		if FileName<>nil then
			begin
				tmd:=GetTexelTempDir;
				if StrPLeft(FileName^,length(tmd))=tmd then fdelete(FileName^)
			end;
		DisposeStr(FileName);
		inherited Done
	end;


function TEmbedded.IsExternal: boolean;

	begin
		IsExternal:=true
	end;


function TEmbedded.GetType: integer;

	begin
		GetType:=0
	end;


function TEmbedded.Save(hdl: integer; emb: boolean): boolean;
	var dummy: integer;

	begin
		Save:=true;
		dummy:=GetType;
		if bwrite(hdl,2,dummy) then exit;
		if SaveData(hdl,emb) then exit;
		Save:=false
	end;


function TEmbedded.SaveData(hdl: integer; emb: boolean): boolean;
	var dummy: longint;
	    prp  : boolean;

	begin
		SaveData:=true;
		if Filename<>nil then
			begin
				if fwrite(hdl,length(Filename^)+1,Filename)<>length(Filename^)+1 then exit
			end
		else
			begin
				dummy:=0;
				if bwrite(hdl,1,dummy) then exit
			end;
		if emb then dummy:=DataLen
		else
			dummy:=0;
		if bwrite(hdl,4,dummy) then exit;
		if dummy>0 then
			if fwrite(hdl,dummy,Data)<>dummy then exit;
		if bwrite(hdl,sizeof(oabuf),oabuf) then exit;
		if bwrite(hdl,4,Width_mm100) then exit;
		if bwrite(hdl,4,Height_mm100) then exit;
		prp:=IsProportional;
		if bwrite(hdl,sizeof(boolean),prp) then exit;
		if bwrite(hdl,sizeof(boolean),embedflag) then exit;
		prp:=CanPrint;
		if bwrite(hdl,sizeof(boolean),prp) then exit;
		SaveData:=false
	end;


function TEmbedded.GetExt(embed,default: boolean): string;
	var ret: string;

	begin
		if (length(GetFile)=0) and default then ret:=GetDefaultExt
		else
			ret:=GetExtension(GetFile);
		if (length(ret)>0) or not(embed) then
			begin
				ret:=StrPLeft(ret,4);
				while length(ret)<4 do ret:=ret+#0
			end;
		GetExt:=ret
	end;


function TEmbedded.GetDefaultExt: string;

	begin
		GetDefaultExt:=''
	end;


procedure TEmbedded.Link;
	var pipe: Pipearray;
	    pc  : pointer;

	begin
		if length(GetFile)>0 then
			if Application^.OLGAManager>=0 then
				begin
					GlobalAlloc(pc,256);
					if pc<>nil then
						begin
							StrPCopy(pc,GetFile);
							pipe[0]:=OLGA_LINK;
							pipe[1]:=Application^.apID;
							pipe[2]:=0;
							pipe[3]:=integer(HiWord(pc));
							pipe[4]:=integer(LoWord(pc));
							pipe[5]:=Parent^.GetOLGAGroup;
							pipe[6]:=0;
							pipe[7]:=0;
							appl_write(Application^.OLGAManager,16,@pipe)
						end
				end
	end;


procedure TEmbedded.Unlink;
	var pc  : pointer;
	    pipe: Pipearray;

	begin
		if length(GetFile)>0 then
			if Application^.OLGAManager>=0 then
				if not(Application^.Terminating) then
					begin
						GlobalAlloc(pc,256);
						if pc<>nil then
							begin
								StrPCopy(pc,GetFile);
								pipe[0]:=OLGA_UNLINK;
								pipe[1]:=Application^.apID;
								pipe[2]:=0;
								pipe[3]:=integer(HiWord(pc));
								pipe[4]:=integer(LoWord(pc));
								pipe[5]:=Parent^.GetOLGAGroup;
								pipe[6]:=0;
								pipe[7]:=0;
								appl_write(Application^.OLGAManager,16,@pipe)
							end
					end
	end;


procedure TEmbedded.BreakLink;

	begin
		SetFile('');
		{ !!! }
	end;


procedure TEmbedded.CheckLink;
	label _error;

	var res: longint;
	    hdl: integer;

	begin
		if Data<>nil then freemem(Data,DataLen);
		Data:=nil;
		DataLen:=0;
		if length(GetFile)=0 then exit;
		res:=fopen(GetFile,FO_READ);
		if res<0 then exit;
		hdl:=integer(res);
		DataLen:=fseek(0,hdl,2);
		if DataLen<0 then goto _error;
		if fseek(0,hdl,0)<0 then goto _error;
		getmem(Data,DataLen);
		if Data<>nil then
			if fread(hdl,DataLen,Data)<>DataLen then
				begin
					freemem(Data,DataLen);
					Data:=nil;
					DataLen:=0
				end;
		_error:
		fclose(hdl)
	end;


procedure TEmbedded.Update;

	begin
		ClearDirtyFlag;
		CheckLink;
		Redraw
	end;


function TEmbedded.CreateLinkFile: boolean;
	var s  : string;
	    ret: longint;
	    hdl: integer;

	begin
		if Exist(GetFile) then CreateLinkFile:=true
		else
			begin
				CreateLinkFile:=false;
				if (DataLen<=0) or (Data=nil) then exit;
				if length(GetFile)=0 then
					begin
						repeat
							s:=GetTexelTempDir+GetTempFilename;
							if length(GetDefaultExt)>0 then s:=CutRightF(s,4)+GetDefaultExt
						until not(Exist(s))
					end
				else
					begin
						s:=GetTexelTempDir+GetFilename(GetFile,true);
						while Exist(s) do
							s:=GetTexelTempDir+GetFilename(GetTempFilename,false)+GetExtension(GetFile)
					end;
				ret:=fcreate(s,0);
				if ret>=0 then
					begin
						hdl:=integer(ret);
						if fwrite(hdl,DataLen,Data)<>DataLen then
							begin
								fclose(hdl);
								exit
							end
						else
							fclose(hdl);
						Unlink;
						SetFile(s);
						Link;
						CreateLinkFile:=true
					end
			end
	end;


procedure TEmbedded.SetWorkstationValues(dev,colrs: integer; xofs,yofs: longint; xmm100,ymm100,perc,ffak: real; scale,outs: boolean);

	begin
		devID:=dev;
		XOffs:=xofs;
		YOffs:=yofs;
		xmm100fak:=xmm100;
		ymm100fak:=ymm100;
		ScaleIMG:=scale;
		percent:=perc;
		fontfak:=ffak;
		colors:=colrs;
		outscr:=outs
	end;


procedure TEmbedded.Paint(handle: integer; const clip: GRECT; screen: boolean);
	var pxy,ps: ARRAY_4;
	    pxya  : array [0..9] of integer;
	    d     : integer;
	    g     : GRECT;

	begin
		PaintX:=GetPixXPos(screen);
		PaintY:=GetPixYPos(screen);
		PaintW:=GetPixWidth(screen);
		PaintH:=GetPixHeight(screen);
		vsf_perimeter(handle,PER_ON);
		if screen then
			if oabuf.trans=bf_Checked then
				begin
					g.X:=PaintX;
					g.Y:=PaintY;
					g.W:=PaintW;
					g.H:=PaintH;
					if rc_intersect(clip,g) then
						begin
							Parent^.GetBlock(Parent^.dblock^.GetText,false,ps[0],ps[1],ps[2],ps[3],d,d);
							Parent^.DrawBlockRaw(ps[0],ps[1],ps[2],ps[3],g)
						end
				end;
		vswr_mode(handle,MD_REPLACE);
		pxy[0]:=PaintX;
		pxy[1]:=PaintY;
		pxy[2]:=pxy[0]+PaintW-1;
		pxy[3]:=pxy[1]+PaintH-1;
		if oabuf.trans<>bf_Checked then
			begin
				vsf_interior(handle,FIS_SOLID);
				if not(screen) and (oabuf.color>=colors) then vsf_color(handle,Black)
				else
					vsf_color(handle,oabuf.color);
				v_bar(handle,pxy)
			end;
		if (oabuf.border=bf_Checked) or (screen and IsSelected) then
			begin
				vsl_type(handle,LT_SOLID);
				vsl_color(handle,Black);
				vsl_width(handle,1);
				vsl_ends(handle,LE_SQUARED,LE_SQUARED);
				pxya[0]:=pxy[0];
				pxya[1]:=pxy[1];
				pxya[2]:=pxy[2];
				pxya[3]:=pxy[1];
				pxya[4]:=pxy[2];
				pxya[5]:=pxy[3];
				pxya[6]:=pxy[0];
				pxya[7]:=pxy[3];
				pxya[8]:=pxy[0];
				pxya[9]:=pxy[1];
				v_pline(handle,5,pxya)
			end;
		UserPaint(handle,clip,screen);
		vsl_width(handle,1);
		vsl_ends(handle,LE_SQUARED,LE_SQUARED);
		if screen then
			begin
				if IsSelected then
					begin
						vs_clip(handle,CLIP_ON,clip.A2);
						vswr_mode(handle,MD_REPLACE);
						vsf_perimeter(handle,PER_ON);
						if IsLocked then
							begin
								vsf_interior(handle,FIS_PATTERN);
								vsf_style(handle,4)
							end
						else
							vsf_interior(handle,FIS_SOLID);
						vsf_color(handle,Black);
						d:=round(8.0*Parent^.PercentSize);
						ps[0]:=pxy[0];
						ps[1]:=pxy[1];
						ps[2]:=pxy[0]+d;
						ps[3]:=pxy[1]+d;
						v_bar(handle,ps);
						ps[0]:=pxy[2]-d;
						ps[1]:=pxy[1];
						ps[2]:=pxy[2];
						ps[3]:=pxy[1]+d;
						v_bar(handle,ps);
						ps[0]:=pxy[2]-d;
						ps[1]:=pxy[3]-d;
						ps[2]:=pxy[2];
						ps[3]:=pxy[3];
						v_bar(handle,ps);
						ps[0]:=pxy[0];
						ps[1]:=pxy[3]-d;
						ps[2]:=pxy[0]+d;
						ps[3]:=pxy[3];
						v_bar(handle,ps);
						if not(IsProportional) then
							begin
								ps[0]:=(pxy[0]+pxy[2]-d) shr 1;
								ps[1]:=pxy[1];
								ps[2]:=ps[0]+d;
								ps[3]:=pxy[1]+d;
								v_bar(handle,ps);
								ps[1]:=pxy[3]-d;
								ps[3]:=pxy[3];
								v_bar(handle,ps);
								ps[0]:=pxy[2]-d;
								ps[1]:=(pxy[1]+pxy[3]-d) shr 1;
								ps[2]:=pxy[2];
								ps[3]:=ps[1]+d;
								v_bar(handle,ps);
								ps[0]:=pxy[0];
								ps[2]:=pxy[0]+d;
								v_bar(handle,ps)
							end;
						vsf_interior(handle,FIS_SOLID)
					end;
				g.X:=PaintX;
				g.Y:=PaintY;
				g.W:=PaintW;
				g.H:=PaintH;
				if rc_intersect(clip,g) then
					begin
						Parent^.GetBlock(Parent^.dblock^.GetText,false,ps[0],ps[1],ps[2],ps[3],d,d);
						Parent^.DrawBlockRaw(ps[0],ps[1],ps[2],ps[3],g)
					end
			end
	end;


procedure TEmbedded.UserPaint(handle: integer; clip: GRECT; screen: boolean);
	label _fehler;

	var cnt,q,
	    odi,os   : integer;
	    psi,pcl  : PGRECT;
	    prc      : longint;

	begin
		if objectinfo=nil then goto _fehler;
		if ServerID<0 then goto _fehler;
		if not(CreateLinkFile) then goto _fehler;
		inc(objectinfo^.CBLock);
		if objectinfo^.CBLock<=0 then goto _fehler;
		if screen or outscr then os:=1
		else
			os:=0;
		if screen then
			begin
				prc:=round(Parent^.PercentSize*10000.0);
				odi:=0
			end
		else
			begin
				prc:=round(percent*10000.0);
				odi:=devID
			end;
		psi:=@PTexelObjectInfo(objectinfo)^.r1;
		psi^.X:=PaintX+1;
		psi^.Y:=PaintY+1;
		psi^.W:=PaintW-2;
		psi^.H:=PaintH-2;
		GRtoA2(psi^);
		if rc_intersect(psi^,clip) then
			begin
				vs_clip(handle,CLIP_ON,clip.A2);
				pcl:=@PTexelObjectInfo(objectinfo)^.r2;
				pcl^:=clip;
				StrPCopy(objectinfo^.Filename,GetFile);
				if assigned(objectinfo^.CBXDraw) then objectinfo^.CBXDraw(nil,nil,0,0,0,objectinfo,os,handle,odi,psi,pcl,Width_mm100*10,Height_mm100*10,prc)
				else
					if assigned(objectinfo^.CBDraw) then objectinfo^.CBDraw(nil,nil,0,0,0,objectinfo,os,handle,odi,psi,pcl)
					else
						begin
							dec(objectinfo^.CBLock);
							goto _fehler
						end
			end;
		dec(objectinfo^.CBLock);
		exit;
		_fehler:
		vsl_color(handle,Red);
		pxya[0]:=PaintX+1;
		pxya[1]:=PaintY+1;
		pxya[2]:=PaintX+PaintW-2;
		pxya[3]:=PaintY+PaintH-2;
		v_pline(handle,2,pxya);
		pxya[1]:=pxya[3];
		pxya[3]:=PaintY+1;
		v_pline(handle,2,pxya)
	end;


procedure TEmbedded.Redraw;
	var r1,r2: GRECT;
	    pipe : Pipearray;

	begin
		Parent^.GetSheetRect(r1);
		with r2 do
			begin
				X:=GetPixXPos(true);
				Y:=GetPixYPos(true);
				W:=GetPixWidth(true);
				H:=GetPixHeight(true)
			end;
		if rc_intersect(r1,r2) then
			begin
				pipe[0]:=WM_REDRAW;
				pipe[1]:=Application^.apID;
				pipe[2]:=0;
				pipe[3]:=Parent^.Attr.gemHandle;
				pipe[4]:=r2.X;
				pipe[5]:=r2.Y;
				pipe[6]:=r2.W;
				pipe[7]:=r2.H;
				appl_write(pipe[1],16,@pipe)
			end
	end;


procedure TEmbedded.Unembed;

	begin
		ServerID:=id_No;
		Redraw
	end;


function TEmbedded.IsVisible(const r: GRECT; screen: boolean): boolean;
	var r2: GRECT;

	begin
		with r2 do
			begin
				X:=GetPixXPos(screen);
				Y:=GetPixYPos(screen);
				W:=GetPixWidth(screen);
				H:=GetPixHeight(screen)
			end;
		IsVisible:=rc_intersect(r,r2)
	end;


procedure TEmbedded.Resize(pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100: longint; xyvalid,draw: boolean);

	begin
		if draw then
			if (Width_mm100>0) and (Height_mm100>0) then Redraw;
		if IsLocked then Application^.Bing
		else
			begin
				if xyvalid then
					begin
						XPos_mm100:=x100;
						YPos_mm100:=y100
					end
				else
					begin
						XPos_mm100:=round((longint(pixx)+Parent^.Scroller^.XPos-Parent^.LeftColWidth-Parent^.Work.X)*longint(Application^.Attr.PixW)/(10.0*Parent^.PercentSize));
						YPos_mm100:=round((longint(pixy)+Parent^.Scroller^.YPos-Parent^.PaintOffs-Parent^.TopRowHeight-Parent^.Work.Y-1)*longint(Application^.Attr.PixH)/(10.0*Parent^.PercentSize))
					end;
				if w100>0 then Width_mm100:=w100
				else
					Width_mm100:=round(longint(pixw-1)*longint(Application^.Attr.PixW)/(10.0*Parent^.PercentSize));
				if h100>0 then Height_mm100:=h100
				else
					Height_mm100:=round(longint(pixh-1)*longint(Application^.Attr.PixH)/(10.0*Parent^.PercentSize));
				{ CELL_INVISIBLE !!! }
				if draw then Redraw;
				with osbuf do
					begin
						x:=ftoa(XPos_mm100/100.0);
						y:=ftoa(YPos_mm100/100.0);
						width:=ftoa(Width_mm100/100.0);
						height:=ftoa(Height_mm100/100.0);
						if objsize<>nil then
							begin
								if objsize^.ed1<>nil then objsize^.ed1^.SetText(x);
								if objsize^.ed2<>nil then objsize^.ed2^.SetText(y);
								if objsize^.ed3<>nil then objsize^.ed3^.SetText(width);
								if objsize^.ed4<>nil then objsize^.ed4^.SetText(height)
							end
					end
			end
	end;


function TEmbedded.GetPixXPos(screen: boolean): integer;

	begin
		if screen then GetPixXPos:=round(XPos_mm100*10.0*Parent^.PercentSize/longint(Application^.Attr.PixW))+Parent^.LeftColWidth+Parent^.Work.X-Parent^.Scroller^.XPos
		else
			GetPixXPos:=round(XPos_mm100*xmm100fak)-XOffs
	end;


function TEmbedded.GetPixYPos(screen: boolean): integer;

	begin
		if screen then GetPixYPos:=round(YPos_mm100*10.0*Parent^.PercentSize/longint(Application^.Attr.PixH))+Parent^.PaintOffs+Parent^.TopRowHeight+Parent^.Work.Y+1-Parent^.Scroller^.YPos
		else
			GetPixYPos:=round(YPos_mm100*ymm100fak)-YOffs
	end;


function TEmbedded.GetPixWidth(screen: boolean): integer;

	begin
		if screen then GetPixWidth:=round(Width_mm100*10.0*Parent^.PercentSize/longint(Application^.Attr.PixW))+1
		else
			GetPixWidth:=round(Width_mm100*xmm100fak)+1
	end;


function TEmbedded.GetPixHeight(screen: boolean): integer;

	begin
		if screen then GetPixHeight:=round(Height_mm100*10.0*Parent^.PercentSize/longint(Application^.Attr.PixH))+1
		else
			GetPixHeight:=round(Height_mm100*ymm100fak)+1
	end;


function TEmbedded.IsInside(mx,my: integer): boolean;
	var x,y: integer;

	begin
		x:=GetPixXPos(true);
		y:=GetPixYPos(true);
		IsInside:=Between(mx,x,x+GetPixWidth(true)-1) and Between(my,y,y+GetPixHeight(true)-1)
	end;


procedure TEmbedded.Click(mX,mY,KStat: integer);
	var ms,dummy,
	    fx,fy,el,
	    xo,yo,
	    xdif,ydif,
	    w,h,d,x,y: integer;
	    r        : GRECT;

	begin
		evnt_timer(10,0);
		if Parent^.inpstat then
			begin
				Application^.Bing;
				exit
			end;
		graf_mkstate(dummy,dummy,ms,dummy);
		if not(bTst(ms,1)) then Toggle
		else
			begin
				wind_update(BEG_UPDATE);
				wind_update(BEG_MCTRL);
				x:=GetPixXPos(true);
				y:=GetPixYPos(true);
				w:=GetPixWidth(true);
				h:=GetPixHeight(true);
				Parent^.GetSheetRect(r);
				el:=-1;
				if IsSelected then
					begin
						d:=round(8.0*Parent^.PercentSize);
						if mX<=x+d then
							begin
								if mY<=y+d then el:=0
								else if mY>=y+h-d then el:=6
								else
									if not(IsProportional) then
										if Between(mY,y+((h-d) shr 1),y+((h+d) shr 1)) then el:=7
							end
						else if mX>=x+w-d then
							begin
								if mY<=y+d then el:=2
								else if mY>=y+h-d then el:=4
								else
									if not(IsProportional) then
										if Between(mY,y+((h-d) shr 1),y+((h+d) shr 1)) then el:=3
							end
						else
							if not(IsProportional) then
								if Between(mX,x+((w-d) shr 1),x+((w+d) shr 1)) then
									begin
										if mY<=y+d then el:=1
										else if mY>=y+h-d then el:=5
									end
					end;
				if el>=0 then
					begin
						d:=round(20.0*Parent^.PercentSize);
						SetMouse(THIN_CROSS,nil);
						pxya[0]:=x;
						pxya[1]:=y;
						pxya[2]:=x+w-1;
						pxya[3]:=y;
						pxya[4]:=pxya[2];
						pxya[5]:=y+h-1;
						pxya[6]:=x;
						pxya[7]:=pxya[5];
						pxya[8]:=x;
						pxya[9]:=y;
						case el of
						0,1:
							begin
								xdif:=x-mX;
								ydif:=y-mY
							end;
						2,3:
							begin
								xdif:=x+w-mX-1;
								ydif:=y-mY
							end;
						4,5:
							begin
								xdif:=x+w-mX-1;
								ydif:=y+h-mY-1
							end;
						6,7:
							begin
								xdif:=x-mX;
								ydif:=y+h-mY-1
							end
						end;
						vswr_mode(Parent^.vdiHandle,MD_XOR);
						vsl_type(Parent^.vdiHandle,LT_USERDEF);
						xo:=mX;
						yo:=mY;
						HideMouse;
						repeat
							mX:=xo;
							mY:=yo;
							case el of
							0:
								begin
									pxya[0]:=mX+xdif;
									if pxya[0]>pxya[2]-d then pxya[0]:=pxya[2]-d;
									if IsProportional then
										begin
											if round(longint(h)*longint(pxya[2]-pxya[0])/longint(w))<d then pxya[0]:=pxya[2]-round(longint(d)*longint(w)/longint(h));
											pxya[1]:=pxya[5]-round(longint(h)*longint(pxya[2]-pxya[0])/longint(w))
										end
									else
										begin
											pxya[1]:=mY+ydif;
											if pxya[1]>pxya[5]-d then pxya[1]:=pxya[5]-d
										end;
									pxya[8]:=pxya[0];
									pxya[9]:=pxya[1];
									pxya[6]:=pxya[0];
									pxya[3]:=pxya[1]
								end;
							1:
								begin
									pxya[1]:=mY+ydif;
									if pxya[1]>pxya[5]-d then pxya[1]:=pxya[5]-d;
									pxya[9]:=pxya[1];
									pxya[3]:=pxya[1]
								end;
							2:
								begin
									pxya[2]:=mX+xdif;
									if pxya[2]<pxya[0]+d then pxya[2]:=pxya[0]+d;
									if IsProportional then
										begin
											if round(longint(h)*longint(pxya[2]-pxya[0])/longint(w))<d then pxya[2]:=round(longint(d)*longint(w)/longint(h))+pxya[0];
											pxya[3]:=pxya[5]-round(longint(h)*longint(pxya[2]-pxya[0])/longint(w))
										end
									else
										begin
											pxya[3]:=mY+ydif;
											if pxya[3]>pxya[5]-d then pxya[3]:=pxya[5]-d
										end;
									pxya[1]:=pxya[3];
									pxya[9]:=pxya[3];
									pxya[4]:=pxya[2]
								end;
							3:
								begin
									pxya[2]:=mX+xdif;
									if pxya[2]<pxya[0]+d then pxya[2]:=pxya[0]+d;
									pxya[4]:=pxya[2]
								end;
							4:
								begin
									pxya[4]:=mX+xdif;
									if pxya[4]<pxya[0]+d then pxya[4]:=pxya[0]+d;
									if IsProportional then
										begin
											if round(longint(h)*longint(pxya[4]-pxya[0])/longint(w))<d then pxya[4]:=round(longint(d)*longint(w)/longint(h))+pxya[0];
											pxya[5]:=pxya[1]+round(longint(h)*longint(pxya[4]-pxya[0])/longint(w))
										end
									else
										begin
											pxya[5]:=mY+ydif;
											if pxya[5]<pxya[1]+d then pxya[5]:=pxya[1]+d
										end;
									pxya[2]:=pxya[4];
									pxya[7]:=pxya[5]
								end;
							5:
								begin
									pxya[5]:=mY+ydif;
									if pxya[5]<pxya[1]+d then pxya[5]:=pxya[1]+d;
									pxya[7]:=pxya[5]
								end;
							6:
								begin
									pxya[6]:=mX+xdif;
									if pxya[6]>pxya[2]-d then pxya[6]:=pxya[2]-d;
									if IsProportional then
										begin
											if round(longint(h)*longint(pxya[2]-pxya[6])/longint(w))<d then pxya[6]:=pxya[2]-round(longint(d)*longint(w)/longint(h));
											pxya[7]:=pxya[1]+round(longint(h)*longint(pxya[2]-pxya[6])/longint(w))
										end
									else
										begin
											pxya[7]:=mY+ydif;
											if pxya[7]<pxya[1]+d then pxya[7]:=pxya[1]+d
										end;
									pxya[8]:=pxya[6];
									pxya[0]:=pxya[6];
									pxya[5]:=pxya[7]
								end;
							7:
								begin
									pxya[6]:=mX+xdif;
									if pxya[6]>pxya[2]-d then pxya[6]:=pxya[2]-d;
									pxya[8]:=pxya[6];
									pxya[0]:=pxya[6]
								end
							end;
							v_pline(Parent^.vdiHandle,5,pxya);
							ShowMouse;
							repeat
								graf_mkstate(xo,yo,ms,dummy)
							until (xo<>mX) or (yo<>mY) or ((ms and 3)<>1);
							HideMouse;
							v_pline(Parent^.vdiHandle,5,pxya)
						until (ms and 3)<>1;
						ShowMouse;
						vsl_type(Parent^.vdiHandle,LT_SOLID);
						vswr_mode(Parent^.vdiHandle,MD_REPLACE);
						if (ms and 3)=0 then
							begin
								Resize(pxya[0],pxya[1],pxya[4]+1-pxya[0],pxya[5]+1-pxya[1],0,0,0,0,false,true);
								Parent^.SetDirty
							end
					end
				else
					begin
						SetMouse(FLAT_HAND,nil);
						if graf_dragbox(w,h,x,y,r.X+2-w,r.Y+2-h,r.W+(w shl 1)-4,r.H+(h shl 1)-4,fx,fy)<>0 then
							begin
								Resize(fx,fy,w,h,0,0,0,0,false,true);
								Parent^.SetDirty
							end
					end;
				LastMouse;
				wind_update(END_MCTRL);
				wind_update(END_UPDATE)
			end
	end;


procedure TEmbedded.DblClick(mX,mY,KStat: integer);
	label _raus;
	
	var callpath,s: string;
	    ret       : longint;
	    hdl,q     : integer;
	    pc        : pointer;
	    pc2       : PChar;
	    pipe      : Pipearray;

	begin
		callpath:='';
		if Application^.OLGAManager<0 then goto _raus;
		if Exist(GetFile) then callpath:=GetFile
		else
			if (DataLen>0) and (Data<>nil) then
				begin
					if length(GetFile)=0 then
						begin
							repeat
								callpath:=GetTexelTempDir+GetTempFilename;
								if length(GetDefaultExt)>0 then callpath:=CutRightF(callpath,4)+GetDefaultExt
							until not(Exist(callpath))
						end
					else
						callpath:=GetTexelTempDir+GetFilename(GetFile,true);
					ret:=fcreate(callpath,0);
					if ret>=0 then
						begin
							hdl:=integer(ret);
							fwrite(hdl,DataLen,Data);
							fclose(hdl);
							Unlink;
							SetFile(callpath);
							Link
						end
					else
						callpath:=''
				end;
		_raus:
		if length(callpath)=0 then Application^.Bing
		else
			begin
				GlobalAlloc(pc,256);
				if pc<>nil then
					begin
						StrPCopy(pc,callpath);
						pipe[0]:=OLGA_START;
						pipe[1]:=Application^.apID;
						pipe[2]:=0;
						pipe[3]:=OLS_EXTENSION;
						pipe[6]:=integer(HiWord(pc));
						pipe[7]:=integer(LoWord(pc));
						s:=StrPUpper(GetExt(false,true));
						pc2:=PChar(@pipe[4]);
						for q:=1 to 4 do
							begin
								pc2^:=s[q];
								inc(longint(pc2))
							end;
						appl_write(Application^.OLGAManager,16,@pipe)
					end
			end
	end;


procedure TEmbedded.RButton(mX,mY,KStat,Clicks: integer);

	begin
		if Clicks=1 then DoMenu(mX,mY)
	end;


procedure TEmbedded.DoMenu(mX,mY: integer);
	var p: PPopup;

	begin
		TexelApp.ActivateExtResource;
		new(p,Init(Parent,RTPOPUPS2,RTP2OBJECT,id_No));
		TexelApp.DeactivateExtResource;
		if p<>nil then
			begin
				if (Data=nil) or (DataLen<=0) then p^.Disable(5);
				BusyMouse;
				if (Application^.OLGAManager<0) or (not(Exist(GetFile)) and ((DataLen<=0) or (Data=nil))) then p^.Disable(6);
				ArrowMouse;
				if IsEmbedded then p^.Check(11);
				if CanPrint then p^.Check(12);
				HandleMenu(Application^.Popup(p,mX,mY,POP_CENTER))
			end
	end;


procedure TEmbedded.HandleMenu(indx: integer);
	var path,
	    name,
	    ext : string;
	    ret : longint;
	    hdl : integer;
	    pb  : PButton;

	begin
		case indx of
		0:
			Cut;
		1:
			Copy;
		2:
			Paste;
		3:
			if Application^.Alert(Parent,2,WAIT,MESSAGE_EMBED_DELETE,BUTTON_YESNO)=1 then Destroy;
		5:
			begin
				path:='';
				name:='';
				ext:=GetExtension(GetFile);
				if length(ext)=0 then ext:=GetDefaultExt;
				if length(ext)=0 then ext:='.*';
				if FileSelect(Parent,FSELTITLE_OBJECTSAVEAS,'*'+ext,path,name,false) then
					begin
						if Exist(path+name) then
							if Application^.Alert(Parent,1,WAIT,MESSAGE_EMBED_EXIST1+CompressPath(path+name,78)+MESSAGE_EMBED_EXIST2,BUTTON_YESNO)<>1 then exit;
						ret:=fcreate(path+name,0);
						if ret>=0 then
							begin
								hdl:=integer(ret);
								fwrite(hdl,DataLen,Data);
								fclose(hdl)
							end
					end
			end;
		6:
			DblClick(0,0,0);
		8:
			begin
				if objsize=nil then
					begin
						TexelApp.ActivateExtResource;
						new(objsize,Init(Parent,@self,TEXELWINDPREFIX+TITLE_OBJSIZE,STG_OBJSIZE,ICNTITLE_OBJSIZE,RTOBJSIZE));
						if objsize<>nil then
							begin
								new(PGroupBox,Init(objsize,RTOSSIZE,'',BUBBLE_OBJSIZE_SIZE));
								new(PGroupBox,Init(objsize,RTOSFLAGS,'',BUBBLE_OBJSIZE_FLAGS));
								new(objsize^.ed1,Init(objsize,RTOSX,8,BUBBLE_OBJSIZE_X));
								if objsize^.ed1<>nil then objsize^.ed1^.SetValidator(new(PMinMaxValidator,Init(-999.99,999.99)));
								new(objsize^.ed2,Init(objsize,RTOSY,8,BUBBLE_OBJSIZE_Y));
								if objsize^.ed2<>nil then objsize^.ed2^.SetValidator(new(PMinMaxValidator,Init(-999.99,999.99)));
								new(objsize^.ed3,Init(objsize,RTOSWIDTH,8,BUBBLE_OBJSIZE_WIDTH));
								if objsize^.ed3<>nil then objsize^.ed3^.SetValidator(new(PMinMaxValidator,Init(5.0,999.99)));
								new(objsize^.ed4,Init(objsize,RTOSHEIGHT,8,BUBBLE_OBJSIZE_HEIGHT));
								if objsize^.ed4<>nil then objsize^.ed4^.SetValidator(new(PMinMaxValidator,Init(5.0,999.99)));
								new(objsize^.cb1,Init(objsize,RTOSPROP,true,BUBBLE_OBJSIZE_PROP));
								new(objsize^.cb2,Init(objsize,RTOSSPERR,true,BUBBLE_OBJSIZE_SPERR));
								new(pb,Init(objsize,RTOSHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(objsize,RTOSCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(PButton,Init(objsize,RTOSSET,id_No,true,BUBBLE_GENERAL_OBJSET));
								new(PButton,Init(objsize,RTOSOK,id_OK,true,BUBBLE_GENERAL_OBJSETOK));
								objsize^.TransferBuffer:=@osbuf
							end;
						TexelApp.DeactivateExtResource
					end;
				if objsize<>nil then objsize^.MakeWindow
			end;
		9:
			begin
				if objattr=nil then
					begin
						TexelApp.ActivateExtResource;
						new(objattr,Init(Parent,@self,TEXELWINDPREFIX+TITLE_OBJATTR,STG_OBJATTR,ICNTITLE_OBJATTR,RTOBJATTR,RTOASET));
						if objattr<>nil then
							begin
								new(PGroupBox,Init(objattr,RTOABACKGROUND,GROUP_OBJECT_BACKGR,BUBBLE_OBJATTR_BACKGR));
								new(objattr^.pbg,Init(objattr,RTOACOLOR,RTOACOLCYC,RTOACOLTITLE,RTPOPUPS2,RTP2COLOR,RTP2COLSTART,false,false,BUBBLE_OBJATTR_BGCOL));
								new(PObjAttrBox,Init(objattr,RTOATRANS,true,BUBBLE_OBJATTR_TRANS));
								new(PCheckBox,Init(objattr,RTOABORDER,true,BUBBLE_OBJATTR_BORDER));
								new(pb,Init(objattr,RTOAHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(objattr,RTOACANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(PButton,Init(objattr,RTOASET,id_No,true,BUBBLE_GENERAL_OBJSET));
								new(PButton,Init(objattr,RTOAOK,id_OK,true,BUBBLE_GENERAL_OBJSETOK));
								objattr^.TransferBuffer:=@oabuf
							end;
						TexelApp.DeactivateExtResource
					end;
				if objattr<>nil then objattr^.MakeWindow
			end;
		11:
			begin
				if IsEmbedded then ClearEmbedFlag
				else
					SetEmbedFlag
			end;
		12:
			begin
				if CanPrint then ClearPrintFlag
				else
					SetPrintFlag
			end
		end
	end;


function TEmbedded.IsEmbedded: boolean;

	begin
		IsEmbedded:=embedflag
	end;


procedure TEmbedded.SetEmbedFlag;

	begin
		if IsEmbedded then exit;
		embedflag:=true;
		Parent^.SetDirty
	end;


procedure TEmbedded.ClearEmbedFlag;

	begin
		if not(IsEmbedded) then exit;
		embedflag:=false;
		Parent^.SetDirty
	end;


procedure TEmbedded.Select;
	var pe: PEmbedded;
	    p : PCalcWindow;
	    q : integer;

	begin
		if IsSelected then exit;
		if Next<>nil then
			begin
				if Prev=nil then Parent^.Embedded:=Next
					else Prev^.Next:=Next;
				Next^.Prev:=Prev;
				pe:=Parent^.Embedded;
				while pe^.Next<>nil do pe:=pe^.Next;
				pe^.Next:=@self;
				Prev:=pe;
				Next:=nil;
				pe:=Parent^.Embedded;
				while pe<>nil do
					begin
						pe^.Deselect;
						pe:=pe^.Next
					end
			end;
		selected:=true;
		Redraw;
		p:=PCalcWindow(Parent);
		if p^.links<>nil then
			if p^.links^.linklist<>nil then
				if p^.links^.linklist^.Count>0 then
					for q:=0 to p^.links^.linklist^.Count-1 do
						if PLinkData(p^.links^.linklist^.At(q))^.ObjRef=@self then
							begin
								p^.links^.plb^.SetSelection(q);
								p^.links^.plb^.ScrollBar^.SetPosition(q);
								break
							end
	end;


procedure TEmbedded.Deselect;

	begin
		if not(IsSelected) then exit;
		selected:=false;
		Redraw
	end;


procedure TEmbedded.Toggle;

	begin
		if IsSelected then Deselect
		else
			Select
	end;


function TEmbedded.IsSelected: boolean;

	begin
		IsSelected:=selected
	end;


procedure TEmbedded.Destroy;

	begin
		Parent^.SetDirty;
		if objsize<>nil then objsize^.Free;
		if objattr<>nil then objattr^.Free;
		Unlink;
		Redraw;
		Free
	end;


procedure TEmbedded.Cut;

	begin
		Copy;
		Destroy
	end;


procedure TEmbedded.Copy;
	var res: longint;
	    hdl: integer;
	    msk: word;
	    tci: TCookieID;
	    scs: boolean;
	    ext: string;

	begin
		if Parent^.Clipboard=nil then exit;
		with Parent^.Clipboard^ do
			begin
				if not(OpenClipboard(true)) then exit;
				scs:=false;
				msk:=SCF_INDEF;
				if (Data<>nil) and (DataLen>0) then
					begin
						ext:=StrPLower(GetExtension(GetFile));
						if length(ext)>0 then
							begin
								res:=fcreate(GetClipboardFilename+CutLeftF(ext,1),0);
								if res>=0 then
									begin
										hdl:=integer(res);
										if fwrite(hdl,DataLen,Data)=DataLen then
											begin
												scs:=true;
												if (ext='.txt') or (ext='.asc') then msk:=SCF_TEXT
												else if ext='.img' then msk:=SCF_RASTER
												else if (ext='.cwg') or (ext='.cvg') or (ext='.gem') or (ext='.ai') then msk:=SCF_VECTOR
											end;
										fclose(hdl)
									end
							end
					end;
				res:=fcreate(GetClipboardFilename+'tob',0);
				if res>=0 then
					begin
						hdl:=integer(res);
						tci:='TXLO';
						fwrite(hdl,sizeof(TCookieID),@tci);
						Save(hdl,false);
						fclose(hdl);
						scs:=true;
						ext:='.tob'
					end;
				if scs then SetClipboardFormat(msk,ext);
				CloseClipboard
			end
	end;


procedure TEmbedded.Paste;

	begin
		Parent^.PasteObject
	end;


procedure TEmbedded.SetDirty;

	begin
		embfiledirty:=true
	end;


procedure TEmbedded.ClearDirtyFlag;

	begin
		embfiledirty:=false
	end;


function TEmbedded.IsDirty: boolean;

	begin
		IsDirty:=embfiledirty
	end;


procedure TEmbedded.SetPropFlag;

	begin
		if IsProportional then exit;
		osbuf.prop:=bf_Checked;
		if objsize<>nil then
			if objsize^.cb1<>nil then objsize^.cb1^.Check;
		Parent^.SetDirty
	end;


procedure TEmbedded.ClearPropFlag;

	begin
		if not(IsProportional) then exit;
		osbuf.prop:=bf_Unchecked;
		if objsize<>nil then
			if objsize^.cb1<>nil then objsize^.cb1^.Uncheck;
		Parent^.SetDirty
	end;


function TEmbedded.IsProportional: boolean;

	begin
		IsProportional:=(osbuf.prop=bf_Checked)
	end;


procedure TEmbedded.Lock;

	begin
		if IsLocked then exit;
		osbuf.sperr:=bf_Checked;
		if objsize<>nil then
			if objsize^.cb2<>nil then objsize^.cb2^.Check;
		Parent^.SetDirty
	end;


procedure TEmbedded.Unlock;

	begin
		if not(IsLocked) then exit;
		osbuf.sperr:=bf_Unchecked;
		if objsize<>nil then
			if objsize^.cb2<>nil then objsize^.cb2^.Uncheck;
		Parent^.SetDirty
	end;


function TEmbedded.IsLocked: boolean;

	begin
		IsLocked:=(osbuf.sperr=bf_Checked)
	end;


procedure TEmbedded.SetPrintFlag;

	begin
		if CanPrint then exit;
		printflag:=true;
		Parent^.SetDirty
	end;


procedure TEmbedded.ClearPrintFlag;

	begin
		if not(CanPrint) then exit;
		printflag:=false;
		Parent^.SetDirty
	end;


function TEmbedded.CanPrint: boolean;

	begin
		CanPrint:=printflag
	end;


procedure TEmbedded.SetFile(s: string);
	var p   : PCalcWindow;
	    q   : longint;
	    pld : PLinkData;
	    ext,
	    edsc: string;

	begin
		DisposeStr(FileName);
		FileName:=NewStr(s);
		p:=PCalcWindow(Parent);
		if p^.links<>nil then
			if p^.links^.linklist<>nil then
				begin
					pld:=nil;
					if p^.links^.linklist^.Count>0 then
						for q:=0 to p^.links^.linklist^.Count-1 do
							if PLinkData(p^.links^.linklist^.At(q))^.ObjRef=@self then
								begin
									pld:=PLinkData(p^.links^.linklist^.At(q));
									break
								end;
					if pld<>nil then
						begin
							DisposeStr(pld^.Descr);
							ext:=StrPUpper(GetExtension(s));
							edsc:='';
							if TexelApp.OLETypes<>nil then
								if TexelApp.OLETypes^.Count>0 then
									for q:=0 to TexelApp.OLETypes^.Count-1 do
										if StrPUpper(POLEType(TexelApp.OLETypes^.At(q))^.Ext)=ext then
											begin
												edsc:=StrPTrimF(POLEType(TexelApp.OLETypes^.At(q))^.Descr^);
												break
											end;
							if length(edsc)=0 then
								begin
									if ext='.IMG' then edsc:=STRING_IMG
									else
										if (ext='.TXT') or (ext='.ASC') then edsc:=STRING_TXT
										else
											edsc:=ext
								end;
							if length(edsc)>25 then edsc:=StrPLeft(edsc,22)+'...';
							pld^.Descr:=NewStr('  '+edsc+StrPSpace(27-length(edsc))+CompressPath(s,40)+#0);
							p^.links^.UpdateList(nil)
						end
				end
	end;


function TEmbedded.GetFile: string;

	begin
		if FileName<>nil then GetFile:=FileName^
		else
			GetFile:=''
	end;


function TEmbedded.bwrite(hdl: integer; count: longint; var buffer): boolean;

	begin
		bwrite:=(fwrite(hdl,count,@buffer)<>count)
	end;


constructor TEmbeddedTAD.Init(AParent: PCalcWindow; poi: POLGAObjectInfo; fName: string; srvid,pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100,dlen: longint; dat: pointer;
                              xyvalid,draw,prop,embd,prntflg,lckflg: boolean; poa: PEmbedBuf; pdb: PDiagrammBuf);

	begin
		fname:=GetPath(fname)+GetFilename(fname,false)+'.cwg';
		StrPCopy(poi^.Filename,fname);
		if not(inherited Init(AParent,poi,fname,srvid,pixx,pixy,pixw,pixh,w100,h100,x100,y100,dlen,dat,xyvalid,draw,prop,embd,prntflg,lckflg,poa)) then fail;
		if poa=nil then embedflag:=true;
		if pdb<>nil then
			begin
				diabuf:=pdb^;
				dbvalid:=(diabuf.rb1<>0)
			end
		else
			dbvalid:=false
	end;


function TEmbeddedTAD.GetType: integer;

	begin
		GetType:=3
	end;


function TEmbeddedTAD.SaveData(hdl: integer; emb: boolean): boolean;

	begin
		SaveData:=true;
		if inherited SaveData(hdl,emb) then exit;
		if bwrite(hdl,sizeof(boolean),dbvalid) then exit;
		if dbvalid then
			if bwrite(hdl,sizeof(TDiagrammBuf),diabuf) then exit;
		SaveData:=false
	end;


procedure TEmbeddedTAD.DoMenu(mX,mY: integer);
	var p  : PPopup;
	    ret: integer;

	begin
		TexelApp.ActivateExtResource;
		new(p,Init(Parent,RTPOPUPS2,RTP2TAD,id_No));
		TexelApp.DeactivateExtResource;
		if p<>nil then
			begin
				if (Data=nil) or (DataLen<=0) then p^.Disable(5);
				BusyMouse;
				if (Application^.OLGAManager<0) or (not(Exist(GetFile)) and ((DataLen<=0) or (Data=nil))) then p^.Disable(6);
				ArrowMouse;
				if not(dbvalid) or (Parent^.diagramm=nil) then p^.Disable(7);
				if IsEmbedded then p^.Check(12);
				if CanPrint then p^.Check(13);
				ret:=Application^.Popup(p,mX,mY,POP_CENTER);
				if ret=7 then
					begin
						Parent^.diagramm^.Work;
						if Parent^.diagramm^.ADialog<>nil then
							begin
								Parent^.diagrammbuf:=diabuf;
								Parent^.diagramm^.ADialog^.TransferData(tf_SetData)
							end
					end
				else
					if ret<7 then HandleMenu(ret)
					else
						HandleMenu(ret-1)
			end
	end;


function TEmbeddedStatic.IsExternal: boolean;

	begin
		IsExternal:=false
	end;


function TEmbeddedStatic.GetExt(embed,default: boolean): string;

	begin
		if embed then GetExt:=''
		else
			GetExt:=inherited GetExt(false,default)
	end;


constructor TEmbeddedIMG.Init(AParent: PCalcWindow; fName: string; pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100,dlen: longint; dat: pointer; xyvalid,draw,prop,embd,skal,prntflg,lckflg: boolean; poa: PEmbedBuf);

	begin
		fillchar(srcMFDB,sizeof(srcMFDB),0);
		fd_dlen:=0;
		if not(inherited Init(AParent,nil,fName,id_No,pixx,pixy,pixw,pixh,w100,h100,x100,y100,dlen,dat,xyvalid,draw,prop,embd,prntflg,lckflg,poa)) then fail;
		if (dat<>nil) and (dlen>0) then Decode;
		if poa=nil then
			begin
				oabuf.fcolor:=Black;
				ClearPropFlag;
				skalieren:=true;
			end
		else
			skalieren:=skal
	end;


destructor TEmbeddedIMG.Done;

	begin
		if srcMFDB.fd_addr<>nil then freemem(srcMFDB.fd_addr,fd_dlen);
		inherited Done
	end;


function TEmbeddedIMG.GetDefaultExt: string;

	begin
		GetDefaultExt:='.img'
	end;


function TEmbeddedIMG.GetType: integer;

	begin
		GetType:=1
	end;


function TEmbeddedIMG.SaveData(hdl: integer; emb: boolean): boolean;

	begin
		SaveData:=true;
		if inherited SaveData(hdl,emb) then exit;
		if bwrite(hdl,sizeof(boolean),skalieren) then exit;
		SaveData:=false
	end;


procedure TEmbeddedIMG.CheckLink;
	label _error;

	var res: longint;
	    hdl: integer;

	begin
		if Data<>nil then freemem(Data,DataLen);
		Data:=nil;
		DataLen:=0;
		fillchar(srcMFDB,sizeof(srcMFDB),0);
		fd_dlen:=0;
		if length(GetFile)=0 then exit;
		res:=fopen(GetFile,FO_READ);
		if res<0 then exit;
		hdl:=integer(res);
		DataLen:=fseek(0,hdl,2);
		if DataLen<0 then goto _error;
		if fseek(0,hdl,0)<0 then goto _error;
		getmem(Data,DataLen);
		if Data<>nil then
			if fread(hdl,DataLen,Data)<>DataLen then
				begin
					freemem(Data,DataLen);
					Data:=nil;
					DataLen:=0
				end;
		_error:
		fclose(hdl);
		if not(Decode) then
			begin
				if Data<>nil then freemem(Data,DataLen);
				if srcMFDB.fd_addr<>nil then freemem(srcMFDB.fd_addr,fd_dlen);
				Data:=nil;
				DataLen:=0;
				srcMFDB.fd_addr:=nil;
				fd_dlen:=0
			end
	end;


function TEmbeddedIMG.Decode: boolean;
	const MAX_PATTERNS = 8;

	var imgheader: PIMGHeader;
	    line_ptr,
	    rast_ptr,
	    src,dst  : PByte;
	    i,cnt,len,
	    max_pat,
	    l_buflen,
	    bytecols,
	    zeile,vrc: integer;
	    boffs    : longint;
	    wert     : byte;
	    pattern  : array [0..MAX_PATTERNS-1] of byte;

	begin
		Decode:=false;
		if (DataLen<16) or (Data=nil) then exit;
		imgheader:=Data;
		if imgheader^.version<>1 then exit;
		if imgheader^.headlen<8 then exit;
		{ Farbbilder !!! }
		if imgheader^.planes<>1 then exit;
		srcMFDB.fd_w:=imgheader^.sl_width;
		srcMFDB.fd_h:=imgheader^.sl_height;
		srcMFDB.fd_wdwidth:=(imgheader^.sl_width+15) shr 4;
		srcMFDB.fd_stand:=1;
		srcMFDB.fd_nplanes:=1;
		boffs:=srcMFDB.fd_wdwidth shl 1;
		fd_dlen:=longint(srcMFDB.fd_h)*boffs;
		getmem(srcMFDB.fd_addr,fd_dlen);
		if srcMFDB.fd_addr=nil then
			begin
				Decode:=true;
				exit
			end;
		src:=PByte(longint(Data)+(imgheader^.headlen shl 1));
		l_buflen:=(imgheader^.sl_width+7) shr 3;
		max_pat:=min(imgheader^.pat_run,MAX_PATTERNS);
		dst:=srcMFDB.fd_addr;
		zeile:=0;
		while zeile<imgheader^.sl_height do
			begin
				vrc:=1;
				bytecols:=l_buflen;
				line_ptr:=dst;
				while bytecols>0 do
					begin
						wert:=src^;
						inc(longint(src));
						case wert of
						0:
							begin
								wert:=src^;
								inc(longint(src));
								if wert=0 then
									begin
										wert:=src^;
										inc(longint(src));
										if wert=$ff then
											begin
												vrc:=src^;
												inc(longint(src))
											end
									end
								else
									begin
										dec(bytecols,wert*imgheader^.pat_run);
										for i:=0 to max_pat-1 do pattern[i]:=PByte(longint(src)+i)^;
										inc(longint(src),imgheader^.pat_run);
										while wert>0 do
											begin
												for i:=0 to max_pat-1 do
													begin
														line_ptr^:=pattern[i];
														inc(longint(line_ptr))
													end;
												dec(wert)
											end
									end
							end;
						$80:
							begin
								wert:=src^;
								inc(longint(src));
								dec(bytecols,wert);
								while wert>0 do
									begin
										line_ptr^:=src^;
										inc(longint(line_ptr));
										inc(longint(src));
										dec(wert)
									end
							end
						else
							begin
								len:=wert and $7f;
								dec(bytecols,len);
								if bTst(wert,$80) then wert:=$ff else wert:=0;
								while len>0 do
									begin
										line_ptr^:=wert;
										inc(longint(line_ptr));
										dec(len)
									end
							end
						end
					end;
				if vrc>1 then
					for cnt:=1 to vrc-1 do
						begin
							line_ptr:=dst;
							rast_ptr:=PByte(longint(dst)+longint(cnt)*boffs);
							for i:=0 to l_buflen-1 do
								begin
									rast_ptr^:=line_ptr^;
									inc(longint(line_ptr));
									inc(longint(rast_ptr))
								end
						end;
				inc(longint(dst),longint(vrc)*boffs);
				inc(zeile,vrc)
			end;
		colidx[1]:=White;
		imgxy[0]:=0;
		imgxy[1]:=0;
		imgxy[2]:=imgheader^.sl_width-1;
		imgxy[3]:=imgheader^.sl_height-1;
		Decode:=true
	end;


procedure TEmbeddedIMG.UserPaint(handle: integer; clip: GRECT; screen: boolean);
	var r : GRECT;
	    si: boolean;

	begin
		if srcMFDB.fd_addr<>nil then
			begin
				if not(screen) and (oabuf.fcolor>=colors) then colidx[0]:=Black
				else
					colidx[0]:=oabuf.fcolor;
				desMFDB.fd_addr:=nil;
				imgxy[4]:=PaintX+1;
				imgxy[5]:=PaintY+1;
				imgxy[6]:=PaintX+PaintW-2;
				imgxy[7]:=PaintY+PaintH-2;
				if screen then si:=TexelApp.ScaleIMG
				else
					si:=ScaleIMG;
				if si and skalieren then
					vrt_cpyfm(handle,integer(word(MD_TRANS) or word($8000)),imgxy,srcMFDB,desMFDB,colidx)
				else
					begin
						r.X:=imgxy[4];
						r.Y:=imgxy[5];
						r.W:=PaintW-2;
						r.H:=PaintH-2;
						if rc_intersect(clip,r) then
							begin
								vs_clip(handle,CLIP_ON,r.A2);
								vrt_cpyfm(handle,MD_TRANS,imgxy,srcMFDB,desMFDB,colidx)
							end
					end
			end
		else
			begin
				vsl_color(handle,Red);
				pxya[0]:=PaintX+1;
				pxya[1]:=PaintY+1;
				pxya[2]:=PaintX+PaintW-2;
				pxya[3]:=PaintY+PaintH-2;
				v_pline(handle,2,pxya);
				pxya[1]:=pxya[3];
				pxya[3]:=PaintY+1;
				v_pline(handle,2,pxya)
			end
	end;


procedure TEmbeddedIMG.DoMenu(mX,mY: integer);
	var p  : PPopup;
	    ret: integer;
	    pb : PButton;

	begin
		TexelApp.ActivateExtResource;
		new(p,Init(Parent,RTPOPUPS2,RTP2IMGOBJECT,id_No));
		TexelApp.DeactivateExtResource;
		if p<>nil then
			begin
				if (Data=nil) or (DataLen<=0) then p^.Disable(5);
				BusyMouse;
				if (Application^.OLGAManager<0) or (not(Exist(GetFile)) and ((DataLen<=0) or (Data=nil))) then p^.Disable(6);
				ArrowMouse;
				if IsEmbedded then p^.Check(11);
				if CanPrint then p^.Check(12);
				if TexelApp.ScaleIMG then
					begin
						if skalieren then p^.Check(13)
					end
				else
					p^.Disable(13);
				ret:=Application^.Popup(p,mX,mY,POP_CENTER);
				if ret=9 then
					begin
						if objattr=nil then
							begin
								TexelApp.ActivateExtResource;
								new(objattr,Init(Parent,@self,TEXELWINDPREFIX+TITLE_IMGOBJ,STG_IMGOBJ,ICNTITLE_IMGOBJ,RTIMGOBJATTR,RTIOASET));
								if objattr<>nil then
									begin
										new(PGroupBox,Init(objattr,RTIOABACKGROUND,GROUP_OBJECT_BACKGR,BUBBLE_IMGOBJ_BACKGR));
										new(PGroupBox,Init(objattr,RTIOAIMG,GROUP_OBJECT_IMAGE,BUBBLE_IMGOBJ_IMAGE));
										new(objattr^.pbg,Init(objattr,RTIOACOLOR,RTIOACOLCYC,RTIOACOLTITLE,RTPOPUPS2,RTP2COLOR,RTP2COLSTART,false,false,BUBBLE_IMGOBJ_BGCOL));
										new(PObjAttrBox,Init(objattr,RTIOATRANS,true,BUBBLE_IMGOBJ_TRANS));
										new(PCheckBox,Init(objattr,RTIOABORDER,true,BUBBLE_IMGOBJ_BORDER));
										new(PColorBox,Init(objattr,RTIOAICOLOR,RTIOAICOLCYC,RTIOAICOLTITLE,RTPOPUPS2,RTP2COLOR,RTP2COLSTART,false,false,BUBBLE_IMGOBJ_IMGCOL));
										new(pb,Init(objattr,RTIOAHELP,id_Help,false,BUBBLE_GENERAL_HELP));
										if pb<>nil then
											if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
										new(PButton,Init(objattr,RTIOACANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
										new(PButton,Init(objattr,RTIOASET,id_No,true,BUBBLE_GENERAL_OBJSET));
										new(PButton,Init(objattr,RTIOAOK,id_OK,true,BUBBLE_GENERAL_OBJSETOK));
										objattr^.TransferBuffer:=@oabuf
									end;
								TexelApp.DeactivateExtResource
							end;
						if objattr<>nil then objattr^.MakeWindow
					end
				else
					if ret=13 then
						begin
							skalieren:=not(skalieren);
							Redraw;
							Parent^.SetDirty
						end
					else
						HandleMenu(ret)
			end
	end;


constructor TEmbeddedText.Init(AParent: PCalcWindow; fName: string; pixx,pixy,pixw,pixh: integer; w100,h100,x100,y100,dlen: longint; dat: pointer; xyvalid,draw,prop,embd,umbr,prntflg,lckflg: boolean; poa: PEmbedBuf);

	begin
		if not(inherited Init(AParent,nil,fName,id_No,pixx,pixy,pixw,pixh,w100,h100,x100,y100,dlen,dat,xyvalid,draw,prop,embd,prntflg,lckflg,poa)) then fail;
		if poa=nil then
			begin
				with oabuf do
					begin
						fsize:=Parent^.FontSize2Index(Parent^.GetFontSize);
						fid:=Parent^.FontID2Index(Parent^.GetFontIndex);
						fcolor:=Black
					end;
				ClearPropFlag;
				umbruch:=true
			end
		else
			umbruch:=umbr;
		txOffs:=2;
		tyOffs:=2
	end;


function TEmbeddedText.GetDefaultExt: string;

	begin
		GetDefaultExt:='.txt'
	end;


function TEmbeddedText.GetType: integer;

	begin
		GetType:=2
	end;


function TEmbeddedText.SaveData(hdl: integer; emb: boolean): boolean;

	begin
		SaveData:=true;
		if inherited SaveData(hdl,emb) then exit;
		if bwrite(hdl,sizeof(boolean),umbruch) then exit;
		if bwrite(hdl,2,txOffs) then exit;
		if bwrite(hdl,2,tyOffs) then exit;
		SaveData:=false
	end;


procedure TEmbeddedText.CheckLink;
	label _error;

	var res: longint;
	    hdl: integer;

	begin
		if Data<>nil then freemem(Data,DataLen);
		Data:=nil;
		DataLen:=0;
		if length(GetFile)=0 then exit;
		res:=fopen(GetFile,FO_READ);
		if res<0 then exit;
		hdl:=integer(res);
		DataLen:=fseek(0,hdl,2);
		if DataLen<0 then goto _error;
		if fseek(0,hdl,0)<0 then goto _error;
		getmem(Data,DataLen);
		if Data<>nil then
			if fread(hdl,DataLen,Data)<>DataLen then
				begin
					freemem(Data,DataLen);
					Data:=nil;
					DataLen:=0
				end;
		_error:
		fclose(hdl)
	end;


procedure TEmbeddedText.UserPaint(handle: integer; clip: GRECT; screen: boolean);
	label _nochmal;

	var s,sout     : string;
	    rpt,breite,
	    dummy,py,px,
	    q,findx,
	    fsize,
	    wchar,hchar,
	    wcell,hcell: integer;
	    pend       : longint;
	    p          : PChar;
	    c          : char;
	    g          : GRECT;
	    ext        : ARRAY_8;
	    pf         : PFont;

	begin
		if (Data=nil) or (DataLen<=0) then exit;
		g.X:=PaintX+txOffs;
		g.Y:=PaintY+tyOffs;
		breite:=PaintW-(txOffs shl 1);
		g.W:=breite;
		g.H:=PaintH-(tyOffs shl 1);
		if not(rc_intersect(clip,g)) then exit;
		vs_clip(handle,CLIP_ON,g.A2);
		if not(screen) and (oabuf.fcolor>=colors) then vst_color(handle,Black)
		else
			vst_color(handle,oabuf.fcolor);
		if Parent^.Fonts=nil then findx:=vqt_name(handle,1,s)
		else
			if (oabuf.fid>=0) and (oabuf.fid<Parent^.Fonts^.Count) then findx:=PFont(Parent^.Fonts^.At(oabuf.fid))^.index
			else
				findx:=vqt_name(handle,1,s);
		if Parent^.Fonts=nil then fsize:=10
		else
			if (oabuf.fid<0) or (oabuf.fid>=Parent^.Fonts^.Count) then fsize:=10
			else
				begin
					pf:=Parent^.Fonts^.At(oabuf.fid);
					if pf^.SizeCount=0 then fsize:=4+oabuf.fsize
					else
						if (oabuf.fsize<0) or (oabuf.fsize>=pf^.SizeCount) then fsize:=10
						else
							fsize:=pf^.Sizes^[pf^.SizeCount-oabuf.fsize-1]
				end;
		vst_font(handle,findx);
		if screen then rpt:=round(fsize*Parent^.PercentSize)
		else
			rpt:=round(fsize*fontfak*percent);
		if Parent^.Speedo then vst_arbpt(handle,rpt,wchar,hchar,wcell,hcell)
		else
			vst_point(handle,rpt,wchar,hchar,wcell,hcell);
		vst_rotation(handle,0);
		vst_effects(handle,TF_NORMAL);
		vst_alignment(handle,TA_LEFT,TA_TOP,dummy,dummy);
		vswr_mode(handle,MD_TRANS);
		p:=Data;
		pend:=longint(p)+DataLen-1;
		px:=PaintX+txOffs;
		py:=PaintY+tyOffs;
		s:='';
		while (py<g.Y2) and ((longint(p)<=pend) or (length(s)>0)) do
			begin
				while longint(p)<=pend do
					begin
						c:=p^;
						inc(longint(p));
						if ord(c)>=32 then
							begin
								if length(s)<255 then s:=s+c
							end
						else
							if c=#10 then break
					end;
				if umbruch then
					begin
						sout:=s;
						s:='';
						if length(sout)>0 then
							begin
								_nochmal:
								if Parent^.Speedo then vqt_my_extent(handle,sout,ext)
								else
									vqt_extent(handle,sout,ext);
								if abs(ext[2]-ext[0])>breite then
									if length(sout)>1 then
										begin
											s:=StrPRight(sout,1)+s;
											CutRight(sout,1);
											goto _nochmal
										end;
								StrPTrim(s);
								if length(s)>0 then
									begin
										q:=length(sout);
										while (sout[q]<>' ') and (q>1) do dec(q);
										if q>1 then
											begin
												s:=StrPRight(sout,length(sout)-q)+s;
												sout:=StrPLeft(sout,q);
												StrPTrim(s)
											end
									end;
								if StrPRight(s,1)='-' then
									begin
										if StrPRight(s,2)=' -' then s:=s+' '
										else
											CutRight(s,1)
									end
								else
									if length(s)>0 then s:=s+' '
							end
					end
				else
					begin
						sout:=s;
						s:=''
					end;
				if Parent^.Speedo then v_ftext(handle,px,py,sout)
				else
					v_gtext(handle,px,py,sout);
				inc(py,hcell)
			end
	end;


procedure TEmbeddedText.DblClick(mX,mY,KStat: integer);
	var ret: longint;

	begin
		if length(GetFile)>0 then
			if not(Exist(GetFile)) then
				if (Data=nil) and (DataLen<=0) then
					begin
						ret:=fcreate(GetFile,0);
						if ret>=0 then fclose(integer(ret))
					end;
		inherited DblClick(mX,mY,KStat)
	end;


procedure TEmbeddedText.DoMenu(mX,mY: integer);
	var p     : PPopup;
	    ret   : integer;
	    pb    : PButton;
	    fsizes: PStringCollection;
	    pfsb  : PFontSizeBox;
	    pfb   : PFontBox;

	begin
		TexelApp.ActivateExtResource;
		new(p,Init(Parent,RTPOPUPS2,RTP2TXTOBJECT,id_No));
		TexelApp.DeactivateExtResource;
		if p<>nil then
			begin
				if (Data=nil) or (DataLen<=0) then p^.Disable(5);
				BusyMouse;
				if (Application^.OLGAManager<0) or ((length(GetFile)=0) and ((Data=nil) or (DataLen<=0))) then p^.Disable(6);
				ArrowMouse;
				if IsEmbedded then p^.Check(11);
				if CanPrint then p^.Check(12);
				if umbruch then p^.Check(13);
				ret:=Application^.Popup(p,mX,mY,POP_CENTER);
				if ret=13 then
					begin
						umbruch:=not(umbruch);
						Redraw;
						Parent^.SetDirty
					end
				else
					if ret=9 then
						begin
							if objattr=nil then
								begin
									TexelApp.ActivateExtResource;
									new(objattr,Init(Parent,@self,TEXELWINDPREFIX+TITLE_TXTOBJ,STG_TXTOBJ,ICNTITLE_TXTOBJ,RTTEXTOBJATTR,RTTOASET));
									if objattr<>nil then
										begin
											new(PGroupBox,Init(objattr,RTTOABACKGROUND,GROUP_OBJECT_BACKGR,BUBBLE_TXTOBJ_BACKGR));
											new(PGroupBox,Init(objattr,RTTOATEXT,GROUP_OBJECT_TEXT,BUBBLE_TXTOBJ_TEXT));
											new(objattr^.pbg,Init(objattr,RTTOACOLOR,RTTOACOLCYC,RTTOACOLTITLE,RTPOPUPS2,RTP2COLOR,RTP2COLSTART,false,false,BUBBLE_TXTOBJ_BGCOL));
											new(PObjAttrBox,Init(objattr,RTTOATRANS,true,BUBBLE_TXTOBJ_TRANS));
											new(PCheckBox,Init(objattr,RTTOABORDER,true,BUBBLE_TXTOBJ_BORDER));
											new(PColorBox,Init(objattr,RTTOATCOLOR,RTTOATCOLCYC,RTTOATCOLTITLE,RTPOPUPS2,RTP2COLOR,RTP2COLSTART,false,false,BUBBLE_TXTOBJ_TXTCOL));
											new(pfb,InitCollection(objattr,RTTOAFONTPOP,RTTOAFONTCYC,RTTOAFONTTITLE,26,Parent^.Fonts,false,false,false,BUBBLE_TXTOBJ_FONTID));
											if pfb<>nil then
												begin
													pfb^.newsize:=-1;
													new(fsizes,Init(130,20));
													new(pfsb,InitCollection(objattr,RTTOASIZEPOP,RTTOASIZECYC,RTTOASIZETITLE,6,fsizes,true,false,false,BUBBLE_TXTOBJ_FONTSIZE));
													pfsb^.setsize:=true;
													pfb^.fsizebox:=pfsb;
													pfb^.Work
												end;
											new(pb,Init(objattr,RTTOAHELP,id_Help,false,BUBBLE_GENERAL_HELP));
											if pb<>nil then
												if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
											new(PButton,Init(objattr,RTTOACANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
											new(PButton,Init(objattr,RTTOASET,id_No,true,BUBBLE_GENERAL_OBJSET));
											new(PButton,Init(objattr,RTTOAOK,id_OK,true,BUBBLE_GENERAL_OBJSETOK));
											objattr^.TransferBuffer:=@oabuf
										end;
									TexelApp.DeactivateExtResource
								end;
							if objattr<>nil then objattr^.MakeWindow
						end
					else
						HandleMenu(ret)
			end
	end;


function TOLEDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then Embed;
		OK:=valid
	end;


function TOLEDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		case AnIndx of
		RTOBSERVER:
			PCalcWindow(Parent)^.CallID4Server('');
		RTOBEINFUEGEN:
			if inherited OK then Embed
		end
	end;


procedure TOLEDialog.EndDlg(Indx: integer; DblClick: boolean);

	begin
		inherited EndDlg(Indx,DblClick);
		if DblClick then
			if plb<>nil then
				if plb^.TestIndex(Indx) then
					begin
						OK;
						Cont:=false;
						Result:=RTOBOK;
						Destroy
					end
	end;


procedure TOLEDialog.Embed;
	var ext: string;
	    p  : PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		ext:='';
		if trnsbuf>=0 then ext:=POLEType(TexelApp.OLETypes^.At(trnsbuf))^.Ext;
		if length(ext)=0 then ext:='.*';
		if XFileSelect(p,FSELTITLE_OBJECTINSERT,'*'+ext,TexelApp.LastPath[17],TexelApp.LastFile[17],0,FSEL_EMBED,true,false) then p^.EmbedNewObject(TexelApp.LastPath[17]+TexelApp.LastFile[17],0,0,0,0,0,nil,nil,nil,false,false,false,true,false,true,false)
	end;


procedure TOLEObject.Work;
	var p : PCalcWindow;
	    pb: PButton;

	begin
		if TexelApp.OLETypes=nil then exit;
		p:=PCalcWindow(Parent);
		if ADialog=nil then
			begin
				TexelApp.ActivateExtResource;
				ADialog:=new(POLEDialog,Init(p,TEXELWINDPREFIX+TITLE_INSOBJ,STG_INSOBJ,ICNTITLE_INSOBJ,RTOBJECT));
				if ADialog<>nil then
					begin
						new(POLEDialog(ADialog)^.plb,Init(ADialog,RTOBLIST,RTOBSLID,RTOBUP,RTOBDOWN,TexelApp.OLETypes,false,BUBBLE_INSOBJ_LIST));
						new(pb,Init(ADialog,RTOBSERVER,id_No,true,BUBBLE_INSOBJ_SERVER));
						if pb<>nil then pb^.Disable; { !!! }
						new(pb,Init(ADialog,RTOBHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTOBABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTOBEINFUEGEN,id_No,true,BUBBLE_INSOBJ_INSERT));
						new(PButton,Init(ADialog,RTOBOK,id_OK,true,BUBBLE_INSOBJ_OK));
						POLEDialog(ADialog)^.trnsbuf:=0;
						ADialog^.TransferBuffer:=@POLEDialog(ADialog)^.trnsbuf
					end;
				TexelApp.DeactivateExtResource
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


function TLink.ExitDlg(AnIndx: integer): boolean;
	var r,c,
	    sel  : integer;
	    x,y  : longint;
	    pld  : PLinkData;
	    p    : PCalcWindow;
	    fp,fn: string;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		sel:=plb^.GetSelection;
		pld:=PLinkData(linklist^.At(sel));
		case AnIndx of
		RTLICHANGE:
			begin
				fp:=GetPath(pld^.ObjRef^.GetFile);
				fn:=GetFilename(pld^.ObjRef^.GetFile,true);
				if FileSelect(@self,FSELTITLE_CHANGELINK,'*.*',fp,fn,true) then
					begin
						pld^.ObjRef^.Unlink;
						pld^.ObjRef^.SetFile(fp+fn);
						pld^.ObjRef^.Link;
						p^.SetDirty;
						pld^.ObjRef^.Update
					end
			end;
		RTLIACTIVATE:
			begin
				ExitDlg:=true;
				r:=0;
				c:=0;
				x:=pld^.ObjRef^.XPos_mm100;
				y:=pld^.ObjRef^.YPos_mm100;
				while ((y-p^.PRow^[r])>0) and (r<p^.Parms.Rows) do
					begin
						dec(y,p^.PRow^[r]);
						inc(r)
					end;
				while ((x-p^.PCol^[c])>0) and (c<p^.Parms.Columns) do
					begin
						dec(x,p^.PCol^[c]);
						inc(c)
					end;
				p^.SetCursorPos(r,c,true);
				pld^.ObjRef^.Select
			end;
		RTLIEDIT:
			begin
				ExitDlg:=true;
				pld^.ObjRef^.DblClick(0,0,K_NORMAL)
			end
		end
	end;


procedure TLink.EndDlg(Indx: integer; DblClick: boolean);

	begin
		inherited EndDlg(Indx,DblClick);
		if DblClick then
			if plb<>nil then
				if plb^.TestIndex(Indx) then
					begin
						ExitDlg(RTLIACTIVATE);
						Cont:=false;
						Result:=RTLIOK;
						Destroy
					end
	end;


procedure TLink.AddObject(pe: PEmbedded);
	var pld : PLinkData;
	    edsc,
	    ext : string;
	    q   : longint;

	begin
		if linklist=nil then exit;
		new(pld);
		if pld=nil then exit;
		ext:=StrPUpper(GetExtension(pe^.GetFile));
		edsc:='';
		if TexelApp.OLETypes<>nil then
			if TexelApp.OLETypes^.Count>0 then
				for q:=0 to TexelApp.OLETypes^.Count-1 do
					if StrPUpper(POLEType(TexelApp.OLETypes^.At(q))^.Ext)=ext then
						begin
							edsc:=StrPTrimF(POLEType(TexelApp.OLETypes^.At(q))^.Descr^);
							break
						end;
		if length(edsc)=0 then
			begin
				if ext='.IMG' then edsc:=STRING_IMG
				else
					if (ext='.TXT') or (ext='.ASC') then edsc:=STRING_TXT
					else
						edsc:=ext
			end;
		if length(edsc)>25 then edsc:=StrPLeft(edsc,22)+'...';
		pld^.ObjRef:=pe;
		pld^.Descr:=NewStr('  '+edsc+StrPSpace(27-length(edsc))+CompressPath(pe^.GetFile,40)+#0);
		if pld^.Descr=nil then
			begin
				dispose(pld);
				pld:=nil
			end
		else
			linklist^.Insert(pld);
		UpdateList(pld^.ObjRef)
	end;


procedure TLink.RemoveObject(pe: PEmbedded);
	var q: longint;

	begin
		if linklist=nil then exit;
		if linklist^.Count>0 then
			for q:=0 to linklist^.Count-1 do
				if PLinkData(linklist^.At(q))^.ObjRef=pe then
					begin
						linklist^.AtFree(q);
						break
					end;
		UpdateList(nil);
		if linklist^.Count=0 then
			begin
				PCalcWindow(Parent)^.links:=nil;
				Free
			end
	end;


procedure TLink.UpdateList(pe: PEmbedded);
	var sel,q: integer;

	begin
		if linklist<>nil then
			begin
				sel:=plb^.GetSelection;
				plb^.SetCollection(linklist);
				if pe<>nil then
					if linklist^.Count>0 then
						for q:=0 to linklist^.Count-1 do
							if PLinkData(linklist^.At(q))^.ObjRef=pe then
								begin
									sel:=q;
									break
								end;
				plb^.SetSelection(sel);
				plb^.ScrollBar^.SetPosition(sel)
			end;
		plb^.Work
	end;


procedure TLinkBox.Work;
	var p  : PLink;
	    sel: integer;

	begin
		p:=PLink(Parent);
		if p^.linklist=nil then
			begin
				p^.pb1^.Disable;
				p^.pb2^.Disable;
				p^.pb3^.Disable;
				exit
			end;
		sel:=GetSelection;
		if (sel<0) or (sel>=p^.linklist^.Count) then
			begin
				p^.pb1^.Disable;
				p^.pb2^.Disable;
				p^.pb3^.Disable
			end
		else
			begin
				p^.pb1^.Enable;
				p^.pb2^.Enable;
				p^.pb3^.Enable
			end
	end;


procedure TUmbruch.Work;
	var p    : PCalcWindow;
	    rbis,
	    cbis,
	    cmin,
	    cmax,
	    dummy,
	    r,c  : integer;

	begin
		p:=PCalcWindow(Parent);
		with p^ do
			begin
				GetBlock(dblock^.GetText,false,r,c,rbis,cbis,dummy,dummy);
				cmin:=cbis;
				cmax:=cmin;
				RowsClearOverflow(0,Parms.Rows,cmin,cmax);
				PRowFlags^[rbis]:=PRowFlags^[rbis] or CRF_UMBRUCH;
				PColFlags^[cbis]:=PColFlags^[cbis] or CRF_UMBRUCH;
				RowsCheckOverflow(0,Parms.Rows,cmin,cmax);
				DrawCells(0,cmin,Parms.Rows,cmax);
				DrawCells(rbis,0,rbis,Parms.Columns);
				SetDirty
			end
	end;


procedure TTextObj.Work;

	begin
		if XFileSelect(PCalcWindow(Parent),FSELTITLE_LOADTEXT,'*.txt',TexelApp.LastPath[18],TexelApp.LastFile[18],0,FSEL_LOADTEXT,false,false) then Load(TexelApp.LastPath[18]+TexelApp.LastFile[18])
	end;


procedure TTextObj.Load(fname: string);
	var pe       : PEmbeddedText;
	    p        : PCalcWindow;
	    r        : GRECT;
	    xmin,ymin,
	    xw,yh    : integer;

	begin
		p:=PCalcWindow(Parent);
		p^.GetSheetRect(r);
		if (r.W<40) then
			begin
				xmin:=r.X;
				xw:=50
			end
		else
			begin
				xmin:=r.X+(r.W shr 2);
				xw:=r.W shr 1
			end;
		if (r.H<40) then
			begin
				ymin:=r.Y;
				yh:=50
			end
		else
			begin
				ymin:=r.Y+(r.H shr 2);
				yh:=r.H shr 1
			end;
		new(pe,Init(p,fname,xmin,ymin,xw,yh,0,0,0,0,0,nil,false,true,false,false,false,true,false,nil));
		if pe<>nil then p^.SetDirty
	end;


procedure TGrafik.Work;

	begin
		if XFileSelect(PCalcWindow(Parent),FSELTITLE_LOADIMG,'*.img',TexelApp.LastPath[14],TexelApp.LastFile[14],0,FSEL_LOADIMG,true,false) then Load(TexelApp.LastPath[14]+TexelApp.LastFile[14])
	end;


procedure TGrafik.Load(fname: string);
	var pe       : PEmbeddedIMG;
	    p        : PCalcWindow;
	    r        : GRECT;
	    xmin,ymin,
	    xw,yh,hdl: integer;
	    imgh     : TIMGHeader;
	    res      : longint;
	    notbw    : boolean;

	begin
		p:=PCalcWindow(Parent);
		notbw:=true;
		res:=fopen(fname,FO_READ);
		if res>=0 then
			begin
				hdl:=integer(res);
				if fread(hdl,sizeof(TIMGHeader),@imgh)=sizeof(TIMGHeader) then notbw:=(imgh.version<>1) or (imgh.headlen<8) or (imgh.planes<>1);
				fclose(hdl)
			end;
		if notbw then p^.EmbedNewObject(fname,0,0,0,0,0,nil,nil,nil,false,false,false,true,false,true,false)
		else
			begin
				p^.GetSheetRect(r);
				if (r.W<40) then
					begin
						xmin:=r.X;
						xw:=50
					end
				else
					begin
						xmin:=r.X+(r.W shr 2);
						xw:=r.W shr 1
					end;
				if (r.H<40) then
					begin
						ymin:=r.Y;
						yh:=50
					end
				else
					begin
						ymin:=r.Y+(r.H shr 2);
						yh:=r.H shr 1
					end;
				new(pe,Init(p,fname,xmin,ymin,xw,yh,0,0,0,0,0,nil,false,true,false,false,false,true,false,nil));
				if pe<>nil then p^.SetDirty
			end
	end;


function TURLDialog.ExitDlg(AnIndx: integer): boolean;
	var pipe: Pipearray;

	begin
		ExitDlg:=false;
		if AnIndx=RTUOPEN then
			begin
				TransferData(tf_GetData);
				StrPTrim(urlbuf);
				if length(urlbuf)=0 then exit;
				StrPCopy(helpbuf,urlbuf);
				pipe[0]:=CAB_VIEW;
				pipe[1]:=Application^.apID;
				pipe[2]:=0;
				pipe[3]:=integer(HiWord(helpbuf));
				pipe[4]:=integer(LoWord(helpbuf));
				pipe[5]:=0;
				pipe[6]:=0;
				pipe[7]:=0;
				appl_write(TexelApp.WebID,16,@pipe)
			end
	end;


function TURLDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTUOPEN);
		OK:=valid
	end;


procedure TOpenUrl.Work;
	var pb: PButton;

	begin
		if ADialog=nil then
			begin
				TexelApp.ActivateExtResource;
				ADialog:=new(PURLDialog,Init(nil,TEXELWINDPREFIX+TITLE_URL,STG_URL,ICNTITLE_URL,RTURL));
				if ADialog<>nil then
					begin
						new(PEdit,Init(ADialog,RTUURL,68,BUBBLE_URL_EDIT));
						new(pb,Init(ADialog,RTUHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTUABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(pb1,Init(ADialog,RTUOPEN,id_No,true,BUBBLE_URL_OPEN));
						new(pb2,Init(ADialog,RTUOK,id_OK,true,BUBBLE_URL_OK));
						PURLDialog(ADialog)^.urlbuf:='';
						ADialog^.TransferBuffer:=@PURLDialog(ADialog)^.urlbuf
					end;
				TexelApp.DeactivateExtResource
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


procedure TOpen.Work;

	begin
		if XFileSelect(nil,FSELTITLE_OPEN,'*.'+TEXELEXTENSION,TexelApp.LastPath[0],TexelApp.LastFile[0],0,FSEL_OPEN,true,false) then Load(TexelApp.LastPath[0]+TexelApp.LastFile[0])
	end;


procedure TOpen.Load(fname: string);
	label _raus,_error,_errmsg,_pweiter,_pagain;

	var header    : TTexelHeader;
	    head2     : TTexelHead2;
	    parms     : TTexelParms;
	    tdbuf     : TDialogBuffer;
	    tsbuf     : TSheetBuffer;
	    taebuf    : TExportAscBuf;
	    diabuf    : TDiagrammBuf;
	    texbuf    : TExportBuf;
	    tzwbuf    : TZielBuf;
	    srtbuf    : TSortBuf;
	    infbuf    : TInfoBuf;
	    findbuf   : TFindBuf;
	    repbuf    : TReplaceBuf;
	    fillbuf   : TFillBuffer;
	    buf       : PByteArray;
			l         : byte;
			pdb       : PDiagrammBuf;
			prntflg,
			lckflg,
			skal,umbr,
			prop,embd,
			npredef,
			dbv,
	    rerror    : boolean;
	    bufsize,
	    bufpos,
	    ende,
	    offs,w,q,
	    pmask,dlen,
	    w100,h100,
	    x100,y100,
	    res,dummy : longint;
	    dat       : pointer;
	    objtyp,
	    passmask,
	    prnrange,
	    hdl,i     : integer;
	    npval     : TNumber;
	    bhist     : PStringCollection;
			ppc       : PParameterCollection;
			oldcell,
	    sheet,cell: PCell;
	    prowflags,
	    pcolflags : PByteArray;
			prow,
			pcol      : PWordArray;
			pcolnames : PItemList;
	    coffs     : word;
	    buffer    : array [0..127] of byte;
	    ttxt,tname,
	    tdescr    : string;
			rval      : real;
			pp        : PParameter;
			pfm       : PFormat;
			ufrm      : PFormatCollection;
			pre,pred  : PProtoEmbedded;
			pw        : PWindow;
			pwd       : PDialog;
			ps        : PStatic;
			pg        : PProgressWindow;
			apwd      : TPassWord;
			tb        : string[21];
			oabuf     : TEmbedBuf;
			prnset    : PRN_SETTINGS;
			pprnset   : PPRN_SETTINGS;
			findold   : record
				search,
				replace : string[45];
				rows,
				columns,
				cse,
				complete,
				formula,
				value,
				txt,
				note,
				iform,
				ival    : integer
			end;
			tdold     : record
				font,
				size,
				percent,
				color,
				pattern,
				direction: integer;
				input    : string[55];
				txtcolor,
				border   : integer;
				resvd1,
				resvd2,
				resvd3,
				resvd4   : longint
			end;

	function bfread(var buffer; count: longint): boolean;

		begin
			if fread(hdl,count,@buffer)=count then bfread:=false
			else
				begin
					rerror:=true;
					bfread:=true
				end
		end;

	function bread(var buffer; count: longint): boolean;
		var q,len: longint;

		begin
			bread:=false;
			if count<1 then exit;
			if bufpos+count>res then
				if res=bufsize then
					begin
						len:=bufsize-bufpos;
						if len>0 then move(buf^[bufpos],buf^[0],len);
						res:=fread(hdl,bufsize-len,@buf^[len]);
						if res<0 then
							begin
								rerror:=true;
								bread:=true;
								exit
							end;
						if passmask<>0 then
							for q:=len to bufsize-1 do buf^[q]:=buf^[q] xor system.random(256);
						inc(res,len);
						bufpos:=0
					end;
			if bufpos+count>res then
				begin
					rerror:=true;
					bread:=true
				end
			else
				begin
					move(buf^[bufpos],buffer,count);
					inc(bufpos,count)
				end
		end;

	function readtree(var node: PNode): boolean;
		var op,q: integer;

		begin
			readtree:=true;
			node:=nil;
			if bread(op,2) then exit;
			if op<>NT_ENDOFDATA then
				begin
					new(node);
					if node=nil then exit;
					node^.Typ:=op;
					node^.All:=0;
					node^.Left.Node:=nil;
					node^.Right.Node:=nil;
					if op>=5000 then
						begin
							if bread(node^.Count,4) then exit;
							if node^.Count<>NT_LIST_EMPTY then
								begin
									getmem(node^.Left.List,node^.Count shl 2);
									if node^.Left.List=nil then exit;
									for q:=0 to node^.Count-1 do
										if readtree(PNode(node^.Left.List^[q])) then exit
								end
						end
					else
						if op>=1000 then
							begin
								if readtree(node^.Left.Node) then exit;
								if readtree(node^.Right.Node) then exit
							end
						else
							case op of
							NT_NEGATE,
							NT_KLAMMER:
								if readtree(node^.Left.Node) then exit;
							NT_MINUS,
							NT_MULT,
							NT_DIV,
							NT_POWER,
							NT_EQUAL,
							NT_GREATER,
							NT_LESS,
							NT_GREATEREQUAL,
							NT_LESSEQUAL,
							NT_UNEQUAL,
							NT_PLUS:
								begin
									if readtree(node^.Left.Node) then exit;
									if readtree(node^.Right.Node) then exit
								end;
							NT_CELL:
								begin
									if bread(node^.All,4) then exit;
									if bread(node^.Right.Flg,2) then exit
								end;
							NT_RANGE:
								begin
									if bread(node^.Left.All,4) then exit;
									if bread(node^.Right.All,4) then exit;
									if bread(node^.All,4) then exit
								end;
							NT_VARIABLE:
								begin
									if bread(l,1) then exit;
									if l>0 then
										begin
											if bread(ttxt[1],l) then exit;
											ttxt[0]:=chr(l);
											node^.Varb:=NewStr(ttxt)
										end
								end;
							NT_CONST:
								begin
									if bread(rval,sizeof(real)) then exit;
									new(node^.Num);
									if node^.Num=nil then exit;
									node^.Num^:=rval;
									if bread(l,1) then exit;
									if l>0 then
										begin
											if bread(ttxt[1],l) then exit;
											ttxt[0]:=chr(l);
											node^.Left.Txt:=NewStr(ttxt)
										end
								end
							end
				end;
			readtree:=false
		end;

	function readcell: boolean;

		begin
			readcell:=true;
			if bread(cell^.Flags,CELLSIZE-4) then exit;
			cell^.Data.Value:=0;
			case cell^.Typ of
			CTYPE_TEXT:
				begin
					if bread(l,1) then exit;
					if l>0 then
						begin
							if bread(ttxt[1],l) then exit;
							ttxt[0]:=chr(l);
							cell^.Data.Txt:=NewStr(ttxt)
						end
				end;
			CTYPE_CONST:
				begin
					new(cell^.Data.Konst);
					if cell^.Data.Konst<>nil then
						with cell^.Data.Konst^ do
							begin
								if bread(rval,sizeof(real)) then exit;
								Value:=rval;
								if bread(l,1) then exit;
								if l>0 then
									begin
										if bread(ttxt[1],l) then exit;
										ttxt[0]:=chr(l);
										Txt:=NewStr(ttxt)
									end
								else
									Txt:=nil;
								if bread(FPts,1) then exit
							end
				end;
			CTYPE_FORMULA:
				begin
					new(cell^.Data.Formula);
					if cell^.Data.Formula<>nil then
						with cell^.Data.Formula^ do
							begin
								if bread(rval,sizeof(real)) then exit;
								Value:=rval;
								if bread(l,1) then exit;
								if l>0 then
									if bread(ttxt[1],l) then exit;
								ttxt[0]:=chr(l);
								if bread(FPts,1) then exit;
								if bread(Error,1) then exit;
								VarDef:=NewStr(TexelApp.EscText2Formula(ttxt));
								Func:=nil
							end
				end;
			CTYPE_PARSED:
				begin
					new(cell^.Data.Formula);
					if cell^.Data.Formula=nil then exit;
					with cell^.Data.Formula^ do
						begin
							if bread(rval,sizeof(real)) then exit;
							Value:=rval;
							if bread(FPts,1) then exit;
							if bread(Error,1) then exit;
							if readtree(Func) then exit;
							if bread(l,1) then exit;
							if l>0 then
								begin
									if bread(ttxt[1],l) then exit;
									ttxt[0]:=chr(l);
									VarDef:=NewStr(ttxt)
								end
							else
								VarDef:=nil
						end
				end
			end;
			oldcell:=cell;
			readcell:=false
		end;

	begin
		if length(fname)=0 then exit;
		BusyMouse;
		if TexelApp.abruf<>nil then TexelApp.abruf^.Add(fname,true);
		pg:=nil;
		bhist:=nil;
		pprnset:=nil;
		pre:=nil;
		buf:=GetMemBuffer(16384,128,bufsize);
		if buf=nil then
			begin
				Application^.Alert(nil,1,STOP,MESSAGE_OPEN_MEMORY1+CompressPath(fname,78)+MESSAGE_OPEN_MEMORY2,BUTTON_OK);
				goto _raus
			end;
		if not(Exist(fname)) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_OPEN_EXIST1+CompressPath(fname,78)+MESSAGE_OPEN_EXIST2,BUTTON_OK);
				goto _raus
			end;
		pw:=Application^.MainWindow;
		while pw<>nil do
			begin
				if pw^.GetClassName=TEXELWINDCLASS then
					if PCalcWindow(pw)^.GetWindowFilename=fname then
						if Application^.Alert(nil,1,WAIT,MESSAGE_OPEN_LOADED1+CompressPath(fname,78)+MESSAGE_OPEN_LOADED2,BUTTON_YESNO)<>1 then goto _raus;
				pw:=pw^.Next
			end;
		rerror:=false;
		res:=fopen(fname,FO_READ);
		if res<0 then goto _errmsg;
		hdl:=integer(res);
		res:=bufsize;
		bufpos:=res;
		passmask:=0;
		if fread(hdl,sizeof(TTexelHeader),@header)<>sizeof(TTexelHeader) then
			begin
				rerror:=true;
				goto _error
			end;
		with header do
			begin
				if Magic<>TEXELMAGIC then
					begin
						Application^.Alert(nil,1,NOTE,MESSAGE_OPEN_FORMAT1+CompressPath(fname,78)+MESSAGE_OPEN_FORMAT2,BUTTON_OK);
						fclose(hdl);
						goto _raus
					end
				else
					if (Compatible<17) or (Compatible>TEXELCOMPAT) then
						begin
							Application^.Alert(nil,1,NOTE,MESSAGE_OPEN_VERSION1+CompressPath(fname,78)+MESSAGE_OPEN_VERSION2+ltoa(Compatible)+MESSAGE_OPEN_VERSION3+VtoS(Version)+MESSAGE_OPEN_VERSION4,BUTTON_OK);
							fclose(hdl);
							goto _raus
						end
					else
						if (PackAlgo<>PA_HORIZONTAL) and (PackAlgo<>PA_VERTICAL) then
							begin
								if PackAlgo=PA_BLOCK then Application^.Alert(nil,1,NOTE,MESSAGE_OPEN_CCP,BUTTON_OK)
								else
									Application^.Alert(nil,1,NOTE,MESSAGE_OPEN_ALGO1+CompressPath(fname,78)+MESSAGE_OPEN_ALGO2+' (#'+ltoa(PackAlgo)+').',BUTTON_OK);
								fclose(hdl);
								goto _raus
							end
			end;
		if fread(hdl,sizeof(TTexelHead2),@head2)<>sizeof(TTexelHead2) then
			begin
				rerror:=true;
				goto _error
			end;
		apwd.Flag:=head2.PassFlag;
		apwd.Code:=head2.PassCode;
		apwd.Mask:=0;
		if head2.PassFlag<>0 then
			begin
				TexelApp.ActivateExtResource;
				_pagain:
				new(pwd,Init(nil,'',RTPASS));
				if pwd<>nil then
					begin
						new(ps,Init(pwd,RTPWFILE,30,true,BUBBLE_PASS_FILE));
						if ps<>nil then ps^.SetText(CompressPath(fname,29));
						new(PEdit,Init(pwd,RTPWPASS,21,BUBBLE_PASS_EDIT));
						new(PButton,Init(pwd,RTPWABBRUCH,id_Cancel,true,BUBBLE_PASS_CANCEL));
						new(PButton,Init(pwd,RTPWOK,id_OK,true,BUBBLE_PASS_OK));
						tb:='';
						pwd^.TransferBuffer:=@tb;
						if Application^.ExecDialog(pwd)=RTPWOK then
							begin
								if length(tb)<6 then
									begin
										Application^.Alert(nil,1,NOTE,MESSAGE_OPEN_PASSLEN,BUTTON_OK);
										goto _pagain
									end;
								if CheckPassWord(tb,head2.PassCode,pmask) then
									begin
										head2.RSeed:=head2.RSeed xor pmask;
										apwd.Mask:=pmask;
										TexelApp.DeactivateExtResource;
										goto _pweiter
									end
								else
									Application^.Alert(nil,1,STOP,MESSAGE_OPEN_PASSWRONG,BUTTON_CANCEL)
							end;
						TexelApp.DeactivateExtResource;
						fclose(hdl);
						goto _raus
					end
				else
					begin
						TexelApp.DeactivateExtResource;
						rerror:=true;
						goto _error
					end
			end;
		_pweiter:
		if header.Compatible>29 then
			begin
				if bfread(coffs,2) then goto _error;
				pred:=nil;
				if coffs>0 then
					for q:=0 to coffs-1 do
						begin
							if bfread(objtyp,2) then goto _error;
							if bfread(l,1) then goto _error;
							if l>0 then
								if bfread(ttxt[1],l) then goto _error;
							ttxt[0]:=chr(l);
							if bfread(dlen,4) then goto _error;
							if dlen=0 then dat:=nil
							else
								begin
									getmem(dat,dlen);
									if dat=nil then
										begin
											rerror:=true;
											goto _error
										end;
									if bfread(dat^,dlen) then goto _error
								end;
							if bfread(oabuf,sizeof(TEmbedBuf)) then goto _error;
							if bfread(x100,4) then goto _error;
							if bfread(y100,4) then goto _error;
							if bfread(w100,4) then goto _error;
							if bfread(h100,4) then goto _error;
							if bfread(prop,sizeof(boolean)) then goto _error;
							if bfread(embd,sizeof(boolean)) then goto _error;
							prntflg:=true;
							lckflg:=false;
							if header.Compatible>34 then
								begin
									if bfread(prntflg,sizeof(boolean)) then goto _error;
									if bfread(lckflg,sizeof(boolean)) then goto _error
								end;
							skal:=false;
							umbr:=false;
							pdb:=nil;
							case objtyp of
							1:
								if bfread(skal,sizeof(boolean)) then goto _error;
							2:
								begin
									if bfread(umbr,sizeof(boolean)) then goto _error;
									if bfread(dummy,4) then goto _error
								end;
							3:
								begin
									if bfread(dbv,sizeof(boolean)) then goto _error;
									if dbv then
										begin
											new(pdb);
											if pdb=nil then
												begin
													rerror:=true;
													goto _error
												end;
											if bfread(pdb^,sizeof(TDiagrammBuf)) then goto _error
										end
								end
							end;
							if pre=nil then new(pre,Init(objtyp,ttxt,dat,dlen,x100,y100,w100,h100,oabuf,pdb,prop,embd,skal,umbr,prntflg,lckflg))
							else
								begin
									pred:=pre;
									while pred^.Next<>nil do pred:=pred^.Next;
									new(pred^.Next,Init(objtyp,ttxt,dat,dlen,x100,y100,w100,h100,oabuf,pdb,prop,embd,skal,umbr,prntflg,lckflg))
								end
						end
			end;
		if head2.CryptFlag<>0 then
			begin
				randseed:=head2.RSeed;
				passmask:=1
			end;
		if bread(parms,sizeof(TTexelParms)) then goto _error;
		with parms do
			begin
				if Rows<1 then Rows:=1;
				if Columns<1 then Columns:=1;
				if header.Compatible<37 then Toolbar:=TexelApp.setupbuffer.toolbar
			end;
		ScanConst(ppc);
		new(ufrm,Init(50,25));
		getmem(prow,(parms.Rows+1) shl 1);
		getmem(pcol,(parms.Columns+1) shl 1);
		getmem(pcolnames,(parms.Columns+1) shl 2);
		getmem(prowflags,parms.Rows+1);
		getmem(pcolflags,parms.Columns+1);
		dummy:=longint(parms.Rows+1)*longint(parms.Columns+1)*CELLSIZE;
		getmem(sheet,dummy);
		if (prow=nil) or (pcol=nil) or (sheet=nil) or (pcolnames=nil) or (prowflags=nil) or (pcolflags=nil) then
			begin
				if prow<>nil then freemem(prow,(parms.Rows+1) shl 1);
				if pcol<>nil then freemem(pcol,(parms.Columns+1) shl 1);
				if prowflags<>nil then freemem(prowflags,parms.Rows+1);
				if pcolflags<>nil then freemem(pcolflags,parms.Columns+1);
				if pcolnames<>nil then freemem(pcolnames,(parms.Columns+1) shl 2);
				if sheet<>nil then freemem(sheet,dummy);
				TexelApp.ErrorWindowMemory(nil);
				fclose(hdl);
				goto _raus
			end;
		new(pg,Init(parms.Rows+(parms.Rows shr 2)+1,TITLE_OPEN,fname));
		fillchar(pcolnames^,(parms.Columns+1) shl 2,0);
		fillchar(pcolflags^,parms.Columns+1,0);
		fillchar(prowflags^,parms.Rows+1,0);
		fillchar(sheet^,dummy,0);
		TexelApp.InitCells(sheet,parms.Rows+1,parms.Columns+1);
		if header.Compatible<27 then
			begin
				if bread(tdold,sizeof(tdold)) then goto _error;
				tdbuf.font:=tdold.font;
				tdbuf.size:=tdold.size;
				tdbuf.percent:=tdold.percent;
				tdbuf.color:=tdold.color;
				tdbuf.pattern:=tdold.pattern;
				tdbuf.direction:=tdold.direction;
				tdbuf.input:=tdold.input;
				tdbuf.txtcolor:=tdold.txtcolor;
				tdbuf.border:=tdold.border;
				tdbuf.resvd1:=tdold.resvd1;
				tdbuf.resvd2:=tdold.resvd2;
				tdbuf.resvd3:=tdold.resvd3;
				tdbuf.resvd4:=tdold.resvd4
			end
		else
			if bread(tdbuf,sizeof(TDialogBuffer)) then goto _error;
		if header.Compatible<26 then
			begin
				if bread(tsbuf.font,sizeof(TSheetBuffer)-12) then goto _error;
				tsbuf.umbruch:=bf_Checked
			end
		else
			if bread(tsbuf.font,sizeof(TSheetBuffer)-10) then goto _error;
		if header.Compatible<24 then
			begin
				with tzwbuf do
					begin
						zzelle:='';
						vzelle:='';
						wert:='0';
						iterationen:='100'
					end
			end
		else
			if bread(tzwbuf,sizeof(TZielBuf)) then goto _error;
		if header.Compatible<29 then
			begin
				with diabuf do
					begin
						rb1:=bf_Checked;
						rb2:=bf_Unchecked;
						rb3:=bf_Unchecked;
						rb4:=bf_Unchecked;
						rb5:=bf_Unchecked;
						typLinie:=bf_Checked;
						typBalken:=bf_Unchecked;
						typKreis:=bf_Unchecked;
						Farbe:=bf_Checked;
						Absolut:=bf_Checked;
						xyLinear:=bf_Checked;
						xyFirst:=bf_Unchecked;
						xyAlternate:=bf_Unchecked;
						xyLine:=bf_Unchecked;
						xyPt:=bf_Unchecked;
						xyLinept:=bf_Checked;
						Stapeln:=bf_Unchecked;
						DreiD:=bf_Unchecked;
						Neben:=bf_Checked;
						stilLinie:=0;
						stilPunkt:=5;
						Titel:='';
						Legende:=bf_Checked;
						Border:=bf_Checked;
						nRow:=bf_Unchecked;
						nColumn:=bf_Unchecked;
						Size:=TexelApp.setupbuffer.stdfsize;
						Font:=TexelApp.setupbuffer.stdfont;
						dRows:=bf_Checked;
						dColumns:=bf_Unchecked;
						Ticks:=bf_Checked;
						numTicks:='4';
						alName:='Y';
						alTicks:=bf_Checked;
						alNum:='3';
						alMin:='';
						alMax:='';
						auName:='X';
						auTicks:=bf_Checked;
						auNum:='3';
						auMin:='';
						auMax:='';
						szWidth:='50.0';
						szHeight:='50.0';
						objFilename:=''
					end
			end
		else
			if bread(diabuf,sizeof(TDiagrammBuf)) then goto _error;
		if header.Compatible<23 then
			begin
				if bread(texbuf.ascii,sizeof(TExportAscBuf)) then goto _error;
				with texbuf do
					begin
						exporttype:=0;
						clipboard:=bf_Unchecked;
						bereich:=bf_Unchecked;
						htmldoctype:=0;
						htmlsavedt:=bf_Checked;
						htmlcolor:=bf_Checked;
						csvformula:=bf_Unchecked;
						csvvalue:=bf_Checked;
						difformula:=bf_Unchecked;
						difvalue:=bf_Checked;
						difstandard:=bf_Checked;
						difexcel:=bf_Unchecked;
						difformat:=bf_Checked;
						csvformat:=bf_Checked;
						asciiformat:=bf_Checked;
						htmlembed:=bf_Unchecked;
						filter:=0
					end
			end
		else
			if header.Compatible<28 then
				begin
					if bread(texbuf,sizeof(TExportBuf)-10) then goto _error;
					texbuf.difformat:=bf_Checked;
					texbuf.csvformat:=bf_Checked;
					texbuf.asciiformat:=bf_Checked;
					texbuf.htmlembed:=bf_Unchecked;
					texbuf.htmldoctype:=0;
					texbuf.htmlsavedt:=bf_Checked;
					texbuf.filter:=0
				end
			else
				if header.Compatible<31 then
					begin
						if bread(texbuf,sizeof(TExportBuf)-4) then goto _error;
						texbuf.htmlembed:=bf_Unchecked;
						texbuf.htmldoctype:=0;
						texbuf.htmlsavedt:=bf_Checked;
						texbuf.filter:=0
					end
				else
					if header.Compatible<34 then
						begin
							if bread(texbuf,sizeof(TExportBuf)-2) then goto _error;
							texbuf.filter:=0;
							if header.Compatible<32 then
								begin
									texbuf.htmldoctype:=0;
									texbuf.htmlsavedt:=bf_Checked
								end
						end
					else
						if bread(texbuf,sizeof(TExportBuf)) then goto _error;
		if header.Compatible<22 then
			begin
				if bread(srtbuf,sizeof(TSortBuf)-2) then goto _error;
				srtbuf.Attribute:=bf_Unchecked
			end
		else
			if bread(srtbuf,sizeof(TSortBuf)) then goto _error;
		if bread(infbuf,sizeof(TInfoBuf)-4) then goto _error;
		infbuf.Last:=gettime;
		infbuf.Version:=header.Version;
		infbuf.Release:=header.Release;
		inc(infbuf.Used);
		if head2.CryptFlag=0 then infbuf.Encrypt:=bf_Unchecked
		else
			infbuf.Encrypt:=bf_Checked;
		if header.Compatible<18 then
			begin
				if bread(findold,sizeof(findold)) then goto _error;
				with findbuf do
					begin
						search:=findold.search;
						rows:=findold.rows;
						columns:=findold.columns;
						cse:=findold.cse;
						complete:=findold.complete;
						formula:=findold.formula;
						value:=findold.value;
						txt:=findold.txt;
						iform:=findold.iform;
						ival:=findold.ival;
						vor:=bf_Checked;
						zurueck:=bf_Unchecked;
						resvd:=0
					end;
				with repbuf do
					begin
						search:='';
						replace:='';
						rows:=bf_Checked;
						columns:=bf_Unchecked;
						cse:=bf_Unchecked;
						complete:=bf_Unchecked;
						formula:=bf_Checked;
						value:=bf_Checked;
						txt:=bf_Checked;
						vor:=bf_Checked;
						zurueck:=bf_Unchecked;
						resvd:=0
					end
			end
		else
			begin
				if bread(findbuf,sizeof(TFindBuf)) then goto _error;
				if bread(repbuf,sizeof(TReplaceBuf)) then goto _error
			end;
		if bread(fillbuf,sizeof(TFillBuffer)) then goto _error;
		if bread(coffs,2) then goto _error;
		while coffs>0 do
			begin
				if bread(buffer,Min(128,coffs)) then goto _error;
				if coffs>128 then dec(coffs,128)
				else
					coffs:=0
			end;
		if bread(prow^,(parms.Rows+1) shl 1) then goto _error;
		if bread(pcol^,(parms.Columns+1) shl 1) then goto _error;
		for q:=0 to parms.Columns do
			begin
				if bread(l,1) then goto _error;
				if l>0 then
					begin
						if bread(ttxt[1],l) then goto _error;
						ttxt[0]:=chr(l);
						pcolnames^[q]:=NewStr(ttxt)
					end
			end;
		if header.Compatible>=25 then
			begin
				if bread(prowflags^,Parms.Rows+1) then goto _error;
				if bread(pcolflags^,Parms.Columns+1) then goto _error
			end;
		if bread(coffs,2) then goto _error;
		oldcell:=nil;
		cell:=sheet;
		if header.PackAlgo=PA_VERTICAL then
			begin
				offs:=longint(parms.Columns+1)*CELLSIZE;
				ende:=longint(sheet)+(longint(parms.Columns+1)*longint(parms.Rows+1)-1)*CELLSIZE;
				while coffs<>65535 do
					begin
						if coffs>32768 then
							for q:=0 to coffs-32769 do
								begin
									cell^:=oldcell^;
									cell^.Flags:=cell^.Flags and CELL_EMPTYMASK;
									inc(longint(cell),offs);
									if longint(cell)>ende then cell:=PCell(longint(sheet)+longint(cell)-ende)
								end
						else
							if coffs>0 then
								for q:=0 to coffs-1 do
									begin
										inc(longint(cell),offs);
										if longint(cell)>ende then cell:=PCell(longint(sheet)+longint(cell)-ende)
									end;
						if readcell then goto _error;
						inc(longint(cell),offs);
						if longint(cell)>ende then cell:=PCell(longint(sheet)+longint(cell)-ende);
						if bread(coffs,2) then goto _error
					end
			end
		else
			while coffs<>65535 do
				begin
					if coffs>32768 then
						for q:=0 to coffs-32769 do
							begin
								cell^:=oldcell^;
								cell^.Flags:=cell^.Flags and CELL_EMPTYMASK;
								inc(longint(cell),CELLSIZE)
							end
					else
						if coffs>0 then inc(longint(cell),longint(coffs)*CELLSIZE);
					if readcell then goto _error;
					inc(longint(cell),CELLSIZE);
					if bread(coffs,2) then goto _error
				end;
		if bread(coffs,2) then goto _error;
		if coffs>0 then
			for q:=0 to coffs-1 do
				begin
					if bread(l,1) then goto _error;
					if l>0 then
						if bread(tname[1],l) then goto _error;
					tname[0]:=chr(l);
					if bread(l,1) then goto _error;
					if l>0 then
						if bread(ttxt[1],l) then goto _error;
					ttxt[0]:=chr(l);
					if bread(l,1) then goto _error;
					if l>0 then
						if bread(tdescr[1],l) then goto _error;
					tdescr[0]:=chr(l);
					if ppc<>nil then
						begin
							npval:=atof(ttxt);
							npredef:=false;
							if ppc^.Count>0 then
								for w:=0 to ppc^.Count-1 do
									if StrPUpper(PParameter(ppc^.At(w))^.Name^)=StrPUpper(tname) then
										begin
											if PParameter(ppc^.At(w))^.Value=npval then npredef:=true;
											ppc^.AtFree(w);
											break
										end;
							new(pp);
							if pp<>nil then
								begin
									pp^.Value:=npval;
									pp^.Name:=NewStr(tname);
									pp^.ListName:=NewStr('  '+tname+' '#0);
									pp^.Txt:=NewStr(ttxt);
									pp^.Descr:=NewStr(tdescr);
									pp^.Predef:=npredef;
									if (pp^.Name=nil) or (pp^.Txt=nil) then
										begin
											DisposeStr(pp^.Name);
											DisposeStr(pp^.ListName);
											DisposeStr(pp^.Txt);
											DisposeStr(pp^.Descr);
											dispose(pp)
										end
									else
										ppc^.Insert(pp)
								end
						end
				end;
		if header.Compatible>18 then
			if ufrm<>nil then
				begin
					ufrm^.Sort:=false;
					if bread(coffs,2) then goto _error;
					if coffs>0 then
						for q:=0 to coffs-1 do
							begin
								if bread(i,2) then goto _error;
								if bread(l,1) then goto _error;
								if l>0 then
									if bread(ttxt[1],l) then goto _error;
								ttxt[0]:=chr(l);
								new(pfm);
								if pfm<>nil then
									begin
										pfm^.Name:=NewStr(ttxt);
										pfm^.Group:=1;
										pfm^.Index:=i;
										ufrm^.Insert(pfm)
									end
							end
				end;
		if header.Compatible>20 then
			begin
				if bread(coffs,2) then goto _error;
				if coffs>0 then
						for q:=0 to coffs-1 do
							begin
								if bread(l,1) then goto _error;
								if l>0 then
									if bread(ttxt[1],l) then goto _error;
								ttxt[0]:=chr(l);
								if bhist=nil then
									begin
										new(bhist,Init(5+atol(TexelApp.setupbuffer.history),10));
										if bhist<>nil then bhist^.Sort:=false
									end;
								if bhist<>nil then bhist^.Insert(NewStr(ttxt))
							end
			end;
		if header.Compatible>32 then
			begin
				if bread(dummy,4) then goto _error;
				if dummy>0 then
					begin
						if bread(prnset,dummy) then goto _error;
						pprnset:=@prnset
					end
			end;
		prnrange:=-1;
		if header.Compatible>35 then
			if bread(prnrange,2) then goto _error;
{		if bread(coffs,2) then goto _error;
		if coffs>0 then
			for q:=0 to coffs-1 do
				begin
					if bread(l,1) then goto _error;
					if l>0 then
						if bread(tname[1],l) then goto _error;
					tname[0]:=chr(l);
					if bread(w,2) then goto _error;
					 ... 
				end;
		if bread(coffs,2) then goto _error; ... }
		_error:
		fclose(hdl);
		_errmsg:
		if rerror or (res<0) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_OPEN_ERROR1+CompressPath(fname,78)+MESSAGE_OPEN_ERROR2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done)
			end
		else
			begin
				if pg<>nil then pg^.Progress(parms.Rows shr 2);
				tsbuf.protect:=bf_Unchecked; { ... }
				TexelApp.FontID2Index(tdbuf.font);
				TexelApp.FontSize2Index(tdbuf.font,tdbuf.size);
				TexelApp.FontID2Index(tsbuf.font);
				TexelApp.FontSize2Index(tsbuf.font,tsbuf.size);
				new(PCalcWindow,InitFile(fname,pg,parms,tdbuf,tsbuf,findbuf,repbuf,
				    fillbuf,tzwbuf,texbuf,srtbuf,infbuf,diabuf,sheet,prow,pcol,pcolnames,ppc,ufrm,pre,
				    apwd,bhist,pcolflags,prowflags,pprnset,prnrange,header.Compatible<TEXELCOMPAT,
				    header.Compatible<38))
			end;
		_raus:
		if buf<>nil then freemem(buf,bufsize);
		ArrowMouse
	end;


procedure TSave.Work;
	var p    : PCalcWindow;
      fname: string;

	begin
		p:=PCalcWindow(Parent);
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				exit
			end;
		fname:=p^.GetWindowFileName;
		if length(fname)=0 then p^.saveas^.Work
		else
			if p^.sheetbuffer.vorlage=bf_Unchecked then Save(fname)
			else
				if Application^.Alert(p,2,WAIT,MESSAGE_SAVE_FORMDOC,BUTTON_FORMDOC)=1 then Save(fname)
				else
					if XFileSelect(p,FSELTITLE_SAVEFORMASDOC,'*.'+TEXELEXTENSION,TexelApp.LastPath[0],TexelApp.LastFile[0],1,FSEL_SAVE2,false,p^.closing) then p^.saveas^.SaveAs(TexelApp.LastPath[0]+TexelApp.LastFile[0],1)
	end;


function TSave.Save(fname: string): boolean;
	label _unreg,_raus;

	var p        : PCalcWindow;
      fn2      : string;
      buf      : PByteArray;
      res,dummy,
      packsize,
      hsize,
      vsize,
      lctrl,
      bufsize,
      bufcnt   : longint;
      passmask,
      nctrl,
      objtyp,
      hdl,q    : integer;
      header   : TTexelHeader;
      head2    : TTexelHead2;
      l        : byte;
      embdirty,
      werror,
      prp,
      test     : boolean;
      oldtb    : pointer;
      newtb    : TDialogBuffer;
      newsb    : TSheetBuffer;
      coffs    : word;
      ps       : PString;
	    pp       : PParameter;
	    pfm      : PFormat;
	    pf       : PFont;
	    rval     : real;
	    cell,
	    oldcell  : PCell;
	    pe       : PEmbedded;

	function IsCellEqual: boolean;

		begin
			IsCellEqual:=false;
			if cell^.Data.Value=0 then
				with oldcell^ do
					if Data.Value=0 then
						if Typ=cell^.Typ then
							if Color=cell^.Color then
								if Style=cell^.Style then
									if Interior=cell^.Interior then
										if Border.Val1=cell^.Border.Val1 then
											if Border.Val2=cell^.Border.Val2 then
												if Format=cell^.Format then
													if (Flags and CELL_EMPTYMASK)=(cell^.Flags and CELL_EMPTYMASK) then
														if cell^.TxtVal.Flags=0 then
															with TxtVal do
																if Flags=0 then
																	if Font=cell^.TxtVal.Font then
																		if Size=cell^.TxtVal.Size then
																			if Rotat=cell^.TxtVal.Rotat then
																				if Skew=cell^.TxtVal.Skew then
																					if Color=cell^.TxtVal.Color then
																						if Effects=cell^.TxtVal.Effects then
																							if Align=cell^.TxtVal.Align then IsCellEqual:=true
		end;

	function bfwrite(var buffer; count: longint): boolean;

		begin
			if fwrite(hdl,count,@buffer)=count then bfwrite:=false
			else
				begin
					werror:=true;
					bfwrite:=true
				end
		end;

	function bwrite(var buffer; count: longint): boolean;
		var q,rlen: longint;
		    pb    : PByte;

		begin
			if test then
				begin
					bwrite:=false;
					inc(packsize,count);
					exit
				end;
			if count>bufsize then
				begin
					werror:=true;
					bwrite:=true;
					exit
				end;
			bwrite:=false;
			if count<1 then
				begin
					if count=0 then exit;
					if bufcnt>0 then
						begin
							if passmask<>0 then
								begin
									pb:=PByte(buf);
									for q:=0 to bufcnt-1 do
										begin
											pb^:=pb^ xor system.random(256);
											inc(longint(pb))
										end
								end;
							rlen:=fwrite(hdl,bufcnt,buf);
							if rlen<>bufcnt then
								begin
									werror:=true;
									bwrite:=true
								end;
							bufcnt:=0
						end;
					exit
				end;
			if bufcnt+count>bufsize then
				begin
					if passmask<>0 then
						begin
							pb:=PByte(buf);
							for q:=0 to bufcnt-1 do
								begin
									pb^:=pb^ xor system.random(256);
									inc(longint(pb))
								end
						end;
					rlen:=fwrite(hdl,bufcnt,buf);
					if rlen<>bufcnt then
						begin
							werror:=true;
							bwrite:=true
						end;
					bufcnt:=0
				end;
			move(buffer,buf^[bufcnt],count);
			inc(bufcnt,count)
		end;

	function savetree(pn: PNode): boolean;
		var q: integer;

		begin
			savetree:=true;
			if pn=nil then
				begin
					if bwrite(nctrl,2) then exit
				end
			else
				begin
					if bwrite(pn^.Typ,2) then exit;
					if pn^.Typ>=5000 then
						begin
							if pn^.Left.List=nil then
								begin
									if bwrite(lctrl,4) then exit
								end
							else
								begin
									if bwrite(pn^.Count,4) then exit;
									for q:=0 to pn^.Count-1 do
										if savetree(pn^.Left.List^[q]) then exit
								end
						end
					else
						if pn^.Typ>=1000 then
							begin
								if savetree(pn^.Left.Node) then exit;
								if savetree(pn^.Right.Node) then exit
							end
						else
							case pn^.Typ of
							NT_NEGATE,
							NT_KLAMMER:
								if savetree(pn^.Left.Node) then exit;
							NT_MINUS,
							NT_MULT,
							NT_DIV,
							NT_POWER,
							NT_EQUAL,
							NT_GREATER,
							NT_LESS,
							NT_GREATEREQUAL,
							NT_LESSEQUAL,
							NT_UNEQUAL,
							NT_PLUS:
								begin
									if savetree(pn^.Left.Node) then exit;
									if savetree(pn^.Right.Node) then exit
								end;
							NT_CELL:
								begin
									if bwrite(pn^.All,4) then exit;
									if bwrite(pn^.Right.Flg,2) then exit
								end;
							NT_RANGE:
								begin
									if bwrite(pn^.Left.All,4) then exit;
									if bwrite(pn^.Right.All,4) then exit;
									if bwrite(pn^.All,4) then exit
								end;
							NT_VARIABLE:
								if bwrite(pn^.Varb^,length(pn^.Varb^)+1) then exit;
							NT_CONST:
								begin
									rval:=pn^.Num^;
									if bwrite(rval,sizeof(real)) then exit;
									if pn^.Left.Txt=nil then
										begin
											l:=0;
											if bwrite(l,1) then exit
										end
									else
										if bwrite(pn^.Left.Txt^,length(pn^.Left.Txt^)+1) then exit
								end
							end
				end;
			savetree:=false
		end;

	function writecell: boolean;
	
		begin
			writecell:=true;
			if bwrite(coffs,2) then exit;
			case cell^.Typ of
			CTYPE_TEXT:
				begin
					if bwrite(cell^.Flags,CELLSIZE-4) then exit;
					if bwrite(cell^.Data.Txt^,length(cell^.Data.Txt^)+1) then exit
				end;
			CTYPE_CONST:
				begin
					if bwrite(cell^.Flags,CELLSIZE-4) then exit;
					with cell^.Data.Konst^ do
						begin
							rval:=Value;
							if bwrite(rval,sizeof(real)) then exit;
							if bwrite(Txt^,length(Txt^)+1) then exit;
							if bwrite(FPts,1) then exit
						end
				end;
			CTYPE_FORMULA:
				begin
					cell^.Typ:=CTYPE_PARSED;
					if bwrite(cell^.Flags,CELLSIZE-4) then
						begin
							cell^.Typ:=CTYPE_FORMULA;
							exit
						end;
					cell^.Typ:=CTYPE_FORMULA;
					with cell^.Data.Formula^ do
						begin
							rval:=Value;
							if bwrite(rval,sizeof(real)) then exit;
							if bwrite(FPts,1) then exit;
							if bwrite(Error,1) then exit;
							if savetree(Func) then exit;
							if VarDef=nil then
								begin
									l:=0;
									if bwrite(l,1) then exit
								end
							else
								if bwrite(VarDef^,length(VarDef^)+1) then exit
						end
				end
{				with cell^.Data.Formula^ do
					begin
						rval:=Value;
						if bwrite(rval,sizeof(real)) then exit;
						fn2:=p^.BuildFunction(cell,false);
						if bwrite(fn2,length(fn2)+1) then exit;
						if bwrite(FPts,1) then exit;
						if bwrite(Error,1) then exit
					end ... }
			else
				if bwrite(cell^.Flags,CELLSIZE-4) then exit
			end;
			writecell:=false;
			oldcell:=cell;
			coffs:=32768
		end;

	function pack_hor: boolean;
		label _write,_nextcell;
		var c: longint;

		begin
			pack_hor:=true;
			packsize:=0;
			cell:=p^.Sheet;
			oldcell:=nil;
			coffs:=0;
			for c:=0 to longint(p^.Parms.Rows)*longint(p^.Parms.Columns)+longint(p^.Parms.Rows)+longint(p^.Parms.Columns) do
				begin
					if p^.IsEmptyCell(cell) then
						begin
							if coffs>=32767 then
								begin
									if coffs=32768 then coffs:=1
									else
										goto _write
								end
							else
								inc(coffs)
						end
					else
						begin
							if coffs>=32768 then
								begin
									if IsCellEqual then
										begin
											if coffs=65534 then goto _write
											else
												begin
													inc(coffs);
													goto _nextcell
												end
										end
									else
										if coffs=32768 then coffs:=0
								end;
							_write:
							if writecell then exit
						end;
					_nextcell:
					inc(longint(cell),CELLSIZE)
				end;
			if coffs>32768 then
				begin
					if coffs=32769 then coffs:=0
					else
						dec(coffs);
					cell:=oldcell;
					if writecell then exit
				end;
			pack_hor:=false
		end;

	function pack_ver: boolean;
		label _write,_nextcell;
		var x,y,offs: longint;
		    ooc     : PCell;

		begin
			pack_ver:=true;
			packsize:=0;
			oldcell:=nil;
			offs:=longint(p^.Parms.Columns+1)*CELLSIZE;
			ooc:=p^.Sheet;
			coffs:=0;
			for x:=0 to longint(p^.Parms.Columns) do
				begin
					cell:=ooc;
					for y:=0 to longint(p^.Parms.Rows) do
						begin
							if p^.IsEmptyCell(cell) then
								begin
									if coffs>=32767 then
										begin
											if coffs=32768 then coffs:=1
											else
												goto _write
										end
									else
										inc(coffs)
								end
							else
								begin
									if coffs>=32768 then
										begin
											if IsCellEqual then
												begin
													if coffs=65534 then goto _write
													else
														begin
															inc(coffs);
															goto _nextcell
														end
												end
											else
												if coffs=32768 then coffs:=0
										end;
									_write:
									if writecell then exit
								end;
							_nextcell:
							inc(longint(cell),offs)
						end;
					inc(longint(ooc),CELLSIZE)
				end;
			if coffs>32768 then
				begin
					if coffs=32769 then coffs:=0
					else
						dec(coffs);
					cell:=oldcell;
					if writecell then exit
				end;
			pack_ver:=false
		end;

	begin
		p:=PCalcWindow(Parent);
		Save:=false;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				exit
			end;
		buf:=nil;
		embdirty:=false;
		pe:=p^.Embedded;
		while pe<>nil do
			begin
				if pe^.IsDirty then
					begin
						embdirty:=true;
						break
					end;
				pe:=pe^.Next
			end;
		if embdirty then
			if Application^.Alert(p,1,WAIT,MESSAGE_SAVE_EMBEDDED,BUTTON_SAVECANCEL)<>1 then goto _raus;
		BusyMouse;
		buf:=GetMemBuffer(131072,512,bufsize);
		if buf=nil then
			begin
				Application^.Alert(p,1,STOP,MESSAGE_SAVE_MEMORY,BUTTON_OK);
				goto _raus
			end;
		werror:=false;
		if TexelApp.setupbuffer.bak=bf_Checked then
			if Exist(fname) then
				begin
					if TexelApp.IsLongFileName(fname) then fn2:=fname+'.bak'
					else
						fn2:=GetPath(fname)+GetFilename(fname,false)+'.bak';
					if Exist(fn2) then fdelete(fn2);
					frename(fname,fn2);
					TexelApp.UpdateFile(fn2,0)
				end;
		res:=fcreate(fname,0);
		if res<0 then
			begin
				Application^.Alert(p,1,STOP,MESSAGE_SAVE_WPROT,BUTTON_OK);
				goto _raus
			end;
		hdl:=integer(res);
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				goto _unreg
			end;
		{$IFNDEF DEMO}
		test:=true;
		pack_hor;
		hsize:=packsize;
		pack_ver;
		vsize:=packsize;
		test:=false;
		bufcnt:=0;
		nctrl:=NT_ENDOFDATA;
		lctrl:=NT_LIST_EMPTY;
		passmask:=0;
		with header do
			begin
				Magic:=TEXELMAGIC;
				Version:=TEXELVER;
				Compatible:=TEXELCOMPAT;
				if hsize>vsize then PackAlgo:=PA_VERTICAL
				else
					PackAlgo:=PA_HORIZONTAL;
				Resvd1:=0;
				Resvd2:=0;
				Resvd3:=0;
				Resvd4:=0
			end;
		header.Release:=RELEASE;
		if bwrite(header,sizeof(TTexelHeader)) then goto _unreg;
		fillchar(head2,sizeof(head2),0);
		if p^.infobuf.Encrypt=bf_Checked then head2.CryptFlag:=1;
		head2.RSeed:=randseed xor p^.PassWord.Mask;
		head2.PassFlag:=p^.PassWord.Flag;
		head2.PassCode:=p^.PassWord.Code;
		if bwrite(head2,sizeof(TTexelHead2)) then goto _unreg;
		bwrite(dummy,-1);
		coffs:=0;
		pe:=p^.Embedded;
		while pe<>nil do
			begin
				inc(coffs);
				pe:=pe^.Next
			end;
		if bfwrite(coffs,2) then goto _unreg;
		if coffs>0 then
			begin
				pe:=p^.Embedded;
				while pe<>nil do
					begin
						objtyp:=pe^.GetType;
						if bfwrite(objtyp,2) then goto _unreg;
						if pe^.Filename<>nil then
							begin
								if bfwrite(pe^.Filename^,length(pe^.Filename^)+1) then goto _unreg
							end
						else
							begin
								dummy:=0;
								if bfwrite(dummy,1) then goto _unreg
							end;
						if pe^.IsEmbedded then dummy:=pe^.DataLen
						else
							dummy:=0;
						if bfwrite(dummy,4) then goto _unreg;
						if dummy>0 then
							if bfwrite(pe^.Data^,dummy) then goto _unreg;
						if bfwrite(pe^.oabuf,sizeof(pe^.oabuf)) then goto _unreg;
						if bfwrite(pe^.XPos_mm100,4) then goto _unreg;
						if bfwrite(pe^.YPos_mm100,4) then goto _unreg;
						if bfwrite(pe^.Width_mm100,4) then goto _unreg;
						if bfwrite(pe^.Height_mm100,4) then goto _unreg;
						prp:=pe^.IsProportional;
						if bfwrite(prp,sizeof(boolean)) then goto _unreg;
						if bfwrite(pe^.embedflag,sizeof(boolean)) then goto _unreg;
						prp:=pe^.CanPrint;
						if bfwrite(prp,sizeof(boolean)) then goto _unreg;
						prp:=pe^.IsLocked;
						if bfwrite(prp,sizeof(boolean)) then goto _unreg;
						case objtyp of
						1:
							if bfwrite(PEmbeddedIMG(pe)^.skalieren,sizeof(boolean)) then goto _unreg;
						2:
							begin
								if bfwrite(PEmbeddedText(pe)^.umbruch,sizeof(boolean)) then goto _unreg;
								if bfwrite(PEmbeddedText(pe)^.txOffs,2) then goto _unreg;
								if bfwrite(PEmbeddedText(pe)^.tyOffs,2) then goto _unreg
							end;
						3:
							begin
								if bfwrite(PEmbeddedTAD(pe)^.dbvalid,sizeof(boolean)) then goto _unreg;
								if PEmbeddedTAD(pe)^.dbvalid then
									if bfwrite(PEmbeddedTAD(pe)^.diabuf,sizeof(TDiagrammBuf)) then goto _unreg
							end
						end;
						pe:=pe^.Next
					end
			end;
		if p^.infobuf.Encrypt=bf_Checked then passmask:=1;
		oldtb:=p^.TransferBuffer;
		p^.TransferBuffer:=@newtb;
		p^.TransferData(tf_GetData);
		p^.TransferBuffer:=oldtb;
		if not(p^.IsIconified) then p^.GetCurr;
		p^.Parms.CurrSize:=p^.Curr;
		p^.Parms.ScrlXPos:=p^.Scroller^.XPos;
		p^.Parms.ScrlYPos:=p^.Scroller^.YPos;
		if p^.Class.ToolbarTree<>nil then p^.Parms.Toolbar:=bf_Checked
		else
			p^.Parms.Toolbar:=bf_Unchecked;
		newtb.border:=0; { ... }
		newtb.resvd1:=0;
		newtb.resvd2:=0;
		newtb.resvd3:=0;
		newtb.resvd4:=0;
		newtb.font:=p^.GetFontIndex;
		newtb.size:=p^.GetFontSize;
		newsb:=p^.sheetbuffer;
		newsb.font:=p^.GetStdFontIndex;
		newsb.size:=p^.GetStdFontSize;
		if bwrite(p^.Parms,sizeof(TTexelParms)) then goto _unreg;
		if bwrite(newtb,sizeof(TDialogBuffer)) then goto _unreg;
		if bwrite(newsb.font,sizeof(TSheetBuffer)-10) then goto _unreg;
		if bwrite(p^.zwbuf,sizeof(TZielBuf)) then goto _unreg;
		if bwrite(p^.diagrammbuf,sizeof(TDiagrammBuf)) then goto _unreg;
		if bwrite(p^.exportbuf,sizeof(TExportBuf)) then goto _unreg;
		if bwrite(p^.sortbuf,sizeof(TSortBuf)) then goto _unreg;
		if bwrite(p^.infobuf,sizeof(TInfoBuf)-4) then goto _unreg;
		if bwrite(p^.findbuf,sizeof(TFindBuf)) then goto _unreg;
		if bwrite(p^.replacebuf,sizeof(TReplaceBuf)) then goto _unreg;
		if bwrite(p^.fillbuf,sizeof(TFillBuffer)) then goto _unreg;
		coffs:=0;
		if bwrite(coffs,2) then goto _unreg;
		if bwrite(p^.PRow^,(p^.Parms.Rows+1) shl 1) then goto _unreg;
		if bwrite(p^.PCol^,(p^.Parms.Columns+1) shl 1) then goto _unreg;
		l:=0;
		for q:=0 to p^.Parms.Columns do
			begin
				if p^.PColNames^[q]<>nil then
					begin
						if bwrite(PString(p^.PColNames^[q])^,length(PString(p^.PColNames^[q])^)+1) then goto _unreg
					end
				else
					if bwrite(l,1) then goto _unreg
			end;
		if bwrite(p^.PRowFlags^,p^.Parms.Rows+1) then goto _unreg;
		if bwrite(p^.PColFlags^,p^.Parms.Columns+1) then goto _unreg;
		if header.PackAlgo=PA_VERTICAL then
			begin
				if pack_ver then goto _unreg
			end
		else
			if pack_hor then goto _unreg;
		coffs:=65535;
		if bwrite(coffs,2) then goto _unreg;
		if p^.Parameter<>nil then coffs:=p^.Parameter^.Count
		else
			coffs:=0;
		if bwrite(coffs,2) then goto _unreg;
		l:=0;
		if coffs>0 then
			for q:=0 to coffs-1 do
				begin
					pp:=p^.Parameter^.At(q);
					if pp^.Name<>nil then
						begin
							if bwrite(pp^.Name^,length(pp^.Name^)+1) then goto _unreg
						end
					else
						if bwrite(l,1) then goto _unreg;
					if pp^.Txt<>nil then
						begin
							if bwrite(pp^.Txt^,length(pp^.Txt^)+1) then goto _unreg
						end
					else
						if bwrite(l,1) then goto _unreg;
					if pp^.Descr<>nil then
						begin
							if bwrite(pp^.Descr^,length(pp^.Descr^)+1) then goto _unreg
						end
					else
						if bwrite(l,1) then goto _unreg
				end;
		if p^.UsrFormats<>nil then coffs:=p^.UsrFormats^.Count
		else
			coffs:=0;
		if bwrite(coffs,2) then goto _unreg;
		l:=0;
		if coffs>0 then
			for q:=0 to coffs-1 do
				begin
					pfm:=p^.UsrFormats^.At(q);
					if bwrite(pfm^.Index,2) then goto _unreg;
					if pfm^.Name<>nil then
						begin
							if bwrite(pfm^.Name^,length(pfm^.Name^)+1) then goto _unreg
						end
					else
						if bwrite(l,1) then goto _unreg
				end;
		if p^.BlockHistory<>nil then coffs:=p^.BlockHistory^.Count
		else
			coffs:=0;
		if bwrite(coffs,2) then goto _unreg;
		l:=0;
		if coffs>0 then
			for q:=0 to coffs-1 do
				begin
					ps:=p^.BlockHistory^.At(q);
					if ps<>nil then
						begin
							if bwrite(ps^,length(ps^)+1) then goto _unreg
						end
					else
						if bwrite(l,1) then goto _unreg
				end;
		dummy:=0;
		if p^.wnd_prnt_set<>nil then
			if p^.wnd_prnt_set^.magic='pset' then dummy:=p^.wnd_prnt_set^.len;
		if bwrite(dummy,4) then goto _unreg;
		if dummy>0 then
			if bwrite(p^.wnd_prnt_set^,dummy) then goto _unreg;
		if bwrite(p^.prnRangeFlag,2) then goto _unreg;
		coffs:=p^.pfbox^.List^.Count;
		if bwrite(coffs,2) then goto _unreg;
		l:=0;
		if coffs>0 then
			for q:=0 to coffs-1 do
				begin
					pf:=PFont(p^.pfbox^.List^.At(q));
					if pf^.Name<>nil then
						begin
							fn2:=StrPTrimF(pf^.Name^);
							if bwrite(fn2,length(fn2)+1) then goto _unreg
						end
					else
						if bwrite(l,1) then goto _unreg;
					if bwrite(pf^.Index,2) then goto _unreg
				end;
		coffs:=0;
		if bwrite(coffs,2) then goto _unreg;
		coffs:=0;
		if bwrite(coffs,2) then goto _unreg;
		if bwrite(coffs,2) then goto _unreg;
		bwrite(dummy,-1);
		p^.infobuf.Version:=TEXELVER;
		p^.infobuf.Release:=RELEASE;
		Save:=true;
		TexelApp.UpdateFile(fname,-p^.GetOLGAGroup-1);
		{$ENDIF}
		_unreg:
		fclose(hdl);
		if werror then
			begin
				fdelete(fname);
				Application^.Alert(p,1,STOP,MESSAGE_SAVE_DISKFULL,BUTTON_OK)
			end
		else
			begin
				p^.ClearDirty;
			end;
		_raus:
		if buf<>nil then freemem(buf,bufsize);
		ArrowMouse
	end;


constructor TAbruf.Init(AParent: PEventObject; mNum,popTree,popIndex: integer);

	begin
		if not(inherited Init(AParent,mNum,popTree,popIndex)) then fail;
		Disable;
		Count:=0;
		Dirty:=false;
		fillchar(Files,sizeof(Files),0);
		with Popup^.PopTree^[ROOT] do
			begin
				cpw:=ob_width div 40;
				cph:=ob_height div 10
			end
	end;


procedure TAbruf.HandleMenu(Indx: integer);

	begin
		if (Indx<0) or (Indx>=Count) or (TexelApp.opennewdoc=nil) then exit;
		if Files[Indx]<>nil then TexelApp.LoadFile(nil,Files[Indx]^)
	end;


procedure TAbruf.Add(fname: string; dodhst: boolean);
	label _dhst;
	
	var ps      : PString;
	    q,w,ml  : integer;
	    dhstid  : longint;
	    pipe    : Pipearray;
	    dhstinfo: PDHSTInfo;
	    oldfname: string;

	begin
		if length(fname)=0 then exit;
		CorrectPath(fname);
		oldfname:=fname;
		ps:=NewStr(fname);
		if ps=nil then goto _dhst;
		Dirty:=true;
		if Count>0 then
			begin
				ml:=-1;
				fname:=StrPUpper(fname);
				for q:=0 to Count-1 do
					if StrPUpper(Files[q]^)=fname then
						begin
							ml:=q;
							break
						end;
				if ml>=0 then
					begin
						DisposeStr(Files[ml]);
						if ml<9 then
							for q:=ml to 8 do Files[q]:=Files[q+1];
						dec(Count);
						Files[9]:=nil
					end
			end;
		if Count=10 then DisposeStr(Files[9]);
		for q:=9 downto 1 do Files[q]:=Files[q-1];
		Files[0]:=ps;
		if Count<10 then inc(Count);
		ml:=0;
		for q:=0 to Count-1 do
			if length(Files[q]^)>ml then ml:=length(Files[q]^);
		if ml>37 then ml:=37;
		with Popup^ do
			begin
				PopTree^[ROOT].ob_height:=cph*Count;
				PopTree^[ROOT].ob_width:=cpw*(ml+3);
				w:=PopTree^[ROOT].ob_head;
				for q:=0 to Count-1 do
					begin
						PopTree^[w].ob_flags:=PopTree^[w].ob_flags and not(HIDETREE);
						PopTree^[w].ob_width:=PopTree^[ROOT].ob_width;
						StrPCopy(PopTree^[w].ob_spec.free_string,'  '+CompressPath(Files[q]^,ml)+' ');
						w:=PopTree^[w].ob_next
					end;
				if Count<10 then
					for q:=Count to 9 do
						begin
							PopTree^[w].ob_flags:=PopTree^[w].ob_flags or HIDETREE;
							w:=PopTree^[w].ob_next
						end
			end;
		Enable;
		_dhst:
		if dodhst and (Application^.apPath<>nil) then
			if GetCookie('DHST',dhstid) then
				begin
					dhstid:=dhstid and $0000ffff;
					if dhstid>=0 then
						begin
							GlobalAlloc(pointer(dhstinfo),1024+sizeof(TDHSTInfo));
							if dhstinfo<>nil then
								begin
									dhstinfo^.AppName:=PChar(longint(dhstinfo)+sizeof(TDHSTInfo));
									dhstinfo^.AppPath:=PChar(longint(dhstinfo)+sizeof(TDHSTInfo)+256);
									dhstinfo^.DocName:=PChar(longint(dhstinfo)+sizeof(TDHSTInfo)+512);
									dhstinfo^.DocPath:=PChar(longint(dhstinfo)+sizeof(TDHSTInfo)+768);
									strpcopy(dhstinfo^.AppName,TEXELNAME);
									strpcopy(dhstinfo^.AppPath,Application^.apPath^+TEXELAPPNAME);
									strpcopy(dhstinfo^.DocName,GetFilename(oldfname,true));
									strpcopy(dhstinfo^.DocPath,oldfname);
									pipe[0]:=DHST_ADD;
									pipe[1]:=Application^.apID;
									pipe[2]:=0;
									pipe[3]:=integer(HiWord(dhstinfo));
									pipe[4]:=integer(LoWord(dhstinfo));
									pipe[5]:=0;
									pipe[6]:=0;
									pipe[7]:=0;
									appl_write(dhstid,16,@pipe)
								end
						end
				end
	end;


procedure TImport.HandleMenu(Indx: integer);

	begin
		case Indx of
		0:
			ImportFromClipboard;
		2:
			if XFileSelect(nil,FSELTITLE_IMPORTLDW,'*.ldp',TexelApp.LastPath[9],TexelApp.LastFile[9],0,FSEL_LOADLDW,true,false) then LoadLDW(TexelApp.LastPath[9]+TexelApp.LastFile[9]);
		3:
			if XFileSelect(nil,FSELTITLE_IMPORTDIF,'*.dif',TexelApp.LastPath[2],TexelApp.LastFile[2],0,FSEL_LOADDIF,true,false) then LoadDIF(TexelApp.LastPath[2]+TexelApp.LastFile[2]);
		4:
			if XFileSelect(nil,FSELTITLE_IMPORTCSV,'*.csv',TexelApp.LastPath[4],TexelApp.LastFile[4],0,FSEL_LOADCSV,true,false) then LoadCSV(TexelApp.LastPath[4]+TexelApp.LastFile[4]);
		5:
			if XFileSelect(nil,FSELTITLE_IMPORTASCII,'*.txt',TexelApp.LastPath[6],TexelApp.LastFile[6],1,FSEL_LOADASCII,true,false) then LoadASCII(TexelApp.LastPath[6]+TexelApp.LastFile[6]);
		6:
			if XFileSelect(nil,FSELTITLE_IMPORTDBASE,'*.dbf',TexelApp.LastPath[12],TexelApp.LastFile[12],0,FSEL_LOADDBF,true,false) then LoadGDBC(TexelApp.LastPath[12]+TexelApp.LastFile[12]);
		8:
			if XFileSelect(nil,FSELTITLE_IMPORTEXCEL,'*.xls',TexelApp.LastPath[7],TexelApp.LastFile[7],0,FSEL_LOADXLS,true,false) then LoadXLS(TexelApp.LastPath[7]+TexelApp.LastFile[7]);
		9:
			if XFileSelect(nil,FSELTITLE_IMPORT123,'*.wk?',TexelApp.LastPath[10],TexelApp.LastFile[10],0,FSEL_LOAD123,true,false) then Load123(TexelApp.LastPath[10]+TexelApp.LastFile[10])
		end
	end;


function TImportBox.CreatePopup: boolean;

	begin
		CreatePopup:=inherited CreatePopup;
		if Popup<>nil then Popup^.AutoCheck:=false
	end;


procedure TImportRowColBox.SetValue(Sel: integer);

	begin
		if Popup=nil then exit;
		case Sel of
		0:
			SetText('13,10');
		1:
			SetText('13');
		2:
			SetText('10')
		else
			SetText('')
		end
	end;


procedure TImportCellBox.SetValue(Sel: integer);

	begin
		if Popup=nil then exit;
		case Sel of
		0:
			SetText('9');
		1:
			SetText('32');
		2:
			SetText('44');
		3:
			SetText('59')
		else
			SetText('')
		end
	end;


procedure TImportTextBox.SetValue(Sel: integer);

	begin
		if Popup=nil then exit;
		case Sel of
		0:
			SetText('34');
		1:
			SetText('39')
		else
			SetText('')
		end
	end;


procedure TImportButton.Changed(AnIndx: integer; DblClick: boolean);
	var txt: string;

	begin
		if Parent^.Parent=nil then
			begin
				if AnIndx=RTAIHOR then txt:=STRING_ROWDIV+':'#0
				else
					txt:=STRING_COLDIV+':'#0
			end
		else
			begin
				if AnIndx=RTEXASCIIHOR then txt:=STRING_ROWDIV+':'#0
				else
					txt:=STRING_COLDIV+':'#0
			end;
		pircb^.SetTitle(txt)
	end;


function TASCIIImportDialog.OK: boolean;
	var valid: boolean;
	    s    : string;

	begin
		valid:=inherited OK;
		if valid then
			if Parent=nil then
				with TexelApp do
					begin
						s:=StrPTrimF(pcb^.GetText);
						import^.ImportASCII(import^.filename,TexelApp.num2str(ascbuf.rcTxt),TexelApp.num2str(ascbuf.cellTxt),TexelApp.num2str(ascbuf.textTxt),s[1],ascbuf.hor=bf_Checked,ascbuf.quote=bf_Checked,ascbuf.filter)
					end;
		OK:=valid
	end;


procedure TImport.LoadASCII(fname: string);
	var pib1,
	    pib2: PImportButton;
	    pv  : PValidator;
	    picb: PImportCellBox;
	    pb  : PButton;
	    i   : integer;
	    flt : PStringCollection;

	begin
		filename:=fname;
		if ascii=nil then
			begin
				new(ascii,Init(nil,TEXELWINDPREFIX+TITLE_IMPORTASCII,STG_IMPORTASCII,ICNTITLE_IMPORTASCII,RTASCIIIMPORT));
				if ascii<>nil then
					begin
						new(st,Init(ascii,RTAIDATEI,41,true,BUBBLE_IMPASC_FILE));
						new(PGroupBox,Init(ascii,RTAIROWS,GROUP_GENERAL_ROWS,BUBBLE_IMPASC_ROWS));
						new(pib1,Init(ascii,RTAIHOR,true,BUBBLE_IMPASC_HOR));
						new(pib2,Init(ascii,RTAIVERT,true,BUBBLE_IMPASC_VERT));
						new(pib1^.pircb,Init(ascii,RTAIROWCOL,RTAIRCCYC,RTAIRCTITLE,RTPOPUPS,RTPAIROWCOL,id_No,false,true,BUBBLE_IMPASC_LINEEND));
						pib2^.pircb:=pib1^.pircb;
						if pib1^.pircb<>nil then
							if pib1^.pircb^.Edit<>nil then
								begin
									new(pv,Init);
									if pv<>nil then pv^.Options:=voNotEmpty;
									pib1^.pircb^.Edit^.SetValidator(pv)
								end;
						new(picb,Init(ascii,RTAICELLS,RTAICCYC,RTAICTITLE,RTPOPUPS,RTPAICELLS,id_No,false,true,BUBBLE_IMPASC_CELLDIV));
						if picb<>nil then
							if picb^.Edit<>nil then
								begin
									new(pv,Init);
									if pv<>nil then pv^.Options:=voNotEmpty;
									picb^.Edit^.SetValidator(pv)
								end;
						new(PImportTextBox,Init(ascii,RTAITEXT,RTAITCYC,RTAITTITLE,RTPOPUPS,RTPAITEXT,id_No,false,true,BUBBLE_IMPASC_QUOTECHAR));
						new(PCheckBox,Init(ascii,RTAIQUOTE,true,BUBBLE_IMPASC_QUOTING));
						new(ascii^.pcb,Init(ascii,RTAINUMBER,RTAINCYC,RTAINTITLE,RTPOPUPS,RTPAINUMBERS,id_No,true,false,BUBBLE_IMPASC_FPOINT));
						new(flt,Init(10,5));
						if flt<>nil then
							begin
								flt^.Sort:=false;
								if InitKeyTab then
									for i:=0 to pkt^.GetImportCount do flt^.Insert(NewStr('  '+StrPPas(pkt^.GetImportName(nil,nil,0,0,0,i))+' '#0))
								else
									flt^.Insert(NewStr('  Atari '#0))
							end;
						new(PComboBox,InitCollection(ascii,RTAIFILTER,RTAIFCYC,RTAIFTITLE,20,flt,true,true,false,BUBBLE_IMPASC_FILTER));
						new(pb,Init(ascii,RTAIHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ascii,RTAIABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ascii,RTAIOK,id_OK,true,BUBBLE_IMPASC_OK));
						ascii^.TransferBuffer:=@TexelApp.ascbuf;
						if TexelApp.ascbuf.hor=bf_Checked then pib1^.Changed(RTAIHOR,false)
						else
							pib2^.Changed(RTAIVERT,false)
					end
			end;
		if ascii<>nil then
			begin
				if st<>nil then st^.SetText(CompressPath(fname,40));
				ascii^.MakeWindow
			end
	end;


function TGDBCDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then import^.ImportDBF(import^.quelle,lb2^.List);
		OK:=valid
	end;


function TGDBCDialog.ExitDlg(AnIndx: integer): boolean;
	var sel: integer;

	begin
		ExitDlg:=false;
		case AnIndx of
		RTGDIMPORT:
			begin
				sel:=lb1^.GetSelection;
				if sel<0 then exit;
				lb2^.List^.Insert(lb1^.List^.At(sel));
				lb1^.List^.AtDelete(sel);
				lb1^.SetCollection(lb1^.List);
				lb2^.SetCollection(lb2^.List);
				lb1^.SetSelection(sel);
				lb2^.SetSelection(lb2^.List^.Count-1);
				CheckButtons
			end;
		RTGDIGNORE:
			begin
				sel:=lb2^.GetSelection;
				if sel<0 then exit;
				lb1^.List^.Insert(lb2^.List^.At(sel));
				lb2^.List^.AtDelete(sel);
				lb1^.SetCollection(lb1^.List);
				lb2^.SetCollection(lb2^.List);
				lb1^.SetSelection(lb1^.List^.Count-1);
				lb2^.SetSelection(sel);
				CheckButtons
			end;
		RTGDALL:
			begin
				while lb1^.List^.Count>0 do
					begin
						lb2^.List^.Insert(lb1^.List^.At(0));
						lb1^.List^.AtDelete(0)
					end;
				lb1^.SetCollection(lb1^.List);
				lb2^.SetCollection(lb2^.List);
				lb2^.SetSelection(lb2^.List^.Count-1);
				CheckButtons
			end;
		RTGDNONE:
			LoadFields(lb1)
		end
	end;


procedure TGDBCDialog.CheckButtons;

	begin
		if lb1^.List^.Count=0 then
			begin
				pb1^.Disable;
				pb3^.Disable
			end
		else
			begin
				pb1^.Enable;
				pb3^.Enable
			end;
		if lb2^.List^.Count=0 then
			begin
				pb2^.Disable;
				pb4^.Disable;
				pb0^.Disable
			end
		else
			begin
				pb2^.Enable;
				pb4^.Enable;
				pb0^.Enable
			end
	end;


procedure TGDBCDialog.LoadFields(lb: PListBox);
	var txt : string;
	    pxb : PXBase;
	    pxbf: PXBField;
	    anz : longint;

	begin
		lb1^.List^.FreeAll;
		lb1^.List^.Sort:=false;
		lb2^.List^.FreeAll;
		lb2^.List^.Sort:=false;
		anz:=0;
		BusyMouse;
		new(pxb,InitFile(import^.quelle));
		if pxb<>nil then
			begin
				anz:=pxb^.GetMaxRecords;
				pxbf:=pxb^.Fields;
				while pxbf<>nil do
					begin
						lb^.List^.Insert(NewStr('  '+StrPLeft(pxbf^.GetName,18)+#0));
						pxbf:=pxbf^.Next
					end;
				dispose(pxb,Done)
			end;
		ArrowMouse;
		if length(import^.quelle)=0 then
			begin
				if st<>nil then st^.SetText(STRING_DB_SOURCE+': ['+STRING_DB_EMPTY+']')
			end
		else
			begin
				txt:='" ('+ltoa(anz)+' '+STRING_DB_RECORDS+')';
				if st<>nil then st^.SetText(STRING_DB_SOURCE+': "'+CompressPath(import^.quelle,52-length(txt))+txt)
			end;
		lb1^.SetCollection(lb1^.List);
		lb2^.SetCollection(lb2^.List);
		CheckButtons
	end;


procedure TImport.LoadGDBC(fname: string);
	var pb: PButton;

	begin
		quelle:=fname;
		if gdbc=nil then
			begin
				TexelApp.ActivateExtResource;
				new(gdbc,Init(nil,TEXELWINDPREFIX+TITLE_IMPORTGDBC,STG_IMPORTGDBC,ICNTITLE_IMPORTGDBC,RTGDBC));
				if gdbc<>nil then
					begin
						gdbc^.import:=@self;
						new(gdbc^.st,Init(gdbc,RTGDSOURCE,63,true,BUBBLE_IMPDB_SOURCE));
						new(gdbc^.pb1,Init(gdbc,RTGDIMPORT,id_No,true,BUBBLE_IMPDB_IMPORT));
						new(gdbc^.pb2,Init(gdbc,RTGDIGNORE,id_No,true,BUBBLE_IMPDB_IGNORE));
						new(gdbc^.pb3,Init(gdbc,RTGDALL,id_No,true,BUBBLE_IMPDB_ALL));
						new(gdbc^.pb4,Init(gdbc,RTGDNONE,id_No,true,BUBBLE_IMPDB_NONE));
						new(gdbc^.lb1,Init(gdbc,RTGDIGNORELIST,RTGDIGNSLID,RTGDIGNDEC,RTGDIGNINC,new(PStringCollection,Init(20,10)),true,BUBBLE_IMPDB_IGNORELIST));
						new(gdbc^.lb2,Init(gdbc,RTGDIMPORTLIST,RTGDIMPSLID,RTGDIMPDEC,RTGDIMPINC,new(PStringCollection,Init(20,10)),true,BUBBLE_IMPDB_IMPORTLIST));
						new(pb,Init(gdbc,RTGDHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(gdbc,RTGDABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(gdbc^.pb0,Init(gdbc,RTGDOK,id_OK,true,BUBBLE_IMPDB_OK))
					end;
				TexelApp.DeactivateExtResource
			end;
		if gdbc<>nil then
			begin
				gdbc^.LoadFields(gdbc^.lb2);
				gdbc^.MakeWindow
			end
	end;


procedure TImport.ImportDBF(fname: string; fields: PStringCollection);
	label _raus,_error;

	var pxb      : PXBase;
	    pxbf     : PXBField;
	    pg       : PProgressWindow;
	    dummy,
	    cmax,
	    rmax,
	    loffs,
	    sze,q    : longint;
	    w,ww,sf,
	    fldmax,sg: integer;
	    sheet,
	    cell     : PCell;
			prow,
			pcol     : PWordArray;
			pfldindx : PIntegerArray;
			pcolnames: PItemList;
			ttxt     : string;
			error    : boolean;
			fp       : byte;

	begin
		if length(fname)=0 then exit;
		BusyMouse;
		new(pxb,InitFile(fname));
		if pxb=nil then
			begin
				ArrowMouse;
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_LOAD1+CompressPath(fname,78)+MESSAGE_IMPORT_LOAD2,BUTTON_OK);
				exit
			end;
		new(pg,Init(0,TITLE_IMPORT,fname));
		pfldindx:=nil;
		fldmax:=pxb^.GetMaxFields;
		rmax:=Max(pxb^.GetMaxRecords,2);
		if rmax>16384 then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_DBSIZE,BUTTON_OK);
				if pg<>nil then dispose(pg,Done);
				goto _raus
			end;
		if fields<>nil then
			if fields^.Count>0 then fldmax:=fields^.Count;
		getmem(pfldindx,fldmax shl 1);
		if pfldindx=nil then
			begin
				if pg<>nil then dispose(pg,Done);
				TexelApp.ErrorWindowMemory(nil);
				goto _raus
			end;
		for w:=0 to fldmax-1 do pfldindx^[w]:=w;
		if fields<>nil then
			if fields^.Count>0 then
				for w:=0 to fldmax-1 do
					begin
						q:=0;
						pxbf:=pxb^.Fields;
						while pxbf<>nil do
							begin
								if pxbf^.GetName=StrPTrimF(PString(fields^.At(w))^) then break;
								inc(q);
								pxbf:=pxbf^.Next
							end;
						pfldindx^[w]:=q
					end;
		cmax:=Max(fldmax,2);
		getmem(prow,rmax shl 1);
		getmem(pcol,cmax shl 1);
		getmem(pcolnames,cmax shl 2);
		loffs:=cmax*CELLSIZE;
		dummy:=rmax*loffs;
		getmem(sheet,dummy);
		if (prow=nil) or (pcol=nil) or (sheet=nil) or (pcolnames=nil) then
			begin
				if prow<>nil then freemem(prow,rmax shl 1);
				if pcol<>nil then freemem(pcol,cmax shl 1);
				if pcolnames<>nil then freemem(pcolnames,cmax shl 2);
				if sheet<>nil then freemem(sheet,dummy);
				if pg<>nil then dispose(pg,Done);
				TexelApp.ErrorWindowMemory(nil);
				goto _raus
			end;
		if pg<>nil then pg^.SetMax(pxb^.GetMaxRecords shl 1);
		fillchar(pcolnames^,cmax shl 2,0);
		fillchar(sheet^,dummy,0);
		with TexelApp do
			begin
				vst_font(vdiHandle,GetStdFontIndex);
				if SpeedoActive then vst_arbpt(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
				else
					vst_point(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight);
				if vqt_width(vdiHandle,ord('9'),ww,w,w)<>ord('9') then ww:=Attr.charWidth;
				SetSystemFont(vdiHandle,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
			end;
		sze:=Max(Min(round(longint(ww)*atol(TexelApp.setupbuffer.stdcolwidth)*longint(Application^.Attr.PixW)/10.0),65535),0);
		for q:=0 to cmax-1 do pcol^[q]:=sze;
		TexelApp.InitCells(sheet,rmax,cmax);
		for w:=0 to fldmax-1 do
			begin
				pxbf:=pxb^.GetFieldByNumber(pfldindx^[w]);
				if pxbf<>nil then
					begin
						pcolnames^[w]:=NewStr(pxbf^.GetName);
						pcol^[w]:=Max(Min(round(longint(ww)*longint(pxbf^.GetLength)*longint(Application^.Attr.PixW)/10.0),65535),0)
					end
			end;
		sf:=TexelApp.GetStdFontIndex;
		sg:=TexelApp.GetStdFontSize;
		fp:=atol(TexelApp.setupbuffer.floatpoint);
		error:=false;
		for q:=1 to pxb^.GetMaxRecords do
			begin
				cell:=PCell(longint(sheet)+q*loffs-loffs);
				if not(pxb^.GetRecord) then
					begin
						error:=(q=1);
						goto _error
					end;
				if pg<>nil then pg^.Progress(1);
				for w:=0 to fldmax-1 do
					begin
						pxbf:=pxb^.GetFieldByNumber(pfldindx^[w]);
						if pxbf<>nil then
							case pxbf^.GetType of
							'C':
								begin
									ttxt:=pxbf^.GetString;
									if length(ttxt)>0 then
										begin
											cell^.Data.Txt:=NewStr(ttxt);
											if cell^.Data.Txt<>nil then
												begin
													cell^.Typ:=CTYPE_TEXT;
													cell^.TxtVal.Font:=sf;
													cell^.TxtVal.Size:=sg
												end
										end
								end;
							'N','F':
								begin
									new(cell^.Data.Konst);
									if cell^.Data.Konst<>nil then
										begin
											cell^.Typ:=CTYPE_CONST;
											cell^.TxtVal.Font:=sf;
											cell^.TxtVal.Size:=sg;
											cell^.TxtVal.Align:=TA_RIGHT;
											with cell^.Data.Konst^ do
												begin
													Txt:=NewStr(pxbf^.GetString);
													Value:=pxbf^.GetNumber;
													FPts:=pxbf^.GetFloatpt
												end
										end
								end;
							'L':
								begin
									if pxbf^.GetLogical=xb_True then ttxt:='='+STRING_TRUE
									else
										ttxt:='='+STRING_FALSE;
									new(cell^.Data.Formula);
									if cell^.Data.Formula<>nil then
										begin
											cell^.Typ:=CTYPE_FORMULA;
											with cell^.Data.Formula^ do
												begin
													Value:=0.0;
													FPts:=0;
													Error:=FE_OK;
													VarDef:=NewStr(ttxt);
													Func:=nil;
													cell^.TxtVal.Font:=sf;
													cell^.TxtVal.Size:=sg;
													cell^.TxtVal.Align:=TA_RIGHT
												end
										end
								end;
							'D':
								begin
									cell^.Typ:=CTYPE_TEXT;
									cell^.Data.Txt:=NewStr(pxbf^.GetDate);
									{ ... }
									cell^.TxtVal.Font:=sf;
									cell^.TxtVal.Size:=sg
								end
							end;
						inc(longint(cell),CELLSIZE)
					end
			end;
		_error:
		if error then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_LOAD1+CompressPath(fname,78)+MESSAGE_IMPORT_LOAD2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done)
			end
		else
			new(PCalcWindow,InitImport(pg,rmax-1,cmax-1,fname,sheet,prow,pcol,pcolnames,false));
		_raus:
		pxb^.Free;
		if pfldindx<>nil then freemem(pfldindx,fldmax shl 1);
		ArrowMouse
	end;


procedure TImport.Load123(fname: string);
	label _error,_errmsg,_raus;
	
	const WK_BOF            = $0000;
	      WK_EOF            = $0001;
	      WK_SAVE_RANGE     = $0006;
	      WK_WINDOW1        = $0007;
	      WK_COLUMN_WIDTH_1 = $0008;
	      WK_INTEGER        = $000d;
	      WK_NUMBER         = $000e;
	      WK_LABEL          = $000f;
	      WK_FORMULA        = $0010;
	      WK_WKS_PASSWORD   = $004b;

	var pg       : PProgressWindow;
	    buf      : PByteArray;
	    spos,q,
	    sze,
	    bufsize,
	    dummy,res,
	    stdcol,
	    rmax,cmax: longint;
	    sf,sg,
	    rowoffs,
	    coloffs,
	    hdl,w,ww : integer;
	    sheet,
	    cell     : PCell;
	    pb       : PByte;
			prow,
			pcol     : PWordArray;
			stack    : PStringCollection;
			pcolnames: PItemList;
			fp       : byte;
			ttxt     : string;
			ieee64   : double;
	    rec      : record
	    	opcode,
	    	len   : word
	    end;

	function bread(buffer: pointer; count: longint): boolean;

		begin
			if fread(hdl,count,buffer)=count then bread:=false
			else
				begin
					bread:=true;
					res:=-1
				end
		end;
	
	function readrecord: boolean;
	
		begin
			readrecord:=true;
			if bread(@rec,sizeof(rec)) then exit;
			rec.opcode:=swap(rec.opcode);
			rec.len:=swap(rec.len);
			if rec.len>0 then
				begin
					if rec.len>4096 then
						begin
							res:=-1;
							exit
						end;
					if bread(buf,rec.len) then exit
				end;
			readrecord:=false
		end;

	function getint(boffs: integer): integer;
	
		begin
			getint:=buf^[boffs] or (buf^[boffs+1] shl 8)
		end;

	function getcell(r,c: longint): PCell;
	
		begin
			getcell:=PCell(longint(sheet)+(r*cmax+c)*CELLSIZE)
		end;

	function GetColumnIndex(hsb,lsb: byte): string;
		var Nr,ofs: integer;

		begin
			if bTst(hsb,$80) then
				begin
					ofs:=coloffs;
					hsb:=hsb and $7f
				end
			else
				ofs:=0;
			Nr:=integer((word(hsb) shl 8) or word(lsb));
			if hsb=0 then
				begin
					if Nr>=128 then dec(Nr,256)
				end
			else
				if Nr>=8192 then dec(Nr,16384);
			inc(Nr,ofs);
			if Nr<0 then GetColumnIndex:='?'
			else
				if Nr<26 then GetColumnIndex:=chr(65+Nr)
				else
					GetColumnIndex:=chr(64+(Nr div 26))+chr(65+(Nr mod 26))
		end;

	function GetRowIndex(hsb,lsb: byte): string;
		var Nr,ofs: integer;

		begin
			if bTst(hsb,$80) then
				begin
					ofs:=rowoffs;
					hsb:=hsb and $7f
				end
			else
				ofs:=0;
			Nr:=integer((word(hsb) shl 8) or word(lsb));
			if Nr>=8192 then dec(Nr,16384);
			inc(Nr,ofs);
			if Nr<0 then GetRowIndex:='0'
			else
				GetRowIndex:=ltoa(Nr+1)
		end;

	function getformula: string;
		var txt,txt2: string;
		    foffs,i : integer;
		    fehler  : boolean;

		procedure push(s: string);
		
			begin
				stack^.AtInsert(0,NewStr(s))
			end;
		
		function pop: string;
		
			begin
				if stack^.Count>0 then
					begin
						pop:=PString(stack^.At(0))^;
						stack^.AtFree(0)
					end
				else
					begin
						pop:='';
						fehler:=true
					end
			end;
	
		begin
			foffs:=15;
			fehler:=false;
			stack^.FreeAll;
			while (buf^[foffs]<>$03) and not(fehler) do
				begin
					case buf^[foffs] of
					$00:
						begin
							pb:=@ieee64;
							for i:=foffs+8 downto foffs+1 do
								begin
									pb^:=buf^[i];
									inc(longint(pb))
								end;
							push(ftoa(ieee64));
							inc(foffs,9)
						end;
					$01:
						begin
							push(GetColumnIndex(buf^[foffs+2],buf^[foffs+1])+GetRowIndex(buf^[foffs+4],buf^[foffs+3]));
							inc(foffs,5)
						end;
					$02:
						begin
							push(GetColumnIndex(buf^[foffs+2],buf^[foffs+1])+GetRowIndex(buf^[foffs+4],buf^[foffs+3])+':'+GetColumnIndex(buf^[foffs+6],buf^[foffs+5])+GetRowIndex(buf^[foffs+8],buf^[foffs+7]));
							inc(foffs,9)
						end;
					$04:
						begin
							inc(foffs);
							push('('+pop+')')
						end;
					$05:
						begin
							push(ltoa(getint(foffs+1)));
							inc(foffs,3)
						end;
					$06:
						begin
							txt:='';
							inc(foffs);
							while buf^[foffs]<>0 do
								begin
									txt:=txt+chr(buf^[foffs]);
									inc(foffs)
								end;
							push(TexelApp.dosmask(txt));
							inc(foffs)
						end;
					$08:
						begin
							inc(foffs);
							push('-('+pop+')')
						end;
					$09:
						begin
							inc(foffs);
							txt:=pop;
							push(pop+'+'+txt)
						end;
					$0a:
						begin
							inc(foffs);
							txt:=pop;
							push(pop+'-'+txt)
						end;
					$0b:
						begin
							inc(foffs);
							txt:=pop;
							push(pop+'*'+txt)
						end;
					$0c:
						begin
							inc(foffs);
							txt:=pop;
							push(pop+'/'+txt)
						end;
					$0d:
						begin
							inc(foffs);
							txt:=pop;
							push(pop+'^'+txt)
						end;
					$0e:
						begin
							inc(foffs);
							txt:=pop;
							push('('+pop+')=('+txt+')')
						end;
					$0f:
						begin
							inc(foffs);
							txt:=pop;
							push('('+pop+')<>('+txt+')')
						end;
					$10:
						begin
							inc(foffs);
							txt:=pop;
							push('('+pop+')<=('+txt+')')
						end;
					$11:
						begin
							inc(foffs);
							txt:=pop;
							push('('+pop+')>=('+txt+')')
						end;
					$12:
						begin
							inc(foffs);
							txt:=pop;
							push('('+pop+')<('+txt+')')
						end;
					$13:
						begin
							inc(foffs);
							txt:=pop;
							push('('+pop+')>('+txt+')')
						end;
					$17:
						inc(foffs);
					$21:
						begin
							inc(foffs);
							push(#27+ltoa(NT_ABS)+#27'('+pop+')')
						end;
					$22:
						begin
							inc(foffs);
							push(#27+ltoa(NT_INT)+#27'('+pop+')')
						end;
					$23:
						begin
							inc(foffs);
							push(#27+ltoa(NT_SQRT)+#27'('+pop+')')
						end;
					$24:
						begin
							inc(foffs);
							push(#27+ltoa(NT_LOG10)+#27'('+pop+')')
						end;
					$25:
						begin
							inc(foffs);
							push(#27+ltoa(NT_LN)+#27'('+pop+')')
						end;
					$27:
						begin
							inc(foffs);
							push(#27+ltoa(NT_SIN)+#27'('+pop+')')
						end;
					$28:
						begin
							inc(foffs);
							push(#27+ltoa(NT_COS)+#27'('+pop+')')
						end;
					$29:
						begin
							inc(foffs);
							push(#27+ltoa(NT_TAN)+#27'('+pop+')')
						end;
					$2b:
						begin
							inc(foffs);
							push(#27+ltoa(NT_ARCTAN)+#27'('+pop+')')
						end;
					$2c:
						begin
							inc(foffs);
							push(#27+ltoa(NT_ARCSIN)+#27'('+pop+')')
						end;
					$2d:
						begin
							inc(foffs);
							push(#27+ltoa(NT_ARCCOS)+#27'('+pop+')')
						end;
					$2e:
						begin
							inc(foffs);
							push(#27+ltoa(NT_EXP)+#27'('+pop+')')
						end;
					$3b:
						begin
							inc(foffs);
							txt2:=pop;
							txt:=pop;
							push(#27+ltoa(NT_WENN)+#27'('+pop+','+txt+','+txt2+')')
						end;
					$3f:
						begin
							inc(foffs);
							push(#27+ltoa(NT_ROUND)+#27'('+pop+')')
						end;
					$50:
						begin
							txt:=#27+ltoa(NT_SUMME)+#27'('+pop;
							i:=buf^[foffs+1];
							if i<1 then fehler:=true;
							inc(foffs,2);
							while i>1 do
								begin
									txt:=txt+','+pop;
									dec(i)
								end;
							push(txt+')')
						end;
					$51:
						begin
							if buf^[foffs+1]=1 then
								begin
									inc(foffs,2);
									push(#27+ltoa(NT_MITTEL)+#27'('+pop+')')
								end
							else if buf^[foffs+1]=2 then
								begin
									inc(foffs,2);
									txt:=pop;
									push(#27+ltoa(NT_MITTEL)+#27'('+pop+':'+txt+')')
								end
							else
								fehler:=true
						end;
					$52:
						begin
							if buf^[foffs+1]<>1 then fehler:=true; { ... }
							inc(foffs,2);
							push(#27+ltoa(NT_ANZAHL2)+#27'('+pop+')')
						end;
					$57:
						begin
							if buf^[foffs+1]<>2 then fehler:=true; { ... }
							inc(foffs,2);
							txt:=pop;
							push(#27+ltoa(NT_VARIANZ)+#27'('+pop+':'+txt+')')
						end;
					else
						fehler:=true
					end
				end;
			getformula:='='+pop;
			if fehler then getformula:='='#27+ltoa(NT_FEHLER)+#27
		end;

	begin
		if length(fname)=0 then exit;
		BusyMouse;
		pg:=nil;
		buf:=GetMemBuffer(16384,4096,bufsize);
		new(stack,Init(100,50));
		if (buf=nil) or (stack=nil) then
			begin
				Application^.Alert(nil,1,STOP,MESSAGE_IMPORT_MEMORY1+CompressPath(fname,78)+MESSAGE_IMPORT_MEMORY2,BUTTON_OK);
				goto _raus
			end;
		stack^.Sort:=false;
		if not(Exist(fname)) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_EXIST1+CompressPath(fname,78)+MESSAGE_IMPORT_EXIST2,BUTTON_OK);
				goto _raus
			end;
		new(pg,Init(0,TITLE_IMPORT,fname));
		res:=fopen(fname,FO_READ);
		if res<0 then goto _errmsg;
		hdl:=integer(res);
		if readrecord then goto _error;
		if (rec.opcode<>WK_BOF) or (rec.len<>2) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_LOTUS1+CompressPath(fname,78)+MESSAGE_IMPORT_LOTUS2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done);
				fclose(hdl);
				goto _raus
			end;
		w:=swap(PWord(buf)^);
		if (w<$0404) or (w>$0406) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_WKS1+CompressPath(fname,78)+MESSAGE_IMPORT_WKS2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done);
				fclose(hdl);
				goto _raus
			end;
		spos:=fseek(0,hdl,1);
		if spos<0 then
			begin
				res:=-1;
				goto _error
			end;
		rmax:=2;
		cmax:=2;
		sze:=0;
		stdcol:=atol(TexelApp.setupbuffer.stdcolwidth);
		if readrecord then goto _error;
		while rec.opcode<>WK_EOF do
			begin
				case rec.opcode of
				WK_FORMULA,
				WK_LABEL:
					inc(sze);
				WK_WINDOW1:
					stdcol:=getint(6);
				WK_WKS_PASSWORD:
					begin
						Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_WKPASS1+CompressPath(fname,78)+MESSAGE_IMPORT_WKPASS2,BUTTON_OK);
						if pg<>nil then dispose(pg,Done);
						fclose(hdl);
						goto _raus
					end;
				WK_SAVE_RANGE:
					if swap(PInteger(buf)^)=-1 then
						begin
							Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_WKEMPTY1+CompressPath(fname,78)+MESSAGE_IMPORT_WKEMPTY2,BUTTON_OK);
							if pg<>nil then dispose(pg,Done);
							fclose(hdl);
							goto _raus
						end
					else
						begin
							if swap(PWord(longint(buf)+4)^)>=cmax then cmax:=swap(PWord(longint(buf)+4)^)+1;
							if swap(PWord(longint(buf)+6)^)>=rmax then rmax:=swap(PWord(longint(buf)+6)^)+1
						end
				end;
				if readrecord then goto _error
			end;
		getmem(prow,rmax shl 1);
		getmem(pcol,cmax shl 1);
		getmem(pcolnames,cmax shl 2);
		dummy:=rmax*cmax*CELLSIZE;
		getmem(sheet,dummy);
		if (prow=nil) or (pcol=nil) or (sheet=nil) or (pcolnames=nil) then
			begin
				if prow<>nil then freemem(prow,rmax shl 1);
				if pcol<>nil then freemem(pcol,cmax shl 1);
				if pcolnames<>nil then freemem(pcolnames,cmax shl 2);
				if sheet<>nil then freemem(sheet,dummy);
				if pg<>nil then dispose(pg,Done);
				TexelApp.ErrorWindowMemory(nil);
				fclose(hdl);
				goto _raus
			end;
		if pg<>nil then pg^.SetMax(rmax+sze);
		fillchar(pcolnames^,cmax shl 2,0);
		fillchar(sheet^,dummy,0);
		with TexelApp do
			begin
				vst_font(vdiHandle,GetStdFontIndex);
				if SpeedoActive then vst_arbpt(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
				else
					vst_point(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight);
				if vqt_width(vdiHandle,ord('9'),ww,w,w)<>ord('9') then ww:=Attr.charWidth;
				SetSystemFont(vdiHandle,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
			end;
		sze:=Max(Min(round(longint(ww)*stdcol*longint(Application^.Attr.PixW)/10.0),65535),0);
		for q:=0 to cmax-1 do pcol^[q]:=sze;
		TexelApp.InitCells(sheet,rmax,cmax);
		if fseek(spos,hdl,0)<0 then
			begin
				res:=-1;
				goto _error
			end;
		sf:=TexelApp.GetStdFontIndex;
		sg:=TexelApp.GetStdFontSize;
		fp:=atol(TexelApp.setupbuffer.floatpoint);
		if readrecord then goto _error;
		while rec.opcode<>WK_EOF do
			begin
				case rec.opcode of
				WK_LABEL:
					begin
						if pg<>nil then pg^.Progress(1);
						ttxt:=StrPTrimF(StrPas(@buf^[5]));
						if length(ttxt)>1 then
							begin
								cell:=getcell(getint(3),getint(1));
								cell^.Typ:=CTYPE_TEXT;
								case ttxt[1] of
								'^':
									cell^.TxtVal.Align:=TA_CENTER;
								'"':
									cell^.TxtVal.Align:=TA_RIGHT;
								else
									cell^.TxtVal.Align:=TA_LEFT
								end;
								cell^.Data.Txt:=NewStr(TexelApp.dosmask(StrPRight(ttxt,length(ttxt)-1)));
								cell^.TxtVal.Font:=sf;
								cell^.TxtVal.Size:=sg
							end
					end;
				WK_INTEGER:
					begin
						cell:=getcell(getint(3),getint(1));
						new(cell^.Data.Konst);
						if cell^.Data.Konst<>nil then
							begin
								cell^.Typ:=CTYPE_CONST;
								cell^.TxtVal.Font:=sf;
								cell^.TxtVal.Size:=sg;
								cell^.TxtVal.Align:=TA_RIGHT;
								with cell^.Data.Konst^ do
									begin
										Value:=getint(5);
										Txt:=NewStr(ltoa(getint(5)));
										FPts:=0
									end
							end
					end;
				WK_NUMBER:
					begin
						cell:=getcell(getint(3),getint(1));
						new(cell^.Data.Konst);
						if cell^.Data.Konst<>nil then
							begin
								pb:=@ieee64;
								for w:=12 downto 5 do
									begin
										pb^:=buf^[w];
										inc(longint(pb))
									end;
								cell^.Typ:=CTYPE_CONST;
								cell^.TxtVal.Font:=sf;
								cell^.TxtVal.Size:=sg;
								cell^.TxtVal.Align:=TA_RIGHT;
								with cell^.Data.Konst^ do
									begin
										Value:=ieee64;
										Txt:=NewStr(ftoa(Value));
										FPts:=fp
									end
							end
					end;
				WK_FORMULA:
					begin
						if pg<>nil then pg^.Progress(1);
						rowoffs:=getint(3);
						coloffs:=getint(1);
						cell:=getcell(rowoffs,coloffs);
						pb:=@ieee64;
						for w:=12 downto 5 do
							begin
								pb^:=buf^[w];
								inc(longint(pb))
							end;
						ttxt:=TexelApp.EscText2Formula(getformula);
						if length(ttxt)>0 then
							begin
								new(cell^.Data.Formula);
								if cell^.Data.Formula<>nil then
									begin
										cell^.Typ:=CTYPE_FORMULA;
										cell^.TxtVal.Font:=sf;
										cell^.TxtVal.Size:=sg;
										cell^.TxtVal.Align:=TA_RIGHT;
										with cell^.Data.Formula^ do
											begin
												Value:=ieee64;
												FPts:=fp;
												Error:=FE_OK;
												VarDef:=NewStr(ttxt);
												Func:=nil
											end
									end
							end
					end;
				WK_COLUMN_WIDTH_1:
					pcol^[getint(0)]:=Max(Min(round(longint(ww)*longint(buf^[2])*longint(Application^.Attr.PixW)/10.0),65535),0);
				{ ... }
				end;
				if readrecord then goto _error
			end;
		_error:
		fclose(hdl);
		_errmsg:
		if res<0 then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_LOAD1+CompressPath(fname,78)+MESSAGE_IMPORT_LOAD2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done)
			end
		else
			new(PCalcWindow,InitImport(pg,rmax-1,cmax-1,fname,sheet,prow,pcol,pcolnames,false));
		_raus:
		if buf<>nil then freemem(buf,bufsize);
		if stack<>nil then dispose(stack,Done);
		ArrowMouse
	end;


procedure TImport.LoadXLS(fname: string);
	label _raus,_errmsg,_error;

	const BIFF_BOF           =  $09;
	      BIFF_EOF           =  $0a;
	      BIFF2_DIMENSIONS   =  $00;
	      BIFF3_DIMENSIONS   = $200;
	      BIFF_DEFCOLWIDTH   =  $55;
	      BIFF_STANDARDWIDTH =  $99;
	      BIFF_COLWIDTH      =  $24;
	      BIFF_COLINFO       =  $7d;
	      BIFF2_DEFROWHEIGHT =  $25;
	      BIFF3_DEFROWHEIGHT = $225;
	      BIFF2_ROW          =  $08;
	      BIFF3_ROW          = $208;
	      BIFF_FILEPASS      =  $2f;
	      BIFF_FILESHARING   =  $5b;
	      BIFF_INTEGER       =  $02;
	      BIFF_RK            = $27e;
	      BIFF2_NUMBER       =  $03;
	      BIFF3_NUMBER       = $203;
	      BIFF2_LABEL        =  $04;
	      BIFF3_LABEL        = $204;
	      BIFF_1904          =  $22;
	      BIFF2_XF           =  $43;
	      BIFF3_XF           = $243;
	      BIFF4_XF           = $443;
	      BIFF_CODEPAGE      =  $42;
	      BIFF2_FORMULA      =  $06;
	      BIFF3_FORMULA      = $206;
	      BIFF4_FORMULA      = $406;
	      BIFF2_ARRAY        =  $21;
	      BIFF3_ARRAY        = $221;
	      BIFF2_BOOLERR      =  $05;
	      BIFF3_BOOLERR      = $205;
	      BIFF_HORPAGEBREAKS =  $1b;

	var buf,xfbuf : PByteArray;
	    bufsize,q,
	    dummy,sze,
	    rmax,cmax,
	    dcw,drh,
	    cdef,rdef,
	    anzxf,
	    xfcnt,
	    xfsize,
	    res,spos  : longint;
	    hdl,w,ww  : integer;
	    www,
	    von,bis,
	    tlast,
	    cpage,
	    typ,len   : word;
	    stdfpts,
	    xlsver    : byte;
	    sheet,cell: PCell;
	    prowflags,
	    pcolflags : PByteArray;
			prow,
			pcol      : PWordArray;
			pcolnames : PItemList;
			ppc       : PParameterCollection;
			ufrm      : PFormatCollection;
			stack     : PStringCollection;
	    parms     : TTexelParms;
	    tsbuf     : TSheetBuffer;
	    tdbuf     : TDialogBuffer;
	    tzwbuf    : TZielBuf;
	    diabuf    : TDiagrammBuf;
	    texbuf    : TExportBuf;
	    srtbuf    : TSortBuf;
	    infbuf    : TInfoBuf;
	    findbuf   : TFindBuf;
	    repbuf    : TReplaceBuf;
	    fillbuf   : TFillBuffer;
	    apwd      : TPassWord;
	    pg        : PProgressWindow;
	    biff2,
	    biff3,
	    biff4     : boolean;

	function bread(count: longint): boolean;

		begin
			bread:=(fread(hdl,count,buf)<>count)
		end;

	function GetLong(offs: longint): longint;

		begin
			GetLong:=(longint(PByte(longint(buf)+offs+3)^) shl 24)+(longint(PByte(longint(buf)+offs+2)^) shl 16)+(longint(PByte(longint(buf)+offs+1)^) shl 8)+longint(PByte(longint(buf)+offs)^)
		end;

	function GetWord(offs: longint): word;

		begin
			GetWord:=(PByte(longint(buf)+offs+1)^ shl 8)+PByte(longint(buf)+offs)^
		end;

	function GetByte(offs: longint): byte;

		begin
			GetByte:=PByte(longint(buf)+offs)^
		end;

	function ReadRecord: boolean;

		begin
			ReadRecord:=true;
			if bread(4) then exit;
			typ:=GetWord(0);
			len:=GetWord(2);
			if len>0 then
				if bread(len) then exit;
			ReadRecord:=false
		end;

	procedure GetCell(r,c: integer);

		begin
			cell:=PCell(longint(sheet)+(longint(r)*longint(cmax)+longint(c))*CELLSIZE)
		end;
	
	function GetFloat(offs: longint): double;
		var dbl: double;
	
		begin
			if GetWord(offs+6)=$ffff then
				begin
					case buf^[offs] of
					0,2:
						begin
							GetFloat:=0.0;
							exit
						end;
					1:
						begin
							if buf^[offs+2]<>0 then GetFloat:=1.0
							else
								GetFloat:=0.0;
							exit
						end
					end
				end;
			PWord(@dbl)^:=GetWord(offs+6);
			PWord(longint(@dbl)+2)^:=GetWord(offs+4);
			PWord(longint(@dbl)+4)^:=GetWord(offs+2);
			PWord(longint(@dbl)+6)^:=GetWord(offs);
			GetFloat:=dbl
		end;

	procedure CellText(r,c: word; t: string);

		begin
			if (r>=rmax) or (c>=cmax) or (length(t)=0) then exit;
			GetCell(r,c);
			cell^.Typ:=CTYPE_TEXT;
			if cpage=$8000 then cell^.Data.Txt:=NewStr(TexelApp.macmask(t))
			else
				cell^.Data.Txt:=NewStr(TexelApp.dosmask(t));
			with cell^.TxtVal do
				begin
					Font:=TexelApp.GetStdFontIndex;
					Size:=TexelApp.GetStdFontSize
				end
		end;

	procedure CellConst(r,c: word; num: real; fpts: byte);
		var pc: PConst;

		begin
			if (r>=rmax) or (c>=cmax) then exit;
			GetCell(r,c);
			new(pc);
			if pc<>nil then
				begin
					pc^.Value:=num;
					pc^.FPts:=fpts;
					pc^.Txt:=NewStr(TexelApp.Num2Txt(num,12,true));
					with cell^.TxtVal do
						begin
							Font:=TexelApp.GetStdFontIndex;
							Size:=TexelApp.GetStdFontSize;
							Align:=(Align and $f0) or TA_RIGHT
						end;
					cell^.Data.Konst:=pc;
					cell^.Typ:=CTYPE_CONST
				end
		end;

	procedure CellFormula(r,c: word; num: real; fpts: byte; esctxt: string);
		var pf: PFormula;

		begin
			esctxt:=TexelApp.EscText2Formula(esctxt);
			if (r>=rmax) or (c>=cmax) or (length(esctxt)=0) then exit;
			GetCell(r,c);
			new(pf);
			if pf<>nil then
				begin
					pf^.Value:=num;
					pf^.FPts:=fpts;
					pf^.Error:=FE_OK;
					pf^.VarDef:=NewStr(esctxt);
					pf^.Func:=nil;
					with cell^.TxtVal do
						begin
							Font:=TexelApp.GetStdFontIndex;
							Size:=TexelApp.GetStdFontSize;
							Align:=(Align and $f0) or TA_RIGHT
						end;
					cell^.Data.Formula:=pf;
					cell^.Typ:=CTYPE_FORMULA
				end
		end;

	function GetFormula(offs,lmax: longint): string;
		var fehler: boolean;
		    bend  : longint;
		    txt   : string;
		    i,anz : integer;

		function GetCellRef(rbits: word; cref: integer): string;
			var rref: integer;
			    refs: string[5];

			begin
				rref:=rbits and $3fff;
				rbits:=rbits and $c000;
				if cref<0 then refs:='?'
				else
					if cref<26 then refs:=chr(65+cref)
					else
						refs:=chr(64+(cref div 26))+chr(65+(cref mod 26));
				if not(bTst(rbits,$4000)) then refs:='$'+refs;
				if not(bTst(rbits,$8000)) then refs:=refs+'$';
				GetCellRef:=refs+ltoa(rref+1)
			end;

		procedure push(s: string);
		
			begin
				stack^.AtInsert(0,NewStr(s))
			end;
		
		function pop: string;
		
			begin
				if stack^.Count>0 then
					begin
						pop:=PString(stack^.At(0))^;
						stack^.AtFree(0)
					end
				else
					begin
						pop:='';
						fehler:=true
					end
			end;
	
		begin
			fehler:=false;
			stack^.FreeAll;
			bend:=offs+lmax;
			while (offs<bend) and not(fehler) do
				case buf^[offs] of
				$03:
					begin
						txt:=pop;
						push(pop+'+'+txt);
						inc(offs)
					end;
				$04:
					begin
						txt:=pop;
						push(pop+'-'+txt);
						inc(offs)
					end;
				$05:
					begin
						txt:=pop;
						push(pop+'*'+txt);
						inc(offs)
					end;
				$06:
					begin
						txt:=pop;
						push(pop+'/'+txt);
						inc(offs)
					end;
				$07:
					begin
						txt:=pop;
						push(pop+'^'+txt);
						inc(offs)
					end;
				$09:
					begin
						txt:=pop;
						push('('+pop+')<('+txt+')');
						inc(offs)
					end;
				$0a:
					begin
						txt:=pop;
						push('('+pop+')<=('+txt+')');
						inc(offs)
					end;
				$0b:
					begin
						txt:=pop;
						push('('+pop+')=('+txt+')');
						inc(offs)
					end;
				$0c:
					begin
						txt:=pop;
						push('('+pop+')>=('+txt+')');
						inc(offs)
					end;
				$0d:
					begin
						txt:=pop;
						push('('+pop+')>('+txt+')');
						inc(offs)
					end;
				$0e:
					begin
						txt:=pop;
						push('('+pop+')<>('+txt+')');
						inc(offs)
					end;
				$11:
					begin
						txt:=pop;
						push(pop+':'+txt);
						inc(offs)
					end;
				$12:
					begin
						push('+('+pop+')');
						inc(offs)
					end;
				$13:
					begin
						push('-('+pop+')');
						inc(offs)
					end;
				$14:
					begin
						push('('+pop+')%');
						inc(offs)
					end;
				$15:
					begin
						push('('+pop+')');
						inc(offs)
					end;
				$16:
					begin
						push('');
						inc(offs)
					end;
				$17:
					begin
						anz:=buf^[offs+1];
						txt[0]:=chr(anz);
						if anz>0 then
							for i:=1 to anz do txt[i]:=chr(buf^[offs+i+1]);
						push('"'+txt+'"');
						inc(offs,2+anz)
					end;
				$19:
					begin
						if buf^[offs+1]=$10 then push(#27+ltoa(NT_SUMME)+#27'('+pop+')')
						else
							if buf^[offs+1]<>$01 then
								begin
{									writeln('spez: ',ltoh(buf^[offs+1],2));  !!! }
									fehler:=true
								end;
						if biff2 then inc(offs,3)
						else
							begin
								if biff4 then
									if bTst(buf^[offs+1],$40) then inc(offs);
								inc(offs,4)
							end
					end;
				$1c:
					begin
						push(#27+ltoa(NT_FEHLER)+#27);
						inc(offs,2)
					end;
				$1d:
					begin
						if buf^[offs+1]<>0 then push(STRING_TRUE)
						else
							push(STRING_FALSE);
						inc(offs,2)
		 			end;
				$1e:
					begin
						push(ltoa(GetWord(offs+1)));
						inc(offs,3)
					end;
				$1f:
					begin
						push(ftoa(GetFloat(offs+1)));
						inc(offs,9)
					end;
				$24,
				$44:
					begin
						push(GetCellRef(GetWord(offs+1),buf^[offs+3]));
						inc(offs,4)
					end;
				$25,
				$2d:
					begin
						push(GetCellRef(GetWord(offs+1),buf^[offs+5])+':'+GetCellRef(GetWord(offs+3),buf^[offs+6]));
						inc(offs,7)
					end;
				$41:
					begin
						{ Formeln mit fester Anzahl Parameter }
						case buf^[offs+1] of
						$0f:
							push(#27+ltoa(NT_SIN)+#27'('+pop+')');
						$10:
							push(#27+ltoa(NT_COS)+#27'('+pop+')');
						$11:
							push(#27+ltoa(NT_TAN)+#27'('+pop+')');
						$12:
							push(#27+ltoa(NT_ARCTAN)+#27'('+pop+')');
						$13:
							push('Pi');
						$14:
							push(#27+ltoa(NT_SQRT)+#27'('+pop+')');
						$15:
							push(#27+ltoa(NT_EXP)+#27'('+pop+')');
						$16:
							push(#27+ltoa(NT_LN)+#27'('+pop+')');
						$17:
							push(#27+ltoa(NT_LOG10)+#27'('+pop+')');
						$18:
							push(#27+ltoa(NT_ABS)+#27'('+pop+')');
						$19:
							push(#27+ltoa(NT_INT)+#27'('+pop+')');
						$1a:
							push(#27+ltoa(NT_SGN)+#27'('+pop+')');
						$27:
							begin
								txt:=pop;
								push(#27+ltoa(NT_MOD)+#27'('+pop+','+txt+')')
							end;
						$b8:
							push(#27+ltoa(NT_FAK)+#27'('+pop+')');
						$3f:
							push(#27+ltoa(NT_RND)+#27);
						$61:
							begin
								txt:=pop;
								push(#27+ltoa(NT_ARCTAN2)+#27'('+pop+','+txt+')')
							end;
						$62:
							push(#27+ltoa(NT_ARCSIN)+#27'('+pop+')');
						$63:
							push(#27+ltoa(NT_ARCCOS)+#27'('+pop+')');
						$e5:
							push(#27+ltoa(NT_SINH)+#27'('+pop+')');
						$e6:
							push(#27+ltoa(NT_COSH)+#27'('+pop+')');
						$e7:
							push(#27+ltoa(NT_TANH)+#27'('+pop+')');
						$e8:
							push(#27+ltoa(NT_ARSINH)+#27'('+pop+')');
						$e9:
							push(#27+ltoa(NT_ARCOSH)+#27'('+pop+')');
						$ea:
							push(#27+ltoa(NT_ARTANH)+#27'('+pop+')');
						else
							begin
{								writeln('fest: ',ltoh(buf^[offs+1],2));  !!! }
								fehler:=true
							end
						end;
						inc(offs,2)
					end;
				$22,
				$42:
					begin
						{ Formeln mit variabler Anzahl Parameter }
						anz:=buf^[offs+1] and $7f;
						if anz<1 then fehler:=true
						else
							begin
								while anz>1 do
									begin
										txt:=pop;
										push(pop+','+txt);
										dec(anz)
									end;
								case (buf^[offs+2] and $7f) of
								$01:
									push(#27+ltoa(NT_WENN)+#27'('+pop+')');
								$04:
									push(#27+ltoa(NT_SUMME)+#27'('+pop+')');
								else
									begin
{										writeln('var.: ',ltoh(buf^[offs+1],2));  !!! }
										fehler:=true
									end
								end
							end;
						inc(offs,3)
					end;
				else
					begin
{						while (offs<bend) do
							begin
								write(ltoh(buf^[offs],2),' ');
								inc(offs)
							end;
						writeln;  !!! }
						fehler:=true
					end
				end;
			GetFormula:='='+pop;
			if fehler then GetFormula:='='#27+ltoa(NT_FEHLER)+#27
		end;

	function Long2Real(l: longint): real;
		var nr: real;
		    xp: longint;

		begin
			xp:=(l shr 18) and $000007ff;
			if xp=$07ff then Long2Real:=0.0
			else
				begin
					if xp=0 then nr:=exp(-1022.0*ln(2.0))*(l and $0003ffff)/262144.0
					else
						nr:=exp((xp-1023)*ln(2.0))*(1.0+(l and $0003ffff)/262144.0);
					if bTst(l,$20000000) then Long2Real:=-nr
					else
						Long2Real:=nr
				end
		end;

	function ExcelColor(c,def: integer): integer;

		begin
			case c of
			8:
				ExcelColor:=Black;
			9:
				ExcelColor:=White;
			10:
				ExcelColor:=Red;
			11:
				ExcelColor:=Green;
			12:
				ExcelColor:=Blue;
			13:
				ExcelColor:=Yellow;
			14:
				ExcelColor:=Magenta;
			15:
				ExcelColor:=Cyan;
			16:
				ExcelColor:=LRed;
			17:
				ExcelColor:=LGreen;
			18:
				ExcelColor:=LBlue;
			19:
				ExcelColor:=LYellow;
			20:
				ExcelColor:=LMagenta;
			21:
				ExcelColor:=LCyan;
			22:
				ExcelColor:=LWhite;
			23:
				ExcelColor:=LBlack
			else
				ExcelColor:=def
			end
		end;

	procedure SetXF(xf: longint);
		var xfp: PByteArray;

		procedure GetXFP(xfn: longint; bit: word);
			var nxfn: longint;

			begin
				xfp:=PByteArray(longint(xfbuf)+xfn*xfsize);
				if not(bTst(xfp^[5],bit)) then
					begin
						nxfn:=((longint(xfp^[2]) shr 4) and $000f) or ((longint(xfp^[3]) shl 4) and $0ff0);
						if nxfn<$0fff then
							if xfn<>nxfn then
								if nxfn>=0 then GetXFP(nxfn,bit)
					end
			end;

		begin
{	TBorders = record
		case byte of
			0: (Left,
			    Top,
			    Right,
			    Bottom,
			    Hor,
			    Vert  : byte);
			1: (Val1: integer;
			    Val2: longint)
	end;
	TCell = record
		Data    : TCombiData;
		Flags,
		Typ,
		Color,
		Style,
		Interior,
		Resvd   : byte;
		Format  : integer;
		Border  : TBorders;
		TxtVal  : TTxtVal
	end;
	TTxtVal = record
		Font,
		Size,
		Rotat,
		Skew   : integer;
		Color,
		Effects,
		Align,
		Flags  : byte
	end; ... }
			if xlsver<>4 then exit; { ... }
			GetXFP(xf,128);
			if bTst(xfp^[2],1) then cell^.Flags:=cell^.Flags or CELL_PROTECTED;
			GetXFP(xf,16);
			with cell^.TxtVal do
				begin
					case (xfp^[4] and $30) of
					$00:
						Align:=Align or TA_OBEN;
					$20:
						Align:=Align or TA_UNTEN
					else
						Align:=Align or TA_MITTE
					end;
					case (xfp^[4] and $07) of
					2:
						Align:=Align or TA_CENTER;
					3:
						Align:=Align or TA_RIGHT
					else
						Align:=Align or TA_LEFT
					end
				end;
			GetXFP(xf,64);
			cell^.Color:=ExcelColor(((xfp^[6] shr 6) and $03) or ((xfp^[7] shl 2) and $1c),White);
			if cell^.Color=White then cell^.Color:=Black
			else
				cell^.Interior:=FIS_SOLID; { ... }
			GetXFP(xf,32);
			GetXFP(xf,8);
			GetXFP(xf,4);
			{ ... }
			with cell^.Border do
				begin
					{ ... }
				end;
		end;

	begin
		if length(fname)=0 then exit;
		BusyMouse;
		pg:=nil;
		xfbuf:=nil;
		buf:=GetMemBuffer(16384,4096,bufsize);
		new(stack,Init(100,50));
		if (buf=nil) or (stack=nil) then
			begin
				Application^.Alert(nil,1,STOP,MESSAGE_IMPORT_MEMORY1+CompressPath(fname,78)+MESSAGE_IMPORT_MEMORY2,BUTTON_OK);
				goto _raus
			end;
		stack^.Sort:=false;
		if not(Exist(fname)) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_EXIST1+CompressPath(fname,78)+MESSAGE_IMPORT_EXIST2,BUTTON_OK);
				goto _raus
			end;
		new(pg,Init(0,TITLE_IMPORT,fname));
		res:=fopen(fname,FO_READ);
		if res<0 then goto _errmsg;
		hdl:=integer(res);
		if bread(8) then
			begin
				res:=-1;
				goto _error
			end;
		xlsver:=buf^[1];
		len:=GetWord(2);
		if (buf^[0]<>BIFF_BOF) or ((xlsver<>$00) and (xlsver<>$02) and (xlsver<>$04)) or (len<4) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_EXCEL1+CompressPath(fname,78)+MESSAGE_IMPORT_EXCEL2,BUTTON_OK);
				fclose(hdl);
				if pg<>nil then dispose(pg,Done);
				goto _raus
			end;
		biff2:=(xlsver=$00);
		biff3:=(xlsver=$02);
		biff4:=(xlsver=$04);
		if GetWord(6)<>$10 then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_XLS1+CompressPath(fname,78)+MESSAGE_IMPORT_XLS2,BUTTON_OK);
				fclose(hdl);
				if pg<>nil then dispose(pg,Done);
				goto _raus
			end;
		if len>4 then
			if bread(len-4) then
				begin
					res:=-1;
					goto _error
				end;
		spos:=fseek(0,hdl,1);
		if xlsver=0 then xfsize:=5
		else
			xfsize:=12;
		rmax:=Max(2,atol(TexelApp.setupbuffer.stdrows));
		cmax:=Max(2,atol(TexelApp.setupbuffer.stdcolumns));
		cdef:=0;
		cpage:=0;
		dcw:=atol(TexelApp.setupbuffer.stdcolwidth)*longint(256);
		drh:=255;
		anzxf:=1;
		repeat
			if ReadRecord then
				begin
					res:=-1;
					goto _error
				end;
			case typ of
			BIFF_FILEPASS:
				begin
					Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_XLPASS1+CompressPath(fname,78)+MESSAGE_IMPORT_XLPASS2,BUTTON_OK);
					fclose(hdl);
					if pg<>nil then dispose(pg,Done);
					goto _raus
				end;
			BIFF_FILESHARING:
				{ ? ... };
			BIFF2_DIMENSIONS,BIFF3_DIMENSIONS:
				begin
					if GetWord(2)>=rmax then rmax:=GetWord(2)+1;
					if GetWord(6)>=cmax then cmax:=GetWord(6)+1
				end;
			BIFF_DEFCOLWIDTH:
				dcw:=longint(GetWord(0))*longint(256);
			BIFF_STANDARDWIDTH:
				dcw:=GetWord(0);
			BIFF2_DEFROWHEIGHT:
				drh:=GetWord(0);
			BIFF3_DEFROWHEIGHT:
				drh:=GetWord(2);
			BIFF2_ROW,BIFF3_ROW:
				if GetWord(4)>=cdef then cdef:=GetWord(4)+1;
			BIFF_1904:
				if GetWord(0)=1 then
					if Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_XLDATE1+CompressPath(fname,78)+MESSAGE_IMPORT_XLDATE2,BUTTON_OKCANCEL)=2 then
						begin
							fclose(hdl);
							if pg<>nil then dispose(pg,Done);
							goto _raus
						end;
			BIFF2_XF,BIFF3_XF,BIFF4_XF:
				inc(anzxf);
			BIFF_CODEPAGE:
				cpage:=GetWord(0);
			{ ... }
			end
		until typ=BIFF_EOF;
		if pg<>nil then
			begin
				pg^.SetMax(rmax+((rmax shr 2) shl 1));
				pg^.Progress(rmax shr 2)
			end;
		res:=fseek(spos,hdl,0);
		if res<0 then goto _error;
		ScanConst(ppc);
		new(ufrm,Init(50,25));
		if ufrm<>nil then ufrm^.Sort:=false;
		if cdef>1 then cmax:=Max(cdef,atol(TexelApp.setupbuffer.stdcolumns));
		getmem(prow,rmax shl 1);
		getmem(pcol,cmax shl 1);
		getmem(pcolnames,cmax shl 2);
		getmem(prowflags,rmax);
		getmem(pcolflags,cmax);
		dummy:=rmax*cmax*CELLSIZE;
		q:=anzxf*xfsize;
		getmem(sheet,dummy);
		getmem(xfbuf,q);
		if (prow=nil) or (pcol=nil) or (sheet=nil) or (pcolnames=nil) or (xfbuf=nil) or (prowflags=nil) or (pcolflags=nil) then
			begin
				if prow<>nil then freemem(prow,rmax shl 1);
				if pcol<>nil then freemem(pcol,cmax shl 1);
				if prowflags<>nil then freemem(prowflags,rmax);
				if pcolflags<>nil then freemem(pcolflags,cmax);
				if pcolnames<>nil then freemem(pcolnames,cmax shl 2);
				if sheet<>nil then freemem(sheet,dummy);
				if xfbuf<>nil then freemem(xfbuf,q);
				if pg<>nil then dispose(pg,Done);
				TexelApp.ErrorWindowMemory(nil);
				fclose(hdl);
				goto _raus
			end;
		fillchar(xfbuf^,q,0);
		fillchar(pcolnames^,cmax shl 2,0);
		fillchar(pcolflags^,cmax,0);
		fillchar(prowflags^,rmax,0);
		fillchar(sheet^,dummy,0);
		with TexelApp do
			begin
				vst_font(vdiHandle,GetStdFontIndex);
				if SpeedoActive then vst_arbpt(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
				else
					vst_point(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight);
				if vqt_width(vdiHandle,ord('9'),ww,w,w)<>ord('9') then ww:=Attr.charWidth;
				rdef:=longint(Attr.boxHeight)*longint(Application^.Attr.PixH);
				SetSystemFont(vdiHandle,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
			end;
		sze:=round(drh*rdef/2550.0);
		for q:=0 to rmax-1 do prow^[q]:=sze;
		sze:=Max(Min(round(longint(ww)*dcw*longint(Application^.Attr.PixW)/2560.0),65535),0);
		for q:=0 to cmax-1 do pcol^[q]:=sze;
		TexelApp.InitCells(sheet,rmax,cmax);
		with parms do
			begin
				Rows:=rmax-1;
				Columns:=cmax-1;
				ScrlXPos:=0;
				ScrlYPos:=0;
				CurrSize:=SysInfo.Desktop
			end;
		TexelApp.InitSheetStructs(parms,tsbuf,tdbuf,tzwbuf,diabuf,texbuf,srtbuf,infbuf,findbuf,repbuf,fillbuf);
		stdfpts:=atol(TexelApp.setupbuffer.floatpoint);
		tlast:=0;
		xfcnt:=0;
		repeat
			if ReadRecord then
				begin
					res:=-1;
					goto _error
				end;
			case typ of
			BIFF_COLWIDTH:
				begin
					von:=GetByte(0);
					www:=GetWord(2);
					if von<cmax then
						if not(bTst(www,32768)) then
							begin
								bis:=GetByte(1);
								if bis>=cmax then bis:=cmax-1;
								sze:=Max(Min(round(longint(ww)*longint(www)*longint(Application^.Attr.PixW)/2560.0),65535),0);
								for q:=von to bis do pcol^[q]:=sze
							end
				end;
			BIFF_COLINFO:
				begin
					von:=GetWord(0);
					www:=GetWord(4);
					if von<cmax then
						if not(bTst(www,32768)) then
							begin
								bis:=GetWord(2);
								if bis>=cmax then bis:=cmax-1;
								sze:=Max(Min(round(longint(ww)*longint(www)*longint(Application^.Attr.PixW)/2560.0),65535),0);
								for q:=von to bis do pcol^[q]:=sze
							end
				end;
			BIFF2_ROW,BIFF3_ROW:
				begin
					von:=GetWord(6);
					bis:=GetWord(0);
					if bis<rmax then
						if not(bTst(von,32768)) then prow^[bis]:=round(longint(von)*rdef/2550.0)
				end;
			BIFF_INTEGER:
				CellConst(GetWord(0),GetWord(2),GetWord(7),0);
			BIFF2_NUMBER:
				CellConst(GetWord(0),GetWord(2),GetFloat(7),stdfpts);
			BIFF3_NUMBER:
				begin
					CellConst(GetWord(0),GetWord(2),GetFloat(6),stdfpts);
					SetXF(GetWord(4))
				end;
			BIFF_RK:
				begin
					q:=GetLong(6);
					case (q and $00000003) of
					0:
						CellConst(GetWord(0),GetWord(2),Long2Real((q shr 2) and $3fffffff),stdfpts);
					1:
						CellConst(GetWord(0),GetWord(2),Long2Real((q shr 2) and $3fffffff)/100.0,stdfpts);
					2:
						CellConst(GetWord(0),GetWord(2),(q shr 2) and $3fffffff,0);
					3:
						CellConst(GetWord(0),GetWord(2),((q shr 2) and $3fffffff)/100.0,0);
					end;
					SetXF(GetWord(4))
				end;
			BIFF2_FORMULA:
				CellFormula(GetWord(0),GetWord(2),GetFloat(7),stdfpts,GetFormula(17,buf^[16]));
			BIFF3_FORMULA,
			BIFF4_FORMULA:
				begin
					CellFormula(GetWord(0),GetWord(2),GetFloat(6),stdfpts,GetFormula(18,GetWord(16)));
					SetXF(GetWord(4))
				end;
			BIFF2_ARRAY:
{				writeln('BIFF2 Array')  !!! };
			BIFF3_ARRAY:
{				writeln('BIFF3 Array')  !!! };
			BIFF2_LABEL:
				CellText(GetWord(0),GetWord(2),StrLPas(@buf^[8],GetByte(7)));
			BIFF3_LABEL:
				begin
					CellText(GetWord(0),GetWord(2),StrLPas(@buf^[8],GetWord(6)));
					SetXF(GetWord(4))
				end;
			BIFF2_XF:
				begin
					system.move(buf^[0],xfbuf^[xfcnt],5);
					inc(xfcnt,5)
				end;
			BIFF3_XF,BIFF4_XF:
				begin
					system.move(buf^[0],xfbuf^[xfcnt],12);
					inc(xfcnt,12)
				end;
			BIFF2_BOOLERR:
				CellFormula(GetWord(0),GetWord(2),0.0,stdfpts,'='#27+ltoa(NT_FEHLER)+#27);
			BIFF3_BOOLERR:
				begin
					CellFormula(GetWord(0),GetWord(2),0.0,stdfpts,'='#27+ltoa(NT_FEHLER)+#27);
					SetXF(GetWord(4))
				end;
			BIFF_HORPAGEBREAKS:
				begin
					bis:=GetWord(0) shl 1;
					q:=2;
					while q<=bis do
						begin
							von:=GetWord(q);
							if von<rmax then prowflags^[von]:=prowflags^[von] or CRF_UMBRUCH;
							inc(q,2)
						end
				end;
			{ ... }
			end;
			tlast:=typ
		until typ=BIFF_EOF;
		_error:
		fclose(hdl);
		_errmsg:
		if res<0 then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_LOAD1+CompressPath(fname,78)+MESSAGE_IMPORT_LOAD2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done)
			end
		else
			begin
				if pg<>nil then pg^.Progress(rmax shr 2);
				if fname=StrPUpper(fname) then fname:=GetPath(fname)+GetFilename(fname,false)+'.'+StrPUpper(TEXELEXTENSION)
				else
					fname:=GetPath(fname)+GetFilename(fname,false)+'.'+TEXELEXTENSION;
				with apwd do
					begin
						Flag:=0;
						Code:=0;
						Mask:=0
					end;
{				evnt_timer(3000,0);  !!! }
				new(PCalcWindow,InitFile(fname,pg,parms,tdbuf,tsbuf,findbuf,repbuf,fillbuf,tzwbuf,
				                         texbuf,srtbuf,infbuf,diabuf,sheet,prow,pcol,pcolnames,ppc,
				                         ufrm,nil,apwd,nil,pcolflags,prowflags,nil,-1,false,true))
			end;
		_raus:
		if buf<>nil then freemem(buf,bufsize);
		if xfbuf<>nil then freemem(xfbuf,anzxf*xfsize);
		if stack<>nil then dispose(stack,Done);
		ArrowMouse
	end;


procedure TImport.LoadLDW(fname: string);
	label _raus,_error,_errmsg;

	var ttxt,otxt : string;
	    sze,
	    lstr,anzr,
	    q,dc,dr,
	    rmax,cmax,
	    bufsize,
	    res,dummy : longint;
	    sf,sg,ww,
	    hdl,e,w   : integer;
	    buf       : PByteArray;
	    sheet,cell: PCell;
			prow,
			pcol      : PWordArray;
			pcolnames : PItemList;
			number    : TNumber;
			fp        : byte;
			pg        : PProgressWindow;

	procedure ttxt2rc(indx: string; var r,c: longint);
		var q: integer;

		begin
			q:=1;
			while (indx[q] in ['A'..'Z']) and (q<=length(indx)) do inc(q);
			if q=2 then c:=ord(indx[1])-64
			else
				if q=3 then c:=ord(indx[1])*26+ord(indx[2])-1728
				else
					c:=0;
			r:=atol(StrPRight(indx,length(indx)+1-q))
		end;

	procedure insertcell;
		var formorconst: boolean;
	
		function klammeraffeweg(s: string): string;
			var i: integer;
		
			begin
				i:=pos('@',s);
				while i>0 do
					begin
						s:=StrPLeft(s,i-1)+StrPRight(s,length(s)-i);
						i:=pos('@',s)
					end;
				klammeraffeweg:=s
			end;

		procedure insertformula(cutl: integer);

			begin
				new(cell^.Data.Formula);
				if cell^.Data.Formula<>nil then
					begin
						cell^.Typ:=CTYPE_FORMULA;
						with cell^.Data.Formula^ do
							begin
								Value:=0.0;
								FPts:=fp;
								Error:=FE_OK;
								VarDef:=NewStr('='+klammeraffeweg(StrPRight(ttxt,length(ttxt)-cutl)));
								Func:=nil;
								cell^.TxtVal.Font:=sf;
								cell^.TxtVal.Size:=sg;
								cell^.TxtVal.Align:=TA_RIGHT
							end
					end
			end;

		begin
			StrPTrim(ttxt);
			if length(ttxt)=0 then exit;
			w:=pos(':',ttxt);
			if w>0 then
				begin
					formorconst:=false;
					ttxt2rc(StrPUpper(StrPLeft(ttxt,w-1)),dr,dc);
					if dr<>lstr then
						begin
							lstr:=dr;
							if pg<>nil then pg^.Progress(1)
						end;
					cell:=PCell(longint(sheet)+((dr-1)*cmax+dc-1)*CELLSIZE);
					ttxt:=StrPTrimF(StrPRight(ttxt,length(ttxt)-w));
					if StrPLeft(ttxt,1)='(' then
						begin
							formorconst:=true;
							e:=pos(')',ttxt);
							{ Format... }
							ttxt:=StrPTrimF(StrPRight(ttxt,length(ttxt)-e))
						end;
					if StrPLeft(ttxt,1)='{' then
						begin
							e:=pos('}',ttxt);
							if e=3 then
								if ttxt[2]='F' then cell^.TxtVal.Effects:=cell^.TxtVal.Effects or TF_THICKENED;
							{ Attribute... }
							ttxt:=StrPTrimF(StrPRight(ttxt,length(ttxt)-e))
						end;
					if StrPLeft(ttxt,1)='[' then
						begin
							e:=pos(']',ttxt);
							if e>3 then
								if ttxt[2]='B' then
									pcol^[dc-1]:=Max(Min(round(longint(ww)*atol(StrPMid(ttxt,3,e-3))*longint(Application^.Attr.PixW)/10.0),65535),0);
							ttxt:=StrPTrimF(StrPRight(ttxt,length(ttxt)-e))
						end;
					if length(ttxt)>0 then
						case ttxt[1] of
						'''':
							begin
								if length(ttxt)>1 then
									begin
										cell^.Typ:=CTYPE_TEXT;
										cell^.Data.Txt:=NewStr(StrPRight(ttxt,length(ttxt)-1))
									end;
								cell^.TxtVal.Font:=sf;
								cell^.TxtVal.Size:=sg
							end;
						'"':
							begin
								if length(ttxt)>1 then
									begin
										cell^.Typ:=CTYPE_TEXT;
										cell^.Data.Txt:=NewStr(StrPRight(ttxt,length(ttxt)-1))
									end;
								cell^.TxtVal.Font:=sf;
								cell^.TxtVal.Size:=sg;
								cell^.TxtVal.Align:=TA_RIGHT
							end;
						'^':
							begin
								if length(ttxt)>1 then
									begin
										cell^.Typ:=CTYPE_TEXT;
										cell^.Data.Txt:=NewStr(StrPRight(ttxt,length(ttxt)-1))
									end;
								cell^.TxtVal.Font:=sf;
								cell^.TxtVal.Size:=sg;
								cell^.TxtVal.Align:=TA_CENTER
							end;
						'+','=','@':
							insertformula(1);
						else
							if TexelApp.IsNumber(ttxt,number,otxt,true,',') then
								begin
									new(cell^.Data.Konst);
									if cell^.Data.Konst<>nil then
										begin
											cell^.Typ:=CTYPE_CONST;
											cell^.TxtVal.Font:=sf;
											cell^.TxtVal.Size:=sg;
											cell^.TxtVal.Align:=TA_RIGHT;
											with cell^.Data.Konst^ do
												begin
													Txt:=NewStr(otxt);
													Value:=number;
													FPts:=fp
												end
										end
								end
							else
								if formorconst then insertformula(0)
								else
									begin
										cell^.Typ:=CTYPE_TEXT;
										cell^.Data.Txt:=NewStr(ttxt);
										cell^.TxtVal.Font:=sf;
										cell^.TxtVal.Size:=sg
									end
						end
				end;
			ttxt:=''
		end;

	begin
		if length(fname)=0 then exit;
		BusyMouse;
		pg:=nil;
		buf:=GetMemBuffer(16384,128,bufsize);
		if buf=nil then
			begin
				Application^.Alert(nil,1,STOP,MESSAGE_IMPORT_MEMORY1+CompressPath(fname,78)+MESSAGE_IMPORT_MEMORY2,BUTTON_OK);
				goto _raus
			end;
		if not(Exist(fname)) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_EXIST1+CompressPath(fname,78)+MESSAGE_IMPORT_EXIST2,BUTTON_OK);
				goto _raus
			end;
		new(pg,Init(0,TITLE_IMPORT,fname));
		res:=fopen(fname,FO_READ);
		if res<0 then goto _errmsg;
		hdl:=integer(res);
		cmax:=2;
		rmax:=2;
		ttxt:='';
		anzr:=0;
		lstr:=0;
		repeat
			res:=fread(hdl,bufsize,buf);
			if res>0 then
				for q:=0 to res-1 do
					begin
						if buf^[q]=CR then
							begin
								StrPTrim(ttxt);
								if length(ttxt)>0 then
									begin
										w:=pos(':',ttxt);
										if w>0 then
											begin
												ttxt2rc(StrPUpper(StrPLeft(ttxt,w-1)),dr,dc);
												if dc>cmax then cmax:=dc;
												if dr>rmax then rmax:=dr;
												if dr<>lstr then
													begin
														lstr:=dr;
														inc(anzr)
													end
											end;
										ttxt:=''
									end
							end
						else
							if buf^[q]>=32 then ttxt:=ttxt+chr(buf^[q])
					end
		until res<>bufsize;
		if res<0 then goto _error;
		StrPTrim(ttxt);
		if length(ttxt)>0 then
			begin
				w:=pos(':',ttxt);
				if w>0 then
					begin
						ttxt2rc(StrPUpper(StrPLeft(ttxt,w-1)),dr,dc);
						if dc>cmax then cmax:=dc;
						if dr>rmax then rmax:=dr
					end
			end;
		res:=fseek(0,hdl,0);
		if res<0 then goto _error;
		getmem(prow,rmax shl 1);
		getmem(pcol,cmax shl 1);
		getmem(pcolnames,cmax shl 2);
		dummy:=rmax*cmax*CELLSIZE;
		getmem(sheet,dummy);
		if (prow=nil) or (pcol=nil) or (sheet=nil) or (pcolnames=nil) then
			begin
				if prow<>nil then freemem(prow,rmax shl 1);
				if pcol<>nil then freemem(pcol,cmax shl 1);
				if pcolnames<>nil then freemem(pcolnames,cmax shl 2);
				if sheet<>nil then freemem(sheet,dummy);
				if pg<>nil then dispose(pg,Done);
				TexelApp.ErrorWindowMemory(nil);
				fclose(hdl);
				goto _raus
			end;
		if pg<>nil then
			begin
				pg^.SetMax(rmax+(rmax shr 2)+anzr);
				pg^.Progress(rmax shr 2)
			end;
		fillchar(pcolnames^,cmax shl 2,0);
		fillchar(sheet^,dummy,0);
		with TexelApp do
			begin
				vst_font(vdiHandle,GetStdFontIndex);
				if SpeedoActive then vst_arbpt(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
				else
					vst_point(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight);
				if vqt_width(vdiHandle,ord('9'),ww,w,w)<>ord('9') then ww:=Attr.charWidth;
				SetSystemFont(vdiHandle,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
			end;
		sze:=Max(Min(round(longint(ww)*atol(TexelApp.setupbuffer.stdcolwidth)*longint(Application^.Attr.PixW)/10.0),65535),0);
		for q:=0 to cmax-1 do pcol^[q]:=sze;
		TexelApp.InitCells(sheet,rmax,cmax);
		ttxt:='';
		sf:=TexelApp.GetStdFontIndex;
		sg:=TexelApp.GetStdFontSize;
		fp:=atol(TexelApp.setupbuffer.floatpoint);
		lstr:=0;
		repeat
			res:=fread(hdl,bufsize,buf);
			if res>0 then
				for q:=0 to res-1 do
					begin
						if buf^[q]=CR then insertcell
						else
							if buf^[q]>=32 then ttxt:=ttxt+chr(buf^[q])
					end
		until res<>bufsize;
		if res>0 then insertcell;
		_error:
		fclose(hdl);
		_errmsg:
		if res<0 then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_LOAD1+CompressPath(fname,78)+MESSAGE_IMPORT_LOAD2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done)
			end
		else
			new(PCalcWindow,InitImport(pg,rmax-1,cmax-1,fname,sheet,prow,pcol,pcolnames,false));
		_raus:
		if buf<>nil then freemem(buf,bufsize);
		ArrowMouse
	end;


procedure TImport.LoadCSV(fname: string);
	label _raus,_error,_errmsg;

	var res,q,w,dc,
	    dummy,dr,
	    bufsize,
	    anzkomma,
	    anzsemi,
	    dcs,csmax,
	    cmax,rmax : longint;
	    hdl,sf,sg : integer;
	    buf       : PByteArray;
	    ttxt,otxt : string;
	    number    : TNumber;
	    fp        : byte;
	    mscsv,
	    tflag     : boolean;
	    sheet,cell: PCell;
			prow,
			pcol      : PWordArray;
			pcolnames : PItemList;
			pg        : PProgressWindow;

	procedure insertcell;
		var i: integer;

		begin
			StrPTrim(ttxt);
			if length(ttxt)>1 then
				begin
					if StrPLeft(ttxt,1)=#34 then
						if StrPRight(ttxt,1)=#34 then
							begin
								ttxt:=StrPMid(ttxt,2,length(ttxt)-2);
							end;
					i:=1;
					while i<length(ttxt) do
						begin
							if ttxt[i]=#34 then
								if ttxt[i+1]=#34 then
									ttxt:=StrPLeft(ttxt,i)+StrPRight(ttxt,length(ttxt)-i-1);
							inc(i)
						end
				end;
			if length(ttxt)=0 then exit;
			cell^.TxtVal.Font:=sf;
			cell^.TxtVal.Size:=sg;
			if ttxt[1]='=' then
				begin
					new(cell^.Data.Formula);
					if cell^.Data.Formula<>nil then
						begin
							cell^.Typ:=CTYPE_FORMULA;
							with cell^.Data.Formula^ do
								begin
									Value:=0.0;
									FPts:=fp;
									Error:=FE_OK;
									VarDef:=NewStr(ttxt);
									Func:=nil;
									cell^.TxtVal.Align:=TA_RIGHT
								end
						end
				end
			else
				if TexelApp.IsNumber(ttxt,number,otxt,true,'.') then
					begin
						new(cell^.Data.Konst);
						if cell^.Data.Konst<>nil then
							begin
								cell^.Typ:=CTYPE_CONST;
								with cell^.Data.Konst^ do
									begin
										Txt:=NewStr(otxt);
										Value:=number;
										FPts:=fp;
										cell^.TxtVal.Align:=TA_RIGHT
									end
							end
					end
				else
					begin
						cell^.Typ:=CTYPE_TEXT;
						cell^.Data.Txt:=NewStr(ttxt)
					end;
			ttxt:=''
		end;

	begin
		if length(fname)=0 then exit;
		BusyMouse;
		pg:=nil;
		buf:=GetMemBuffer(16384,128,bufsize);
		if buf=nil then
			begin
				Application^.Alert(nil,1,STOP,MESSAGE_IMPORT_MEMORY1+CompressPath(fname,78)+MESSAGE_IMPORT_MEMORY2,BUTTON_OK);
				goto _raus
			end;
		if not(Exist(fname)) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_EXIST1+CompressPath(fname,78)+MESSAGE_IMPORT_EXIST2,BUTTON_OK);
				goto _raus
			end;
		new(pg,Init(0,TITLE_IMPORT,fname));
		res:=fopen(fname,FO_READ);
		if res<0 then goto _errmsg;
		hdl:=integer(res);
		dc:=1;
		dcs:=1;
		dr:=1;
		cmax:=2;
		csmax:=2;
		rmax:=2;
		tflag:=false;
		anzkomma:=0;
		anzsemi:=0;
		repeat
			res:=fread(hdl,bufsize,buf);
			if res>0 then
				for q:=0 to res-1 do
					begin
						if buf^[q]=CR then
							begin
								if dc>cmax then cmax:=dc;
								if dcs>csmax then csmax:=dcs;
								inc(dr);
								dc:=1;
								dcs:=1;
								tflag:=false
							end
						else
							if buf^[q]=34 then tflag:=not(tflag)
							else
								if buf^[q]=59 then
									begin
										if not(tflag) then
											begin
												inc(dcs);
												inc(anzsemi)
											end
									end
								else
									if buf^[q]=44 then
										if not(tflag) then 
											begin
												inc(dc);
												inc(anzkomma)
											end
					end
		until res<>bufsize;
		if res<0 then goto _error;
		mscsv:=(anzsemi>anzkomma);
		if dc>cmax then cmax:=dc;
		if dcs>csmax then csmax:=dcs;
		if dr>rmax then rmax:=dr;
		if mscsv then cmax:=csmax;		
		res:=fseek(0,hdl,0);
		if res<0 then goto _error;
		getmem(prow,rmax shl 1);
		getmem(pcol,cmax shl 1);
		getmem(pcolnames,cmax shl 2);
		dummy:=rmax*cmax*CELLSIZE;
		getmem(sheet,dummy);
		if (prow=nil) or (pcol=nil) or (sheet=nil) or (pcolnames=nil) then
			begin
				if prow<>nil then freemem(prow,rmax shl 1);
				if pcol<>nil then freemem(pcol,cmax shl 1);
				if pcolnames<>nil then freemem(pcolnames,cmax shl 2);
				if sheet<>nil then freemem(sheet,dummy);
				if pg<>nil then dispose(pg,Done);
				TexelApp.ErrorWindowMemory(nil);
				fclose(hdl);
				goto _raus
			end;
		if pg<>nil then
			begin
				pg^.SetMax((rmax shl 1)+(rmax shr 2));
				pg^.Progress(rmax shr 2)
			end;
		fillchar(pcolnames^,cmax shl 2,0);
		fillchar(sheet^,dummy,0);
		TexelApp.InitCells(sheet,rmax,cmax);
		tflag:=false;
		sf:=TexelApp.GetStdFontIndex;
		sg:=TexelApp.GetStdFontSize;
		fp:=atol(TexelApp.setupbuffer.floatpoint);
		dr:=0;
		ttxt:='';
		cell:=sheet;
		repeat
			res:=fread(hdl,bufsize,buf);
			if res>0 then
				for q:=0 to res-1 do
					begin
						if buf^[q]=CR then
							begin
								insertcell;
								inc(dr);
								cell:=PCell(longint(sheet)+dr*cmax*CELLSIZE);
								tflag:=false;
								if pg<>nil then pg^.Progress(1)
							end
						else
							if buf^[q]=34 then
								begin
									tflag:=not(tflag);
									ttxt:=ttxt+#34
								end
							else
								if buf^[q]=44 then
									begin
										if not(tflag) and not(mscsv) then
											begin
												insertcell;
												inc(longint(cell),CELLSIZE)
											end
										else
											ttxt:=ttxt+#44
									end
								else
									if buf^[q]=59 then
										begin
											if not(tflag) and mscsv then
												begin
													insertcell;
													inc(longint(cell),CELLSIZE)
												end
											else
												ttxt:=ttxt+#59
										end
									else
										if buf^[q]>=32 then ttxt:=ttxt+chr(buf^[q])
					end
		until res<>bufsize;
		if res>0 then insertcell;
		_error:
		fclose(hdl);
		_errmsg:
		if res<0 then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_LOAD1+CompressPath(fname,78)+MESSAGE_IMPORT_LOAD2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done)
			end
		else
			new(PCalcWindow,InitImport(pg,rmax-1,cmax-1,fname,sheet,prow,pcol,pcolnames,true));
		_raus:
		if buf<>nil then freemem(buf,bufsize);
		ArrowMouse
	end;


procedure TImport.ImportASCII(fname,rctrenn,celltrenn,tquote: string; numtrenn: char; hor,quote: boolean; flt: integer);
	label _raus,_error,_errmsg;

	var res,q,w,dc,
	    dummy,dr,
	    bufsize,
	    loffs,
	    cmax,rmax : longint;
	    rowcolcnt,
	    cellcnt,
	    textcnt,lq,
	    hdl,sf,sg : integer;
	    buf       : PByteArray;
	    ttxt,otxt : string;
	    number    : TNumber;
	    fp        : byte;
	    textvalid,
	    spacevalid,
	    space,
	    usepkt,
	    tflag     : boolean;
	    sheet,cell: PCell;
			prow,
			pcol      : PWordArray;
			pcolnames : PItemList;
			pg        : PProgressWindow;

	procedure insertcell;
		label _txt;

		var i: integer;

		begin
			StrPTrim(ttxt);
			if textvalid then
				if length(ttxt)>lq then
					begin
						if StrPLeft(ttxt,lq)=tquote then
							if StrPRight(ttxt,lq)=tquote then
								ttxt:=StrPMid(ttxt,lq+1,length(ttxt)-(lq shl 1));
						if quote then
							begin
								i:=1;
								while i<=(length(ttxt)+1-(lq shl 1)) do
									begin
										if StrPMid(ttxt,i,lq)=tquote then
											if StrPMid(ttxt,i+lq,lq)=tquote then
												begin
													ttxt:=StrPLeft(ttxt,i-1)+StrPRight(ttxt,length(ttxt)+1-i-lq);
													inc(i,lq);
													continue
												end;
										inc(i)
									end
							end
					end;
			i:=1;
			while i<=length(ttxt) do
				begin
					if ord(ttxt[i])<32 then ttxt:=StrPLeft(ttxt,i-1)+StrPRight(ttxt,length(ttxt)-i)
					else
						inc(i)
				end;
			if length(ttxt)=0 then goto _txt;
			cell^.TxtVal.Font:=sf;
			cell^.TxtVal.Size:=sg;
			if ttxt[1]='=' then
				begin
					new(cell^.Data.Formula);
					if cell^.Data.Formula<>nil then
						begin
							cell^.Typ:=CTYPE_FORMULA;
							with cell^.Data.Formula^ do
								begin
									Value:=0.0;
									FPts:=fp;
									Error:=FE_OK;
									VarDef:=NewStr(ttxt);
									Func:=nil;
									cell^.TxtVal.Align:=TA_RIGHT
								end
						end
				end
			else
				if TexelApp.IsNumber(ttxt,number,otxt,true,numtrenn) then
					begin
						new(cell^.Data.Konst);
						if cell^.Data.Konst<>nil then
							begin
								cell^.Typ:=CTYPE_CONST;
								with cell^.Data.Konst^ do
									begin
										Txt:=NewStr(otxt);
										Value:=number;
										FPts:=fp;
										cell^.TxtVal.Align:=TA_RIGHT
									end
							end
					end
				else
					begin
						cell^.Typ:=CTYPE_TEXT;
						cell^.Data.Txt:=NewStr(ttxt)
					end;
			_txt:
			ttxt:=''
		end;

	begin
		if (length(fname)=0) or (length(rctrenn)=0) or (length(celltrenn)=0) then exit;
		BusyMouse;
		pg:=nil;
		buf:=GetMemBuffer(16384,128,bufsize);
		if buf=nil then
			begin
				Application^.Alert(nil,1,STOP,MESSAGE_IMPORT_MEMORY1+CompressPath(fname,78)+MESSAGE_IMPORT_MEMORY2,BUTTON_OK);
				goto _raus
			end;
		if not(Exist(fname)) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_EXIST1+CompressPath(fname,78)+MESSAGE_IMPORT_EXIST2,BUTTON_OK);
				goto _raus
			end;
		new(pg,Init(0,TITLE_IMPORT,fname));
		res:=fopen(fname,FO_READ);
		if res<0 then goto _errmsg;
		hdl:=integer(res);
		dc:=1;
		dr:=1;
		cmax:=2;
		rmax:=2;
		tflag:=false;
		rowcolcnt:=1;
		cellcnt:=1;
		textcnt:=1;
		lq:=length(tquote);
		textvalid:=(lq>0);
		spacevalid:=(celltrenn=' ');
		space:=false;
		usepkt:=InitKeyTab and (flt>=0);
		repeat
			res:=fread(hdl,bufsize,buf);
			if res>0 then
				for q:=0 to res-1 do
					begin
						if usepkt then buf^[q]:=ord(pkt^.ImportChar(nil,nil,0,0,0,flt,chr(buf^[q])));
						if space then
							begin
								if buf^[q]=32 then continue
								else
									space:=false
							end;
						if rctrenn[rowcolcnt]=chr(buf^[q]) then
							begin
								inc(rowcolcnt);
								if rowcolcnt>length(rctrenn) then
									begin
										if hor then
											begin
												if dc>cmax then cmax:=dc;
												inc(dr);
												dc:=1
											end
										else
											begin
												if dr>rmax then rmax:=dr;
												inc(dc);
												dr:=1
											end;
										tflag:=false;
										rowcolcnt:=1;
										cellcnt:=1;
										textcnt:=1
									end
							end
						else
							rowcolcnt:=1;
						if textvalid then
							begin
								if tquote[textcnt]=chr(buf^[q]) then
									begin
										inc(textcnt);
										if textcnt>length(tquote) then
											begin
												tflag:=not(tflag);
												textcnt:=1;
												cellcnt:=1;
												rowcolcnt:=1
											end
									end
								else
									textcnt:=1
							end;
						if celltrenn[cellcnt]=chr(buf^[q]) then
							begin
								inc(cellcnt);
								if cellcnt>length(celltrenn) then
									begin
										if not(tflag) then
											begin
												if hor then inc(dc)
												else
													inc(dr);
												if spacevalid then space:=true;
												rowcolcnt:=1;
												textcnt:=1
											end;
										cellcnt:=1
									end
							end
						else
							cellcnt:=1
					end
		until res<>bufsize;
		if res<0 then goto _error;
		if dr>rmax then rmax:=dr;
		if dc>cmax then cmax:=dc;
		res:=fseek(0,hdl,0);
		if res<0 then goto _error;
		getmem(prow,rmax shl 1);
		getmem(pcol,cmax shl 1);
		getmem(pcolnames,cmax shl 2);
		dummy:=rmax*cmax*CELLSIZE;
		getmem(sheet,dummy);
		if (prow=nil) or (pcol=nil) or (sheet=nil) or (pcolnames=nil) then
			begin
				if prow<>nil then freemem(prow,rmax shl 1);
				if pcol<>nil then freemem(pcol,cmax shl 1);
				if pcolnames<>nil then freemem(pcolnames,cmax shl 2);
				if sheet<>nil then freemem(sheet,dummy);
				if pg<>nil then dispose(pg,Done);
				TexelApp.ErrorWindowMemory(nil);
				fclose(hdl);
				goto _raus
			end;
		if pg<>nil then
			begin
				if hor then pg^.SetMax((rmax shl 1)+(rmax shr 2))
				else
					pg^.SetMax(rmax+cmax+(rmax shr 2));
				pg^.Progress(rmax shr 2)
			end;
		fillchar(pcolnames^,cmax shl 2,0);
		fillchar(sheet^,dummy,0);
		TexelApp.InitCells(sheet,rmax,cmax);
		tflag:=false;
		sf:=TexelApp.GetStdFontIndex;
		sg:=TexelApp.GetStdFontSize;
		fp:=atol(TexelApp.setupbuffer.floatpoint);
		if hor then
			begin
				dc:=1;
				dr:=0
			end
		else
			begin
				dc:=0;
				dr:=1
			end;
		ttxt:='';
		rowcolcnt:=1;
		cellcnt:=1;
		textcnt:=1;
		space:=false;
		loffs:=cmax*CELLSIZE;
		cell:=sheet;
		repeat
			res:=fread(hdl,bufsize,buf);
			if res>0 then
				for q:=0 to res-1 do
					begin
						if usepkt then buf^[q]:=ord(pkt^.ImportChar(nil,nil,0,0,0,flt,chr(buf^[q])));
						if space then
							begin
								if buf^[q]=32 then continue
								else
									space:=false
							end;
						ttxt:=ttxt+chr(buf^[q]);
						if rctrenn[rowcolcnt]=chr(buf^[q]) then
							begin
								inc(rowcolcnt);
								if rowcolcnt>length(rctrenn) then
									begin
										ttxt:=StrPLeft(ttxt,length(ttxt)-length(rctrenn));
										insertcell;
										if hor then
											begin
												inc(dr);
												dc:=1;
												cell:=PCell(longint(sheet)+dr*loffs)
											end
										else
											begin
												inc(dc);
												dr:=1;
												cell:=PCell(longint(sheet)+dc*CELLSIZE)
											end;
										tflag:=false;
										rowcolcnt:=1;
										cellcnt:=1;
										textcnt:=1;
										if pg<>nil then pg^.Progress(1)
									end
							end
						else
							rowcolcnt:=1;
						if textvalid then
							begin
								if tquote[textcnt]=chr(buf^[q]) then
									begin
										inc(textcnt);
										if textcnt>length(tquote) then
											begin
												tflag:=not(tflag);
												ttxt:=StrPLeft(ttxt,length(ttxt)-length(tquote));
												textcnt:=1;
												cellcnt:=1;
												rowcolcnt:=1
											end
									end
								else
									textcnt:=1
							end;
						if celltrenn[cellcnt]=chr(buf^[q]) then
							begin
								inc(cellcnt);
								if cellcnt>length(celltrenn) then
									begin
										if not(tflag) then
											begin
												ttxt:=StrPLeft(ttxt,length(ttxt)-length(celltrenn));
												insertcell;
												if hor then
													begin
														inc(dc);
														inc(longint(cell),CELLSIZE)
													end
												else
													begin
														inc(dr);
														inc(longint(cell),loffs)
													end;
												if spacevalid then space:=true;
												textcnt:=1;
												rowcolcnt:=1
											end;
										cellcnt:=1
									end
							end
						else
							cellcnt:=1
					end
		until res<>bufsize;
		if res>0 then insertcell;
		_error:
		fclose(hdl);
		_errmsg:
		if res<0 then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_LOAD1+CompressPath(fname,78)+MESSAGE_IMPORT_LOAD2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done)
			end
		else
			new(PCalcWindow,InitImport(pg,rmax-1,cmax-1,fname,sheet,prow,pcol,pcolnames,true));
		_raus:
		if buf<>nil then freemem(buf,bufsize);
		ArrowMouse
	end;


procedure TImport.LoadDIF(fname: string);
	label _errmsg,_raus,_weiter;

	var res,q,w,dc,
	    dummy,dr,e,
	    bufsize,
	    cmax,rmax : longint;
	    hdl,
	    si1,si2,
	    sf,sg     : integer;
	    sf2       : TNumber;
	    buf       : PByteArray;
	    table,
	    ttxt,
	    s1,s2     : string;
	    fp        : byte;
	    header    : boolean;
	    sheet,cell: PCell;
			prow,
			pcol      : PWordArray;
			pcolnames : PItemList;
			pg        : PProgressWindow;

	procedure split_s1;
		var p: integer;

		begin
			p:=pos(',',s1);
			if p=0 then
				begin
					si1:=0;
					sf2:=0.0
				end
			else
				begin
					si1:=atol(StrPLeft(s1,p-1));
					s2:=StrPRight(s1,length(s1)-p);
					sf2:=atof(s2)
				end
		end;

	procedure split_s2;
		var p: integer;

		begin
			p:=pos(',',s2);
			if p=0 then
				begin
					si1:=0;
					si2:=0
				end
			else
				begin
					si1:=atol(StrPLeft(s2,p-1));
					si2:=atol(StrPRight(s2,length(s2)-p))
				end
		end;

	begin
		if length(fname)=0 then exit;
		BusyMouse;
		pg:=nil;
		buf:=GetMemBuffer(16384,128,bufsize);
		if buf=nil then
			begin
				Application^.Alert(nil,1,STOP,MESSAGE_IMPORT_MEMORY1+CompressPath(fname,78)+MESSAGE_IMPORT_MEMORY2,BUTTON_OK);
				goto _raus
			end;
		if not(Exist(fname)) then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_EXIST1+CompressPath(fname,78)+MESSAGE_IMPORT_EXIST2,BUTTON_OK);
				goto _raus
			end;
		new(pg,Init(0,TITLE_IMPORT,fname));
		res:=fopen(fname,FO_READ);
		if res<0 then goto _errmsg;
		hdl:=integer(res);
		table:='';
		ttxt:='';
		s1:='';
		s2:='';
		cmax:=2;
		rmax:=2;
		header:=true;
		pcolnames:=nil;
		repeat
			res:=fread(hdl,bufsize,buf);
			if res>0 then
				for q:=0 to res-1 do
					if buf^[q]=CR then
						begin
							StrPTrim(ttxt);
							if length(ttxt)>0 then
								begin
									if header then
										begin
											if length(s1)=0 then s1:=ttxt
											else
												if length(s2)=0 then s2:=ttxt
												else
													begin
														split_s2;
														if s1='VECTORS' then
															begin
																if table='"EXCEL"' then
																	begin
																		if si2>rmax then rmax:=si2;
																		if pg<>nil then pg^.SetMax(rmax shl 1)
																	end
																else
																	begin
																		if si2>cmax then cmax:=si2;
																		getmem(pcolnames,cmax shl 2);
																		if pcolnames<>nil then fillchar(pcolnames^,cmax shl 2,0)
																	end
															end
														else
															if s1='TUPLES' then
																begin
																	if table='"EXCEL"' then
																		begin
																			if si2>cmax then cmax:=si2;
																			getmem(pcolnames,cmax shl 2);
																			if pcolnames<>nil then fillchar(pcolnames^,cmax shl 2,0)
																		end
																	else
																		begin
																			if si2>rmax then rmax:=si2;
																			if pg<>nil then pg^.SetMax(rmax shl 1)
																		end
																end
															else
																if s1='DATA' then
																	begin
																		header:=false;
																		getmem(prow,rmax shl 1);
																		getmem(pcol,cmax shl 1);
																		dummy:=rmax*cmax*CELLSIZE;
																		getmem(sheet,dummy);
																		if (prow=nil) or (pcol=nil) or (sheet=nil) or (pcolnames=nil) then
																			begin
																				if prow<>nil then freemem(prow,rmax shl 1);
																				if pcol<>nil then freemem(pcol,cmax shl 1);
																				if pcolnames<>nil then freemem(pcolnames,cmax shl 2);
																				if sheet<>nil then freemem(sheet,dummy);
																				TexelApp.ErrorWindowMemory(nil);
																				fclose(hdl);
																				goto _raus
																			end;
																		fillchar(sheet^,dummy,0);
																		TexelApp.InitCells(sheet,rmax,cmax);
																		sf:=TexelApp.GetStdFontIndex;
																		sg:=TexelApp.GetStdFontSize;
																		fp:=atol(TexelApp.setupbuffer.floatpoint);
																		dr:=-1;
																		dc:=0;
																		cell:=sheet
																	end
																else
																	if s1='LABEL' then
																		begin
																			if pcolnames<>nil then
																				for e:=si1-1 to si1+si2-2 do pcolnames^[e]:=NewStr(StrPMid(ttxt,2,length(ttxt)-2))
																		end
																	else
																		if s1='SIZE' then
																			begin
																				{ ... }
																			end
																		else
																			if s1='TABLE' then table:=ttxt;
														s1:='';
														s2:=''
													end
										end
									else
										begin
											if length(s1)=0 then s1:=ttxt
											else
												begin
													split_s1;
													case si1 of
													-1:
														begin
															if ttxt='EOD' then goto _weiter;
															if ttxt='BOT' then
																begin
																	inc(dr);
																	dc:=0;
																	if dr>=rmax then goto _weiter;
																	cell:=PCell(longint(sheet)+dr*cmax*CELLSIZE);
																	if pg<>nil then pg^.Progress(1)
																end
														end;
													0:
														begin
															if dc<cmax then
																begin
																	new(cell^.Data.Konst);
																	if cell^.Data.Konst<>nil then
																		begin
																			cell^.Typ:=CTYPE_CONST;
																			cell^.TxtVal.Font:=sf;
																			cell^.TxtVal.Size:=sg;
																			cell^.TxtVal.Align:=TA_RIGHT;
																			with cell^.Data.Konst^ do
																				begin
																					Txt:=NewStr(s2);
																					Value:=sf2;
																					FPts:=fp
																				end
																		end;
																	inc(longint(cell),CELLSIZE)
																end;
															inc(dc)
														end;
													1:
														begin
															if dc<cmax then
																begin
																	if ttxt[2]='=' then
																		begin
																			new(cell^.Data.Formula);
																			if cell^.Data.Formula<>nil then
																				begin
																					cell^.Typ:=CTYPE_FORMULA;
																					cell^.TxtVal.Font:=sf;
																					cell^.TxtVal.Size:=sg;
																					cell^.TxtVal.Align:=TA_RIGHT;
																					with cell^.Data.Formula^ do
																						begin
																							Value:=0.0;
																							FPts:=fp;
																							Error:=FE_OK;
																							VarDef:=NewStr(StrPMid(ttxt,2,length(ttxt)-2));
																							Func:=nil
																						end
																				end
																		end
																	else
																		if length(ttxt)>2 then
																			begin
																				cell^.Typ:=CTYPE_TEXT;
																				cell^.TxtVal.Font:=sf;
																				cell^.TxtVal.Size:=sg;
																				cell^.Data.Txt:=NewStr(StrPMid(ttxt,2,length(ttxt)-2))
																			end;
																	inc(longint(cell),CELLSIZE)
																end;
															inc(dc)
														end
													end;
													s1:=''
												end
										end
								end;
							ttxt:=''
						end
					else
						if buf^[q]>=32 then ttxt:=ttxt+chr(buf^[q])
		until res<>bufsize;
		if header then
			begin
				res:=-1;
				if pcolnames<>nil then freemem(pcolnames,cmax shl 2)
			end;
		_weiter:
		fclose(hdl);
		_errmsg:
		if res<0 then
			begin
				Application^.Alert(nil,1,NOTE,MESSAGE_IMPORT_LOAD1+CompressPath(fname,78)+MESSAGE_IMPORT_LOAD2,BUTTON_OK);
				if pg<>nil then dispose(pg,Done)
			end
		else
			new(PCalcWindow,InitImport(pg,rmax-1,cmax-1,fname,sheet,prow,pcol,pcolnames,true));
		_raus:
		if buf<>nil then freemem(buf,bufsize);
		ArrowMouse
	end;


procedure TImport.ImportFromClipboard;
	var ext: string;

	begin
		if Application^.Clipboard=nil then exit;
		with Application^.Clipboard^ do
			begin
				if not(OpenClipboard(false)) then exit;
				ext:=GetPriorityClipboardFormat('xls.dif.csv.txl');
				if ext='txl' then TexelApp.opennewdoc^.Load(GetClipboardFilename+'txl')
				else
					if ext='dif' then LoadDIF(GetClipboardFilename+'dif')
					else
						if ext='csv' then LoadCSV(GetClipboardFilename+'csv')
						else
							if ext='xls' then LoadXLS(GetClipboardFilename+'xls')
							else
								if ext='dbf' then ImportDBF(GetClipboardFilename+'dbf',nil)
								else
									Application^.Alert(nil,1,NOTE,MESSAGE_CLIP_IMPORT,BUTTON_OK);
				{ andere Formate... }
				CloseClipboard
			end
	end;


procedure TExportCheckBox.Changed(AnIndx: integer; DblClick: boolean);

	begin
		PExportDialog(Parent)^.CheckButtons
	end;


procedure TExportBox.Work;

	begin
		PExportDialog(Parent)^.CheckButtons
	end;


procedure TExportDialog.CheckButtons;
	var sel: integer;
	    s  : string;
	    p  : PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		if pecb^.GetCheck=bf_Checked then
			begin
				pb3^.Disable;
				st^.Disable;
				pb1^.Enable;
				pb2^.Enable
			end
		else
			begin
				pb3^.Enable;
				st^.Enable;
				if length(p^.export^.filename)>0 then
					begin
						pb1^.Enable;
						pb2^.Enable
					end
				else
					begin
						pb1^.Disable;
						pb2^.Disable
					end
			end;
		if pcb=nil then exit;
		sel:=pcb^.GetSelection;
		case sel of
		3:
			begin
				pg1^.Hide(false);
				pg0^.Hide(false);
				pg3^.Hide(false);
				pg4^.Hide(false);
				InitFocus;
				pg2^.Unhide
			end;
		4:
			begin
				pg1^.Hide(false);
				pg2^.Hide(false);
				pg0^.Hide(false);
				pg4^.Hide(false);
				InitFocus;
				pg3^.Unhide
			end;
		5:
			begin
				pg1^.Hide(false);
				pg2^.Hide(false);
				pg3^.Hide(false);
				pg0^.Hide(false);
				pg4^.Unhide;
				InitFocus
			end;
		8:
			begin
				pg0^.Hide(false);
				pg2^.Hide(false);
				pg3^.Hide(false);
				pg4^.Hide(false);
				InitFocus;
				pg1^.Unhide
			end
		else
			begin
				pg1^.Hide(false);
				pg2^.Hide(false);
				pg3^.Hide(false);
				pg4^.Hide(false);
				InitFocus;
				pg0^.Unhide
			end
		end;
		s:=p^.export^.filename;
		if length(GetExtension(s))>0 then
			begin
				s:=GetPath(s)+GetFilename(s,false);
				case sel of
				0:
					s:=s+'.wk1';
				1:
					s:=s+'.xls';
				2:
					s:=s+'.slk';
				3:
					s:=s+'.dif';
				4:
					s:=s+'.csv';
				5,6:
					s:=s+'.txt';
				7:
					s:=s+'.tex';
				8:
					s:=s+'.html';
				9:
					s:=s+'.ui';
				else
					s:=p^.export^.filename
				end;
				p^.export^.SetFile(s)
			end
	end;


procedure TExportDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk)
	end;


function TExportDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTEXEXPORT);
		OK:=valid
	end;


function TExportDialog.ExitDlg(AnIndx: integer): boolean;
	var p   : PCalcWindow;
	    mask: string;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTEXBEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTEXFILE:
			if p^.export<>nil then
				begin
					if pcb=nil then
						begin
							mask:='*.*';
							TexelApp.LastFile[15]:=''
						end
					else
						begin
							mask:='*.';
							TexelApp.LastFile[15]:=GetFilename(p^.GetWindowFilename,false);
							case pcb^.GetSelection of
							0:
								begin
									mask:=mask+'wk?';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.wk1'
								end;
							1:
								begin
									mask:=mask+'xls';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.xls'
								end;
							2:
								begin
									mask:=mask+'slk';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.slk'
								end;
							3:
								begin
									mask:=mask+'dif';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.dif'
								end;
							4:
								begin
									mask:=mask+'csv';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.csv'
								end;
							5:
								begin
									mask:=mask+'*';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.txt'
								end;
							6:
								begin
									mask:=mask+'txt';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.txt'
								end;
							7:
								begin
									mask:=mask+'tex';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.tex'
								end;
							8:
								begin
									mask:=mask+'html';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.html'
								end;
							9:
								begin
									mask:=mask+'ui';
									if length(TexelApp.LastFile[15])>0 then TexelApp.LastFile[15]:=TexelApp.LastFile[15]+'.ui'
								end;
							else
								begin
									mask:=mask+'*';
									TexelApp.LastFile[15]:=''
								end
							end
						end;
					if XFileSelect(p,FSELTITLE_EXPORTFILE,mask,TexelApp.LastPath[15],TexelApp.LastFile[15],1,FSEL_EXPORT,false,false) then p^.export^.SetFile(TexelApp.LastPath[15]+TexelApp.LastFile[15])
				end;
		RTEXEXPORT:
			begin
				if p^.export<>nil then
					begin
						TransferData(tf_GetData);
						p^.export^.Export(p^.exportbuf,p^.export^.filename)
					end
			end
		end
	end;


function TExport.Export(const texbuf: TExportBuf; const fname: string): boolean;
	var sfile: string;

	function getxfname(const extn: string): string;
		var ret: string;

		begin
			ret:=fname;
			if length(ret)>0 then
				begin
					TexelApp.LastPath[15]:=GetPath(ret);
					if length(GetExtension(ret))>1 then ret:=TexelApp.LastPath[15]+GetFilename(ret,true)
					else
						if length(extn)=0 then ret:=TexelApp.LastPath[15]+GetFilename(ret,false)
						else
							if ret=StrPUpper(ret) then ret:=TexelApp.LastPath[15]+GetFilename(ret,false)+'.'+StrPUpper(extn)
							else
								ret:=TexelApp.LastPath[15]+GetFilename(ret,false)+'.'+extn;
					TexelApp.LastFile[15]:=GetFilename(ret,true)
				end;
			getxfname:=ret
		end;

	begin
		if not(Between(texbuf.exporttype,0,9)) then
			begin
				Export:=false;
				exit
			end;
		Export:=true;
		p:=PCalcWindow(Parent);
		if texbuf.clipboard=bf_Checked then
			begin
				if p^.Clipboard=nil then exit;
				if not(p^.Clipboard^.OpenClipboard(false)) then exit;
				sfile:=p^.Clipboard^.GetClipboardFilename;
				p^.Clipboard^.CloseClipboard;
				case texbuf.exporttype of
				0:
					Save123(sfile+'wk1',texbuf);
				1:
					SaveXLS(sfile+'xls',texbuf);
				2:
					SaveSYLK(sfile+'slk',texbuf);
				3:
					SaveDIF(sfile+'dif',texbuf);
				4:
					SaveCSV(sfile+'csv',texbuf);
				5:
					SaveASCII(sfile+'txt',texbuf);
				6:
					SaveText(sfile+'txt',texbuf);
				7:
					SaveLATEX(sfile+'tex',texbuf);
				8:
					SaveHTML(sfile+'html',texbuf);
				9:
					SaveUDO(sfile+'ui',texbuf)
				end
			end
		else
			case texbuf.exporttype of
			0:
				Save123(getxfname('wk1'),texbuf);
			1:
				SaveXLS(getxfname('xls'),texbuf);
			2:
				SaveSYLK(getxfname('slk'),texbuf);
			3:
				SaveDIF(getxfname('dif'),texbuf);
			4:
				SaveCSV(getxfname('csv'),texbuf);
			5:
				SaveASCII(getxfname('txt'),texbuf);
			6:
				SaveText(getxfname('txt'),texbuf);
			7:
				SaveLATEX(getxfname('tex'),texbuf);
			8:
				SaveHTML(getxfname('html'),texbuf);
			9:
				SaveUDO(getxfname('ui'),texbuf)
			end
	end;


procedure TExport.SetFile(fname: string);

	begin
		p:=PCalcWindow(Parent);
		filename:=fname;
		if ADialog<>nil then
			with PExportDialog(ADialog)^ do
				begin
					if st<>nil then st^.SetText(CompressPath(filename,19));
					if (length(filename)>0) or (p^.exportbuf.clipboard=bf_Checked) then
						begin
							pb1^.Enable;
							pb2^.Enable
						end
					else
						begin
							pb1^.Disable;
							pb2^.Disable
						end
				end
	end;


procedure TExport.Work;
	var pb  : PButton;
	    pc  : PCheckBox;
	    pv  : PValidator;
	    picb: PImportCellBox;
	    pib1,
	    pib2: PImportButton;
	    flt : PStringCollection;
	    i   : integer;

	begin
		p:=PCalcWindow(Parent);
		if ADialog=nil then
			begin
				TexelApp.ActivateExtResource;
				ADialog:=new(PExportDialog,Init(p,TEXELWINDPREFIX+TITLE_EXPORT,STG_EXPORT,ICNTITLE_EXPORT,RTEXPORT));
				if ADialog<>nil then
					begin
						new(PExportDialog(ADialog)^.pg0,Init(ADialog,RTEXEMPTY,'',BUBBLE_EXPORT_EMPTY));
						new(PExportDialog(ADialog)^.pg1,Init(ADialog,RTEXHTML,'',BUBBLE_EXPORT_HTML));
						new(PExportDialog(ADialog)^.pg2,Init(ADialog,RTEXDIF,'',BUBBLE_EXPORT_DIF));
						new(PExportDialog(ADialog)^.pg3,Init(ADialog,RTEXCSV,'',BUBBLE_EXPORT_CSV));
						new(PExportDialog(ADialog)^.pg4,Init(ADialog,RTEXASCII,'',BUBBLE_EXPORT_ASCII));
						new(PGroupBox,Init(ADialog,RTEXBEREICH,'',BUBBLE_GENERAL_RANGE));
						new(PExportDialog(ADialog)^.bedt,Init(ADialog,RTEXBEDIT,16,false,BUBBLE_GENERAL_RANGE));
						new(PExportDialog(ADialog)^.pcb,Init(ADialog,RTEXFORMPOP,RTEXFORMCYC,RTEXFORMAT,RTPOPUPS2,RTP2EXPORT,id_No,true,false,BUBBLE_EXPORT_FORMATS));
						new(PExportDialog(ADialog)^.pecb,Init(ADialog,RTEXCLIPBOARD,true,BUBBLE_EXPORT_CLIPBOARD));
						new(pc,Init(ADialog,RTEXBTITLE,true,BUBBLE_EXPORT_RTITLE));
						if pc<>nil then pc^.Disable; { !!! }
						new(PExportDialog(ADialog)^.pb3,Init(ADialog,RTEXFILE,id_No,true,BUBBLE_EXPORT_FILE));
						new(PExportDialog(ADialog)^.st,Init(ADialog,RTEXFILENAME,20,false,BUBBLE_EXPORT_FILENAME));
						new(pb,Init(ADialog,RTEXHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTEXABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PExportDialog(ADialog)^.pb1,Init(ADialog,RTEXEXPORT,id_No,true,BUBBLE_EXPORT_EXPORT));
						new(PExportDialog(ADialog)^.pb2,Init(ADialog,RTEXOK,id_OK,true,BUBBLE_EXPORT_OK));
						new(PGroupBox,Init(ADialog,RTEXHTMLDTYPE,GROUP_EXPORT_DOCTYPE,BUBBLE_EXPORT_DOCTYPE));
						new(PGroupBox,Init(ADialog,RTEXHTMLEXPWITH,GROUP_EXPORT_SAVEWITH,BUBBLE_EXPORT_SAVEWITH));
						new(PComboBox,Init(ADialog,RTEXHTMLDOCTYPE,RTEXHTMLDTCYC,RTEXHTMLDTTITLE,RTPOPUPS2,RTP2HTML,id_No,false,false,BUBBLE_EXPORT_DTPOPUP));
						new(PCheckBox,Init(ADialog,RTEXHTMLSAVEDT,true,BUBBLE_EXPORT_SAVEDT));
						new(PCheckBox,Init(ADialog,RTEXHTMLCOLORS,true,BUBBLE_EXPORT_COLORS));
						new(PGroupBox,Init(ADialog,RTEXCSVINHALT,GROUP_EXPORT_SAVEWITH,BUBBLE_EXPORT_SAVEWITH));
						new(PRadioButton,Init(ADialog,RTEXCSVFORMELN,true,BUBBLE_EXPORT_FORMULA));
						new(PRadioButton,Init(ADialog,RTEXCSVWERTE,true,BUBBLE_EXPORT_VALUE));
						new(PGroupBox,Init(ADialog,RTEXDIFINHALT,GROUP_EXPORT_SAVEWITH,BUBBLE_EXPORT_SAVEWITH));
						new(PRadioButton,Init(ADialog,RTEXDIFFORMELN,true,BUBBLE_EXPORT_FORMULA));
						new(PRadioButton,Init(ADialog,RTEXDIFWERTE,true,BUBBLE_EXPORT_VALUE));
						new(PGroupBox,Init(ADialog,RTEXDIFTYPE,GROUP_EXPORT_TYPE,BUBBLE_EXPORT_DIFTYPE));
						new(PRadioButton,Init(ADialog,RTEXDIFSTANDARD,true,BUBBLE_EXPORT_DIFSTAND));
						new(PRadioButton,Init(ADialog,RTEXDIFEXCEL,true,BUBBLE_EXPORT_DIFMS));
						new(PGroupBox,Init(ADialog,RTEXASCIIROWS,GROUP_GENERAL_ROWS,BUBBLE_EXPORT_ROWS));
						new(pib1,Init(ADialog,RTEXASCIIHOR,true,BUBBLE_EXPORT_LINEHOR));
						new(pib2,Init(ADialog,RTEXASCIIVER,true,BUBBLE_EXPORT_LINEVERT));
						new(PGroupBox,Init(ADialog,RTEXASCIIINHALT,GROUP_EXPORT_SAVEWITH,BUBBLE_EXPORT_SAVEWITH));
						new(pib1^.pircb,Init(ADialog,RTEXASCIIROWCOL,RTEXASCIIRCCYC,RTEXASCIIRCTITLE,RTPOPUPS2,RTP2EXROWCOL,id_No,false,true,BUBBLE_EXPORT_LINEEND));
						pib2^.pircb:=pib1^.pircb;
						if pib1^.pircb<>nil then
							if pib1^.pircb^.Edit<>nil then
								begin
									new(pv,Init);
									if pv<>nil then pv^.Options:=voNotEmpty;
									pib1^.pircb^.Edit^.SetValidator(pv)
								end;
						new(picb,Init(ADialog,RTEXASCIICELLS,RTEXASCIICCYC,RTEXASCIICTITLE,RTPOPUPS2,RTP2EXCELLS,id_No,false,true,BUBBLE_EXPORT_CELLDIV));
						if picb<>nil then
							if picb^.Edit<>nil then
								begin
									new(pv,Init);
									if pv<>nil then pv^.Options:=voNotEmpty;
									picb^.Edit^.SetValidator(pv)
								end;
						new(PImportTextBox,Init(ADialog,RTEXASCIITEXT,RTEXASCIITCYC,RTEXASCIITTITLE,RTPOPUPS2,RTP2EXTEXT,id_No,false,true,BUBBLE_EXPORT_QUOTECHAR));
						new(PCheckBox,Init(ADialog,RTEXASCIIQUOTE,true,BUBBLE_EXPORT_QUOTING));
						new(PComboBox,Init(ADialog,RTEXASCIINUMBER,RTEXASCIINCYC,RTEXASCIINTITLE,RTPOPUPS2,RTP2EXNUMBERS,id_No,true,false,BUBBLE_EXPORT_FPOINT));
						new(PRadioButton,Init(ADialog,RTEXASCIIFORMELN,true,BUBBLE_EXPORT_FORMULA));
						new(PRadioButton,Init(ADialog,RTEXASCIIWERTE,true,BUBBLE_EXPORT_VALUE));
						new(PCheckBox,Init(ADialog,RTEXDIFFORMAT,true,BUBBLE_EXPORT_DIFFORM));
						new(PCheckBox,Init(ADialog,RTEXCSVFORMAT,true,BUBBLE_EXPORT_CSVFORM));
						new(PCheckBox,Init(ADialog,RTEXASCIIFORMAT,true,BUBBLE_EXPORT_ASCIIFORM));
						new(PCheckBox,Init(ADialog,RTEXHTMLEMBED,true,BUBBLE_EXPORT_EMBED));
						new(flt,Init(10,5));
						if flt<>nil then
							begin
								flt^.Sort:=false;
								if InitKeyTab then
									for i:=0 to pkt^.GetExportCount do flt^.Insert(NewStr('  '+StrPPas(pkt^.GetExportName(nil,nil,0,0,0,i))+' '#0))
								else
									flt^.Insert(NewStr('  Atari '#0))
							end;
						new(PComboBox,InitCollection(ADialog,RTEXFILTER,RTEXFCYC,RTEXFTITLE,12,flt,true,true,false,BUBBLE_EXPORT_FILTER));
						ADialog^.TransferBuffer:=@p^.exportbuf;
						if p^.exportbuf.ascii.hor=bf_Checked then pib1^.Changed(RTEXASCIIHOR,false)
						else
							pib2^.Changed(RTEXASCIIVER,false);
						SetFile('')
					end;
				TexelApp.DeactivateExtResource
			end;
		if ADialog<>nil then
			begin
				PExportDialog(ADialog)^.bedt^.SetText(StrPTrimF(p^.dblock^.GetText));
				ADialog^.MakeWindow;
				PExportDialog(ADialog)^.CheckButtons
			end
	end;


function TExport.InitFile(var fname: string; const texbuf: TExportBuf): boolean;
	var cell: PCell;
	    fn2 : string;
	    q,w : integer;

	begin
		InitFile:=false;
		if length(fname)=0 then exit;
		p:=PCalcWindow(Parent);
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				exit
			end;
		if texbuf.clipboard=bf_Checked then
			begin
				if p^.Clipboard=nil then exit;
				if not(p^.Clipboard^.OpenClipboard(true)) then exit;
				fname:=GetExtension(fname);
				fname:=p^.Clipboard^.GetClipboardFilename+StrPRight(fname,length(fname)-1)
			end
		else
			if Exist(fname) then
				if Application^.Alert(p,1,WAIT,MESSAGE_EXPORT_EXIST1+CompressPath(fname,78)+MESSAGE_EXPORT_EXIST2,BUTTON_YESNO)<>1 then exit;
		buf:=GetMemBuffer(16384,512,bufsize);
		if buf=nil then exit;
		BusyMouse;
		cell:=p^.Sheet;
		rmax:=-1;
		cmax:=-1;
		for q:=0 to p^.Parms.Rows do
			for w:=0 to p^.Parms.Columns do
				begin
					if cell^.Data.Value<>0 then
						begin
							if q>rmax then rmax:=q;
							if w>cmax then cmax:=w;
						end
					else
						if p^.PColNames^[w]<>nil then
							if w>cmax then cmax:=w;
					inc(longint(cell),CELLSIZE)
				end;
		if rmax<1 then rmax:=1;
		if cmax<1 then cmax:=1;
		if TexelApp.setupbuffer.bak=bf_Checked then
			if Exist(fname) then
				begin
					if TexelApp.IsLongFileName(fname) then fn2:=fname+'.bak'
					else
						fn2:=GetPath(fname)+GetFilename(fname,false)+'.bak';
					if Exist(fn2) then fdelete(fn2);
					frename(fname,fn2);
					TexelApp.UpdateFile(fn2,0)
				end;
		res:=fcreate(fname,0);
		if res<0 then
			begin
				freemem(buf,bufsize);
				ArrowMouse;
				exit
			end;
		hdl:=integer(res);
		bufcnt:=0;
		werror:=false;
		lend:=#13#10;
		exflt:=texbuf.filter;
		usepkt:=InitKeyTab and (exflt>=0);
		InitFile:=true
	end;


procedure TExport.ExitFile(bits: word; fname: string; const texbuf: TExportBuf);

	begin
		if texbuf.clipboard=bf_Checked then
			begin
				p^.Clipboard^.SetClipboardFormat(bits,GetExtension(fname));
				p^.Clipboard^.CloseClipboard
			end
		else
			TexelApp.UpdateFile(fname,0)
	end;


function TExport.bwrite(var buffer; count: longint): boolean;
	var rlen: longint;

	procedure exfilter;
		var i: longint;
	
		begin
			for i:=0 to bufcnt-1 do buf^[i]:=ord(pkt^.ExportChar(nil,nil,0,0,0,exflt,chr(buf^[i])))
		end;

	begin
		if count>bufsize then
			begin
				werror:=true;
				bwrite:=true;
				exit
			end;
		bwrite:=false;
		if count<1 then
			begin
				if count=0 then exit;
				if bufcnt>0 then
					begin
						if usepkt then exfilter;
						rlen:=fwrite(hdl,bufcnt,buf);
						if rlen<>bufcnt then
							begin
								werror:=true;
								bwrite:=true
							end;
						bufcnt:=0
					end;
				exit
			end;
		if bufcnt+count>bufsize then
			begin
				if usepkt then exfilter;
				rlen:=fwrite(hdl,bufcnt,buf);
				if rlen<>bufcnt then
					begin
						werror:=true;
						bwrite:=true
					end;
				bufcnt:=0
			end;
		move(buffer,buf^[bufcnt],count);
		inc(bufcnt,count)
	end;


function TExport.writeline(s: string): boolean;

	begin
		if bwrite(s[1],length(s)) then
			begin
				writeline:=true;
				exit
			end;
		if bwrite(lend[1],2) then
			begin
				writeline:=true;
				exit
			end;
		writeline:=false
	end;


function TExport.writes(s: string): boolean;

	begin
		if bwrite(s[1],length(s)) then writes:=true
		else
			writes:=false
	end;


procedure TExport.Save123(fname: string; const texbuf: TExportBuf);

	begin
		{ ... }
	end;


procedure TExport.SaveXLS(fname: string; const texbuf: TExportBuf);

	begin
		{ ... }
	end;


procedure TExport.SaveDIF(fname: string; const texbuf: TExportBuf);
	label _ende;

	var q,w : integer;
	    cell: PCell;

	begin
		if not(InitFile(fname,texbuf)) then exit;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				goto _ende
			end;
		{$IFNDEF DEMO}
		if writeline('TABLE') then goto _ende;
		if writeline('0,1') then goto _ende;
		if texbuf.difstandard=bf_Checked then
			begin
				if writeline('"'+GetFileName(p^.GetWindowFilename,true)+'"') then goto _ende;
				if writeline('VECTORS') then goto _ende;
				if writeline('0,'+ltoa(cmax+1)) then goto _ende;
				if writeline('""') then goto _ende;
				if writeline('TUPLES') then goto _ende;
				if writeline('0,'+ltoa(rmax+1)) then goto _ende
			end
		else
			begin
				if writeline('"EXCEL"') then goto _ende;
				if writeline('VECTORS') then goto _ende;
				if writeline('0,'+ltoa(rmax+1)) then goto _ende;
				if writeline('""') then goto _ende;
				if writeline('TUPLES') then goto _ende;
				if writeline('0,'+ltoa(cmax+1)) then goto _ende
			end;
		if writeline('""') then goto _ende;
		for q:=0 to cmax do
			if p^.PColNames^[q]<>nil then
				begin
					if writeline('LABEL') then goto _ende;
					if writeline(ltoa(q+1)+',1') then goto _ende;
					if writeline('"'+PString(p^.PColNames^[q])^+'"') then goto _ende
				end;
		if writeline('DATA') then goto _ende;
		if writeline('0,0') then goto _ende;
		if writeline('""') then goto _ende;
		for q:=0 to rmax do
			begin
				cell:=p^.GetCell(q,0);
				if writeline('-1,0') then goto _ende;
				if writeline('BOT') then goto _ende;
				for w:=0 to cmax do
					begin
						case cell^.Typ of
						CTYPE_TEXT:
							begin
								if writeline('1,0') then goto _ende;
								if writeline('"'+cell^.Data.Txt^+'"') then goto _ende
							end;
						CTYPE_CONST:
							if (texbuf.difformula=bf_Checked) or (texbuf.difformat<>bf_Checked) then
								begin
									if writeline('0,'+p^.Val2TxtF(cell^.Data.Konst^.Value,15,0,nil)) then goto _ende;
									if writeline('V') then goto _ende
								end
							else
								if cell^.Format=0 then
									begin
										if writeline('0,'+p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,0,nil)) then goto _ende;
										if writeline('V') then goto _ende
									end
								else
									begin
										if writeline('1,0') then goto _ende;
										if writeline('"'+p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil)+'"') then goto _ende
									end;
						CTYPE_FORMULA:
							begin
								if texbuf.difformula=bf_Checked then
									begin
										if writeline('1,0') then goto _ende;
										if writeline('"'+p^.BuildFunction(cell,true)+'"') then goto _ende
									end
								else
									if (cell^.Format=0) or (texbuf.difformat<>bf_Checked) then
										begin
											if writeline('0,'+p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,0,nil)) then goto _ende;
											if writeline('V') then goto _ende
										end
									else
										begin
											if writeline('1,0') then goto _ende;
											if writeline('"'+p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil)+'"') then goto _ende
										end
							end
						else
							begin
								if writeline('1,0') then goto _ende;
								if writeline('""') then goto _ende
							end
						end;
						inc(longint(cell),CELLSIZE)
					end
			end;
		if writeline('-1,0') then goto _ende;
		if writeline('EOD') then goto _ende;
		bwrite(q,-1);
		{$ENDIF}
		_ende:
		fclose(hdl);
		freemem(buf,bufsize);
		ArrowMouse;
		ExitFile(SCF_SHEET,fname,texbuf)
	end;


procedure TExport.SaveSYLK(fname: string; const texbuf: TExportBuf);
	label _ende;

	var q,w,e,w2: integer;
	    cell    : PCell;

	function xform(frm: string; ro,co: integer): string;

		begin
			frm:=StrPRight(frm,length(frm)-1);
			{ A1 - > R[]C[]... }
			xform:=frm
		end;

	begin
		if not(InitFile(fname,texbuf)) then exit;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				goto _ende
			end;
		{$IFNDEF DEMO}
		if writeline('ID;PTexel '+VtoS(TEXELVER)) then goto _ende;
		if writeline('B;Y'+ltoa(rmax+1)+';X'+ltoa(cmax+1)) then goto _ende;
		if writes('O;L') then goto _ende;
		if p^.sheetbuffer.autocalc=bf_Unchecked then
			begin
				if writeline(';M') then goto _ende
			end
		else
			if writeline('') then goto _ende;
		w:=round(p^.GetColWidth(0)*2.0/(p^.wWidth*p^.PercentSize));
		q:=1;
		e:=1;
		while q<=cmax do
			begin
				w2:=round(p^.GetColWidth(q)*2.0/(p^.wWidth*p^.PercentSize));
				if w<>w2 then
					begin
						if writeline('F;W'+ltoa(e)+' '+ltoa(q)+' '+ltoa(w)) then goto _ende;
						e:=q+1;
						w:=w2
					end;
				inc(q)
			end;
		if e<>q then
			if writeline('F;W'+ltoa(e)+' '+ltoa(q)+' '+ltoa(w)) then goto _ende;
		e:=-1;
		for q:=0 to rmax do
			begin
				cell:=p^.GetCell(q,0);
				for w:=0 to cmax do
					begin
						if cell^.Data.Value<>0 then
							begin
								if writes('C;') then goto _ende;
								if e<>q then
									begin
										if writes('Y'+ltoa(q+1)+';') then goto _ende;
										e:=q
									end;
								if writes('X'+ltoa(w+1)+';K') then goto _ende;
								case cell^.Typ of
								CTYPE_TEXT:
									if writeline('"'+cell^.Data.Txt^+'"') then goto _ende;
								CTYPE_CONST:
									if writeline(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil)) then goto _ende;
								CTYPE_FORMULA:
									if writeline(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil)) then goto _ende
									{,';E',xform(cell^.Data.Formula^.Txt^,q,w) ... }
								end
							end;
						inc(longint(cell),CELLSIZE)
					end
			end;
		if writeline('E') then goto _ende;
		bwrite(q,-1);
		{$ENDIF}
		_ende:
		fclose(hdl);
		freemem(buf,bufsize);
		ArrowMouse;
		ExitFile(SCF_SHEET,fname,texbuf)
	end;


procedure TExport.SaveCSV(fname: string; const texbuf: TExportBuf);
	label _ende;

	var q,w,
	    bis : integer;
	    cell: PCell;

	function toquote(s: string): string;
		var q: integer;

		begin
			q:=1;
			while q<=length(s) do
				begin
					if s[q]='"' then
						begin
							s:=StrPLeft(s,q)+StrPRight(s,length(s)+1-q);
							inc(q)
						end;
					inc(q)
				end;
			toquote:=s
		end;

	begin
		if not(InitFile(fname,texbuf)) then exit;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				goto _ende
			end;
		{$IFNDEF DEMO}
		for q:=0 to rmax do
			begin
				cell:=p^.GetCell(q,0);
				bis:=-1;
				for w:=0 to cmax do
					begin
						if cell^.Data.Value<>0 then bis:=w;
						inc(longint(cell),CELLSIZE)
					end;
				if bis>=0 then
					begin
						cell:=p^.GetCell(q,0);
						for w:=0 to cmax do
							begin
								if w>0 then
									if writes(',') then goto _ende;
								case cell^.Typ of
								CTYPE_TEXT:
									if writes('"'+toquote(cell^.Data.Txt^)+'"') then goto _ende;
								CTYPE_CONST:
									if (texbuf.csvformula=bf_Checked) or (texbuf.csvformat<>bf_Checked) then
										begin
											if writes(p^.Val2TxtF(cell^.Data.Konst^.Value,15,0,nil)) then goto _ende;
										end
									else
										if cell^.Format=0 then
											begin
												if writes(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,0,nil)) then goto _ende;
											end
										else
											if writes('"'+toquote(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil))+'"') then goto _ende;
								CTYPE_FORMULA:
									begin
										if texbuf.csvformula=bf_Checked then
											begin
												if writes('"'+toquote(p^.BuildFunction(cell,true))+'"') then goto _ende
											end
										else
											if (cell^.Format=0) or (texbuf.csvformat<>bf_Checked) then
												begin
													if writes(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,0,nil)) then goto _ende;
												end
											else
												if writes('"'+toquote(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil))+'"') then goto _ende
									end
								end;
								inc(longint(cell),CELLSIZE)
							end
					end;
				if writeline('') then goto _ende
			end;
		bwrite(q,-1);
		{$ENDIF}
		_ende:
		fclose(hdl);
		freemem(buf,bufsize);
		ArrowMouse;
		ExitFile(SCF_DBASE or SCF_SHEET,fname,texbuf)
	end;


procedure TExport.SaveLATEX(fname: string; const texbuf: TExportBuf);
	label _ende;

	var q,w,i: integer;
	    cell : PCell;

	function texmask(s: string): boolean;

		function replace(c: char; r: string): string;
			var s2: string;

			begin
				s2:='';
				i:=pos(c,s);
				while i>0 do
					begin
						s2:=s2+StrPLeft(s,i-1)+r;
						s:=StrPRight(s,length(s)-i);
						i:=pos(c,s)
					end;
				s:=s2+s
			end;

		begin
			texmask:=true;
			replace('"','""');
			replace('#','\#');
			replace('$','\$');
			replace('&','\&');
			replace('_','\_');
			replace('%','\%');
			replace('{','\{');
			replace('}','\}');
			replace('Ý','\S');
			replace(#189,'\copyright');
			replace(#188,'\P');
			replace(#156,'\pounds');
			{ Akzente etc. ... }
			replace('„','"a');
			replace('”','"o');
			replace('','"u');
			replace('Ž','"A');
			replace('™','"O');
			replace('š','"U');
			replace('ž','"s');
			replace('~','$\sim$');
			if writes(s) then exit;
			texmask:=false
		end;

	begin
		if not(InitFile(fname,texbuf)) then exit;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				goto _ende
			end;
		{$IFNDEF DEMO}
		if writeline('\begin{tabular}{*{'+ltoa(cmax+1)+'}{|c}|} \hline') then goto _ende;
		for q:=0 to rmax do
			begin
				cell:=p^.GetCell(q,0);
				for w:=0 to cmax do
					begin
						if w>0 then
							if writes(' & ') then goto _ende;
						case cell^.Typ of
						CTYPE_TEXT:
							if texmask(cell^.Data.Txt^) then goto _ende;
						CTYPE_CONST:
							if texmask(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil)) then goto _ende;
						CTYPE_FORMULA:
							if texmask(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil)) then goto _ende
						end;
						inc(longint(cell),CELLSIZE)
					end;
				if writeline(' \\ \hline') then goto _ende
			end;
		if writeline('\end{tabular}') then goto _ende;
		bwrite(q,-1);
		{$ENDIF}
		_ende:
		fclose(hdl);
		freemem(buf,bufsize);
		ArrowMouse;
		ExitFile(SCF_TEXT,fname,texbuf)
	end;


procedure TExport.SaveASCII(fname: string; const texbuf: TExportBuf);
	label _ende;

	var q,w,art,lq: integer;
	    loffs     : longint;
	    cell      : PCell;
	    rctrenn,
	    celltrenn,
	    tquote    : string;
	    numtrenn  : char;
	    hor,quote,
	    formula   : boolean;

	function toquote(s: string): string;
		var q: integer;

		begin
			if quote then
				if lq>0 then
					begin
						q:=1;
						if StrPMid(s,q,lq)=tquote then
							begin
								s:=StrPLeft(s,q+lq-1)+StrPRight(s,length(s)+1-q);
								inc(q,lq shl 1)
							end
						else
							inc(q)
					end;
			toquote:=s
		end;

	function tonum(s: string): string;
		var q: integer;

		begin
			if numtrenn<>'.' then
				begin
					q:=pos('.',s);
					while q>0 do
						begin
							s[q]:=numtrenn;
							q:=pos('.',s)
						end
				end;
			tonum:=s
		end;

	function writecell: boolean;
	
		begin
			writecell:=true;
			if w>0 then
				if writes(celltrenn) then exit;
			case cell^.Typ of
			CTYPE_TEXT:
				if writes(tquote+toquote(cell^.Data.Txt^)+tquote) then exit;
			CTYPE_CONST:
				if formula or (texbuf.asciiformat<>bf_Checked) then
					begin
						if writes(tonum(p^.Val2TxtF(cell^.Data.Konst^.Value,15,0,nil))) then exit;
					end
				else
					if cell^.Format=0 then
						begin
							if writes(tonum(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,0,nil))) then exit;
						end
					else
						if writes(tquote+toquote(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil))+tquote) then exit;
			CTYPE_FORMULA:
				begin
					if formula then
						begin
							if writes(tquote+toquote(p^.BuildFunction(cell,true))+tquote) then exit
						end
					else
						if (cell^.Format=0) or (texbuf.asciiformat<>bf_Checked) then
							begin
								if writes(tonum(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,0,nil))) then exit;
							end
						else
							if writes(tquote+toquote(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil))+tquote) then exit
				end
			end;
			writecell:=false
		end;

	begin
		if not(InitFile(fname,texbuf)) then exit;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				goto _ende
			end;
		{$IFNDEF DEMO}
		rctrenn:=TexelApp.num2str(texbuf.ascii.rcTxt);
		celltrenn:=TexelApp.num2str(texbuf.ascii.cellTxt);
		tquote:=TexelApp.num2str(texbuf.ascii.textTxt);
		if texbuf.ascii.numbers=1 then numtrenn:=','
		else
			numtrenn:='.';
		hor:=(texbuf.ascii.hor=bf_Checked);
		quote:=(texbuf.ascii.quote=bf_Checked);
		formula:=(texbuf.ascii.formula=bf_Checked);
		lq:=length(tquote);
		if hor then
			for q:=0 to rmax do
				begin
					cell:=p^.GetCell(q,0);
					for w:=0 to cmax do
						begin
							if writecell then goto _ende;
							inc(longint(cell),CELLSIZE)
						end;
					if writes(rctrenn) then goto _ende
				end
		else
			begin
				loffs:=CELLSIZE*longint(p^.Parms.Columns+1);
				for q:=0 to cmax do
					begin
						cell:=p^.GetCell(0,q);
						for w:=0 to rmax do
							begin
								if writecell then goto _ende;
								inc(longint(cell),loffs)
							end;
						if writes(rctrenn) then goto _ende
					end
			end;
		bwrite(q,-1);
		{$ENDIF}
		_ende:
		fclose(hdl);
		freemem(buf,bufsize);
		ArrowMouse;
		ExitFile(SCF_DBASE or SCF_TEXT or SCF_SHEET,fname,texbuf)
	end;


procedure TExport.SaveText(fname: string; const texbuf: TExportBuf);
	label _ende,_raus;

	var q,w : integer;
	    cell: PCell;
	    pc  : PIntegerArray;

	function writecell(const ct: string; col: integer): boolean;
		var h: integer;

		begin
			writecell:=true;
			case (cell^.TxtVal.Align and $0f) of
			TA_RIGHT:
				if writes(StrPSpace(pc^[col]-length(ct))+ct+' ') then exit;
			TA_CENTER:
				begin
					h:=(pc^[col]-length(ct)) shr 1;
					if writes(StrPSpace((pc^[col]-length(ct))-h)+ct+StrPSpace(h+1)) then exit
				end
			else
				if writes(ct+StrPSpace(pc^[col]+1-length(ct))) then exit
			end;
			writecell:=false
		end;

	procedure checkcell(cl,col: integer);

		begin
			if cl>pc^[col] then pc^[col]:=cl
		end;

	begin
		if not(InitFile(fname,texbuf)) then exit;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				goto _ende
			end;
		getmem(pc,(cmax+1) shl 1);
		if pc=nil then goto _ende;
		{$IFNDEF DEMO}
		for w:=0 to cmax do pc^[w]:=round(p^.GetColWidth(w)/(p^.wWidth*p^.PercentSize));
		for q:=0 to rmax do
			begin
				cell:=p^.GetCell(q,0);
				for w:=0 to cmax do
					begin
						case cell^.Typ of
						CTYPE_TEXT:
							checkcell(length(cell^.Data.Txt^),w);
						CTYPE_CONST:
							checkcell(length(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil)),w);
						CTYPE_FORMULA:
							checkcell(length(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil)),w)
						end;
						inc(longint(cell),CELLSIZE)
					end
			end;
		for q:=0 to rmax do
			begin
				cell:=p^.GetCell(q,0);
				for w:=0 to cmax do
					begin
						case cell^.Typ of
						CTYPE_TEXT:
							if writecell(cell^.Data.Txt^,w) then goto _raus;
						CTYPE_CONST:
							if writecell(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil),w) then goto _raus;
						CTYPE_FORMULA:
							if writecell(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil),w) then goto _raus;
						else
							if writecell('',w) then goto _raus
						end;
						inc(longint(cell),CELLSIZE)
					end;
				if writeline('') then goto _raus
			end;
		bwrite(q,-1);
		{$ENDIF}
		_raus:
		freemem(pc,(cmax+1) shl 1);
		_ende:
		fclose(hdl);
		freemem(buf,bufsize);
		ArrowMouse;
		ExitFile(SCF_TEXT,fname,texbuf)
	end;


procedure TExport.SaveHTML(fname: string; const texbuf: TExportBuf);
	label _ende;

	var q,w,vqc,
	    fsize,
	    walt,
	    fstdsize: integer;
	    cell2,
	    cell    : PCell;
	    rgb     : ARRAY_3;
	    colors,
	    one,
	    html40,
	    html30,
	    html32  : boolean;
	    pe      : PEmbedded;
	    sf,se   : string;
	    xfntinfo: XFNT_INFO;

	function htmlmask(s: string): boolean;
		var s2: string;
		    i : integer;

		function replace(c: char; r: string): string;

			begin
				s2:='';
				i:=pos(c,s);
				while i>0 do
					begin
						s2:=s2+StrPLeft(s,i-1)+r;
						s:=StrPRight(s,length(s)-i);
						i:=pos(c,s)
					end;
				s:=s2+s
			end;

		begin
			htmlmask:=true;
			replace('&','&amp;');
			replace('<','&lt;');
			replace('>','&gt;');
			replace('"','&quot;');
			replace('„','&auml;');
			replace('”','&ouml;');
			replace('','&uuml;');
			replace('Ž','&Auml;');
			replace('™','&Ouml;');
			replace('š','&Uuml;');
			replace('ž','&szlig;');
			replace(#173,'&iexcl;');
			replace(#155,'&cent;');
			replace(#156,'&pound;');
			replace(#157,'&yen;');
			replace(#185,'&uml;');
			replace(#189,'&copy;');
			replace(#170,'&not;');
			replace(#190,'&reg;');
			replace(#248,'&deg;');
			replace(#241,'&plusmn;');
			replace(#253,'&sup2;');
			replace(#254,'&sup3;');
			replace(#230,'&micro;');
			replace(#188,'&para;');
			replace(#250,'&middot;');
			replace(#146,'&AElig;');
			replace(#182,'&Agrave;');
			replace(#143,'&Aring;');
			replace(#183,'&Atilde;');
			replace(#128,'&Ccedil;');
			replace(#144,'&Eacute;');
			replace(#165,'&Ntilde;');
			replace(#178,'&Oslash;');
			replace(#184,'&Otilde;');
			replace(#160,'&aacute;');
			replace(#131,'&acirc;');
			replace(#145,'&aelig;');
			replace(#133,'&agrave;');
			replace(#134,'&aring;');
			replace(#176,'&atilde;');
			replace(#135,'&ccedil;');
			replace(#130,'&eacute;');
			replace(#136,'&ecirc;');
			replace(#138,'&egrave;');
			replace(#137,'&euml;');
			replace(#161,'&iacute;');
			replace(#140,'&icirc;');
			replace(#141,'&igrave;');
			replace(#139,'&iuml;');
			replace(#164,'&ntilde;');
			replace(#162,'&oacute;');
			replace(#147,'&ocirc;');
			replace(#149,'&ograve;');
			replace(#179,'&oslash;');
			replace(#177,'&otilde;');
			replace(#163,'&uacute;');
			replace(#150,'&ucirc;');
			replace(#151,'&ugrave;');
			replace(#152,'&yuml;');
			replace('Ý','&sect;');
			replace(#186,'&acute;');
			replace(#255,'&macr;');
			replace(#174,'&laquo;');
			replace('|','&brvbar;');
			replace(#193,'&Aacute;');
			replace(#194,'&Acirc;');
			replace(#208,'&ETH;');
			replace(#202,'&Ecirc;');
			replace(#200,'&Egrave;');
			replace(#203,'&Euml;');
			replace(#205,'&Iacute;');
			replace(#206,'&Icirc;');
			replace(#204,'&Igrave;');
			replace(#207,'&Iuml;');
			replace(#211,'&Oacute;');
			replace(#212,'&Ocirc;');
			replace(#210,'&Ograve;');
			replace(#222,'&THORN;');
			replace(#218,'&Uacute;');
			replace(#219,'&Ucirc;');
			replace(#217,'&Ugrave;');
			replace(#240,'&eth;');
			if writes(s) then exit;
			htmlmask:=false
		end;

	function rgb2hex(st: integer): string;

		function int2hex(i: longint): string;

			begin
				if Between(st,1,6) then inc(i,((1000-i)*(7-st)) div 7);
				int2hex:=StrPRight(ltoh((i*255) div 1000,2),2)
			end;

		begin
			rgb2hex:='#'+StrPUpper(int2hex(rgb[0])+int2hex(rgb[1])+int2hex(rgb[2]))
		end;

	begin
		if not(InitFile(fname,texbuf)) then exit;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				goto _ende
			end;
		{$IFNDEF DEMO}
		colors:=(texbuf.htmlcolor=bf_Checked);
		html30:=(texbuf.htmldoctype=0);
		html32:=(texbuf.htmldoctype=1);
		html40:=(texbuf.htmldoctype=2);
		fstdsize:=p^.GetStdFontSize;
		if texbuf.htmlsavedt=bf_Checked then
			begin
				if html40 then
					begin
						if writeline('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Draft//EN">') then goto _ende;
					end
				else if html32 then
					begin
						if writeline('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">') then goto _ende;
					end
				else
					if writeline('<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">') then goto _ende;
			end;
		if not(html40) then
			if writeline('<HTML>') then goto _ende;
		if writeline('<!-- Created using ASH-TEXEL '+VtoS(TEXELVER)+'r'+ltoa(RELEASE)+' -->') then goto _ende;
		if html30 then
			if writeline('<HEAD>') then goto _ende;
		if writes('<TITLE>') then goto _ende;
		if htmlmask(p^.GetWindowFilename) then goto _ende;
		if writeline('</TITLE>') then goto _ende;
{		if html40 then
			begin
				if writeline('') then goto _ende;
				if writeline('<STYLE TYPE=''text/css''>') then goto _ende;
				if writeline('<!--') then goto _ende;
				if writeline('-->') then goto _ende;
				if writeline('</STYLE>') then goto _ende
			end; !!! }
		if html30 then
			begin
				if writeline('</HEAD>') then goto _ende;
				if writeline('<BODY>') then goto _ende
			end;
		if writeline('') then goto _ende;
		if writes('<TABLE') then goto _ende;
		if p^.Parms.psbuffer.gitter=bf_Checked then
			if writes(' BORDER') then goto _ende;
		if html40 then
			begin
				if writes(' COLS="') then goto _ende;
				if p^.Parms.psbuffer.rows=bf_Checked then
					begin
						if writes(ltoa(cmax+2)) then goto _ende
					end
				else
					if writes(ltoa(cmax+1)) then goto _ende;
				if writes('"') then goto _ende
			end;
		if writeline('>') then goto _ende;
		if p^.Parms.psbuffer.columns=bf_Checked then
			begin
				if html40 then
					if writeline('<THEAD>') then goto _ende;
				if writeline('  <TR>') then goto _ende;
				if p^.Parms.psbuffer.rows=bf_Checked then
					begin
						if writes('    <TH>') then goto _ende;
						if html30 then
							begin
								if writeline('</TH>') then goto _ende
							end
						else
							if writeline('') then goto _ende
					end;
				for w:=0 to cmax do
					begin
						if writes('    <TH>') then goto _ende;
						if htmlmask(p^.GetColumnName(w)) then goto _ende;
						if html30 then
							begin
								if writeline('</TH>') then goto _ende
							end
						else
							if writeline('') then goto _ende
					end;
				if html30 then
					if writeline('  </TR>') then goto _ende
			end;
		if html40 then
			if writeline('<TBODY>') then goto _ende;
		for q:=0 to rmax do
			begin
				if writeline('  <TR>') then goto _ende;
				if writes('    ') then goto _ende;
				if p^.Parms.psbuffer.rows=bf_Checked then
					begin
						if html30 then
							begin
								if writeline('<TH>'+p^.GetRowIndex(q)+'</TH>') then goto _ende
							end
						else
							if writeline('<TH>'+p^.GetRowIndex(q)) then goto _ende;
						if writes('    ') then goto _ende
					end;
				w:=0;
				repeat
					walt:=w;
					cell:=p^.GetCell(q,w);
					if cell^.Typ=CTYPE_EMPTY then
						if bTst(cell^.TxtVal.Flags,TFL_TEXTFROMRIGHT) then
							begin
								cell2:=cell;
								while bTst(cell2^.TxtVal.Flags,TFL_TEXTFROMRIGHT) do
									begin
										inc(w);
										inc(longint(cell2),CELLSIZE)
									end;
								cell:=cell2
							end;
					if cell^.Typ=CTYPE_TEXT then
						if bTst(cell^.TxtVal.Flags,TFL_TEXT2RIGHT) then
							begin
								cell2:=PCell(longint(cell)+CELLSIZE);
								while bTst(cell2^.TxtVal.Flags,TFL_TEXTFROMLEFT) do
									begin
										inc(w);
										inc(longint(cell2),CELLSIZE)
									end
							end;
					if writes('<TD') then goto _ende;
					if cell^.Typ<>CTYPE_EMPTY then
						begin
							if w>walt then
								if writes(' COLSPAN='+ltoa(w+1-walt)) then goto _ende;
							case (cell^.TxtVal.Align and $0f) of
							TA_CENTER:
								if writes(' ALIGN=CENTER') then goto _ende;
							TA_RIGHT:
								if writes(' ALIGN=RIGHT') then goto _ende
							end;
							case (cell^.TxtVal.Align and $f0) of
							TA_OBEN:
								if writes(' VALIGN=TOP') then goto _ende;
							TA_UNTEN:
								if writes(' VALIGN=BOTTOM') then goto _ende
							end
						end;
					if not(colors) then
						begin
							if writes('>') then goto _ende
						end
					else
						if cell^.Interior=FIS_HOLLOW then
							begin
								if writes(' BGCOLOR=#FFFFFF>') then goto _ende
							end
						else
							if vq_color(p^.vdiHandle,cell^.Color,0,rgb)=-1 then
								begin
									if writes('>') then goto _ende
								end
							else
								if cell^.Interior=FIS_SOLID then
									begin
										if writes(' BGCOLOR='+rgb2hex(0)+'>') then goto _ende
									end
								else
									if writes(' BGCOLOR='+rgb2hex(cell^.Style)+'>') then goto _ende;
					if cell^.Typ<>CTYPE_EMPTY then
						begin
							if colors then
								begin
									if writes('<FONT') then goto _ende;
									vqc:=vq_color(p^.vdiHandle,cell^.TxtVal.Color,0,rgb);
									if vqc<>-1 then
										if writes(' COLOR='+rgb2hex(0)) then goto _ende;
									fsize:=((cell^.TxtVal.Size-fstdsize) shr 1);
									if writes(' SIZE=') then goto _ende;
									if fsize>=0 then
										if writes('+') then goto _ende;
									if writes(ltoa(Min(7,Max(-7,fsize)))) then goto _ende;
									xfntinfo.size:=sizeof(XFNT_INFO);
									if vqtXFntInfo(p^.vdiHandle,cell^.TxtVal.Font,@xfntinfo) then
										if writes(' FACE="'+StrPTrimF(StrPas(xfntinfo.font_name))+'"') then goto _ende;
									if writes('>') then goto _ende
								end;
							if bTst(cell^.TxtVal.Effects,TF_THICKENED) then
								if writes('<B>') then goto _ende;
							if bTst(cell^.TxtVal.Effects,TF_SLANTED) then
								if writes('<I>') then goto _ende;
							if bTst(cell^.TxtVal.Effects,TF_UNDERLINED) then
								if writes('<U>') then goto _ende;
							case cell^.Typ of
							CTYPE_TEXT:
								if htmlmask(cell^.Data.Txt^) then goto _ende;
							CTYPE_CONST:
								if htmlmask(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil)) then goto _ende;
							CTYPE_FORMULA:
								if htmlmask(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil)) then goto _ende
							end;
							if bTst(cell^.TxtVal.Effects,TF_UNDERLINED) then
								if writes('</U>') then goto _ende;
							if bTst(cell^.TxtVal.Effects,TF_SLANTED) then
								if writes('</I>') then goto _ende;
							if bTst(cell^.TxtVal.Effects,TF_THICKENED) then
								if writes('</B>') then goto _ende;
							if colors then
								if vqc<>-1 then
									if writes('</FONT>') then goto _ende;
						end;
					if html30 then
						begin
							if writeline('</TD>') then goto _ende
						end
					else
						if writeline('') then goto _ende;
					if w<cmax then
						if writes('    ') then goto _ende;
					inc(w)
				until w>cmax;
				if html30 then
					if writeline('  </TR>') then goto _ende
			end;
		if writeline('</TABLE>') then goto _ende;
		if writeline('') then goto _ende;
		if texbuf.htmlembed=bf_Checked then
			begin
				pe:=p^.Embedded;
				one:=false;
				while pe<>nil do
					begin
						sf:=pe^.GetFile;
						if length(sf)>0 then
							begin
								if not(one) then
									if writeline('<BR>') then goto _ende;
								se:=StrPUpper(GetExtension(sf));
								if (se='.GIF') or (se='.JPG') then
									begin
										if writeline('<IMG SRC='+sf+'>') then goto _ende
									end
								else
									begin
										if writeline('<EMBED SRC='+sf+' WIDTH='+ltoa(pe^.GetPixWidth(true))+' HEIGHT='+ltoa(pe^.GetPixHeight(true))+'>') then goto _ende
									end;
								one:=true
							end;
						pe:=pe^.Next
					end;
				if one then
					if writeline('') then goto _ende;
			end;
		if html30 then
			if writeline('</BODY>') then goto _ende;
		if not(html40) then
			if writeline('</HTML>') then goto _ende;
		bwrite(q,-1);
		{$ENDIF}
		_ende:
		fclose(hdl);
		freemem(buf,bufsize);
		ArrowMouse;
		ExitFile(SCF_TEXT,fname,texbuf)
	end;


procedure TExport.SaveUDO(fname: string; const texbuf: TExportBuf);
	label _ende;

	var q,w : integer;
	    cell: PCell;

	function udomask(s: string): boolean;

		begin
			udomask:=true;
			{ ... }
			if writes(s) then exit;
			udomask:=false
		end;

	begin
		if not(InitFile(fname,texbuf)) then exit;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				goto _ende
			end;
		{$IFNDEF DEMO}
		if p^.Parms.psbuffer.columns=bf_Checked then rmax:=Min(254,rmax)
		else
			rmax:=Min(255,rmax);
		if p^.Parms.psbuffer.rows=bf_Checked then cmax:=Min(30,cmax)
		else
			cmax:=Min(31,cmax);
		if writeline('!table_caption '+p^.GetWindowFilename) then goto _ende;
		if writes('!begin_table [') then goto _ende;
		if p^.Parms.psbuffer.gitter=bf_Checked then
			begin
				if p^.Parms.psbuffer.rows=bf_Checked then
					if writes('|c') then goto _ende;
				for w:=0 to cmax do
					if writes('|l') then goto _ende;
				if writeline('|] !hline') then goto _ende
			end
		else
			begin
				if p^.Parms.psbuffer.rows=bf_Checked then
					if writes('c') then goto _ende;
				if writeline(StrPFill(cmax+1,'l')+']') then goto _ende
			end;
		if p^.Parms.psbuffer.columns=bf_Checked then
			begin
				if p^.Parms.psbuffer.rows=bf_Checked then
					if writes(' !! ') then goto _ende;
				for w:=0 to cmax do
					begin
						if udomask(p^.GetColumnName(w)) then goto _ende;
						if w<cmax then
							if writes(' !! ') then goto _ende
					end;
				if writeline('') then goto _ende
			end;
		for q:=0 to rmax do
			begin
				if p^.Parms.psbuffer.rows=bf_Checked then
					if writes(p^.GetRowIndex(q)+' !! ') then goto _ende;
				cell:=p^.GetCell(q,0);
				for w:=0 to cmax do
					begin
						case cell^.Typ of
						CTYPE_TEXT:
							if udomask(cell^.Data.Txt^) then goto _ende;
						CTYPE_CONST:
							if udomask(p^.Val2TxtF(cell^.Data.Konst^.Value,cell^.Data.Konst^.FPts,cell^.Format,nil)) then goto _ende;
						CTYPE_FORMULA:
							if udomask(p^.Val2TxtF(cell^.Data.Formula^.Value,cell^.Data.Formula^.FPts,cell^.Format,nil)) then goto _ende
						end;
						if w<cmax then
							if writes(' !! ') then goto _ende;
						inc(longint(cell),CELLSIZE)
					end;
				if writeline('') then goto _ende
			end;
		if p^.Parms.psbuffer.gitter=bf_Checked then
			if writeline('!hline') then goto _ende;
		if writeline('!end_table') then goto _ende;
		bwrite(q,-1);
		{$ENDIF}
		_ende:
		fclose(hdl);
		freemem(buf,bufsize);
		ArrowMouse;
		ExitFile(SCF_TEXT,fname,texbuf)
	end;


procedure TDateButton.Changed(AnIndx: integer; DblClick: boolean);
	var p: PFillDialog;
	    q: integer;

	begin
		p:=PFillDialog(Parent);
		if AnIndx=RTRDATE then
			begin
				p^.rb5^.Enable;
				p^.rb6^.Enable;
				p^.rb7^.Enable;
				p^.rb8^.Enable
			end
		else
			begin
				q:=p^.rb5^.GetCheck;
				p^.rb5^.Disable;
				p^.rb5^.SetCheck(q);
				q:=p^.rb6^.GetCheck;
				p^.rb6^.Disable;
				p^.rb6^.SetCheck(q);
				q:=p^.rb7^.GetCheck;
				p^.rb7^.Disable;
				p^.rb7^.SetCheck(q);
				q:=p^.rb8^.GetCheck;
				p^.rb8^.Disable;
				p^.rb8^.SetCheck(q)
			end;
		if AnIndx=RTRCOPY then
			begin
				p^.ed1^.Disable;
				p^.ed2^.Disable
			end
		else
			if p^.ptb^.GetCheck=bf_Unchecked then
				begin
					p^.ed1^.Enable;
					p^.ed2^.Enable
				end
	end;


procedure TTrendButton.Changed(AnIndx: integer; DblClick: boolean);
	var p: PFillDialog;

	begin
		p:=PFillDialog(Parent);
		if GetCheck=bf_Checked then
			begin
				p^.ed1^.Disable;
				p^.ed2^.Disable;
				if p^.rb3^.GetCheck=bf_Checked then
					begin
						p^.rb3^.Uncheck;
						p^.rb1^.Check;
						p^.rb1^.Changed(RTRARITHM,false)
					end
				else
					if p^.rb4^.GetCheck=bf_Checked then
						begin
							p^.rb4^.Uncheck;
							p^.rb1^.Check
						end;
				p^.rb3^.Disable;
				p^.rb4^.Disable
			end
		else
			begin
				p^.ed1^.Enable;
				p^.ed2^.Enable;
				p^.rb3^.Enable;
				p^.rb4^.Enable
			end
	end;


function TFillDialog.ExitDlg(AnIndx: integer): boolean;
	var p: PCalcWindow;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTRBEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTRCALC:
			begin
				{ ... }
				Application^.Bing
			end
		end
	end;


procedure TFillDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk)
	end;


function TFillDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTRCALC);
		OK:=valid
	end;


procedure TFill.HandleMenu(Indx: integer);
	var p : PCalcWindow;
	    pb: PButton;

	begin
		p:=PCalcWindow(Parent);
		case Indx of
		0:
			{ ... };
		1:
			{ ... };
		2:
			{ ... };
		3:
			{ ... };
		5:
			begin
				if reihe=nil then
					begin
						new(reihe,Init(p,TEXELWINDPREFIX+TITLE_FILL,STG_FILL,ICNTITLE_FILL,RTREIHE));
						if reihe<>nil then
							begin
								new(PGroupBox,Init(reihe,RTRBEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
								new(PGroupBox,Init(reihe,RTRWHERE,'Reihe in',''));
								new(PGroupBox,Init(reihe,RTRTYPE,'Typ',''));
								new(PGroupBox,Init(reihe,RTRTIME,'Zeiteinheit',''));
								new(PGroupBox,Init(reihe,RTRSTEP,'',''));
								new(reihe^.bedt,Init(reihe,RTRBEDIT,16,false,BUBBLE_GENERAL_RANGE));
								new(PRadioButton,Init(reihe,RTRROWS,true,BUBBLE_FILL_ROWS));
								new(PRadioButton,Init(reihe,RTRCOLUMNS,true,BUBBLE_FILL_COLUMNS));
								new(reihe^.rb1,Init(reihe,RTRARITHM,true,BUBBLE_FILL_ARITHM));
								new(reihe^.rb2,Init(reihe,RTRGEOM,true,BUBBLE_FILL_GEOM));
								new(reihe^.rb3,Init(reihe,RTRDATE,true,BUBBLE_FILL_DATE));
								new(reihe^.rb4,Init(reihe,RTRCOPY,true,BUBBLE_FILL_COPY));
								new(reihe^.ptb,Init(reihe,RTRTREND,true,BUBBLE_FILL_TREND));
								new(reihe^.rb5,Init(reihe,RTRDAY,true,BUBBLE_FILL_RDAY));
								new(reihe^.rb6,Init(reihe,RTRWEEKDAY,true,BUBBLE_FILL_RWEEKDAY));
								new(reihe^.rb7,Init(reihe,RTRMONTH,true,BUBBLE_FILL_RMONTH));
								new(reihe^.rb8,Init(reihe,RTRYEAR,true,BUBBLE_FILL_RYEAR));
								new(reihe^.ed1,Init(reihe,RTRSTEPVAL,13,BUBBLE_FILL_STEPVAL));
								new(reihe^.ed2,Init(reihe,RTRENDVAL,13,BUBBLE_FILL_ENDVAL));
								new(pb,Init(reihe,RTRHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(PButton,Init(reihe,RTRABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								new(pb,Init(reihe,RTRCALC,id_No,true,BUBBLE_FILL_CALC));
								if pb<>nil then pb^.Disable; { ... }
								new(pb,Init(reihe,RTROK,id_OK,true,BUBBLE_FILL_OK));
								if pb<>nil then pb^.Disable; { ... }
								reihe^.TransferBuffer:=@p^.fillbuf
							end
					end;
				if reihe<>nil then
					begin
						reihe^.bedt^.SetText(StrPTrimF(p^.dblock^.GetText));
						if p^.fillbuf.date=bf_Checked then reihe^.rb3^.Changed(RTRDATE,false)
						else
							reihe^.rb3^.Changed(-1,false);
						reihe^.MakeWindow;
						reihe^.ptb^.Changed(RTRTREND,false)
					end
			end
		end
	end;


procedure TFormCell.HandleMenu(Indx: integer);
	var p   : PCalcWindow;
	    cell: PCell;

	begin
		p:=PCalcWindow(Parent);
		cell:=p^.GetCell(p^.Parms.Cursor.Row,p^.Parms.Cursor.Col);
		case Indx of
		0:
			p^.FontSelect;
		1:
			p^.AttrDialogs(0,0,cell);
		2:
			p^.AttrDialogs(1,0,cell);
		3:
			p^.AttrDialogs(6,0,cell);
		4:
			p^.AttrDialogs(5,0,cell)
		end
	end;


procedure TFormRow.HandleMenu(Indx: integer);
	var p    : PCalcWindow;
	    rs,re,
	    dummy: integer;

	begin
		p:=PCalcWindow(Parent);
		p^.GetBlock(p^.dblock^.GetText,false,rs,dummy,re,dummy,dummy,dummy);
		case Indx of
		0:
			p^.AttrDialogs(2,rs,nil);
		1:
			{ ... };
		2:
			p^.StandardHoehe(rs,re);
		4:
			{ ... };
		5:
			{ ... }
		end
	end;


procedure TFormCol.HandleMenu(Indx: integer);
	var p    : PCalcWindow;
	    cs,ce,
	    dummy: integer;

	begin
		p:=PCalcWindow(Parent);
		p^.GetBlock(p^.dblock^.GetText,false,dummy,cs,dummy,ce,dummy,dummy);
		case Indx of
		0:
			p^.AttrDialogs(3,cs,nil);
		1:
			{ ... };
		2:
			p^.StandardBreite(cs,ce);
		4:
			p^.AttrDialogs(4,cs,nil);
		6:
			{ ... };
		7:
			{ ... }
		end
	end;


procedure TObjects.HandleMenu(Indx: integer);
	var p : PCalcWindow;
	    pe: PEmbedded;
	    pb: PButton;

	begin
		p:=PCalcWindow(Parent);
		case Indx of
		0:
			begin
				pe:=p^.Embedded;
				while pe<>nil do
					begin
						pe^.SetEmbedFlag;
						pe:=pe^.Next
					end
			end;
		1:
			begin
				pe:=p^.Embedded;
				while pe<>nil do
					begin
						pe^.ClearEmbedFlag;
						pe:=pe^.Next
					end
			end;
		3:
			begin
				pe:=p^.Embedded;
				while pe<>nil do
					begin
						if not(pe^.IsLocked) then
							begin
								pe^.Lock;
								pe^.Redraw
							end;
						pe:=pe^.Next
					end
			end;
		4:
			begin
				pe:=p^.Embedded;
				while pe<>nil do
					begin
						if pe^.IsLocked then
							begin
								pe^.Unlock;
								pe^.Redraw
							end;
						pe:=pe^.Next
					end
			end;
		6:
			begin
				pe:=p^.Embedded;
				while pe<>nil do
					begin
						pe^.SetPrintFlag;
						pe:=pe^.Next
					end
			end;
		7:
			begin
				pe:=p^.Embedded;
				while pe<>nil do
					begin
						pe^.ClearPrintFlag;
						pe:=pe^.Next
					end
			end;
		9:
			begin
				if p^.links=nil then
					begin
						TexelApp.ActivateExtResource;
						new(p^.links,Init(p,TEXELWINDPREFIX+TITLE_LINKS,STG_LINKS,ICNTITLE_LINKS,RTLINKS));
						if p^.links<>nil then
							begin
								new(p^.links^.linklist,Init(20,10));
								new(p^.links^.plb,Init(p^.links,RTLILIST,RTLISLID,RTLIDEC,RTLIINC,p^.links^.linklist,true,BUBBLE_LINK_LIST));
								new(pb,Init(p^.links,RTLIHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(p^.links^.pb1,Init(p^.links,RTLICHANGE,id_No,true,BUBBLE_LINK_CHANGE));
								new(p^.links^.pb2,Init(p^.links,RTLIACTIVATE,id_No,true,BUBBLE_LINK_ACTIVATE));
								new(p^.links^.pb3,Init(p^.links,RTLIEDIT,id_No,true,BUBBLE_LINK_EDIT));
								new(PButton,Init(p^.links,RTLIOK,id_OK,true,BUBBLE_GENERAL_CLOSE));
								if p^.links^.linklist<>nil then
									begin
										pe:=p^.Embedded;
										while pe<>nil do
											begin
												p^.links^.AddObject(pe);
												pe:=pe^.Next
											end
									end
							end;
						TexelApp.DeactivateExtResource
					end;
				if p^.links<>nil then
					begin
						pe:=p^.FirstSelectedObject;
						p^.links^.MakeWindow;
						p^.links^.UpdateList(pe)
					end
			end
		end
	end;


procedure TClear.HandleMenu(Indx: integer);
	var p    : PCalcWindow;
	    x,y,
	    cmin,
	    cmax,
	    rs,cs,
	    re,ce: integer;
	    cell : PCell;
	    valid: boolean;

	begin
		p:=PCalcWindow(Parent);
		with p^.Parms.Cursor do
			if Block then
				begin
					rs:=RowStart;
					re:=RowEnd;
					cs:=ColStart;
					ce:=ColEnd
				end
			else
				begin
					rs:=Row;
					re:=Row;
					cs:=Col;
					ce:=Col
				end;
		case Indx of
		0:
			p^.DeleteCells;
		1:
			begin
				cmin:=cs;
				cmax:=ce;
				p^.RowsClearOverflow(rs,re,cmin,cmax);
				for y:=rs to re do
					begin
						cell:=p^.GetCell(y,cs);
						for x:=cs to ce do
							begin
								with cell^ do
									begin
										Flags:=Flags and not(CELL_EMPTYMASK);
										Color:=Black;
										Style:=8;
										Interior:=FIS_HOLLOW;
										Border.Val1:=0;
										Border.Val2:=0;
										Format:=0;
										with TxtVal do
											begin
												if Typ=0 then
													begin
														Font:=0;
														Size:=0;
														Align:=0
													end;
												Rotat:=0;
												Skew:=0;
												Color:=Black;
												Effects:=0;
												Flags:=0
											end
									end;
								inc(longint(cell),CELLSIZE)
							end
					end;
				p^.RowsCheckOverflow(rs,re,cmin,cmax);
				p^.SetDirty;
				p^.DrawCells(rs,cmin,re,cmax)
			end;
		2:
			begin
				cmin:=cs;
				cmax:=ce;
				p^.RowsClearOverflow(rs,re,cmin,cmax);
				valid:=p^.FreeBlock(rs,cs,re,ce,false);
				p^.RowsCheckOverflow(rs,re,cmin,cmax);
				if valid then
					begin
						p^.SetDirty;
						p^.DrawCells(rs,cmin,re,cmax);
						p^.AutoCalculate(true)
					end
				else
					Application^.Bing
			end;
		3:
			{ Notizen l”schen... }
		end
	end;


function TClearCellDialog.ExitDlg(AnIndx: integer): boolean;
	var rs,cs,re,ce,
	    rw,cl,dummy: integer;
	    cell       : PCell;
	    p          : PCalcWindow;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTCCBEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTCCZEILE:
			with p^ do
				if GetBlock(bedt^.GetText,false,rs,cs,re,ce,dummy,dummy) then
					begin
						if (cs=0) and (ce=Parms.Columns) then exit;
						DrawCursor;
						DeselectAll;
						with Parms.Cursor do
							begin
								Block:=true;
								RowStart:=rs;
								ColStart:=0;
								RowEnd:=re;
								ColEnd:=Parms.Columns
							end;
						SetBlock;
						for rw:=rs to re do
							begin
								cell:=GetCell(rw,0);
								for cl:=0 to Parms.Columns do
									begin
										with cell^ do Flags:=Flags or CELL_SELECTED;
										inc(longint(cell),CELLSIZE)
									end
							end;
						DrawCursor
					end
				else
					Application^.Bing;
		RTCCSPALTE:
			with p^ do
				if GetBlock(bedt^.GetText,false,rs,cs,re,ce,dummy,dummy) then
					begin
						if (rs=0) and (re=Parms.Rows) then exit;
						DrawCursor;
						DeselectAll;
						with Parms.Cursor do
							begin
								Block:=true;
								RowStart:=0;
								ColStart:=cs;
								RowEnd:=Parms.Rows;
								ColEnd:=ce
							end;
						SetBlock;
						for rw:=0 to Parms.Rows do
							begin
								cell:=GetCell(rw,cs);
								for cl:=cs to ce do
									begin
										with cell^ do Flags:=Flags or CELL_SELECTED;
										inc(longint(cell),CELLSIZE)
									end
							end;
						DrawCursor
					end
				else
					Application^.Bing
		end
	end;


procedure TClearCellDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk);
		CheckButtons
	end;


procedure TClearCellDialog.CheckButtons;
	var rs,cs,re,
	    ce,dummy: integer;
	    p       : PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		if not(p^.GetBlock(bedt^.GetText,false,rs,cs,re,ce,dummy,dummy)) then exit;
		if (rs=0) and (cs=0) and (re=p^.Parms.Rows) and (ce=p^.Parms.Columns) then
			begin
				rb2^.Disable;
				rb2^.Uncheck;
				rb3^.Disable;
				rb3^.Uncheck;
				rb4^.Disable;
				rb4^.Uncheck;
				rb5^.Disable;
				rb5^.Uncheck;
				rb1^.Check
			end
		else
			if (cs=0) and (ce=p^.Parms.Columns) then
				begin
					rb4^.Enable;
					rb5^.Enable;
					if (rb2^.GetCheck=bf_Checked) or (rb3^.GetCheck=bf_Checked) then rb4^.Check;
					rb2^.Disable;
					rb3^.Disable;
					rb2^.Uncheck;
					rb3^.Uncheck;
					if rs=0 then
						begin
							if rb5^.GetCheck=bf_Checked then
								begin
									rb5^.Uncheck;
									rb4^.Check
								end;
							rb5^.Disable
						end
					else
						if re=p^.Parms.Rows then
							begin
								if rb4^.GetCheck=bf_Checked then
									begin
										rb4^.Uncheck;
										rb5^.Check
									end;
								rb4^.Disable
							end
				end
			else
				if (rs=0) and (re=p^.Parms.Rows) then
					begin
						rb2^.Enable;
						rb3^.Enable;
						if (rb4^.GetCheck=bf_Checked) or (rb5^.GetCheck=bf_Checked) then rb2^.Check;
						rb4^.Disable;
						rb5^.Disable;
						rb4^.Uncheck;
						rb5^.Uncheck;
						if cs=0 then
							begin
								if rb3^.GetCheck=bf_Checked then
									begin
										rb3^.Uncheck;
										rb2^.Check
									end;
								rb3^.Disable
							end
						else
							if ce=p^.Parms.Columns then
								begin
									if rb2^.GetCheck=bf_Checked then
										begin
											rb2^.Uncheck;
											rb3^.Check
										end;
									rb2^.Disable
								end
					end
				else
					begin
						rb2^.Enable;
						rb3^.Enable;
						rb4^.Enable;
						rb5^.Enable;
						if cs=0 then
							begin
								if rb3^.GetCheck=bf_Checked then
									begin
										rb3^.Uncheck;
										rb1^.Check
									end;
								rb3^.Disable
							end
						else
							if ce=p^.Parms.Columns then
								begin
									if rb2^.GetCheck=bf_Checked then
										begin
											rb2^.Uncheck;
											rb1^.Check
										end;
									rb2^.Disable
								end;
						if rs=0 then
							begin
								if rb5^.GetCheck=bf_Checked then
									begin
										rb5^.Uncheck;
										rb1^.Check
									end;
								rb5^.Disable
							end
						else
							if re=p^.Parms.Rows then
								begin
									if rb4^.GetCheck=bf_Checked then
										begin
											rb4^.Uncheck;
											rb1^.Check
										end;
									rb4^.Disable
								end
					end
	end;


function TClearCellDialog.OK: boolean;
	var valid,
	    movesize : boolean;
	    p        : PCalcWindow;
	    rs,cs,
	    re,ce,
	    r,rbis,
	    c,cbis,
	    x,cdif,
	    y,rdif,
	    cmin,cmax,
	    rmin,rmax,
	    dummy    : integer;
	    ocell,
	    cell     : PCell;
	    oldsel   : byte;

	begin
		valid:=inherited OK;
		if valid then
			begin
				p:=PCalcWindow(Parent);
				if rb1^.GetCheck=bf_Checked then p^.DeleteCells
				else
					begin
						BusyMouse;
						p^.GetBlock(p^.dblock^.GetText,false,rs,cs,re,ce,dummy,dummy);
						if rb2^.GetCheck=bf_Checked then
							begin
								rmin:=rs;
								rmax:=re;
								cmin:=cs;
								cmax:=p^.Parms.Columns
							end
						else if rb3^.GetCheck=bf_Checked then
							begin
								rmin:=rs;
								rmax:=re;
								cmin:=0;
								cmax:=ce
							end
						else if rb4^.GetCheck=bf_Checked then
							begin
								rmin:=rs;
								rmax:=p^.Parms.Rows;
								cmin:=cs;
								cmax:=ce
							end
						else
							begin
								rmin:=0;
								rmax:=re;
								cmin:=cs;
								cmax:=ce
							end;
						p^.RowsClearOverflow(rmin,rmax,cmin,cmax);
						p^.FreeBlock(rs,cs,re,ce,true);
						if rb2^.GetCheck=bf_Checked then
							begin
								movesize:=(rs=0) and (re=p^.Parms.Rows);
								c:=ce+1;
								cbis:=p^.Parms.Columns;
								r:=rs;
								rbis:=re;
								if movesize then
									for x:=c to cbis do p^.PCol^[cs+x-c]:=p^.PCol^[x];
								for y:=r to rbis do
									begin
										cell:=p^.GetCell(y,cs);
										ocell:=p^.GetCell(y,c);
										for x:=c to cbis do
											begin
												oldsel:=cell^.Flags and CELL_SELECTED;
												cell^:=ocell^;
												cell^.Flags:=(cell^.Flags and CELL_EMPTYMASK) or oldsel;
												inc(longint(cell),CELLSIZE);
												inc(longint(ocell),CELLSIZE)
											end
									end;
								p^.ClearBlock(r,cbis-Min(ce-cs,cbis-c),rbis,cbis);
								if movesize then
									for x:=cbis-Min(ce-cs,cbis-c) to cbis do p^.PCol^[x]:=p^.PCol^[x-1];
								cdif:=cs-ce-1;
								rdif:=0;
								ce:=cbis
							end
						else
							if rb3^.GetCheck=bf_Checked then
								begin
									movesize:=(rs=0) and (re=p^.Parms.Rows);
									c:=0;
									cbis:=cs-1;
									r:=rs;
									rbis:=re;
									if movesize then
										for x:=cbis downto c do p^.PCol^[ce+x-cbis]:=p^.PCol^[x];
									for y:=r to rbis do
										begin
											cell:=p^.GetCell(y,ce);
											ocell:=p^.GetCell(y,cbis);
											for x:=cbis downto c do
												begin
													oldsel:=cell^.Flags and CELL_SELECTED;
													cell^:=ocell^;
													cell^.Flags:=(cell^.Flags and CELL_EMPTYMASK) or oldsel;
													dec(longint(cell),CELLSIZE);
													dec(longint(ocell),CELLSIZE)
												end
										end;
									p^.ClearBlock(r,0,rbis,Min(ce-cs,cbis-c));
									if movesize then
										for x:=Min(ce-cs,cbis-c) downto 0 do p^.PCol^[x]:=p^.PCol^[x+1];
									cdif:=ce+1-cs;
									rdif:=0;
									cs:=0
								end
							else
								if rb4^.GetCheck=bf_Checked then
									begin
										movesize:=(cs=0) and (ce=p^.Parms.Columns);
										c:=cs;
										cbis:=ce;
										r:=re+1;
										rbis:=p^.Parms.Rows;
										for y:=r to rbis do
											begin
												cell:=p^.GetCell(rs+y-r,c);
												ocell:=p^.GetCell(y,c);
												if movesize then p^.PRow^[rs+y-r]:=p^.PRow^[y];
												for x:=c to cbis do
													begin
														oldsel:=cell^.Flags and CELL_SELECTED;
														cell^:=ocell^;
														cell^.Flags:=(cell^.Flags and CELL_EMPTYMASK) or oldsel;
														inc(longint(cell),CELLSIZE);
														inc(longint(ocell),CELLSIZE)
													end
											end;
										p^.ClearBlock(rbis-Min(re-rs,rbis-r),c,rbis,cbis);
										if movesize then
											for y:=rbis-Min(re-rs,rbis-r) to rbis do p^.PRow^[y]:=p^.PRow^[y-1];
										cdif:=0;
										rdif:=rs-re-1;
										re:=rbis
									end
								else
									begin
										movesize:=(cs=0) and (ce=p^.Parms.Columns);
										c:=cs;
										cbis:=ce;
										r:=0;
										rbis:=rs-1;
										for y:=rbis downto r do
											begin
												cell:=p^.GetCell(re+y-rbis,c);
												ocell:=p^.GetCell(y,c);
												if movesize then p^.PRow^[re+y-rbis]:=p^.PRow^[y];
												for x:=c to cbis do
													begin
														oldsel:=cell^.Flags and CELL_SELECTED;
														cell^:=ocell^;
														cell^.Flags:=(cell^.Flags and CELL_EMPTYMASK) or oldsel;
														inc(longint(cell),CELLSIZE);
														inc(longint(ocell),CELLSIZE)
													end
											end;
										p^.ClearBlock(0,c,Min(re-rs,rbis-r),cbis);
										if movesize then
											for y:=Min(re-rs,rbis-r) downto 0 do p^.PRow^[y]:=p^.PRow^[y+1];
										cdif:=0;
										rdif:=re+1-rs;
										rs:=0
									end;
						p^.TranslateCells(r,c,rbis,cbis,rdif,cdif,true);
						p^.RowsCheckOverflow(rmin,rmax,cmin,cmax);
						p^.SetDirty;
						if movesize then
							begin
								p^.SetScrollerRange;
								p^.ForceVRedraw
							end
						else
							p^.DrawCells(rmin,cmin,rmax,cmax);
						p^.AutoCalculate(true);
						ArrowMouse
					end
			end;
		OK:=valid
	end;


procedure TClearCell.Work;
	var p : PCalcWindow;
	    pb: PButton;

	begin
		p:=PCalcWindow(Parent);
		if ADialog=nil then
			begin
				ADialog:=new(PClearCellDialog,Init(p,TEXELWINDPREFIX+TITLE_CLEAR,STG_CLEAR,ICNTITLE_CLEAR,RTCLEARCELL));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTCCBEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
						new(PGroupBox,Init(ADialog,RTCCFILL,GROUP_DELCELL_FILL,''));
						new(PClearCellDialog(ADialog)^.bedt,Init(ADialog,RTCCBEDIT,16,false,BUBBLE_GENERAL_RANGE));
						new(PClearCellDialog(ADialog)^.rb1,Init(ADialog,RTCCEMPTY,true,BUBBLE_CLEAR_FILL));
						new(PClearCellDialog(ADialog)^.rb2,Init(ADialog,RTCCLEFT,true,BUBBLE_CLEAR_LEFT));
						new(PClearCellDialog(ADialog)^.rb3,Init(ADialog,RTCCRIGHT,true,BUBBLE_CLEAR_RIGHT));
						new(PClearCellDialog(ADialog)^.rb4,Init(ADialog,RTCCUP,true,BUBBLE_CLEAR_UP));
						new(PClearCellDialog(ADialog)^.rb5,Init(ADialog,RTCCDOWN,true,BUBBLE_CLEAR_DOWN));
						new(pb,Init(ADialog,RTCCHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTCCZEILE,id_No,true,BUBBLE_CLEAR_ROW));
						new(PButton,Init(ADialog,RTCCSPALTE,id_No,true,BUBBLE_CLEAR_COLUMN));
						new(PButton,Init(ADialog,RTCCABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTCCOK,id_OK,true,BUBBLE_CLEAR_OK));
						with p^.tccbuffer do
							begin
								empty:=bf_Unchecked;
								left:=bf_Checked;
								right:=bf_Unchecked;
								up:=bf_Unchecked;
								down:=bf_Unchecked
							end;
						ADialog^.TransferBuffer:=@p^.tccbuffer
					end
			end;
		if ADialog<>nil then
			begin
				PClearCellDialog(ADialog)^.bedt^.SetText(StrPTrimF(p^.dblock^.GetText));
				ADialog^.TransferData(tf_SetData);
				ADialog^.MakeWindow;
				PClearCellDialog(ADialog)^.CheckButtons
			end
	end;


function TInsertCellDialog.ExitDlg(AnIndx: integer): boolean;
	var rs,cs,re,ce,
	    rw,cl,dummy: integer;
	    cell       : PCell;
	    p          : PCalcWindow;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTCCBEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTCCZEILE:
			with p^ do
				if GetBlock(bedt^.GetText,false,rs,cs,re,ce,dummy,dummy) then
					begin
						if (cs=0) and (ce=Parms.Columns) then exit;
						DrawCursor;
						DeselectAll;
						with Parms.Cursor do
							begin
								Block:=true;
								RowStart:=rs;
								ColStart:=0;
								RowEnd:=re;
								ColEnd:=Parms.Columns
							end;
						SetBlock;
						for rw:=rs to re do
							begin
								cell:=GetCell(rw,0);
								for cl:=0 to Parms.Columns do
									begin
										with cell^ do Flags:=Flags or CELL_SELECTED;
										inc(longint(cell),CELLSIZE)
									end
							end;
						DrawCursor
					end
				else
					Application^.Bing;
		RTCCSPALTE:
			with p^ do
				if GetBlock(bedt^.GetText,false,rs,cs,re,ce,dummy,dummy) then
					begin
						if (rs=0) and (re=Parms.Rows) then exit;
						DrawCursor;
						DeselectAll;
						with Parms.Cursor do
							begin
								Block:=true;
								RowStart:=0;
								ColStart:=cs;
								RowEnd:=Parms.Rows;
								ColEnd:=ce
							end;
						SetBlock;
						for rw:=0 to Parms.Rows do
							begin
								cell:=GetCell(rw,cs);
								for cl:=cs to ce do
									begin
										with cell^ do Flags:=Flags or CELL_SELECTED;
										inc(longint(cell),CELLSIZE)
									end
							end;
						DrawCursor
					end
				else
					Application^.Bing
		end
	end;


procedure TInsertCellDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk);
		CheckButtons
	end;


procedure TInsertCellDialog.CheckButtons;
	var rs,cs,re,
	    ce,dummy: integer;
	    oldcheck: PRadioButton;
	    p       : PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		if not(p^.GetBlock(bedt^.GetText,false,rs,cs,re,ce,dummy,dummy)) then exit;
		if (rs=0) and (cs=0) and (re=p^.Parms.Rows) and (ce=p^.Parms.Columns) then
			begin
				rb2^.Disable;
				rb2^.Uncheck;
				rb3^.Disable;
				rb3^.Uncheck;
				rb4^.Disable;
				rb4^.Uncheck;
				rb5^.Disable;
				rb5^.Uncheck;
				pb^.Disable
			end
		else
			begin
				oldcheck:=nil;
				if rb2^.GetCheck=bf_Checked then oldcheck:=rb2
				else
					if rb3^.GetCheck=bf_Checked then oldcheck:=rb3
					else
						if rb4^.GetCheck=bf_Checked then oldcheck:=rb4
						else
							if rb5^.GetCheck=bf_Checked then oldcheck:=rb5;
				if cs=0 then
					begin
						rb2^.Disable;
						rb2^.Uncheck
					end
				else
					rb2^.Enable;
				if ce=p^.Parms.Columns then
					begin
						rb3^.Disable;
						rb3^.Uncheck
					end
				else
					rb3^.Enable;
				if rs=0 then
					begin
						rb4^.Disable;
						rb4^.Uncheck
					end
				else
					rb4^.Enable;
				if re=p^.Parms.Rows then
					begin
						rb5^.Disable;
						rb5^.Uncheck
					end
				else
					rb5^.Enable;
				if oldcheck=nil then
					begin
						if rb3^.GetState=bf_Enabled then rb3^.Check
						else
							if rb5^.GetState=bf_Enabled then rb5^.Check
							else
								if rb4^.GetState=bf_Enabled then rb4^.Check
								else
									rb2^.Check
					end
				else
					if oldcheck^.GetCheck<>bf_Checked then
						begin
							if rb3^.GetState=bf_Enabled then rb3^.Check
							else
								if rb5^.GetState=bf_Enabled then rb5^.Check
								else
									if rb4^.GetState=bf_Enabled then rb4^.Check
									else
										rb2^.Check
						end;
				pb^.Enable
			end
	end;


function TInsertCellDialog.OK: boolean;
	var valid: boolean;
	    p    : PCalcWindow;
	    rs,cs,
	    re,ce,
	    dir,
	    dummy: integer;

	begin
		valid:=inherited OK;
		if valid then
			begin
				p:=PCalcWindow(Parent);
				p^.GetBlock(p^.dblock^.GetText,false,rs,cs,re,ce,dummy,dummy);
				if rb2^.GetCheck=bf_Checked then dir:=CRS_LEFT
				else
					if rb3^.GetCheck=bf_Checked then dir:=CRS_RIGHT
					else
						if rb4^.GetCheck=bf_Checked then dir:=CRS_UP
						else
							dir:=CRS_DOWN;
				p^.InsertCells(rs,cs,re,ce,dir)
			end;
		OK:=valid
	end;


procedure TInsertCell.Work;
	var p : PCalcWindow;
	    pb: PButton;

	begin
		p:=PCalcWindow(Parent);
		if ADialog=nil then
			begin
				ADialog:=new(PInsertCellDialog,Init(p,TEXELWINDPREFIX+TITLE_INSERT,STG_INSERT,ICNTITLE_INSERT,RTINSERTCELLS));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTICBEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
						new(PGroupBox,Init(ADialog,RTICMOVE,'',''));
						new(PInsertCellDialog(ADialog)^.bedt,Init(ADialog,RTICBEDIT,16,false,BUBBLE_GENERAL_RANGE));
						new(PInsertCellDialog(ADialog)^.rb2,Init(ADialog,RTICLEFT,true,BUBBLE_INSERT_LEFT));
						new(PInsertCellDialog(ADialog)^.rb3,Init(ADialog,RTICRIGHT,true,BUBBLE_INSERT_RIGHT));
						new(PInsertCellDialog(ADialog)^.rb4,Init(ADialog,RTICUP,true,BUBBLE_INSERT_UP));
						new(PInsertCellDialog(ADialog)^.rb5,Init(ADialog,RTICDOWN,true,BUBBLE_INSERT_DOWN));
						new(pb,Init(ADialog,RTICHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTICZEILE,id_No,true,BUBBLE_INSERT_ROW));
						new(PButton,Init(ADialog,RTICSPALTE,id_No,true,BUBBLE_INSERT_COLUMN));
						new(PButton,Init(ADialog,RTICABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PInsertCellDialog(ADialog)^.pb,Init(ADialog,RTICOK,id_OK,true,BUBBLE_INSERT_OK));
						with p^.ticbuffer do
							begin
								left:=bf_Unchecked;
								right:=bf_Checked;
								up:=bf_Unchecked;
								down:=bf_Unchecked
							end;
						ADialog^.TransferBuffer:=@p^.ticbuffer
					end
			end;
		if ADialog<>nil then
			begin
				PInsertCellDialog(ADialog)^.bedt^.SetText(StrPTrimF(p^.dblock^.GetText));
				ADialog^.TransferData(tf_SetData);
				ADialog^.MakeWindow;
				PInsertCellDialog(ADialog)^.CheckButtons
			end
	end;


procedure TInsButton.Changed(AnIndx: integer; DblClick: boolean);

	begin
		PInsertDialog(Parent)^.CheckButtons
	end;


function TInsertDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		case AnIndx of
		RTINBEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTININS:
			OK
		end
	end;


procedure TInsertDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk)
	end;


procedure TInsertDialog.CheckButtons;
	var q: integer;

	begin
		if (rb^.GetCheck=bf_Checked) or (rb0^.GetCheck=bf_Checked) then
			begin
				q:=rb1^.GetCheck;
				rb1^.Disable;
				rb1^.SetCheck(q);
				q:=rb2^.GetCheck;
				rb2^.Disable;
				rb2^.SetCheck(q);
				q:=rb3^.GetCheck;
				rb3^.Disable;
				rb3^.SetCheck(q);
				q:=rb4^.GetCheck;
				rb4^.Disable;
				rb4^.SetCheck(q);
				q:=rb5^.GetCheck;
				rb5^.Disable;
				rb5^.SetCheck(q);
				cb^.Disable
			end
		else
			begin
				rb1^.Enable;
				rb2^.Enable;
				rb3^.Enable;
				rb4^.Enable;
				rb5^.Enable;
				cb^.Enable
			end
	end;


function TInsertDialog.OK: boolean;
	var valid: boolean;
	    what,
	    op   : integer;

	begin
		valid:=inherited OK;
		if valid then
			with PCalcWindow(Parent)^ do
				begin
					with tibuffer do
						begin
							if formula=bf_Checked then what:=INS_FORMULA
							else
								if value=bf_Checked then what:=INS_VALUE
								else
									if format=bf_Checked then what:=INS_FORMAT
									else
										if note=bf_Checked then what:=INS_NOTE
										else
											what:=INS_ALL;
							if rb1^.GetState=bf_Disabled then op:=INS_OP_NONE
							else
								if add=bf_Checked then op:=INS_OP_ADD
								else
									if sub=bf_Checked then op:=INS_OP_SUB
									else
										if mul=bf_Checked then op:=INS_OP_MUL
										else
											if divide=bf_Checked then op:=INS_OP_DIV
											else
												op:=INS_OP_NONE
						end;
					InsertFromClipboard(what,op,(tibuffer.empty=bf_Checked) and (cb^.GetState=bf_Enabled),(tibuffer.transpose=bf_Checked),true,false)
				end;
		OK:=valid
	end;


procedure TInsert.Work;
	var p : PCalcWindow;
	    pb: PButton;
	    rb: PInsButton;

	begin
		p:=PCalcWindow(Parent);
		if ADialog=nil then
			begin
				ADialog:=new(PInsertDialog,Init(p,TEXELWINDPREFIX+TITLE_INSVAL,STG_INSVAL,ICNTITLE_INSVAL,RTINSERT));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTINBEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
						new(PGroupBox,Init(ADialog,RTINWHAT,GROUP_INSERT_PASTE,''));
						new(PGroupBox,Init(ADialog,RTINOPERATION,GROUP_INSERT_OPERATION,''));
						new(PGroupBox,Init(ADialog,RTINOPTIONS,'',''));
						new(PInsertDialog(ADialog)^.bedt,Init(ADialog,RTINBEDIT,16,false,BUBBLE_GENERAL_RANGE));
						new(PInsButton,Init(ADialog,RTINALL,true,BUBBLE_INSVAL_ALL));
						new(PInsButton,Init(ADialog,RTINFORMULA,true,BUBBLE_INSVAL_FORMULA));
						new(PInsButton,Init(ADialog,RTINVALUE,true,BUBBLE_INSVAL_VALUE));
						new(PInsertDialog(ADialog)^.rb,Init(ADialog,RTINFORMATS,true,BUBBLE_INSVAL_FORMAT));
						new(rb,Init(ADialog,RTINNOTES,true,BUBBLE_INSVAL_NOTE));
						PInsertDialog(ADialog)^.rb0:=rb;
						if rb<>nil then rb^.Disable; { ... }
						new(PInsertDialog(ADialog)^.rb1,Init(ADialog,RTINNONE,true,BUBBLE_INSVAL_OPNONE));
						new(PInsertDialog(ADialog)^.rb2,Init(ADialog,RTINADD,true,BUBBLE_INSVAL_OPADD));
						new(PInsertDialog(ADialog)^.rb3,Init(ADialog,RTINSUB,true,BUBBLE_INSVAL_OPSUB));
						new(PInsertDialog(ADialog)^.rb4,Init(ADialog,RTINMUL,true,BUBBLE_INSVAL_OPMUL));
						new(PInsertDialog(ADialog)^.rb5,Init(ADialog,RTINDIV,true,BUBBLE_INSVAL_OPDIV));
						new(PInsertDialog(ADialog)^.cb,Init(ADialog,RTINEMPTY,true,BUBBLE_INSVAL_EMPTY));
						new(PCheckBox,Init(ADialog,RTINTRANSPOSE,true,BUBBLE_INSVAL_TRANSPOSE));
						new(pb,Init(ADialog,RTINHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTINABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTININS,id_No,true,BUBBLE_INSVAL_INSERT));
						new(PButton,Init(ADialog,RTINOK,id_OK,true,BUBBLE_INSVAL_OK));
						with p^.tibuffer do
							begin
								all:=bf_Checked;
								formula:=bf_Unchecked;
								value:=bf_Unchecked;
								format:=bf_Unchecked;
								note:=bf_Unchecked;
								none:=bf_Checked;
								add:=bf_Unchecked;
								sub:=bf_Unchecked;
								mul:=bf_Unchecked;
								divide:=bf_Unchecked;
								empty:=bf_Checked;
								transpose:=bf_Unchecked
							end;
						ADialog^.TransferBuffer:=@p^.tibuffer
					end
			end;
		if ADialog<>nil then
			begin
				PInsertDialog(ADialog)^.bedt^.SetText(StrPTrimF(p^.dblock^.GetText));
				ADialog^.TransferData(tf_SetData);
				ADialog^.MakeWindow;
				PInsertDialog(ADialog)^.CheckButtons
			end
	end;


procedure TInsertRows.Work;
	var p    : PCalcWindow;
	    rs,re,
	    dummy: integer;

	begin
		p:=PCalcWindow(Parent);
		p^.GetBlock(p^.dblock^.GetText,false,rs,dummy,re,dummy,dummy,dummy);
		p^.InsertCells(rs,0,re,p^.Parms.Columns,CRS_DOWN)
	end;


procedure TInsertColumns.Work;
	var p    : PCalcWindow;
	    cs,ce,
	    dummy: integer;

	begin
		p:=PCalcWindow(Parent);
		p^.GetBlock(p^.dblock^.GetText,false,dummy,cs,dummy,ce,dummy,dummy);
		p^.InsertCells(0,cs,p^.Parms.Rows,ce,CRS_RIGHT)
	end;


procedure TPrint.Work;

	begin
		Display(RTPPRINT)
	end;


procedure TPrint.Display(def: integer);
	var t          : string;
	    pe         : PEdit;
	    drivers    : PStringCollection;
	    p          : PCalcWindow;
	    pc         : PCheckBox;
	    pb         : PButton;
	    sub_dialogs: PPDLG_SUB;
	    pt         : PTree;

	begin
		if not(Application^.GDOSActive) then exit;
		p:=PCalcWindow(Parent);
		if TexelApp.ExtPrnSel(p^.wnd_prnt_set,TexelApp.app_prnt_set) then
			begin
				getmem(sub_dialogs,sizeof(PDLG_SUB));
				if sub_dialogs<>nil then
					begin
						pt:=Application^.GetAddr(RTICONS);
						with sub_dialogs^ do
							begin
								next:=nil;
								option_flags:=0;
								sub_id:=-1;
								sub_icon:=@pt^[RTIPRINTRANGE];
								sub_tree:=Application^.GetAddr(RTPRINTSUBDIAL);
								dialog:=nil;
								tree:=nil;
								index_offset:=0;
								reserved1:=0;
								reserved2:=0;
								init_dlg:=pinit_texel;
								do_dlg:=nil;
								reset_dlg:=preset_texel;
								reserved3:=0;
								private1:=longint(p);
								private2:=0;
								private3:=0;
								private4:=0
							end;
						with AES_pb do
							begin
								control^[0]:=205;
								control^[1]:=1;
								control^[2]:=1;
								control^[3]:=2;
								control^[4]:=0;
								intin^[0]:=3;
								addrin^[0]:=TexelApp.prnt_dialog;
								addrin^[1]:=sub_dialogs;
								_crystal(@AES_pb)
							end
					end;
				t:=TEXELWINDPREFIX+TITLE_PRINT+#0;
				with AES_pb do
					begin
						control^[0]:=207;
						control^[1]:=1;
						control^[2]:=1;
						control^[3]:=3;
						control^[4]:=0;
						intin^[0]:=PDLG_PRINT or PDLG_ALWAYS_COPIES or PDLG_ALWAYS_SCALE;
						addrin^[0]:=TexelApp.prnt_dialog;
						addrin^[1]:=p^.wnd_prnt_set;
						addrin^[2]:=@t[1];
						_crystal(@AES_pb)
					end;
				if AES_pb.intout^[0]=PDLG_OK then
					begin
						PrintSheet(GetDevice);
						if p^.pagepreview<>nil then p^.pagepreview^.Update(true);
					end;
				if sub_dialogs<>nil then
					begin
						with AES_pb do
							begin
								control^[0]:=205;
								control^[1]:=1;
								control^[2]:=1;
								control^[3]:=1;
								control^[4]:=0;
								intin^[0]:=4;
								addrin^[0]:=TexelApp.prnt_dialog;
								_crystal(@AES_pb)
							end;
						free_sub_dialogs(sub_dialogs)
					end;
				exit
			end;
		if ADialog=nil then
			begin
				ADialog:=new(PPrintDialog,Init(p,TEXELWINDPREFIX+TITLE_PRINT,STG_PRINT,ICNTITLE_PRINT,RTPRINT));
				if ADialog<>nil then
					begin
						PPrintDialog(ADialog)^.drvinfo:=nil;
						new(PGroupBox,Init(ADialog,RTPBEREICH,GROUP_GENERAL_RANGE,''));
						new(st0,Init(ADialog,RTPTITLE,43,true,BUBBLE_PRINT_FILE));
						new(PCheckBox,Init(ADialog,RTPSHEET,true,BUBBLE_PRINT_SHEET));
						new(PCheckBox,Init(ADialog,RTPFEED,true,BUBBLE_PRINT_FEED));
						new(pe,Init(ADialog,RTPCOPIES,4,BUBBLE_PRINT_COPIES));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(1,99)));
						new(ppcb,Init(ADialog,RTPPERCSIZE,RTPPSCYC,RTPPSTITLE,RTPOPUPS,RTPPRINTPERC,id_no,false,true,BUBBLE_PRINT_SCALE));
						if ppcb<>nil then
							begin
								if ppcb^.Popup<>nil then ppcb^.Popup^.AutoCheck:=false;
								if ppcb^.Edit<>nil then ppcb^.Edit^.SetValidator(new(PRangeValidator,Init(MINPERCENT,MAXPERCENT)))
							end;
						new(drivers,Init(10,5));
						new(PPrintDialog(ADialog)^.drvbox,InitCollection(ADialog,RTPDRIVER,RTPDRIVERCYC,RTPDRIVERTITLE,30,drivers,true,true,false,BUBBLE_PRINT_DRIVER));
						new(pb,Init(ADialog,RTPINFO,id_No,true,''));
						if pb<>nil then pb^.Hide(false);
						PPrintDialog(ADialog)^.inf:=pb;
						new(PPrintDialog(ADialog)^.druck,Init(ADialog,RTPPRINT,id_No,true,BUBBLE_PRINT_PRINT));
						new(PPrintDialog(ADialog)^.devbox,Init(ADialog,RTPDEVICE,RTPDEVCYC,RTPDEVTITLE,RTPOPUPS,RTPDEVICES,id_No,false,false,BUBBLE_PRINT_DEVICE));
						new(pc,Init(ADialog,RTPSW,true,BUBBLE_PRINT_BW));
						if pc<>nil then pc^.Disable; { ... }
						new(PRadioButton,Init(ADialog,RTPPBLOCK,true,BUBBLE_PRINT_RANGE));
						new(PRadioButton,Init(ADialog,RTPALL,true,BUBBLE_PRINT_ALL));
						new(PRadioButton,Init(ADialog,RTPBLOCK,true,BUBBLE_PRINT_SELECTION));
						new(PPrintDialog(ADialog)^.paper,Init(ADialog,RTPPSIZE,RTPPCYC,RTPPTITLE,RTPOPUPS,RTPPAPER,id_No,false,false,BUBBLE_PRINT_PAPER));
						new(pe,Init(ADialog,RTPVON,4,BUBBLE_PRINT_PAGEFROM));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(MINPAGES,MAXPAGESOLD)));
						new(PEdit,Init(ADialog,RTPBIS,4,BUBBLE_PRINT_PAGETO));
						new(pb,Init(ADialog,RTPHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTPPAGESETUP,id_No,true,BUBBLE_PRINT_LAYOUT));
						new(PButton,Init(ADialog,RTPPREVIEW,id_No,true,BUBBLE_PRINT_PREVIEW));
						new(PButton,Init(ADialog,RTPOK,id_OK,true,BUBBLE_PRINT_OK));
						new(PButton,Init(ADialog,RTPCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						p^.prnbuffer:=TexelApp.stdprnbuffer;
						p^.prnbuffer.prcindx:=0;
						ADialog^.TransferBuffer:=@p^.prnbuffer
					end
			end;
		if ADialog<>nil then
			begin
				t:=p^.GetWindowFilename;
				if length(t)=0 then t:=p^.GetRawIconTitle;
				if st0<>nil then st0^.SetText(CompressPath(t,42));
				ADialog^.MakeWindow;
				PPrintDialog(ADialog)^.SetDefaultButton(def)
			end
	end;


function TPrint.IsAvailable(open: boolean): boolean;

	begin
		if not(TexelApp.ExtPrnSel(PCalcWindow(Parent)^.wnd_prnt_set,TexelApp.app_prnt_set)) then
			begin
				IsAvailable:=false;
				if ADialog=nil then
					begin
						if open then Work;
						if ADialog=nil then exit;
						ADialog^.WMClosed
					end
			end;
		IsAvailable:=true
	end;


function TPrint.GetDevice: integer;
	var p: PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		if TexelApp.ExtPrnSel(p^.wnd_prnt_set,TexelApp.app_prnt_set) then GetDevice:=p^.wnd_prnt_set^.driver_id
		else
			with PPrintDialog(ADialog)^.drvbox^ do GetDevice:=drivers[GetSelection]
	end;


function TPrint.GetPaperSize: integer;
	var p: PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		if TexelApp.ExtPrnSel(p^.wnd_prnt_set,TexelApp.app_prnt_set) then GetPaperSize:=0
		else
			GetPaperSize:=PPrintDialog(ADialog)^.paper^.GetSelection
	end;


procedure TPrint.GetDriverNames(num,hdl: integer; var txt,dummy: string);
	var p: PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		if TexelApp.ExtPrnSel(p^.wnd_prnt_set,TexelApp.app_prnt_set) then
			begin
				if vqtDevinfo(hdl,num,dummy,txt) then
					if (length(dummy)>0) or (length(txt)>0) then
						begin
							dummy:=StrPLeft(dummy,12);
							txt:=StrPLeft(txt,42);
							exit
						end;
				txt:='';
				dummy:=STRING_DEVICE+' #'+ltoa(num)
			end
		else
			with PPrintDialog(ADialog)^.drvbox^ do
				begin
					txt:=longnames[GetSelection];
					dummy:=shortnames[GetSelection]
				end
	end;


function TPrint.PrintSheet(num: integer): boolean;
	label _leer,_error,_borderr;

	var hndl,q,l,
	    copies,w,
	    tw,th,
	    pgx,pgy,t,
	    pagew,pageh,
	    pagex,pagey,
	    pages,page,
	    cwidth,cheight,
	    bwidth,bheight,
	    cw,wwidth,
	    nwidth,lcw,trh,
	    pgvon,pgbis,
	    vbpages,
	    rsc,csc,
	    rec,cec,
	    rs,cs,re,ce : integer;
	    xmm,ymm,
	    XPixOffs,
	    YPixOffs,
	    printtime,
	    xoffs,yoffs,
	    xoffs2,
	    yoffs2      : longint;
	    ymmfak,yfak,
	    xmmfak,xfak,
	    prcfak,
	    ymm100fak,
	    xmm100fak,
	    mmkopf,
	    mmfuss,
	    pcstemp     : real;
	    wrkout,
	    ewrkout     : workout_ARRAY;
	    progress    : PDialog;
	    bitimage,
	    colfx,meta  : boolean;
	    pps,ppa,
	    st,ppp,ppc  : PStatic;
	    cell        : PCell;
	    p           : PCalcWindow;
	    srect       : GRECT;
	    dummy,txt   : string;
	    pe          : PEmbedded;

	function GetColWidth(num: integer): integer;

		begin
			GetColWidth:=round(longint(p^.PCol^[num])*xmm100fak)+1
		end;

	function GetRowHeight(num: integer): integer;

		begin
			GetRowHeight:=round(longint(p^.PRow^[num])*ymm100fak)+1
		end;

	function abort: boolean;
		var ret,dummy,
		    kstat,key: integer;
		    pipe     : Pipearray;

		begin
			abort:=false;
			ret:=evnt_multi(MU_KEYBD or MU_TIMER,2,1,1,0,0,0,0,0,0,0,0,0,0,pipe,1,0,dummy,dummy,dummy,kstat,key,dummy);
			if bTst(ret,MU_KEYBD) then
				if (kstat=K_NORMAL) and (key=S_Esc) then
					if Application^.Alert(p,2,WAIT,MESSAGE_PRINT_STOP,BUTTON_YESNO)=1 then abort:=true
		end;

	procedure setfont(indx,sze: integer);

		begin
			vst_font(hndl,indx);
			if p^.Speedo then vst_arbpt(hndl,round(sze*prcfak),cwidth,cheight,bwidth,bheight)
			else
				vst_point(hndl,round(sze*prcfak),cwidth,cheight,bwidth,bheight);
			if vqt_width(hndl,ord('W'),cw,l,l)=ord('W') then wwidth:=cw
			else
				wwidth:=cwidth;
			if vqt_width(hndl,ord('9'),cw,l,l)=ord('9') then nwidth:=cw
			else
				nwidth:=cwidth
		end;

	procedure StartGroup;
		var value,dummy: integer;

		begin
			if not(meta) then exit;
			value:=10;
			v_write_meta(hndl,1,@value,0,@dummy)
		end;

	procedure EndGroup;
		var value,dummy: integer;

		begin
			if not(meta) then exit;
			value:=11;
			v_write_meta(hndl,1,@value,0,@dummy)
		end;

	function printdoc(xoffs,yoffs,xoffs2,yoffs2: integer): boolean;
		label _nextgit,_endgit;

		var xy,xy2,xy3,brd,
		    tover             : ARRAY_4;
		    ext               : ARRAY_8;
		    clp,clp2,clp3,clip,
		    sr,bclp           : GRECT;
		    q,w,dummy,c2,
		    oldstyle,oldcolor,
		    oldinter,oldlcolor,
		    b,tx,ty           : integer;
		    cnum,lofs         : longint;
		    title,sval        : string;
		    prctemp           : real;
		    pe                : PEmbedded;
		    cmpval            : TOldTxtVal;
		    cell2             : PCell;

		procedure setfontattr(const tval: TTxtVal);
		
			begin
				if (tval.Font<>cmpval.oldfont) or (tval.Size<>cmpval.oldsize) then
					begin
						setfont(tval.Font,tval.Size);
						cmpval.oldsize:=tval.Size;
						cmpval.oldfont:=tval.Font
					end
			end;
		
		procedure drawbackground;
		
			begin
				with PCell(cnum)^ do
					begin
						if Style<>oldstyle then
							begin
								vsf_style(hndl,Style);
								oldstyle:=Style
							end;
						if Interior<>oldinter then
							begin
								vsf_interior(hndl,Interior);
								oldinter:=Interior
							end;
						if Color<>oldcolor then
							begin
								vsf_color(hndl,Color);
								oldcolor:=Color
							end
					end;
				vr_recfl(hndl,xy3)
			end;

		begin
			if abort then
				begin
					printdoc:=false;
					exit
				end
			else
				printdoc:=true;
			StartGroup;
			vst_color(hndl,Black);
			vst_effects(hndl,TF_NORMAL);
			vst_rotation(hndl,0);
			if p^.Speedo then vst_skew(hndl,0);
			vst_alignment(hndl,TA_LEFT,TA_BASELINE,dummy,dummy);
			vsl_udsty(hndl,$5555);
			vsm_height(hndl,1);
			vsf_color(hndl,White);
			vsf_style(hndl,0);
			vsf_interior(hndl,FIS_HOLLOW);
			clip.X1:=xoffs;
			clip.X2:=xoffs2;
			if mmkopf>0.0 then
				begin
					StartGroup;
					clip.Y1:=round(atof(p^.Parms.psbuffer.oben)*ymmfak);
					clip.Y2:=yoffs-1;
					A2toGR(clip);
					vs_clip(hndl,CLIP_ON,clip.A2);
					prctemp:=prcfak;
					prcfak:=1.0;
					setfont(p^.GetStdFontIndex,p^.GetStdFontSize);
					if p^.Parms.psbuffer.hlefton=bf_Checked then p^.OutputKF(hndl,clip.X1,clip.Y1,TA_LEFT,TA_TOP,page,pages,printtime,p^.Parms.psbuffer.hleft);
					if p^.Parms.psbuffer.hcenteron=bf_Checked then p^.OutputKF(hndl,(clip.X1+clip.X2) shr 1,clip.Y1,TA_CENTER,TA_TOP,page,pages,printtime,p^.Parms.psbuffer.hmid);
					if p^.Parms.psbuffer.hrighton=bf_Checked then p^.OutputKF(hndl,clip.X2,clip.Y1,TA_RIGHT,TA_TOP,page,pages,printtime,p^.Parms.psbuffer.hright);
					prcfak:=prctemp;
					EndGroup
				end;
			StartGroup;
			clip.Y1:=yoffs;
			clip.Y2:=yoffs2;
			A2toGR(clip);
			vs_clip(hndl,CLIP_ON,clip.A2);
			if p^.Parms.psbuffer.hcenter=bf_Checked then
				begin
					dummy:=pagew-srect.W;
					if p^.Parms.psbuffer.rows=bf_Checked then dec(dummy,lcw);
					inc(xoffs,dummy shr 1)
				end;
			if p^.Parms.psbuffer.vcenter=bf_Checked then
				begin
					dummy:=pageh-srect.H;
					if p^.Parms.psbuffer.columns=bf_Checked then dec(dummy,trh);
					inc(yoffs,dummy shr 1)
				end;
			{ Quadrat links oben zeichnen }
			if (p^.Parms.psbuffer.rows=bf_Checked) and (p^.Parms.psbuffer.columns=bf_Checked) then
				begin
					xy[0]:=xoffs;
					xy[1]:=yoffs;
					xy[2]:=xoffs+lcw-1;
					xy[3]:=yoffs+trh-1;
					v_bar(hndl,xy);
					if colfx then
						begin
							inc(xy[0]);
							inc(xy[1]);
							vsf_interior(hndl,FIS_SOLID);
							vsf_color(hndl,LWhite);
							v_bar(hndl,xy);
							vsf_interior(hndl,FIS_HOLLOW);
							vsf_color(hndl,Black)
						end
				end;
			vst_alignment(hndl,TA_CENTER,TA_BOTTOM,dummy,dummy);
			setfont(p^.GetStdFontIndex,p^.GetStdFontSize);
			{ PaintNumbers }
			if p^.Parms.psbuffer.rows=bf_Checked then
				begin
					w:=rs;
					clp.X:=xoffs;
					if p^.Parms.psbuffer.columns=bf_Checked then clp.Y:=yoffs+trh+1
					else
						clp.Y:=yoffs;
					clp.W:=lcw;
					clp.H:=GetRowHeight(w);
					xy[0]:=clp.X-1;
					xy[1]:=clp.Y-1;
					xy[2]:=clp.X+clp.W;
					GRtoA2(clp);
					repeat
						inc(w);
						clp2:=clp;
						if rc_intersect(clip,clp2) then
							begin
								vs_clip(hndl,CLIP_ON,clp2.A2);
								xy[3]:=clp.Y2;
								v_bar(hndl,xy);
								dec(xy[3]);
								if colfx then
									begin
										vsf_interior(hndl,FIS_SOLID);
										vsf_color(hndl,LWhite);
										inc(xy[0],2);
										inc(xy[1],2);
										v_bar(hndl,xy);
										dec(xy[0],2);
										vsf_interior(hndl,FIS_HOLLOW);
										vsf_color(hndl,Black)
									end;
								vswr_mode(hndl,MD_TRANS);
								v_gtext(hndl,(xy[0]+xy[2]) shr 1,xy[3],ltoa(w));
								vswr_mode(hndl,MD_REPLACE)
							end;
						if w>re then break;
						clp.Y1:=clp.Y2+1;
						inc(clp.Y2,GetRowHeight(w));
						A2toGR(clp);
						xy[1]:=clp.Y-1
					until clp.Y1>clip.Y2;
					sr.X:=xoffs+lcw+1
				end
			else
				sr.X:=xoffs+1;
			if abort then
				begin
					printdoc:=false;
					exit
				end;
			{ PaintNames}
			if p^.Parms.psbuffer.columns=bf_Checked then
				begin
					q:=cs;
					if p^.Parms.psbuffer.rows=bf_Checked then clp.X:=xoffs+lcw+1
					else
						clp.X:=xoffs+1;
					clp.Y:=yoffs;
					clp.W:=GetColWidth(q)-1;
					clp.H:=trh;
					xy[0]:=clp.X-1;
					xy[1]:=clp.Y-1;
					xy[3]:=clp.Y+clp.H;
					GRtoA2(clp);
					repeat
						clp2:=clp;
						if rc_intersect(clip,clp2) then
							begin
								vs_clip(hndl,CLIP_ON,clp2.A2);
								xy[2]:=clp.X2;
								v_bar(hndl,xy);
								if colfx then
									begin
										vsf_interior(hndl,FIS_SOLID);
										vsf_color(hndl,LWhite);
										inc(xy[0],2);
										inc(xy[1],2);
										dec(xy[2]);
										v_bar(hndl,xy);
										dec(xy[1],2);
										vsf_interior(hndl,FIS_HOLLOW);
										vsf_color(hndl,Black)
									end;
								vswr_mode(hndl,MD_TRANS);
								v_gtext(hndl,(xy[0]+xy[2]) shr 1,xy[3],p^.GetColumnName(q));
								vswr_mode(hndl,MD_REPLACE)
							end;
						inc(q);
						if q>ce then break;
						clp.X1:=clp.X2+1;
						inc(clp.X2,GetColWidth(q));
						A2toGR(clp);
						xy[0]:=clp.X-1
					until clp.X1>clip.X2;
					sr.Y:=yoffs+trh+1
				end
			else
				sr.Y:=yoffs+1;
			EndGroup;
			{ Zeilen durchlaufen }
			lofs:=longint(p^.Parms.Columns+1)*CELLSIZE;
			w:=rs;
			clp.X:=0;
			if p^.Parms.psbuffer.columns=bf_Checked then clp.Y:=yoffs+trh+1
			else
				clp.Y:=yoffs;
			if p^.Parms.psbuffer.rows=bf_Checked then clp.W:=xoffs+lcw
			else
				clp.W:=xoffs;
			clp.H:=GetRowHeight(w);
			GRtoA2(clp);
			with cmpval do
				begin
					oldfont:=p^.GetFontIndex;
					oldsize:=p^.GetFontSize;
					brd1w:=Max(round(prcfak*Border1*xmmfak)-1,0);
					brd2w:=Max(round(prcfak*Border2*xmmfak)-1,0);
					brd3w:=Max(round(prcfak*Border3*xmmfak)-1,0);
					brd1h:=Max(round(prcfak*Border1*ymmfak)-1,0);
					brd2h:=Max(round(prcfak*Border2*ymmfak)-1,0);
					brd3h:=Max(round(prcfak*Border3*ymmfak)-1,0);
					gitter:=(p^.Parms.psbuffer.gitter=bf_Checked)
				end;
			oldcolor:=White;
			oldlcolor:=Black;
			oldstyle:=0;
			oldinter:=FIS_HOLLOW;
			vsf_color(hndl,oldcolor);
			vsf_style(hndl,oldstyle);
			vsf_interior(hndl,oldinter);
			vsl_color(hndl,oldlcolor);
			setfont(cmpval.oldfont,cmpval.oldsize);
			p^.InitTextValues(hndl,cmpval);
			if abort then
				begin
					printdoc:=false;
					exit
				end;
			repeat
				{ Spalten durchlaufen }
				q:=cs;
				cnum:=longint(p^.Sheet)+(longint(w)*longint(p^.Parms.Columns+1)+longint(q))*CELLSIZE;
				inc(w);
				clp3.X:=clp.X2+2;
				clp3.Y:=clp.Y;
				clp3.W:=GetColWidth(q)-1;
				clp3.H:=clp.H;
				xy3[0]:=clp3.X-1;
				xy3[1]:=clp3.Y-1;
				xy3[3]:=clp3.Y+clp3.H-1;
				if cmpval.gitter then dec(xy3[3]);
				GRtoA2(clp3);
				repeat
					clp2:=clp3;
					if rc_intersect(clip,clp2) then
						begin
							StartGroup;
							vs_clip(hndl,CLIP_ON,clp2.A2);
							xy3[2]:=clp3.X2;
							if cmpval.gitter then
								if (PCell(cnum)^.TxtVal.Flags and TFL_GITTERMASK)=0 then dec(xy3[2]);
							{ Zellinhalt }
							drawbackground;
							with PCell(cnum)^ do
								begin
									vswr_mode(hndl,MD_TRANS);
									case Typ of
									CTYPE_TEXT:
										if Data.Value<>0 then
											begin
												setfontattr(TxtVal);
												p^.OutputVectorText(hndl,PCell(cnum),Data.Txt^,TxtVal,cmpval,xy3,false)
											end;
									CTYPE_CONST:
										with Data.Konst^ do
											begin
												if p^.Val2Txt(Value,sval,FPts,Format,PCell(cnum)) then drawbackground;
												setfontattr(TxtVal);
												p^.OutputVectorText(hndl,PCell(cnum),sval,TxtVal,cmpval,xy3,true)
											end;
									CTYPE_FORMULA:
										with Data.Formula^ do
											if Error=FE_OK then
												begin
													if p^.Val2Txt(Value,sval,FPts,Format,PCell(cnum)) then drawbackground;
													setfontattr(TxtVal);
													p^.OutputVectorText(hndl,PCell(cnum),sval,TxtVal,cmpval,xy3,true)
												end
											else
												begin
													setfontattr(TxtVal);
													p^.OutputErrorText(hndl,PCell(cnum),TxtVal,cmpval,xy3,Error)
												end;
									CTYPE_EMPTY:
										begin
											if bTst(TxtVal.Flags,TFL_TEXTFROMLEFT) then
												begin
													tover:=xy3;
													c2:=q;
													cell2:=PCell(cnum);
													repeat
														dec(longint(cell2),CELLSIZE);
														dec(c2);
														if c2<0 then break
														else
															begin
																tover[2]:=tover[0]-1;
																dec(tover[0],GetColWidth(c2))
															end;
													until (cell2^.TxtVal.Flags and TFL_RIGHTMASK)=TFL_TEXT2RIGHT;
													if c2>=0 then
														begin
															setfontattr(cell2^.TxtVal);
															p^.OutputVectorText(hndl,cell2,cell2^.Data.Txt^,cell2^.TxtVal,cmpval,tover,false)
														end
												end
											else
												if bTst(TxtVal.Flags,TFL_TEXTFROMRIGHT) then
													begin
														tover:=xy3;
														c2:=q;
														cell2:=PCell(cnum);
														repeat
															inc(longint(cell2),CELLSIZE);
															inc(c2);
															if c2>p^.Parms.Columns then break
															else
																begin
																	tover[0]:=tover[2]+1;
																	inc(tover[2],GetColWidth(c2));
																	if cmpval.gitter then dec(tover[2])
																end;
														until (cell2^.TxtVal.Flags and TFL_LEFTMASK)=TFL_TEXT2LEFT;
														if c2<=p^.Parms.Columns then
															begin
																setfontattr(cell2^.TxtVal);
																p^.OutputVectorText(hndl,cell2,cell2^.Data.Txt^,cell2^.TxtVal,cmpval,tover,false)
															end
													end
										end
									end;
									vswr_mode(hndl,MD_REPLACE);
									if cmpval.gitter then
										begin
											if (PCell(cnum)^.TxtVal.Flags and TFL_GITTERMASK)=0 then inc(xy3[2]);
											inc(xy3[3])
										end;
									with Border do
										if (Val1<>0) or (Val2<>0) then
											begin
												bclp.X:=clp3.X-1;
												bclp.Y:=clp3.Y-1;
												bclp.W:=clp3.W+1;
												bclp.H:=clp3.H+1;
												if rc_intersect(clip,bclp) then
													begin
														vs_clip(hndl,CLIP_ON,bclp.A2);
														if Left>=16 then
															if (TxtVal.Flags and TFL_LEFTBORDER)=0 then
																begin
																	if (Left and $f)<>oldlcolor then
																		begin
																			oldlcolor:=Left and $f;
																			vsl_color(hndl,oldlcolor)
																		end;
																	if q=cs then inc(xy3[0]);
																	case (Left shr 4) of
																	1:
																		begin
																			brd[0]:=xy3[0];
																			brd[1]:=xy3[1];
																			brd[2]:=brd[0];
																			brd[3]:=xy3[3];
																			v_pline(hndl,2,brd)
																		end;
																	2:
																		begin
																			brd[0]:=xy3[0];
																			brd[1]:=xy3[1];
																			brd[3]:=xy3[3];
																			for b:=0 to cmpval.brd1w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					inc(brd[0])
																				end
																		end;
																	3:
																		begin
																			brd[0]:=xy3[0];
																			brd[1]:=xy3[1];
																			brd[3]:=xy3[3];
																			for b:=0 to cmpval.brd2w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					inc(brd[0])
																				end
																		end;
																	4:
																		begin
																			brd[0]:=xy3[0];
																			brd[1]:=xy3[1];
																			brd[3]:=xy3[3];
																			for b:=0 to cmpval.brd3w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					inc(brd[0])
																				end
																		end;
																	5:
																		begin
																			brd[0]:=xy3[0];
																			brd[1]:=xy3[1];
																			brd[3]:=xy3[3];
																			for b:=0 to cmpval.brd1w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					inc(brd[0])
																				end;
																			brd[0]:=xy3[0]+cmpval.brd3w;
																			for b:=0 to cmpval.brd1w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					dec(brd[0])
																				end
																		end
																	end;
																	if q=cs then dec(xy3[0])
																end;
														if Right>=16 then
															if (TxtVal.Flags and TFL_RIGHTBORDER)=0 then
																begin
																	if (Right and $f)<>oldlcolor then
																		begin
																			oldlcolor:=Right and $f;
																			vsl_color(hndl,oldlcolor)
																		end;
																	case (Right shr 4) of
																	1:
																		begin
																			brd[0]:=xy3[2];
																			brd[1]:=xy3[1];
																			brd[2]:=brd[0];
																			brd[3]:=xy3[3];
																			v_pline(hndl,2,brd)
																		end;
																	2:
																		begin
																			brd[0]:=xy3[2];
																			brd[1]:=xy3[1];
																			brd[3]:=xy3[3];
																			for b:=0 to cmpval.brd1w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					dec(brd[0])
																				end
																		end;
																	3:
																		begin
																			brd[0]:=xy3[2];
																			brd[1]:=xy3[1];
																			brd[3]:=xy3[3];
																			for b:=0 to cmpval.brd2w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					dec(brd[0])
																				end
																		end;
																	4:
																		begin
																			brd[0]:=xy3[2];
																			brd[1]:=xy3[1];
																			brd[3]:=xy3[3];
																			for b:=0 to cmpval.brd3w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					dec(brd[0])
																				end
																		end;
																	5:
																		begin
																			brd[0]:=xy3[2];
																			brd[1]:=xy3[1];
																			brd[3]:=xy3[3];
																			for b:=0 to cmpval.brd1w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					dec(brd[0])
																				end;
																			brd[0]:=xy3[2]-cmpval.brd3w;
																			brd[1]:=xy3[1];
																			brd[3]:=xy3[3];
																			for b:=0 to cmpval.brd1w do
																				begin
																					brd[2]:=brd[0];
																					v_pline(hndl,2,brd);
																					inc(brd[0])
																				end
																		end
																	end
																end;
														if Top>=16 then
															begin
																if (Top and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Top and $f;
																		vsl_color(hndl,oldlcolor)
																	end;
																if w=rs+1 then inc(xy3[1]);
																case (Top shr 4) of
																1:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=xy3[1];
																		brd[2]:=xy3[2];
																		brd[3]:=brd[1];
																		v_pline(hndl,2,brd)
																	end;
																2:
																	begin
																		brd[1]:=xy3[1];
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd1h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				inc(brd[1])
																			end
																	end;
																3:
																	begin
																		brd[1]:=xy3[1];
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd2h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				inc(brd[1])
																			end
																	end;
																4:
																	begin
																		brd[1]:=xy3[1];
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd3h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				inc(brd[1])
																			end
																	end;
																5:
																	begin
																		brd[1]:=xy3[1];
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd1h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				inc(brd[1])
																			end;
																		brd[1]:=xy3[1]+cmpval.brd3h;
																		for b:=0 to cmpval.brd1h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				dec(brd[1])
																			end
																	end
																end;
																if w=rs+1 then dec(xy3[1])
															end;
														if Bottom>=16 then
															begin
																if (Bottom and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Bottom and $f;
																		vsl_color(hndl,oldlcolor)
																	end;
																case (Bottom shr 4) of
																1:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=xy3[3];
																		brd[2]:=xy3[2];
																		brd[3]:=brd[1];
																		v_pline(hndl,2,brd)
																	end;
																2:
																	begin
																		brd[1]:=xy3[3];
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd1h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				dec(brd[1])
																			end
																	end;
																3:
																	begin
																		brd[1]:=xy3[3];
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd2h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				dec(brd[1])
																			end
																	end;
																4:
																	begin
																		brd[1]:=xy3[3];
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd3h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				dec(brd[1])
																			end
																	end;
																5:
																	begin
																		brd[1]:=xy3[3];
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd1h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				dec(brd[1])
																			end;
																		brd[1]:=xy3[3]-cmpval.brd3h;
																		for b:=0 to cmpval.brd1h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				inc(brd[1])
																			end
																	end
																end
															end;
														if Hor>=16 then
															begin
																if (Hor and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Hor and $f;
																		vsl_color(hndl,oldlcolor)
																	end;
																case (Hor shr 4) of
																1:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=(xy3[1]+xy3[3]) shr 1;
																		brd[2]:=xy3[2];
																		brd[3]:=brd[1];
																		v_pline(hndl,2,brd)
																	end;
																2:
																	begin
																		brd[1]:=(xy3[1]+xy3[3]-cmpval.brd1h) shr 1;
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd1h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				inc(brd[1])
																			end
																	end;
																3:
																	begin
																		brd[1]:=(xy3[1]+xy3[3]-cmpval.brd2h) shr 1;
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd2h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				inc(brd[1])
																			end
																	end;
																4:
																	begin
																		brd[1]:=(xy3[1]+xy3[3]-cmpval.brd3h) shr 1;
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd3h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				inc(brd[1])
																			end
																	end;
																5:
																	begin
																		brd[1]:=(xy3[1]+xy3[3]-cmpval.brd3h) shr 1;
																		brd[0]:=xy3[0];
																		brd[2]:=xy3[2];
																		for b:=0 to cmpval.brd1h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				inc(brd[1])
																			end;
																		brd[1]:=(xy3[1]+xy3[3]+cmpval.brd3h) shr 1;
																		for b:=0 to cmpval.brd1h do
																			begin
																				brd[3]:=brd[1];
																				v_pline(hndl,2,brd);
																				dec(brd[1])
																			end
																	end
																end
															end;
														if Vert>=16 then
															begin
																if (Vert and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Vert and $f;
																		vsl_color(hndl,oldlcolor)
																	end;
																case (Vert shr 4) of
																1:
																	begin
																		brd[0]:=(xy3[0]+xy3[2]) shr 1;
																		brd[1]:=xy3[1];
																		brd[2]:=brd[0];
																		brd[3]:=xy3[3];
																		v_pline(hndl,2,brd)
																	end;
																2:
																	begin
																		brd[0]:=(xy3[0]+xy3[2]-cmpval.brd1w) shr 1;
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd1w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(hndl,2,brd);
																				inc(brd[0])
																			end
																	end;
																3:
																	begin
																		brd[0]:=(xy3[0]+xy3[2]-cmpval.brd2w) shr 1;
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd2w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(hndl,2,brd);
																				inc(brd[0])
																			end
																	end;
																4:
																	begin
																		brd[0]:=(xy3[0]+xy3[2]-cmpval.brd3w) shr 1;
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd3w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(hndl,2,brd);
																				inc(brd[0])
																			end
																	end;
																5:
																	begin
																		brd[0]:=(xy3[0]+xy3[2]-cmpval.brd3w) shr 1;
																		brd[1]:=xy3[1];
																		brd[3]:=xy3[3];
																		for b:=0 to cmpval.brd1w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(hndl,2,brd);
																				inc(brd[0])
																			end;
																		brd[0]:=(xy3[0]+xy3[2]+cmpval.brd3w) shr 1;
																		for b:=0 to cmpval.brd1w do
																			begin
																				brd[2]:=brd[0];
																				v_pline(hndl,2,brd);
																				dec(brd[0])
																			end
																	end
																end
															end;
														vs_clip(hndl,CLIP_ON,clp2.A2)
													end
											end;
									if cmpval.gitter then dec(xy3[3])
								end;
							if cmpval.gitter then
								begin
									{ Begrenzungslinien }
									if colfx then
										begin
											if oldlcolor<>LWhite then
												begin
													oldlcolor:=LWhite;
													vsl_color(hndl,oldlcolor)
												end
										end
									else
										begin
											if oldlcolor<>Black then
												begin
													oldlcolor:=Black;
													vsl_color(hndl,oldlcolor)
												end;
											vsl_type(hndl,LT_USERDEF)
										end;
									if PCell(cnum)^.Border.Right<16 then
										if (PCell(cnum)^.TxtVal.Flags and TFL_GITTERMASK)=0 then
											begin
												if q<p^.Parms.Columns then
													if PCell(cnum+CELLSIZE)^.Border.Left>=16 then goto _nextgit;
												xy2[0]:=xy3[2];
												xy2[1]:=xy3[1];
												xy2[2]:=xy2[0];
												xy2[3]:=xy3[3]+1;
												v_pline(hndl,2,xy2)
											end;
									_nextgit:
									if PCell(cnum)^.Border.Bottom<16 then
										begin
											if w<=p^.Parms.Rows then
												if PCell(cnum+lofs)^.Border.Top>=16 then goto _endgit;
											xy2[0]:=xy3[0];
											xy2[1]:=xy3[3]+1;
											xy2[2]:=xy3[2];
											xy2[3]:=xy2[1];
											v_pline(hndl,2,xy2)
										end;
									_endgit:
									vsl_type(hndl,LT_SOLID)
								end
							else
								dec(xy3[3]);
							EndGroup;
							if not(cmpval.gitter) then inc(xy3[3])
						end;
					inc(q);
					if q>ce then break;
					clp3.X1:=clp3.X2+1;
					inc(clp3.X2,GetColWidth(q));
					A2toGR(clp3);
					xy3[0]:=clp3.X-1;
					inc(cnum,CELLSIZE)
				until clp3.X1>clip.X2;
				if abort then
					begin
						printdoc:=false;
						exit
					end;
				{ n„chste Zeile }
				if w>re then break;
				clp.Y1:=clp.Y2+1;
				inc(clp.Y2,GetRowHeight(w));
				A2toGR(clp)
			until clp.Y1>clip.Y2;
			if p^.Embedded<>nil then
				if p^.Parms.psbuffer.images=bf_Checked then
					begin
						clp.X:=xoffs;
						if p^.Parms.psbuffer.rows=bf_Checked then inc(clp.X,lcw);
						clp.Y:=yoffs;
						if p^.Parms.psbuffer.columns=bf_Checked then inc(clp.Y,trh);
						clp.W:=srect.W;
						clp.H:=srect.H;
						if rc_intersect(clip,clp) then
							begin
								pe:=p^.Embedded;
								while pe<>nil do
									begin
										if pe^.CanPrint then
											begin
												pe^.SetWorkstationValues(num,wrkout[13],XPixOffs-xoffs,YPixOffs-yoffs,xmm100fak,ymm100fak,prcfak,1.0,bTst(ewrkout[30],1),false);
												if pe^.IsVisible(clp,false) then
													begin
														vs_clip(hndl,CLIP_ON,clp.A2);
														pe^.Paint(hndl,clp,false)
													end
											end;
										pe:=pe^.Next
									end
							end
					end;
			setfont(p^.GetStdFontIndex,p^.GetStdFontSize);
			p^.RestoreTextValues(hndl);
			vsl_color(hndl,Black);
			vs_clip(hndl,CLIP_ON,clip.A2);
			{ durchgezogene Linien }
			if (p^.Parms.psbuffer.columns=bf_Checked) or (p^.Parms.psbuffer.rows=bf_Checked) or cmpval.gitter then
				begin
					StartGroup;
					pxya[0]:=xoffs;
					pxya[1]:=yoffs;
					pxya[2]:=xoffs+srect.X2-1;
					if p^.Parms.psbuffer.rows=bf_Checked then inc(pxya[2],lcw);
					pxya[3]:=yoffs;
					v_pline(hndl,2,pxya);
					if p^.Parms.psbuffer.columns=bf_Checked then
						begin
							pxya[1]:=yoffs+trh-1;
							pxya[3]:=pxya[1];
							v_pline(hndl,2,pxya);
							pxya[1]:=yoffs+trh+srect.Y2
						end
					else
						pxya[1]:=yoffs+srect.Y2;
					pxya[3]:=pxya[1];
					v_pline(hndl,2,pxya);
					pxya[0]:=xoffs;
					pxya[1]:=yoffs;
					pxya[2]:=xoffs;
					pxya[3]:=yoffs+srect.Y2;
					if p^.Parms.psbuffer.columns=bf_Checked then inc(pxya[3],trh);
					v_pline(hndl,2,pxya);
					if p^.Parms.psbuffer.rows=bf_Checked then
						begin
							pxya[0]:=xoffs+lcw-1;
							pxya[2]:=pxya[0];
							v_pline(hndl,2,pxya);
							pxya[0]:=xoffs+lcw+srect.X2-1
						end
					else
						pxya[0]:=xoffs+srect.X2-1;
					pxya[2]:=pxya[0];
					v_pline(hndl,2,pxya);
					EndGroup
				end;
			if mmfuss>0.0 then
				begin
					StartGroup;
					vsf_interior(hndl,FIS_HOLLOW);
					clip.Y1:=yoffs2+1;
					clip.Y2:=wrkout[1]-round(atof(p^.Parms.psbuffer.unten)*ymmfak);
					A2toGR(clip);
					vs_clip(hndl,CLIP_ON,clip.A2);
					prctemp:=prcfak;
					prcfak:=1.0;
					setfont(p^.GetStdFontIndex,p^.GetStdFontSize);
					if p^.Parms.psbuffer.flefton=bf_Checked then p^.OutputKF(hndl,clip.X1,clip.Y2,TA_LEFT,TA_BOTTOM,page,pages,printtime,p^.Parms.psbuffer.fleft);
					if p^.Parms.psbuffer.fcenteron=bf_Checked then p^.OutputKF(hndl,(clip.X1+clip.X2) shr 1,clip.Y2,TA_CENTER,TA_BOTTOM,page,pages,printtime,p^.Parms.psbuffer.fmid);
					if p^.Parms.psbuffer.frighton=bf_Checked then p^.OutputKF(hndl,clip.X2,clip.Y2,TA_RIGHT,TA_BOTTOM,page,pages,printtime,p^.Parms.psbuffer.fright);
					prcfak:=prctemp;
					EndGroup
				end;
			EndGroup;
			if abort then
				begin
					printdoc:=false;
					exit
				end;
			if ppa<>nil then ppa^.Disable;
			if pps<>nil then pps^.SetText(STRING_PRINTPAGE);
			v_updwk(hndl);
			if ppa<>nil then ppa^.Enable
		end;

	begin
		PrintSheet:=false;
		p:=PCalcWindow(Parent);
		BusyMouse;
		printtime:=gettime;
		if p^.IsNormalPrintArea then
			begin
				cell:=p^.Sheet;
				rsc:=0;
				csc:=0;
				rec:=-1;
				cec:=-1;
				for q:=0 to p^.Parms.Rows do
					for w:=0 to p^.Parms.Columns do
						begin
							if cell^.Typ=CTYPE_EMPTY then
								if cell^.TxtVal.Flags=0 then
									if cell^.Color=Black then
										if cell^.Style=8 then
											if cell^.Interior=FIS_HOLLOW then
												with cell^.Border do
													if Left<16 then
														if Right<16 then
															if Top<16 then
																if Bottom<16 then
																	if Hor<16 then
																		if Vert<16 then goto _leer;
							if q>rec then rec:=q;
							if w>cec then cec:=w;
							_leer:
							inc(longint(cell),CELLSIZE)
						end;
				if p^.Embedded<>nil then
					if p^.Parms.psbuffer.images=bf_Checked then
						begin
							xmm:=0;
							ymm:=0;
							pe:=p^.Embedded;
							while pe<>nil do
								begin
									if pe^.CanPrint then
										begin
											if pe^.XPos_mm100+pe^.Width_mm100>xmm then xmm:=pe^.XPos_mm100+pe^.Width_mm100;
											if pe^.YPos_mm100+pe^.Height_mm100>ymm then ymm:=pe^.YPos_mm100+pe^.Height_mm100
										end;
									pe:=pe^.Next
								end;
							if xmm>0 then
								begin
									q:=-1;
									repeat
										inc(q);
										dec(xmm,longint(p^.GetColWidth_mm100(q)))
									until (xmm<0) or (q>=p^.Parms.Columns);
									if q>cec then cec:=q
								end;
							if ymm>0 then
								begin
									w:=-1;
									repeat
										inc(w);
										dec(ymm,longint(p^.GetRowHeight_mm100(w)))
									until (ymm<0) or (w>=p^.Parms.Rows);
									if w>rec then rec:=w
								end
						end;
				if (rec<0) or (cec<0) then
					begin
						Application^.Alert(p,1,NOTE,MESSAGE_PRINT_EMPTY,BUTTON_OK);
						goto _error
					end
			end
		else
			if p^.IsBlockPrintArea then p^.GetBlock(p^.Parms.psbuffer.bereich,false,rsc,csc,rec,cec,q,q)
			else
				p^.GetBlock(p^.dblock^.GetText,false,rsc,csc,rec,cec,q,q);
		meta:=Between(num,31,40);
		bitimage:=Between(num,91,99);
		if not(TexelApp.ExtPrnSel(p^.wnd_prnt_set,TexelApp.app_prnt_set)) then
			begin
				if meta then
					if not(FileSelect(p,FSELTITLE_PRINTMETA,'*.gem',TexelApp.LastPath[11],TexelApp.LastFile[11],false)) then goto _error;
				if bitimage then
					if not(FileSelect(p,FSELTITLE_PRINTIMG,'*.img',TexelApp.LastPath[14],TexelApp.LastFile[14],false)) then goto _error;
			end;
 		if bitimage then vOpnwk(num,hndl,wrkout,p^.prnbuffer.papier,TexelApp.LastPath[14]+TexelApp.LastFile[14],p^.wnd_prnt_set)
 		else
			vOpnwk(num,hndl,wrkout,p^.prnbuffer.papier,'',p^.wnd_prnt_set);
		if hndl=0 then Application^.Alert(p,1,NOTE,MESSAGE_PRINT_DEVICE1+ltoa(num)+MESSAGE_PRINT_DEVICE2,BUTTON_OK)
		else
			begin
				if not(TexelApp.ExtPrnSel(p^.wnd_prnt_set,TexelApp.app_prnt_set)) then
					if meta then vm_filename(hndl,TexelApp.LastPath[11]+TexelApp.LastFile[11]);
				pcstemp:=p^.PercentSize;
				p^.PercentSize:=1.0;
				progress:=nil;
				vq_extnd(hndl,1,ewrkout);
				case ewrkout[20] of
				1:
					begin
						xmmfak:=10000/ewrkout[21];
						ymmfak:=10000/ewrkout[22]
					end;
				2:
					begin
						xmmfak:=100000/ewrkout[21];
						ymmfak:=100000/ewrkout[22]
					end;
				3:
					begin
						xmmfak:=1000000/ewrkout[21];
						ymmfak:=1000000/ewrkout[22]
					end
				else
					begin
						xmmfak:=1000/wrkout[3];
						ymmfak:=1000/wrkout[4]
					end
				end;
				inc(wrkout[10],vst_load_fonts(hndl,0));
				if p^.Speedo then vst_kern(hndl,0,1,q,q);
				mmkopf:=atof(p^.Parms.psbuffer.kopf);
				mmfuss:=atof(p^.Parms.psbuffer.fuss);
				xoffs:=round(atof(p^.Parms.psbuffer.links)*xmmfak);
				yoffs:=round((atof(p^.Parms.psbuffer.oben)+mmkopf)*ymmfak);
				xoffs2:=round(atof(p^.Parms.psbuffer.rechts)*xmmfak);
				yoffs2:=round((atof(p^.Parms.psbuffer.unten)+mmfuss)*ymmfak);
				prcfak:=p^.GetPercent/65536.0;
				xmm100fak:=xmmfak*prcfak/100.0;
				ymm100fak:=ymmfak*prcfak/100.0;
				if meta then
					begin
						inc(xoffs,10);
						inc(xoffs2,10);
						inc(yoffs,10);
						inc(yoffs2,10);
						wrkout[0]:=xoffs+xoffs2;
						wrkout[1]:=yoffs+yoffs2;
						for q:=csc to cec do inc(wrkout[0],GetColWidth(q));
						for q:=rsc to rec do inc(wrkout[1],GetRowHeight(q));
						vm_pagesize(hndl,round((longint(wrkout[0])+longint(1))*longint(10)/xmmfak),round((longint(wrkout[1])+longint(1))*longint(10)/ymmfak));
						vmCoords(hndl,0,wrkout[1],wrkout[0],0);
						v_meta_extents(hndl,0,0,wrkout[0],wrkout[1])
					end;
				xoffs2:=wrkout[0]-xoffs2;
				yoffs2:=wrkout[1]-yoffs2;
				if (xoffs2<=xoffs) or (yoffs2<=yoffs) then
					begin
						Application^.Alert(p,1,NOTE,MESSAGE_PRINT_MARGINS,BUTTON_OK);
						goto _borderr
					end;
				setfont(p^.GetStdFontIndex,p^.GetStdFontSize);
				lcw:=nwidth*trunc(ln(rec+2)/ln(10))+((3*nwidth) shr 1);
				trh:=bheight-1;
				if p^.Parms.psbuffer.rows=bf_Checked then tw:=lcw
				else
					tw:=0;
				if p^.Parms.psbuffer.columns=bf_Checked then th:=trh
				else
					th:=0;
				pagew:=xoffs2+1-xoffs;
				pagex:=0;
				srect.X:=tw;
				t:=csc;
				for q:=csc to cec do
					begin
						inc(srect.X,GetColWidth(q));
						if (srect.X>pagew) or bTst(p^.PColFlags^[q],CRF_UMBRUCH) then
							begin
								inc(pagex);
								if t=q then srect.X:=tw
								else
									begin
										srect.X:=tw+GetColWidth(q);
										t:=q
									end
							end
					end;
				if srect.X>tw then inc(pagex);
				pageh:=yoffs2+1-yoffs;
				pagey:=0;
				srect.Y:=th;
				t:=rsc;
				for q:=rsc to rec do
					begin
						inc(srect.Y,GetRowHeight(q));
						if (srect.Y>pageh) or bTst(p^.PRowFlags^[q],CRF_UMBRUCH) then
							begin
								inc(pagey);
								if t=q then srect.Y:=th
								else
									begin
										srect.Y:=th+GetRowHeight(q);
										t:=q
									end
							end
					end;
				if srect.Y>th then inc(pagey);
				pages:=pagex*pagey;
				new(progress,Init(p,TEXELNAME,RTPRINTPROGRESS));
				if progress<>nil then
					begin
						new(st,Init(progress,RTPPFILE,50,false,''));
						if st<>nil then
							begin
								dummy:=p^.GetWindowFilename;
								if length(dummy)=0 then dummy:=p^.GetRawIconTitle;
								st^.SetText(CompressPath(dummy,49))
							end;
						new(st,Init(progress,RTPPDEVICE,59,false,''));
						if st<>nil then
							begin
								GetDriverNames(num,hndl,txt,dummy);
								if length(txt)>0 then dummy:=dummy+' ('+txt+')';
								st^.SetText(dummy)
							end;
						new(ppp,Init(progress,RTPPPAGE,14,false,''));
						if ppp<>nil then ppp^.Clear;
						new(ppc,Init(progress,RTPPCOPY,15,false,''));
						if ppc<>nil then ppc^.Clear;
						new(pps,Init(progress,RTPPSTATE,20,false,''));
						if pps<>nil then pps^.Clear;
						new(ppa,Init(progress,RTPPABBRUCH,18,false,''));
						if ppa<>nil then ppa^.Enable;
						with progress^ do
							begin
								Attr.Style:=NAME or MOVER;
								MakeWindow;
								WMRedraw(Work.X,Work.Y,Work.W,Work.H)
							end
					end;
				copies:=p^.GetCopies(hndl);
				colfx:=(wrkout[13]>LWhite);
				pgvon:=p^.GetPageFrom;
				pgbis:=p^.GetPageTo;
				if not(Between(pgbis,MINPAGES,MAXPAGES)) then pgbis:=pgvon;
				if pgvon>pages then pgvon:=pages;
				if pgbis>pages then pgbis:=pages;
				dec(pgvon);
				dec(pgbis);
				if pgvon>pgbis then
					begin
						pgy:=pgvon;
						pgvon:=pgbis;
						pgbis:=pgy
					end;
				vbpages:=pgbis+1-pgvon;
				repeat
					if ppc<>nil then ppc^.SetText(STRING_COPY+' '+ltoa(p^.GetCopies(hndl)+1-copies)+'/'+ltoa(p^.GetCopies(hndl)));
					re:=rsc-1;
					for pgy:=0 to pagey-1 do
						begin
							rs:=re+1;
							srect.Y:=th;
							repeat
								inc(re);
								inc(srect.Y,GetRowHeight(re))
							until (srect.Y>pageh) or (re=rec) or bTst(p^.PRowFlags^[re],CRF_UMBRUCH);
							if (re>rs) and (((re<>rec) and not(bTst(p^.PRowFlags^[re],CRF_UMBRUCH))) or (srect.Y>pageh)) then dec(re);
							ce:=csc-1;
							for pgx:=0 to pagex-1 do
								begin
									cs:=ce+1;
									srect.X:=tw;
									repeat
										inc(ce);
										inc(srect.X,GetColWidth(ce))
									until (srect.X>pagew) or (ce=cec) or bTst(p^.PColFlags^[ce],CRF_UMBRUCH);
									if (ce>cs) and (((ce<>cec) and not(bTst(p^.PColFlags^[ce],CRF_UMBRUCH))) or (srect.X>pagew)) then dec(ce);
									if p^.Parms.psbuffer.num1=bf_Checked then page:=pgy*pagex+pgx
									else
										page:=pgx*pagey+pgy;
									if (page>=pgvon) and (page<=pgbis) then
										begin
											if ppp<>nil then ppp^.SetText(STRING_PAGE+' '+ltoa(pgy*pagex+pgx+1-pgvon)+'/'+ltoa(vbpages));
											if pps<>nil then pps^.SetText(STRING_BUILDPAGE);
											if p^.ClearDispList then v_clear_disp_list(hndl);
											srect.X1:=0;
											srect.Y1:=0;
											srect.X2:=0;
											srect.Y2:=0;
											for q:=cs to ce do inc(srect.X2,GetColWidth(q));
											for q:=rs to re do inc(srect.Y2,GetRowHeight(q));
											A2toGR(srect);
											if p^.Parms.psbuffer.rows=bf_Checked then XPixOffs:=-lcw-1
											else
												XPixOffs:=0;
											if p^.Parms.psbuffer.columns=bf_Checked then YPixOffs:=-trh-1
											else
												YPixOffs:=0;
											if cs>0 then
												for q:=0 to cs-1 do inc(XPixOffs,GetColWidth(q));
											if rs>0 then
												for q:=0 to rs-1 do inc(YPixOffs,GetRowHeight(q));
											if not(printdoc(xoffs,yoffs,xoffs2,yoffs2)) then
												begin
													if p^.ClearDispList then v_clear_disp_list(hndl);
													goto _borderr
												end;
											if p^.DoFeed then v_form_adv(hndl);
											if not(p^.DoSheet) then
												if Application^.Alert(p,1,NOTE,MESSAGE_PRINT_NEWSHEET,BUTTON_OKCANCEL)=2 then goto _borderr
										end
								end
						end;
					dec(copies)
				until copies<=0;
				PrintSheet:=true;
				inc(p^.infobuf.Printed);
				p^.SetDirty;
				_borderr:
				vst_unload_fonts(hndl,0);
				v_clswk(hndl);
				p^.PercentSize:=pcstemp;
				if progress<>nil then dispose(progress,Done);
				if TexelApp.ExtPrnSel(p^.wnd_prnt_set,TexelApp.app_prnt_set) then TexelApp.UpdateFile(StrPas(p^.wnd_prnt_set^.device),0)
				else
					begin
						if meta then TexelApp.UpdateFile(TexelApp.LastPath[11]+TexelApp.LastFile[11],0);
						if bitimage then TexelApp.UpdateFile(TexelApp.LastPath[14]+TexelApp.LastFile[14],0)
					end
			end;
		_error:
		ArrowMouse
	end;


procedure TPaper.Work;
	var p          : PCalcWindow;
	    docname    : string;
	    sub_dialogs: PPDLG_SUB;
	    pt         : PTree;

	begin
		p:=PCalcWindow(Parent);
		if TexelApp.ExtPrnSel(p^.wnd_prnt_set,TexelApp.app_prnt_set) then
			begin
				getmem(sub_dialogs,sizeof(PDLG_SUB));
				if sub_dialogs<>nil then
					begin
						pt:=Application^.GetAddr(RTICONS);
						with sub_dialogs^ do
							begin
								next:=nil;
								option_flags:=0;
								sub_id:=-1;
								sub_icon:=@pt^[RTIPRINTRANGE];
								sub_tree:=Application^.GetAddr(RTPRINTSUBDIAL);
								dialog:=nil;
								tree:=nil;
								index_offset:=0;
								reserved1:=0;
								reserved2:=0;
								init_dlg:=pinit_texel;
								do_dlg:=nil;
								reset_dlg:=preset_texel;
								reserved3:=0;
								private1:=longint(p);
								private2:=0;
								private3:=0;
								private4:=0
							end;
						with AES_pb do
							begin
								control^[0]:=205;
								control^[1]:=1;
								control^[2]:=1;
								control^[3]:=2;
								control^[4]:=0;
								intin^[0]:=3;
								addrin^[0]:=TexelApp.prnt_dialog;
								addrin^[1]:=sub_dialogs;
								_crystal(@AES_pb)
							end
					end;
				docname:=TEXELWINDPREFIX+TITLE_PAPER+#0;
				with AES_pb do
					begin
						control^[0]:=207;
						control^[1]:=1;
						control^[2]:=1;
						control^[3]:=3;
						control^[4]:=0;
						intin^[0]:=PDLG_PREFS or PDLG_ALWAYS_COPIES or PDLG_ALWAYS_SCALE;
						addrin^[0]:=TexelApp.prnt_dialog;
						addrin^[1]:=p^.wnd_prnt_set;
						addrin^[2]:=@docname[1];
						_crystal(@AES_pb);
						if intout^[0]=PDLG_OK then
							begin
								p^.SetDirty;
								if p^.pagepreview<>nil then p^.pagepreview^.Update(true)
							end;
					end;
				if sub_dialogs<>nil then
					begin
						with AES_pb do
							begin
								control^[0]:=205;
								control^[1]:=1;
								control^[2]:=1;
								control^[3]:=1;
								control^[4]:=0;
								intin^[0]:=4;
								addrin^[0]:=TexelApp.prnt_dialog;
								_crystal(@AES_pb)
							end;
						free_sub_dialogs(sub_dialogs)
					end
			end
	end;


procedure TFormSheet.Work;
	var pe    : PEdit;
	    fsizes: PStringCollection;
	    pfsb  : PFontSizeBox;
	    pfb   : PFontBox;
	    pc    : PCheckBox;
	    pb    : PButton;

	begin
		if ADialog=nil then
			begin
				ADialog:=new(PSheetDialog,Init(PCalcWindow(Parent),TEXELWINDPREFIX+TITLE_SHFORM,STG_SHFORM,ICNTITLE_SHFORM,RTFORMSHEET));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTFSSIZE,GROUP_SHEET_SIZE,BUBBLE_SHFORM_SIZE));
						new(PGroupBox,Init(ADialog,RTFSLINEAL,GROUP_SHEET_RULER,''));
						new(PGroupBox,Init(ADialog,RTFSGENERAL,GROUP_SHEET_GENERAL,''));
						new(pe,Init(ADialog,RTFSROWS,6,BUBBLE_SHFORM_ROWS));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(2,16384)));
						PSheetDialog(ADialog)^.ed1:=pe;
						new(pe,Init(ADialog,RTFSCOLUMNS,4,BUBBLE_SHFORM_COLUMNS));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(2,702)));
						PSheetDialog(ADialog)^.ed2:=pe;
						new(pfb,InitCollection(ADialog,RTFSFONTPOP,RTFSFONTCYC,RTFSFONTTITLE,26,PCalcWindow(Parent)^.Fonts,false,false,false,BUBBLE_SHFORM_FONTID));
						if pfb<>nil then
							begin
								pfb^.newsize:=-1;
								new(fsizes,Init(130,20));
								new(pfsb,InitCollection(ADialog,RTFSSIZEPOP,RTFSSIZECYC,RTFSSIZETITLE,6,fsizes,true,false,false,BUBBLE_SHFORM_FONTSIZE));
								pfsb^.setsize:=true;
								pfb^.fsizebox:=pfsb;
								pfb^.Work
							end;
						new(PCheckBox,Init(ADialog,RTFSGITTER,true,BUBBLE_SHFORM_GRID));
						new(PCheckBox,Init(ADialog,RTFSAUTOCALC,true,BUBBLE_SHFORM_AUTOCALC));
						new(PCheckBox,Init(ADialog,RTFSVORLAGE,true,BUBBLE_SHFORM_FORM));
						new(pc,Init(ADialog,RTFSLHOR,true,BUBBLE_SHFORM_HRULER));
						if pc<>nil then pc^.Disable; { ... }
						new(pc,Init(ADialog,RTFSLVERT,true,BUBBLE_SHFORM_VRULER));
						if pc<>nil then pc^.Disable; { ... }
						new(pc,Init(ADialog,RTFSLMOUSE,true,BUBBLE_SHFORM_RMOUSE));
						if pc<>nil then pc^.Disable; { ... }
						new(pc,Init(ADialog,RTFSLLAYOUT,true,BUBBLE_SHFORM_RLAYOUT));
						if pc<>nil then pc^.Disable; { ... }
						new(PCheckBox,Init(ADialog,RTFSOBJECTS,true,BUBBLE_SHFORM_OBJECTS));
						new(PCheckBox,Init(ADialog,RTFSPROTECT,true,BUBBLE_SHFORM_PROTECT));
						new(PCheckBox,Init(ADialog,RTFSUMBRUCH,true,BUBBLE_SHFORM_BREAK));
						new(PButton,Init(ADialog,RTFSCURRENT,id_No,true,BUBBLE_SHFORM_CURRENT));
						new(PButton,Init(ADialog,RTFSMINIMAL,id_No,true,BUBBLE_SHFORM_MINIMAL));
						new(pb,Init(ADialog,RTFSHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTFSOK,id_OK,true,BUBBLE_GENERAL_OK2));
						new(PButton,Init(ADialog,RTFSCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						ADialog^.TransferBuffer:=@PCalcWindow(Parent)^.sheetbuffer
					end
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


procedure TPreviewBox.Changed(AnIndx: integer; DblClick: boolean);

	begin
		inherited Changed(AnIndx,DblClick);
		Parent^.ForceVRedraw
	end;


function TPreviewDialog.WMKeyDown(Stat,Key: integer): boolean;

	begin
		WMKeyDown:=false;
		if Stat=K_NORMAL then
			begin
				case Key of
				25641,20011:
					if pagenum<pages-1 then
						begin
							inc(pagenum);
							CheckButtons;
							WMKeyDown:=true
						end;
				25384,18989:
					if pagenum>0 then
						begin
							dec(pagenum);
							CheckButtons;
							WMKeyDown:=true
						end;
				28720:
					if pagenum>0 then
						begin
							pagenum:=0;
							CheckButtons;
							WMKeyDown:=true
						end;
				28974:
					if pagenum<pages-1 then
						begin
							pagenum:=pages-1;
							CheckButtons;
							WMKeyDown:=true
						end
				end
			end
		else
			if Stat=K_ALT then
				if Key=Alt_S then
					begin
						WMKeyDown:=true;
						if st^.GetState=bf_Enabled then ExitDlg(RTPVPAGE)
					end
	end;


procedure TPreviewDialog.GetWindowClass(var AWndClass: TWndClass);

	begin
		inherited GetWindowClass(AWndClass);
		AWndClass.hbrBackground:=White+1
	end;


function TPreviewDialog.GetStyle: integer;

	begin
		GetStyle:=inherited GetStyle or FULLER or SIZER
	end;


function TPreviewDialog.GetVDIHandle: integer;

	begin
		GetVDIHandle:=id_NewHandle
	end;


procedure TPreviewDialog.GetWorkMax(var maxX,maxY: integer);

	begin
		maxX:=pmaxx+DlgTree^[ROOT].ob_width;
		maxY:=pmaxy
	end;


procedure TPreviewDialog.SetupSize;

	begin
		pmaxx:=0;
		pmaxy:=DlgTree^[ROOT].ob_height;
		Attr.VWork.X1:=DlgTree^[ROOT].ob_width-1;
		DlgTree^[ROOT].ob_height:=Application^.Attr.MaxPY;
		drvnum:=-1;
		pvok:=false;
		TWindow.SetupSize;
		ScanDriver(false,false)
	end;


procedure TPreviewDialog.ScanDriver(draw,ForceOpen: boolean);
	label _fertig;

	var num,q,
	    ww,wh,
	    hndl   : integer;
	    wrkout : workout_ARRAY;
	    p      : PCalcWindow;
	    r      : GRECT;

	procedure clearval;

		begin
			drvnum:=-1;
			pvok:=false;
			pmaxx:=0;
			pmaxy:=DlgTree^[RTPVHELP].ob_y+DlgTree^[RTPVHELP].ob_height+8
		end;

	begin
		p:=PCalcWindow(Parent);
		if p^.prnt=nil then
			begin
				clearval;
				goto _fertig
			end;
		if not(p^.prnt^.IsAvailable(true)) then
			begin
				clearval;
				goto _fertig
			end;
		num:=p^.prnt^.GetDevice;
		if (num<11) or (num>99) then
			begin
				clearval;
				goto _fertig
			end;
		if (num=drvnum) and not(ForceOpen) then exit;
		BusyMouse;
		clearval;
		r:=SysInfo.Desktop;
		Calc(WC_WORK,r,r);
		ww:=r.W-DlgTree^[ROOT].ob_width;
		wh:=r.H;
		vOpnwk(num,hndl,wrkout,p^.prnt^.GetPaperSize,'',p^.wnd_prnt_set);
		if hndl<>0 then
			begin
				{ Metafile-Anpassung !!! }
				vq_extnd(hndl,1,ewrkout);
				v_clswk(hndl);
				case ewrkout[20] of
				1:
					begin
						xmmfak:=10000/ewrkout[21];
						ymmfak:=10000/ewrkout[22]
					end;
				2:
					begin
						xmmfak:=100000/ewrkout[21];
						ymmfak:=100000/ewrkout[22]
					end;
				3:
					begin
						xmmfak:=1000000/ewrkout[21];
						ymmfak:=1000000/ewrkout[22]
					end
				else
					begin
						xmmfak:=1000/wrkout[3];
						ymmfak:=1000/wrkout[4]
					end
				end;
				devW:=wrkout[0]+1;
				devH:=wrkout[1]+1;
				if (longint(devH)/longint(wh))<(longint(devW)/longint(ww)) then
					begin
						pmaxx:=ww;
						pmaxy:=round(longint(ww)*longint(devH)/longint(devW));
						pvscale:=longint(pmaxx)/longint(devW)
					end
				else
					begin
						pmaxy:=wh;
						pmaxx:=round(longint(wh)*longint(devW)/longint(devH));
						pvscale:=longint(pmaxy)/longint(devH)
					end;
				{ Treiberr„nder beachten... }
				fontfak:=longint(Application^.Attr.PixH)/longint(wrkout[4]);
				colors:=wrkout[13];
				colfx:=(colors>LWhite);
				drvnum:=num;
				pvok:=true
			end;
		ArrowMouse;
		_fertig:
		r.X:=0;
		r.Y:=0;
		GetWorkMax(r.W,r.H);
		if draw then
			begin
				Calc(WC_BORDER,r,r);
				Curr.W:=r.W;
				Curr.H:=r.H;
				Calc(WC_WORK,Curr,Work);
				WMFulled
			end
		else
			begin
				Calc(WC_BORDER,r,Curr);
				Curr.X:=(SysInfo.Desktop.W-Curr.W) shr 1;
				Curr.Y:=(SysInfo.Desktop.H-Curr.H) shr 1;
				Calc(WC_WORK,Curr,Work)
			end
	end;


procedure TPreviewDialog.SetupVDI;
	var dummy: integer;

	begin
		Attr.ExStyle:=Attr.ExStyle or ws_ex_LoadFonts;
		inherited SetupVDI;
		Speedo:=Application^.SpeedoActive;
		if Speedo then vst_kern(vdiHandle,0,1,dummy,dummy)
	end;


procedure TPreviewDialog.SetupWindow;

	begin
		inherited SetupWindow;
		Attr.ExStyle:=(Attr.ExStyle and not(ws_ex_TryModeless)) or ws_ex_Modeless;
		pagenum:=0;
		pages:=1
	end;


function TPreviewDialog.GetColWidth(num: integer): integer;

	begin
		GetColWidth:=round(longint(PCalcWindow(Parent)^.PCol^[num])*xmm100fak)+1
	end;


function TPreviewDialog.GetRowHeight(num: integer): integer;

	begin
		GetRowHeight:=round(longint(PCalcWindow(Parent)^.PRow^[num])*ymm100fak)+1
	end;


procedure TPreviewDialog.SetFont(indx,sze: integer);
	var cw,dummy: integer;

	begin
		vst_font(vdiHandle,indx);
		if Speedo then vst_arbpt(vdiHandle,Max(round(sze*prcfak*fontfak*scale),1),cwidth,cheight,bwidth,bheight)
		else
			vst_point(vdiHandle,Max(round(sze*prcfak*fontfak*scale),1),cwidth,cheight,bwidth,bheight);
		if vqt_width(vdiHandle,ord('W'),cw,dummy,dummy)=ord('W') then wwidth:=cw
		else
			wwidth:=cwidth;
		if vqt_width(vdiHandle,ord('9'),cw,dummy,dummy)=ord('9') then nwidth:=cw
		else
			nwidth:=cwidth
	end;


procedure TPreviewDialog.Paint(var PaintInfo: TPaintStruct);
	label _fertig;

	var p      : PCalcWindow;
	    pr,r,r2,
	    clip   : GRECT;
	    dummy  : integer;
	    prctemp: real;

	function xcolor(cl: integer): integer;

		begin
			if cl>=colors then xcolor:=Black
			else
				xcolor:=cl
		end;

	procedure printdoc(xoffs,yoffs,xoffs2,yoffs2: integer);
		label _nextgit,_endgit;

		var xy,xy2,xy3,xy4,
		    brd,tover        : ARRAY_4;
		    ext              : ARRAY_8;
		    clp,clp2,clp3,
		    sr,bclp          : GRECT;
		    oldlcolor,
		    q,w,b,c2,
		    oldstyle,oldcolor,
		    oldinter,tx,ty   : integer;
		    cnum,lofs        : longint;
		    title,sval       : string;
		    pe               : PEmbedded;
		    cmpval           : TOldTxtVal;
		    cell2            : PCell;

		procedure setfontattr(const tval: TTxtVal);
		
			begin
				if (tval.Font<>cmpval.oldfont) or (tval.Size<>cmpval.oldsize) then
					begin
						SetFont(tval.Font,tval.Size);
						cmpval.oldsize:=tval.Size;
						cmpval.oldfont:=tval.Font
					end
			end;
		
		procedure drawbackground;
		
			begin
				with PCell(cnum)^ do
					begin
						if Style<>oldstyle then
							begin
								vsf_style(vdiHandle,Style);
								oldstyle:=Style
							end;
						if Interior<>oldinter then
							begin
								vsf_interior(vdiHandle,Interior);
								oldinter:=Interior
							end;
						if Color<>oldcolor then
							begin
								vsf_color(vdiHandle,xcolor(Color));
								oldcolor:=Color
							end
					end;
				vr_recfl(vdiHandle,xy4)
			end;

		begin
			vst_color(vdihandle,xcolor(Black));
			vst_effects(vdihandle,TF_NORMAL);
			vst_rotation(vdihandle,0);
			if Speedo then vst_skew(vdiHandle,0);
			vst_alignment(vdiHandle,TA_LEFT,TA_BASELINE,dummy,dummy);
			vsl_udsty(vdiHandle,$5555);
			vsl_color(vdiHandle,xcolor(Black));
			vsm_height(vdihandle,1);
			SetFont(p^.GetStdFontIndex,p^.GetStdFontSize);
			vsf_color(vdiHandle,xcolor(White));
			vsf_style(vdiHandle,0);
			vsf_interior(vdiHandle,FIS_HOLLOW);
			if p^.Parms.psbuffer.hcenter=bf_Checked then
				begin
					dummy:=pagew-srect.W;
					if p^.Parms.psbuffer.rows=bf_Checked then dec(dummy,lcw);
					inc(xoffs,dummy shr 1)
				end;
			if p^.Parms.psbuffer.vcenter=bf_Checked then
				begin
					dummy:=pageh-srect.H;
					if p^.Parms.psbuffer.columns=bf_Checked then dec(dummy,trh);
					inc(yoffs,dummy shr 1)
				end;
			if (p^.Parms.psbuffer.rows=bf_Checked) and (p^.Parms.psbuffer.columns=bf_Checked) then
				begin
					xy[0]:=pr.X1+round(scale*xoffs);
					xy[1]:=pr.Y1+round(scale*yoffs);
					xy[2]:=pr.X1+round((xoffs+lcw-1)*scale);
					xy[3]:=pr.Y1+round((yoffs+trh-1)*scale);
					v_bar(vdiHandle,xy);
					if colfx then
						begin
							xy[0]:=pr.X1+round(scale*(xoffs+1));
							xy[1]:=pr.Y1+round(scale*(yoffs+1));
							vsf_interior(vdiHandle,FIS_SOLID);
							vsf_color(vdiHandle,xcolor(LWhite));
							v_bar(vdiHandle,xy);
							vsf_interior(vdiHandle,FIS_HOLLOW);
							vsf_color(vdiHandle,xcolor(Black))
						end
				end;
			vst_alignment(vdiHandle,TA_CENTER,TA_BOTTOM,dummy,dummy);
			if p^.Parms.psbuffer.rows=bf_Checked then
				begin
					w:=rs;
					clp.X:=xoffs;
					if p^.Parms.psbuffer.columns=bf_Checked then clp.Y:=yoffs+trh+1
					else
						clp.Y:=yoffs;
					clp.W:=lcw;
					clp.H:=GetRowHeight(w);
					GRtoA2(clp);
					xy[0]:=clp.X-1;
					xy[1]:=clp.Y-1;
					xy[2]:=clp.X+clp.W;
					repeat
						inc(w);
						clp2.X1:=pr.X1+round(scale*clp.X1);
						clp2.X2:=pr.X1+round(scale*clp.X2);
						clp2.Y1:=pr.Y1+round(scale*clp.Y1);
						clp2.Y2:=pr.Y1+round(scale*clp.Y2);
						A2toGR(clp2);
						if rc_intersect(clip,clp2) then
							begin
								vs_clip(vdiHandle,CLIP_ON,clp2.A2);
								xy[3]:=clp.Y2;
								xy2[0]:=pr.X1+round(scale*xy[0]);
								xy2[1]:=pr.Y1+round(scale*xy[1]);
								xy2[2]:=pr.X1+round(scale*xy[2]);
								xy2[3]:=pr.Y1+round(scale*xy[3]);
								v_bar(vdiHandle,xy2);
								dec(xy[3]);
								xy2[3]:=pr.Y1+round(scale*xy[3]);
								if colfx then
									begin
										vsf_interior(vdiHandle,FIS_SOLID);
										vsf_color(vdiHandle,xcolor(LWhite));
										inc(xy[0],2);
										inc(xy[1],2);
										xy2[0]:=pr.X1+round(scale*xy[0]);
										xy2[1]:=pr.Y1+round(scale*xy[1]);
										v_bar(vdiHandle,xy2);
										dec(xy[0],2);
										xy2[0]:=pr.X1+round(scale*xy[0]);
										vsf_interior(vdiHandle,FIS_HOLLOW);
										vsf_color(vdiHandle,xcolor(Black))
									end;
								vswr_mode(vdiHandle,MD_TRANS);
								v_gtext(vdiHandle,(xy2[0]+xy2[2]) shr 1,xy2[3],ltoa(w));
								vswr_mode(vdiHandle,MD_REPLACE);
								dec(xy2[3]);
								xy2[1]:=xy2[3];
								v_pline(vdiHandle,2,xy2)
							end;
						if w>re then break;
						clp.Y1:=clp.Y2+1;
						inc(clp.Y2,GetRowHeight(w));
						A2toGR(clp);
						xy[1]:=clp.Y-1
					until round(scale*clp.Y1)>clip.Y2;
					sr.X:=xoffs+lcw+1
				end
			else
				sr.X:=xoffs+1;
			if p^.Parms.psbuffer.columns=bf_Checked then
				begin
					q:=cs;
					if p^.Parms.psbuffer.rows=bf_Checked then clp.X:=xoffs+lcw+1
					else
						clp.X:=xoffs+1;
					clp.Y:=yoffs;
					clp.W:=GetColWidth(q)-1;
					clp.H:=trh;
					xy[0]:=clp.X-1;
					xy[1]:=clp.Y-1;
					xy[3]:=clp.Y+clp.H;
					GRtoA2(clp);
					repeat
						clp2.X1:=pr.X1+round(scale*clp.X1);
						clp2.X2:=pr.X1+round(scale*clp.X2);
						clp2.Y1:=pr.Y1+round(scale*clp.Y1);
						clp2.Y2:=pr.Y1+round(scale*clp.Y2);
						A2toGR(clp2);
						if rc_intersect(clip,clp2) then
							begin
								vs_clip(vdiHandle,CLIP_ON,clp2.A2);
								xy[2]:=clp.X2;
								xy2[0]:=pr.X1+round(scale*xy[0]);
								xy2[1]:=pr.Y1+round(scale*xy[1]);
								xy2[2]:=pr.X1+round(scale*xy[2]);
								xy2[3]:=pr.Y1+round(scale*xy[3]);
								v_bar(vdiHandle,xy);
								if colfx then
									begin
										vsf_interior(vdiHandle,FIS_SOLID);
										vsf_color(vdiHandle,xcolor(LWhite));
										inc(xy[0],2);
										inc(xy[1],2);
										dec(xy[2]);
										xy2[0]:=pr.X1+round(scale*xy[0]);
										xy2[1]:=pr.Y1+round(scale*xy[1]);
										xy2[2]:=pr.X1+round(scale*xy[2]);
										v_bar(vdiHandle,xy);
										dec(xy[1],2);
										xy2[1]:=pr.Y1+round(scale*xy[1]);
										vsf_interior(vdiHandle,FIS_HOLLOW);
										vsf_color(vdiHandle,xcolor(Black))
									end;
								vswr_mode(vdiHandle,MD_TRANS);
								v_gtext(vdiHandle,(xy2[0]+xy2[2]) shr 1,xy2[3],p^.GetColumnName(q));
								vswr_mode(vdiHandle,MD_REPLACE);
								dec(xy2[2]);
								xy2[0]:=xy2[2];
								v_pline(vdiHandle,2,xy2)
							end;
						inc(q);
						if q>ce then break;
						clp.X1:=clp.X2+1;
						inc(clp.X2,GetColWidth(q));
						A2toGR(clp);
						xy[0]:=clp.X-1
					until round(scale*clp.X1)>clip.X2;
					sr.Y:=yoffs+trh+1
				end
			else
				sr.Y:=yoffs+1;
			w:=rs;
			clp.X:=0;
			if p^.Parms.psbuffer.columns=bf_Checked then clp.Y:=yoffs+trh+1
			else
				clp.Y:=yoffs;
			if p^.Parms.psbuffer.rows=bf_Checked then clp.W:=xoffs+lcw
			else
				clp.W:=xoffs;
			clp.H:=GetRowHeight(w);
			GRtoA2(clp);
			oldcolor:=White;
			oldlcolor:=Black;
			oldstyle:=0;
			oldinter:=FIS_HOLLOW;
			vsf_color(vdiHandle,xcolor(oldcolor));
			vsf_style(vdiHandle,oldstyle);
			vsf_interior(vdiHandle,oldinter);
			vsl_color(vdiHandle,xcolor(oldlcolor));
			with cmpval do
				begin
					oldfont:=p^.GetFontIndex;
					oldsize:=p^.GetFontSize;
					brd1w:=Max(round(Border1*prcfak*xmmfak*scale)-1,0);
					brd2w:=Max(round(Border2*prcfak*xmmfak*scale)-1,0);
					brd3w:=Max(round(Border3*prcfak*xmmfak*scale)-1,0);
					brd1h:=Max(round(Border1*prcfak*ymmfak*scale)-1,0);
					brd2h:=Max(round(Border2*prcfak*ymmfak*scale)-1,0);
					brd3h:=Max(round(Border3*prcfak*ymmfak*scale)-1,0);
					gitter:=(p^.Parms.psbuffer.gitter=bf_Checked)
				end;
			SetFont(cmpval.oldfont,cmpval.oldsize);
			p^.InitTextValues(vdiHandle,cmpval);
			lofs:=longint(p^.Parms.Columns+1)*CELLSIZE;
			repeat
				q:=cs;
				cnum:=longint(p^.Sheet)+(longint(w)*longint(p^.Parms.Columns+1)+longint(q))*CELLSIZE;
				inc(w);
				clp3.X:=clp.X2+2;
				clp3.Y:=clp.Y;
				clp3.W:=GetColWidth(q)-1;
				clp3.H:=clp.H;
				xy3[0]:=clp3.X-1;
				xy3[1]:=clp3.Y-1;
				xy3[3]:=clp3.Y+clp3.H-1;
				if cmpval.gitter then dec(xy3[3]);
				GRtoA2(clp3);
				repeat
					clp2.X1:=pr.X1+round(scale*clp3.X1);
					clp2.X2:=pr.X1+round(scale*clp3.X2);
					clp2.Y1:=pr.Y1+round(scale*clp3.Y1);
					clp2.Y2:=pr.Y1+round(scale*clp3.Y2);
					A2toGR(clp2);
					if rc_intersect(clip,clp2) then
						begin
							vs_clip(vdiHandle,CLIP_ON,clp2.A2);
							xy3[2]:=clp3.X2;
							if cmpval.gitter then
								if (PCell(cnum)^.TxtVal.Flags and TFL_GITTERMASK)=0 then dec(xy3[2]);
							xy4[0]:=pr.X1+round(scale*xy3[0]);
							xy4[1]:=pr.Y1+round(scale*xy3[1]);
							xy4[2]:=pr.X1+round(scale*xy3[2]);
							xy4[3]:=pr.Y1+round(scale*xy3[3]);
							drawbackground;
							with PCell(cnum)^ do
								begin
									vswr_mode(vdiHandle,MD_TRANS);
									case Typ of
									CTYPE_TEXT:
										if Data.Value<>0 then
											begin
												setfontattr(TxtVal);
												p^.OutputVectorText(vdiHandle,PCell(cnum),Data.Txt^,TxtVal,cmpval,xy4,false)
											end;
									CTYPE_CONST:
										with Data.Konst^ do
											begin
												if p^.Val2Txt(Value,sval,FPts,Format,PCell(cnum)) then drawbackground;
												setfontattr(TxtVal);
												p^.OutputVectorText(vdiHandle,PCell(cnum),sval,TxtVal,cmpval,xy4,true)
											end;
									CTYPE_FORMULA:
										with Data.Formula^ do
											if Error=FE_OK then
												begin
													if p^.Val2Txt(Value,sval,FPts,Format,PCell(cnum)) then drawbackground;
													setfontattr(TxtVal);
													p^.OutputVectorText(vdiHandle,PCell(cnum),sval,TxtVal,cmpval,xy4,true)
												end
											else
												begin
													setfontattr(TxtVal);
													p^.OutputErrorText(vdiHandle,PCell(cnum),TxtVal,cmpval,xy4,Error)
												end;
									CTYPE_EMPTY:
										begin
											if bTst(TxtVal.Flags,TFL_TEXTFROMLEFT) then
												begin
													tover:=xy3;
													c2:=q;
													cell2:=PCell(cnum);
													repeat
														dec(longint(cell2),CELLSIZE);
														dec(c2);
														if c2<cs then break
														else
															begin
																tover[2]:=tover[0]-1;
																dec(tover[0],GetColWidth(c2))
															end;
													until (cell2^.TxtVal.Flags and TFL_RIGHTMASK)=TFL_TEXT2RIGHT;
													if c2>=cs then
														begin
															tover[0]:=pr.X1+round(scale*tover[0]);
															tover[1]:=pr.Y1+round(scale*tover[1]);
															tover[2]:=pr.X1+round(scale*tover[2]);
															tover[3]:=pr.Y1+round(scale*tover[3]);
															setfontattr(cell2^.TxtVal);
															p^.OutputVectorText(vdiHandle,cell2,cell2^.Data.Txt^,cell2^.TxtVal,cmpval,tover,false)
														end
												end
											else
												if bTst(TxtVal.Flags,TFL_TEXTFROMRIGHT) then
													begin
														tover:=xy3;
														c2:=q;
														cell2:=PCell(cnum);
														repeat
															inc(longint(cell2),CELLSIZE);
															inc(c2);
															if c2>ce then break
															else
																begin
																	tover[0]:=tover[2]+1;
																	inc(tover[2],GetColWidth(c2));
																	if cmpval.gitter then dec(tover[2])
																end;
														until (cell2^.TxtVal.Flags and TFL_LEFTMASK)=TFL_TEXT2LEFT;
														if c2<=ce then
															begin
																tover[0]:=pr.X1+round(scale*tover[0]);
																tover[1]:=pr.Y1+round(scale*tover[1]);
																tover[2]:=pr.X1+round(scale*tover[2]);
																tover[3]:=pr.Y1+round(scale*tover[3]);
																setfontattr(cell2^.TxtVal);
																p^.OutputVectorText(vdiHandle,cell2,cell2^.Data.Txt^,cell2^.TxtVal,cmpval,tover,false)
															end
													end
										end
									end;
									vswr_mode(vdiHandle,MD_REPLACE);
									if cmpval.gitter then
										begin
											if (PCell(cnum)^.TxtVal.Flags and TFL_GITTERMASK)=0 then inc(xy3[2]);
											inc(xy3[3])
										end;
									with Border do
										if (Val1<>0) or (Val2<>0) then
											begin
												bclp.X1:=pr.X1+round(scale*clp3.X1)-1;
												bclp.X2:=pr.X1+round(scale*clp3.X2)-1;
												bclp.Y1:=pr.Y1+round(scale*clp3.Y1);
												bclp.Y2:=pr.Y1+round(scale*clp3.Y2);
												A2toGR(bclp);
												if rc_intersect(clip,bclp) then
													begin
														vs_clip(vdiHandle,CLIP_ON,bclp.A2);
														if Left>=16 then
															if (TxtVal.Flags and TFL_LEFTBORDER)=0 then
																begin
																	if (Left and $f)<>oldlcolor then
																		begin
																			oldlcolor:=Left and $f;
																			vsl_color(vdiHandle,xcolor(oldlcolor))
																		end;
																	if q=cs then inc(xy3[0]);
																	case (Left shr 4) of
																	1:
																		begin
																			brd[0]:=xy3[0];
																			brd[1]:=xy3[1];
																			brd[2]:=brd[0];
																			brd[3]:=xy3[3];
																			xy4[0]:=pr.X1+round(scale*brd[0]);
																			xy4[1]:=pr.Y1+round(scale*brd[1]);
																			xy4[2]:=pr.X1+round(scale*brd[2]);
																			xy4[3]:=pr.Y1+round(scale*brd[3]);
																			v_pline(vdiHandle,2,xy4)
																		end;
																	2:
																		begin
																			xy4[0]:=pr.X1+round(scale*xy3[0]);
																			xy4[1]:=pr.Y1+round(scale*xy3[1]);
																			xy4[3]:=pr.Y1+round(scale*xy3[3]);
																			for b:=0 to cmpval.brd1w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					inc(xy4[0])
																				end
																		end;
																	3:
																		begin
																			xy4[0]:=pr.X1+round(scale*xy3[0]);
																			xy4[1]:=pr.Y1+round(scale*xy3[1]);
																			xy4[3]:=pr.Y1+round(scale*xy3[3]);
																			for b:=0 to cmpval.brd2w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					inc(xy4[0])
																				end
																		end;
																	4:
																		begin
																			xy4[0]:=pr.X1+round(scale*xy3[0]);
																			xy4[1]:=pr.Y1+round(scale*xy3[1]);
																			xy4[3]:=pr.Y1+round(scale*xy3[3]);
																			for b:=0 to cmpval.brd3w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					inc(xy4[0])
																				end
																		end;
																	5:
																		begin
																			xy4[0]:=pr.X1+round(scale*xy3[0]);
																			xy4[1]:=pr.Y1+round(scale*xy3[1]);
																			xy4[3]:=pr.Y1+round(scale*xy3[3]);
																			for b:=0 to cmpval.brd1w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					inc(xy4[0])
																				end;
																			xy4[0]:=pr.X1+round(scale*xy3[0])+cmpval.brd3w;
																			for b:=0 to cmpval.brd1w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					dec(xy4[0])
																				end
																		end
																	end;
																	if q=cs then dec(xy3[0])
																end;
														if Right>=16 then
															if (TxtVal.Flags and TFL_RIGHTBORDER)=0 then
																begin
																	if (Right and $f)<>oldlcolor then
																		begin
																			oldlcolor:=Right and $f;
																			vsl_color(vdiHandle,xcolor(oldlcolor))
																		end;
																	case (Right shr 4) of
																	1:
																		begin
																			brd[0]:=xy3[2];
																			brd[1]:=xy3[1];
																			brd[2]:=brd[0];
																			brd[3]:=xy3[3];
																			xy4[0]:=pr.X1+round(scale*brd[0])-1;
																			xy4[1]:=pr.Y1+round(scale*brd[1]);
																			xy4[2]:=pr.X1+round(scale*brd[2])-1;
																			xy4[3]:=pr.Y1+round(scale*brd[3]);
																			v_pline(vdiHandle,2,xy4)
																		end;
																	2:
																		begin
																			xy4[0]:=pr.X1+round(scale*xy3[2])-1;
																			xy4[1]:=pr.Y1+round(scale*xy3[1]);
																			xy4[3]:=pr.Y1+round(scale*xy3[3]);
																			for b:=0 to cmpval.brd1w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					dec(xy4[0])
																				end
																		end;
																	3:
																		begin
																			xy4[0]:=pr.X1+round(scale*xy3[2])-1;
																			xy4[1]:=pr.Y1+round(scale*xy3[1]);
																			xy4[3]:=pr.Y1+round(scale*xy3[3]);
																			for b:=0 to cmpval.brd2w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					dec(xy4[0])
																				end
																		end;
																	4:
																		begin
																			xy4[0]:=pr.X1+round(scale*xy3[2])-1;
																			xy4[1]:=pr.Y1+round(scale*xy3[1]);
																			xy4[3]:=pr.Y1+round(scale*xy3[3]);
																			for b:=0 to cmpval.brd3w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					dec(xy4[0])
																				end
																		end;
																	5:
																		begin
																			xy4[0]:=pr.X1+round(scale*xy3[2])-1;
																			xy4[1]:=pr.Y1+round(scale*xy3[1]);
																			xy4[3]:=pr.Y1+round(scale*xy3[3]);
																			for b:=0 to cmpval.brd1w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					dec(xy4[0])
																				end;
																			xy4[0]:=pr.X1+round(scale*xy3[2])-cmpval.brd3w-1;
																			for b:=0 to cmpval.brd1w do
																				begin
																					xy4[2]:=xy4[0];
																					v_pline(vdiHandle,2,xy4);
																					inc(xy4[0])
																				end
																		end
																	end
																end;
														if Top>=16 then
															begin
																if (Top and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Top and $f;
																		vsl_color(vdiHandle,xcolor(oldlcolor))
																	end;
																if w=rs+1 then inc(xy3[1]);
																case (Top shr 4) of
																1:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=xy3[1];
																		brd[2]:=xy3[2];
																		brd[3]:=brd[1];
																		xy4[0]:=pr.X1+round(scale*brd[0]);
																		xy4[1]:=pr.Y1+round(scale*brd[1]);
																		xy4[2]:=pr.X1+round(scale*brd[2]);
																		xy4[3]:=pr.Y1+round(scale*brd[3]);
																		v_pline(vdiHandle,2,xy4)
																	end;
																2:
																	begin
																		xy4[1]:=pr.Y1+round(scale*xy3[1]);
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd1h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[1])
																			end
																	end;
																3:
																	begin
																		xy4[1]:=pr.Y1+round(scale*xy3[1]);
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd2h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[1])
																			end
																	end;
																4:
																	begin
																		xy4[1]:=pr.Y1+round(scale*xy3[1]);
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd3h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[1])
																			end
																	end;
																5:
																	begin
																		xy4[1]:=pr.Y1+round(scale*xy3[1]);
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd1h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[1])
																			end;
																		xy4[1]:=pr.Y1+round(scale*xy3[1])+cmpval.brd3h;
																		for b:=0 to cmpval.brd1h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				dec(xy4[1])
																			end
																	end
																end;
																if w=rs+1 then dec(xy3[1])
															end;
														if Bottom>=16 then
															begin
																if (Bottom and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Bottom and $f;
																		vsl_color(vdiHandle,xcolor(oldlcolor))
																	end;
																case (Bottom shr 4) of
																1:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=xy3[3];
																		brd[2]:=xy3[2];
																		brd[3]:=brd[1];
																		xy4[0]:=pr.X1+round(scale*brd[0]);
																		xy4[1]:=pr.Y1+round(scale*brd[1])-1;
																		xy4[2]:=pr.X1+round(scale*brd[2]);
																		xy4[3]:=pr.Y1+round(scale*brd[3])-1;
																		v_pline(vdiHandle,2,xy4)
																	end;
																2:
																	begin
																		xy4[1]:=pr.Y1+round(scale*xy3[3])-1;
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd1h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				dec(xy4[1])
																			end
																	end;
																3:
																	begin
																		xy4[1]:=pr.Y1+round(scale*xy3[3])-1;
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd2h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				dec(xy4[1])
																			end
																	end;
																4:
																	begin
																		xy4[1]:=pr.Y1+round(scale*xy3[3])-1;
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd3h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				dec(xy4[1])
																			end
																	end;
																5:
																	begin
																		xy4[1]:=pr.Y1+round(scale*xy3[3])-1;
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd1h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				dec(xy4[1])
																			end;
																		xy4[1]:=pr.Y1+round(scale*xy3[3])-cmpval.brd3h-1;
																		for b:=0 to cmpval.brd1h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[1])
																			end
																	end
																end
															end;
														if Hor>=16 then
															begin
																if (Hor and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Hor and $f;
																		vsl_color(vdiHandle,xcolor(oldlcolor))
																	end;
																case (Hor shr 4) of
																1:
																	begin
																		brd[0]:=xy3[0];
																		brd[1]:=(xy3[1]+xy3[3]) shr 1;
																		brd[2]:=xy3[2];
																		brd[3]:=brd[1];
																		xy4[0]:=pr.X1+round(scale*brd[0]);
																		xy4[1]:=pr.Y1+round(scale*brd[1]);
																		xy4[2]:=pr.X1+round(scale*brd[2]);
																		xy4[3]:=pr.Y1+round(scale*brd[3]);
																		v_pline(vdiHandle,2,xy4)
																	end;
																2:
																	begin
																		xy4[1]:=pr.Y1+round(scale*(xy3[1]+xy3[3])/2.0)-((cmpval.brd1h+1) shr 1);
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd1h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[1])
																			end
																	end;
																3:
																	begin
																		xy4[1]:=pr.Y1+round(scale*(xy3[1]+xy3[3])/2.0)-((cmpval.brd2h+1) shr 1);
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd2h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[1])
																			end
																	end;
																4:
																	begin
																		xy4[1]:=pr.Y1+round(scale*(xy3[1]+xy3[3])/2.0)-((cmpval.brd3h+1) shr 1);
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd3h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[1])
																			end
																	end;
																5:
																	begin
																		xy4[1]:=pr.Y1+round(scale*(xy3[1]+xy3[3])/2.0)-((cmpval.brd3h+1) shr 1);
																		xy4[0]:=pr.X1+round(scale*xy3[0]);
																		xy4[2]:=pr.X1+round(scale*xy3[2]);
																		for b:=0 to cmpval.brd1h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[1])
																			end;
																		xy4[1]:=pr.Y1+round(scale*(xy3[1]+xy3[3])/2.0)+cmpval.brd3h-((cmpval.brd3h+1) shr 1);
																		for b:=0 to cmpval.brd1h do
																			begin
																				xy4[3]:=xy4[1];
																				v_pline(vdiHandle,2,xy4);
																				dec(xy4[1])
																			end
																	end
																end
															end;
														if Vert>=16 then
															begin
																if (Vert and $f)<>oldlcolor then
																	begin
																		oldlcolor:=Vert and $f;
																		vsl_color(vdiHandle,xcolor(oldlcolor))
																	end;
																case (Vert shr 4) of
																1:
																	begin
																		brd[0]:=(xy3[0]+xy3[2]) shr 1;
																		brd[1]:=xy3[1];
																		brd[2]:=brd[0];
																		brd[3]:=xy3[3];
																		xy4[0]:=pr.X1+round(scale*brd[0]);
																		xy4[1]:=pr.Y1+round(scale*brd[1]);
																		xy4[2]:=pr.X1+round(scale*brd[2]);
																		xy4[3]:=pr.Y1+round(scale*brd[3]);
																		v_pline(vdiHandle,2,xy4)
																	end;
																2:
																	begin
																		xy4[0]:=pr.X1+round(scale*(xy3[0]+xy3[2])/2.0)-((cmpval.brd1w+1) shr 1);
																		xy4[1]:=pr.Y1+round(scale*xy3[1]);
																		xy4[3]:=pr.Y1+round(scale*xy3[3]);
																		for b:=0 to cmpval.brd1w do
																			begin
																				xy4[2]:=xy4[0];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[0])
																			end
																	end;
																3:
																	begin
																		xy4[0]:=pr.X1+round(scale*(xy3[0]+xy3[2])/2.0)-((cmpval.brd2w+1) shr 1);
																		xy4[1]:=pr.Y1+round(scale*xy3[1]);
																		xy4[3]:=pr.Y1+round(scale*xy3[3]);
																		for b:=0 to cmpval.brd2w do
																			begin
																				xy4[2]:=xy4[0];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[0])
																			end
																	end;
																4:
																	begin
																		xy4[0]:=pr.X1+round(scale*(xy3[0]+xy3[2])/2.0)-((cmpval.brd3w+1) shr 1);
																		xy4[1]:=pr.Y1+round(scale*xy3[1]);
																		xy4[3]:=pr.Y1+round(scale*xy3[3]);
																		for b:=0 to cmpval.brd3w do
																			begin
																				xy4[2]:=xy4[0];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[0])
																			end
																	end;
																5:
																	begin
																		xy4[0]:=pr.X1+round(scale*(xy3[0]+xy3[2])/2.0)-((cmpval.brd3w+1) shr 1);
																		xy4[1]:=pr.Y1+round(scale*xy3[1]);
																		xy4[3]:=pr.Y1+round(scale*xy3[3]);
																		for b:=0 to cmpval.brd1w do
																			begin
																				xy4[2]:=xy4[0];
																				v_pline(vdiHandle,2,xy4);
																				inc(xy4[0])
																			end;
																		xy4[0]:=pr.X1+round(scale*(xy3[0]+xy3[2])/2.0)+cmpval.brd3w-((cmpval.brd3w+1) shr 1);
																		for b:=0 to cmpval.brd1w do
																			begin
																				xy4[2]:=xy4[0];
																				v_pline(vdiHandle,2,xy4);
																				dec(xy4[0])
																			end
																	end
																end
															end;
														vs_clip(vdiHandle,CLIP_ON,clp2.A2);
													end
											end;
									if cmpval.gitter then dec(xy3[3])
								end;
							if cmpval.gitter then
								begin
									if colfx then
										begin
											if oldlcolor<>LWhite then
												begin
													vsl_color(vdiHandle,xcolor(LWhite));
													oldlcolor:=LWhite
												end
										end
									else
										begin
											if oldlcolor<>Black then
												begin
													vsl_color(vdiHandle,xcolor(Black));
													oldlcolor:=Black
												end;
											vsl_type(vdiHandle,LT_USERDEF)
										end;
									if PCell(cnum)^.Border.Right<16 then
										if (PCell(cnum)^.TxtVal.Flags and TFL_GITTERMASK)=0 then
											begin
												if q<p^.Parms.Columns then
													if PCell(cnum+CELLSIZE)^.Border.Left>=16 then goto _nextgit;
												xy2[0]:=xy3[2];
												xy2[1]:=xy3[1];
												xy2[2]:=xy2[0];
												xy2[3]:=xy3[3]+1;
												xy4[0]:=pr.X1+round(scale*xy2[0])-1;
												xy4[1]:=pr.Y1+round(scale*xy2[1]);
												xy4[2]:=pr.X1+round(scale*xy2[2])-1;
												xy4[3]:=pr.Y1+round(scale*xy2[3]);
												v_pline(vdiHandle,2,xy4)
											end;
									_nextgit:
									if PCell(cnum)^.Border.Bottom<16 then
										begin
											if w<=p^.Parms.Rows then
												if PCell(cnum+lofs)^.Border.Top>=16 then goto _endgit;
											xy2[0]:=xy3[0];
											xy2[1]:=xy3[3]+1;
											xy2[2]:=xy3[2];
											xy2[3]:=xy2[1];
											xy4[0]:=pr.X1+round(scale*xy2[0]);
											xy4[1]:=pr.Y1+round(scale*xy2[1])-1;
											xy4[2]:=pr.X1+round(scale*xy2[2]);
											xy4[3]:=pr.Y1+round(scale*xy2[3])-1;
											v_pline(vdiHandle,2,xy4)
										end;
									_endgit:
									vsl_type(vdiHandle,LT_SOLID)
								end
							else
								dec(xy3[3]);
							if not(cmpval.gitter) then inc(xy3[3])
						end;
					inc(q);
					if q>ce then break;
					clp3.X1:=clp3.X2+1;
					inc(clp3.X2,GetColWidth(q));
					A2toGR(clp3);
					xy3[0]:=clp3.X-1;
					inc(cnum,CELLSIZE)
				until round(scale*clp3.X1)>clip.X2;
				if w>re then break;
				clp.Y1:=clp.Y2+1;
				inc(clp.Y2,GetRowHeight(w));
				A2toGR(clp)
			until round(scale*clp.Y1)>clip.Y2;
			if p^.Embedded<>nil then
				if p^.Parms.psbuffer.images=bf_Checked then
					begin
						clp.X:=pr.X1+round(scale*xoffs);
						if p^.Parms.psbuffer.rows=bf_Checked then inc(clp.X,round(scale*(lcw+1)));
						clp.Y:=pr.Y1+round(scale*yoffs);
						if p^.Parms.psbuffer.columns=bf_Checked then inc(clp.Y,round(scale*(trh+1)));
						clp.W:=round(scale*srect.W);
						clp.H:=round(scale*srect.H);
						if rc_intersect(clip,clp) then
							begin
								pe:=p^.Embedded;
								while pe<>nil do
									begin
										if pe^.CanPrint then
											begin
												pe^.SetWorkstationValues(drvnum,colors,-pr.X1-round(scale*(xoffs-XPixOffs)),-pr.Y1-round(scale*(yoffs-YPixOffs)),scale*xmm100fak,scale*ymm100fak,prcfak,fontfak*scale,bTst(ewrkout[30],1),true);
												if pe^.IsVisible(clp,false) then
													begin
														vs_clip(vdiHandle,CLIP_ON,clp.A2);
														pe^.Paint(vdiHandle,clp,false)
													end
											end;
										pe:=pe^.Next
									end
							end
					end;
			SetFont(p^.GetStdFontIndex,p^.GetStdFontSize);
			p^.RestoreTextValues(vdiHandle);
			vsl_color(vdiHandle,Black);
			vs_clip(vdiHandle,CLIP_ON,clip.A2);
			if (p^.Parms.psbuffer.columns=bf_Checked) or (p^.Parms.psbuffer.rows=bf_Checked) or cmpval.gitter then
				begin
					pxya[0]:=pr.X1+round(scale*xoffs);
					pxya[1]:=pr.Y1+round(scale*yoffs);
					pxya[2]:=xoffs+srect.X2-1;
					if p^.Parms.psbuffer.rows=bf_Checked then inc(pxya[2],lcw);
					pxya[2]:=pr.X1+round(scale*pxya[2]);
					pxya[3]:=pr.Y1+round(scale*yoffs);
					v_pline(vdiHandle,2,pxya);
					if p^.Parms.psbuffer.columns=bf_Checked then
						begin
							pxya[1]:=pr.Y1+round(scale*(yoffs+trh-1));
							pxya[3]:=pxya[1];
							v_pline(vdiHandle,2,pxya);
							pxya[1]:=pr.Y1+round(scale*(yoffs+trh+srect.Y2))
						end
					else
						pxya[1]:=pr.Y1+round(scale*(yoffs+srect.Y2));
					pxya[3]:=pxya[1];
					v_pline(vdiHandle,2,pxya);
					pxya[0]:=pr.X1+round(scale*xoffs);
					pxya[1]:=pr.Y1+round(scale*yoffs);
					pxya[2]:=pr.X1+round(scale*xoffs);
					pxya[3]:=yoffs+srect.Y2;
					if p^.Parms.psbuffer.columns=bf_Checked then inc(pxya[3],trh);
					pxya[3]:=pr.Y1+round(scale*pxya[3]);
					v_pline(vdiHandle,2,pxya);
					if p^.Parms.psbuffer.rows=bf_Checked then
						begin
							pxya[0]:=pr.X1+round(scale*(xoffs+lcw-1));
							pxya[2]:=pxya[0];
							v_pline(vdiHandle,2,pxya);
							pxya[0]:=pr.X1+round(scale*(xoffs+lcw+srect.X2-1))
						end
					else
						pxya[0]:=pr.X1+round(scale*(xoffs+srect.X2-1));
					pxya[2]:=pxya[0];
					v_pline(vdiHandle,2,pxya)
				end
		end;

	begin
		inherited Paint(PaintInfo);
		if not(pvok) then exit;
		p:=PCalcWindow(Parent);
		pr.X:=Work.X+DlgTree^[ROOT].ob_width;
		pr.Y:=Work.Y;
		pr.W:=pmaxx;
		pr.H:=pmaxy;
		GRtoA2(pr);
		pxya[0]:=pr.X-1;
		pxya[1]:=pr.Y1;
		pxya[2]:=pxya[0];
		pxya[3]:=pr.Y2;
		vsl_color(vdiHandle,xcolor(LWhite));
		v_pline(vdiHandle,2,pxya);
		r:=PaintInfo.rcPaint;
		if not(rc_intersect(pr,r)) then exit;
		vst_color(vdihandle,xcolor(Black));
		vst_effects(vdihandle,TF_NORMAL);
		vst_rotation(vdihandle,0);
		if Speedo then vst_skew(vdihandle,0);
		vst_alignment(vdihandle,TA_LEFT,TA_BASELINE,dummy,dummy);
		vsl_udsty(vdihandle,$5555);
		vsm_height(vdihandle,1);
		vsf_color(vdihandle,xcolor(White));
		vsf_style(vdihandle,0);
		vsf_interior(vdihandle,FIS_HOLLOW);
		clip.X1:=pr.X1+round(scale*xoffs);
		clip.X2:=pr.X1+round(scale*xoffs2);
		if mmkopf>0.0 then
			begin
				clip.Y1:=pr.Y1+round(atof(p^.Parms.psbuffer.oben)*ymmfak*scale);
				clip.Y2:=pr.Y1+round(yoffs*scale)-1;
				A2toGR(clip);
				r2:=r;
				if rc_intersect(clip,r2) then
					begin
						vs_clip(vdihandle,CLIP_ON,r2.A2);
						prctemp:=prcfak;
						prcfak:=1.0;
						SetFont(p^.GetStdFontIndex,p^.GetStdFontSize);
						if p^.Parms.psbuffer.hlefton=bf_Checked then p^.OutputKF(vdiHandle,clip.X1,clip.Y1,TA_LEFT,TA_TOP,pagenum,pages,printtime,p^.Parms.psbuffer.hleft);
						if p^.Parms.psbuffer.hcenteron=bf_Checked then p^.OutputKF(vdiHandle,(clip.X1+clip.X2) shr 1,clip.Y1,TA_CENTER,TA_TOP,pagenum,pages,printtime,p^.Parms.psbuffer.hmid);
						if p^.Parms.psbuffer.hrighton=bf_Checked then p^.OutputKF(vdiHandle,clip.X2,clip.Y1,TA_RIGHT,TA_TOP,pagenum,pages,printtime,p^.Parms.psbuffer.hright);
						prcfak:=prctemp
					end
			end;
		if mmfuss>0.0 then
			begin
				clip.Y1:=pr.Y1+round(scale*yoffs2)+1;
				clip.Y2:=pr.Y2-round(atof(p^.Parms.psbuffer.unten)*ymmfak*scale);
				A2toGR(clip);
				r2:=r;
				if rc_intersect(clip,r2) then
					begin
						vs_clip(vdiHandle,CLIP_ON,r2.A2);
						prctemp:=prcfak;
						prcfak:=1.0;
						SetFont(p^.GetStdFontIndex,p^.GetStdFontSize);
						if p^.Parms.psbuffer.flefton=bf_Checked then p^.OutputKF(vdiHandle,clip.X1,clip.Y2,TA_LEFT,TA_BOTTOM,pagenum,pages,printtime,p^.Parms.psbuffer.fleft);
						if p^.Parms.psbuffer.fcenteron=bf_Checked then p^.OutputKF(vdiHandle,(clip.X1+clip.X2) shr 1,clip.Y2,TA_CENTER,TA_BOTTOM,pagenum,pages,printtime,p^.Parms.psbuffer.fmid);
						if p^.Parms.psbuffer.frighton=bf_Checked then p^.OutputKF(vdiHandle,clip.X2,clip.Y2,TA_RIGHT,TA_BOTTOM,pagenum,pages,printtime,p^.Parms.psbuffer.fright);
						prcfak:=prctemp
					end
			end;
		if (rec<0) or (cec<0) then goto _fertig;
		clip.Y1:=pr.Y1+round(scale*yoffs);
		clip.Y2:=pr.Y1+round(scale*yoffs2);
		A2toGR(clip);
		if rc_intersect(r,clip) then
			begin
				vs_clip(vdiHandle,CLIP_ON,clip.A2);
				printdoc(xoffs,yoffs,xoffs2,yoffs2)
			end;
		_fertig:
		if cb^.GetCheck=bf_Checked then
			begin
				vs_clip(vdiHandle,CLIP_ON,r.A2);
				vsl_color(vdiHandle,xcolor(Black));
				vsl_type(vdiHandle,LT_USERDEF);
				pxya[0]:=pr.X1;
				pxya[1]:=pr.Y1+round(atof(p^.Parms.psbuffer.oben)*ymmfak*scale);
				pxya[2]:=pr.X2;
				pxya[3]:=pxya[1];
				v_pline(vdiHandle,2,pxya);
				pxya[0]:=pr.X1;
				pxya[1]:=pr.Y1+round(yoffs*scale)-1;
				pxya[2]:=pr.X2;
				pxya[3]:=pxya[1];
				v_pline(vdiHandle,2,pxya);
				pxya[0]:=pr.X1;
				pxya[1]:=pr.Y2-round(atof(p^.Parms.psbuffer.unten)*ymmfak*scale);
				pxya[2]:=pr.X2;
				pxya[3]:=pxya[1];
				v_pline(vdiHandle,2,pxya);
				pxya[0]:=pr.X1;
				pxya[1]:=pr.Y1+round(yoffs2*scale)+1;
				pxya[2]:=pr.X2;
				pxya[3]:=pxya[1];
				v_pline(vdiHandle,2,pxya);
				pxya[0]:=pr.X1+round(atof(p^.Parms.psbuffer.links)*xmmfak*scale);
				pxya[1]:=pr.Y1;
				pxya[2]:=pxya[0];
				pxya[3]:=pr.Y2;
				v_pline(vdiHandle,2,pxya);
				pxya[0]:=pr.X2-round(atof(p^.Parms.psbuffer.rechts)*xmmfak*scale);
				pxya[1]:=pr.Y1;
				pxya[2]:=pxya[0];
				pxya[3]:=pr.Y2;
				v_pline(vdiHandle,2,pxya);
				vsl_type(vdiHandle,LT_SOLID)
			end
	end;


function TPreviewDialog.ExitDlg(AnIndx: integer): boolean;
	var p   : PCalcWindow;
	    dbuf: string[15];
	    d   : PDialog;
	    ps  : PStatic;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTPVPAGE:
			begin
				new(d,Init(@self,'',RTPREVPAGE));
				if d<>nil then
					begin
						d^.Attr.ExStyle:=(d^.Attr.ExStyle and not(ws_ex_Center2Parent)) or ws_ex_Popup;
						new(PEdit,Init(d,RTPPINPUT,5,BUBBLE_PAGE_NEW));
						new(ps,Init(d,RTPPMAX,11,false,BUBBLE_PAGE_MAX));
						if ps<>nil then ps^.SetText('('+STRING_PAGEOF+' '+ltoa(pages)+')');
						new(PButton,Init(d,RTPPCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(d,RTPPOK,id_OK,true,BUBBLE_PAGE_OK));
						dbuf:=ltoa(pagenum+1);
						d^.TransferBuffer:=@dbuf;
						if Application^.ExecDialog(d)=RTPPOK then
							if length(StrPTrimF(dbuf))>0 then
								begin
									pagenum:=atol(StrPTrimF(dbuf))-1;
									if pagenum<0 then pagenum:=0;
									if pagenum>=pages then pagenum:=pages-1;
									CheckButtons
								end
					end
			end;
		RTPVDEC:
			if pagenum>0 then
				begin
					dec(pagenum);
					CheckButtons
				end;
		RTPVINC:
			if pagenum<pages-1 then
				begin
					inc(pagenum);
					CheckButtons
				end;
		RTPVPRINT:
			if p^.prnt<>nil then p^.prnt^.Display(RTPOK);
		RTPVPAPER:
			if p^.paper<>nil then p^.paper^.Work;
		RTPVFIT:
			Shrink2Fit;
		RTPV100:
			p^.SetPercent(65536.0);
		RTPVLAYOUT:
			if p^.pagesetup<>nil then p^.pagesetup^.Work
		end
	end;


procedure TPreviewDialog.Shrink2Fit;
	label _raus;
	
	var p    : PCalcWindow;
	    xold,
	    yold,
	    nprc1,
	    nprc2: real;
	    q    : integer;
	    pixw,
	    pixh : longint;

	begin
		if not(pvok) then exit;
		if (pagew<=0) or (pageh<=0) then exit;
		BusyMouse;
		p:=PCalcWindow(Parent);
		xold:=xmm100fak;
		yold:=ymm100fak;
		xmm100fak:=xmmfak/100;
		ymm100fak:=ymmfak/100;
		pixw:=0;
		pixh:=0;
		for q:=csc to cec do inc(pixw,GetColWidth(q));
		for q:=rsc to rec do inc(pixh,GetRowHeight(q));
		if (pixw<=0) or (pixh<=0) then goto _raus;
		nprc1:=pagew*65207.0/pixw;
		nprc2:=pageh*65207.0/pixh;
		xmm100fak:=xold;
		ymm100fak:=yold;
		if nprc1<nprc2 then p^.SetPercent(nprc1)
		else
			p^.SetPercent(nprc2);
		_raus:
		ArrowMouse
	end;


procedure TPreviewDialog.Update(ForceOpen: boolean);
	label _leer,_error;

	var cell : PCell;
	    q,w,t: integer;
	    p    : PCalcWindow;
	    pe   : PEmbedded;
	    xmm,
	    ymm  : longint;

	begin
		if Attr.Status<>ws_Open then exit;
		ScanDriver(true,ForceOpen);
		if not(pvok) then
			begin
				st^.SetText(STRING_NODRIVER);
				_error:
				st^.Disable;
				pb1^.Disable;
				pb2^.Disable;
				pb3^.Disable;
				pb4^.Disable;
				scale:=pvscale;
				ForceVRedraw;
				exit
			end;
		p:=PCalcWindow(Parent);
		printtime:=gettime;
		rsc:=0;
		csc:=0;
		rec:=-1;
		cec:=-1;
		mmkopf:=atof(p^.Parms.psbuffer.kopf);
		mmfuss:=atof(p^.Parms.psbuffer.fuss);
		xoffs:=round(atof(p^.Parms.psbuffer.links)*xmmfak);
		yoffs:=round((atof(p^.Parms.psbuffer.oben)+mmkopf)*ymmfak);
		xoffs2:=devW-round(atof(p^.Parms.psbuffer.rechts)*xmmfak)-1;
		yoffs2:=devH-round((atof(p^.Parms.psbuffer.unten)+mmfuss)*ymmfak)-1;
		prcfak:=p^.GetPercent/65536.0;
		xmm100fak:=xmmfak*prcfak/100;
		ymm100fak:=ymmfak*prcfak/100;
		if (xoffs2<=xoffs) or (yoffs2<=yoffs) then
			begin
				st^.SetText(STRING_WRONGMARGINS);
				goto _error
			end;
		if p^.IsNormalPrintArea then
			begin
				cell:=p^.Sheet;
				for q:=0 to p^.Parms.Rows do
					for w:=0 to p^.Parms.Columns do
						begin
							if cell^.Typ=CTYPE_EMPTY then
								if cell^.TxtVal.Flags=0 then
									if cell^.Color=Black then
										if cell^.Style=8 then
											if cell^.Interior=FIS_HOLLOW then
												with cell^.Border do
													if Left<16 then
														if Right<16 then
															if Top<16 then
																if Bottom<16 then
																	if Hor<16 then
																		if Vert<16 then goto _leer;
							if q>rec then rec:=q;
							if w>cec then cec:=w;
							_leer:
							inc(longint(cell),CELLSIZE)
						end;
				if p^.Embedded<>nil then
					if p^.Parms.psbuffer.images=bf_Checked then
						begin
							xmm:=0;
							ymm:=0;
							pe:=p^.Embedded;
							while pe<>nil do
								begin
									if pe^.CanPrint then
										begin
											if pe^.XPos_mm100+pe^.Width_mm100>xmm then xmm:=pe^.XPos_mm100+pe^.Width_mm100;
											if pe^.YPos_mm100+pe^.Height_mm100>ymm then ymm:=pe^.YPos_mm100+pe^.Height_mm100
										end;
									pe:=pe^.Next
								end;
							if xmm>0 then
								begin
									q:=-1;
									repeat
										inc(q);
										dec(xmm,longint(p^.GetColWidth_mm100(q)))
									until (xmm<0) or (q>=p^.Parms.Columns);
									if q>cec then cec:=q
								end;
							if ymm>0 then
								begin
									w:=-1;
									repeat
										inc(w);
										dec(ymm,longint(p^.GetRowHeight_mm100(w)))
									until (ymm<0) or (w>=p^.Parms.Rows);
									if w>rec then rec:=w
								end
						end;
				if (rec<0) or (cec<0) then
					begin
						st^.SetText(STRING_PAGEEMPTY);
						goto _error
					end
			end
		else
			if p^.IsBlockPrintArea then p^.GetBlock(p^.Parms.psbuffer.bereich,false,rsc,csc,rec,cec,q,q)
			else
				p^.GetBlock(p^.dblock^.GetText,false,rsc,csc,rec,cec,q,q);
		scale:=1.0;
		SetFont(p^.GetStdFontIndex,p^.GetStdFontSize);
		lcw:=nwidth*trunc(ln(rec+2)/ln(10))+((3*nwidth) shr 1);
		trh:=bheight-1;
		if p^.Parms.psbuffer.rows=bf_Checked then tw:=lcw
		else
			tw:=0;
		if p^.Parms.psbuffer.columns=bf_Checked then th:=trh
		else
			th:=0;
		pagew:=xoffs2+1-xoffs;
		pagex:=0;
		srect.X:=tw;
		t:=csc;
		for q:=csc to cec do
			begin
				inc(srect.X,GetColWidth(q));
				if (srect.X>pagew) or bTst(p^.PColFlags^[q],CRF_UMBRUCH) then
					begin
						inc(pagex);
						if t=q then srect.X:=tw
						else
							begin
								srect.X:=tw+GetColWidth(q);
								t:=q
							end
					end
			end;
		if srect.X>tw then inc(pagex);
		pageh:=yoffs2+1-yoffs;
		pagey:=0;
		srect.Y:=th;
		t:=rsc;
		for q:=rsc to rec do
			begin
				inc(srect.Y,GetRowHeight(q));
				if (srect.Y>pageh) or bTst(p^.PRowFlags^[q],CRF_UMBRUCH) then
					begin
						inc(pagey);
						if t=q then srect.Y:=th
						else
							begin
								srect.Y:=th+GetRowHeight(q);
								t:=q
							end
					end
			end;
		if srect.Y>th then inc(pagey);
		pages:=pagex*pagey;
		if pagenum>=pages then pagenum:=pages-1;
		st^.Enable;
		CheckButtons
	end;


procedure TPreviewDialog.CheckButtons;
	label _found;

	var pgy,pgx,page,q: integer;
	    p             : PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		scale:=1.0;
		re:=rsc-1;
		for pgy:=0 to pagey-1 do
			begin
				rs:=re+1;
				srect.Y:=th;
				repeat
					inc(re);
					inc(srect.Y,GetRowHeight(re))
				until (srect.Y>pageh) or (re=rec) or bTst(p^.PRowFlags^[re],CRF_UMBRUCH);
				if (re>rs) and (((re<>rec) and not(bTst(p^.PRowFlags^[re],CRF_UMBRUCH))) or (srect.Y>pageh)) then dec(re);
				ce:=csc-1;
				for pgx:=0 to pagex-1 do
					begin
						cs:=ce+1;
						srect.X:=tw;
						repeat
							inc(ce);
							inc(srect.X,GetColWidth(ce))
						until (srect.X>pagew) or (ce=cec) or bTst(p^.PColFlags^[ce],CRF_UMBRUCH);
						if (ce>cs) and (((ce<>cec) and not(bTst(p^.PColFlags^[ce],CRF_UMBRUCH))) or (srect.X>pagew)) then dec(ce);
						if p^.Parms.psbuffer.num1=bf_Checked then page:=pgy*pagex+pgx
						else
							page:=pgx*pagey+pgy;
						if page=pagenum then goto _found
					end
			end;
		_found:
		srect.X1:=0;
		srect.Y1:=0;
		srect.X2:=0;
		srect.Y2:=0;
		for q:=cs to ce do inc(srect.X2,GetColWidth(q));
		for q:=rs to re do inc(srect.Y2,GetRowHeight(q));
		A2toGR(srect);
		if p^.Parms.psbuffer.rows=bf_Checked then XPixOffs:=-lcw-1
		else
			XPixOffs:=0;
		if p^.Parms.psbuffer.columns=bf_Checked then YPixOffs:=-trh-1
		else
			YPixOffs:=0;
		if cs>0 then
			for q:=0 to cs-1 do inc(XPixOffs,GetColWidth(q));
		if rs>0 then
			for q:=0 to rs-1 do inc(YPixOffs,GetRowHeight(q));
		st^.SetText(STRING_PAGE+' '+ltoa(pagenum+1));
		if pages<1 then
			begin
				pb1^.Disable;
				pb2^.Disable;
				pb3^.Disable;
				pb4^.Disable
			end
		else
			begin
				if pagenum=0 then pb1^.Disable
				else
					pb1^.Enable;
				if pagenum=pages-1 then pb2^.Disable
				else
					pb2^.Enable;
				pb3^.Enable;
				pb4^.Enable
			end;
		scale:=pvscale;
		ForceVRedraw
	end;


procedure TPreview.Work;
	var p : PCalcWindow;
	    pb: PButton;

	begin
		p:=PCalcWindow(Parent);
		if p^.pagepreview=nil then
			begin
				new(p^.pagepreview,Init(p,TEXELWINDPREFIX+TITLE_PREVIEW,STG_PREVIEW,ICNTITLE_PREVIEW,RTPREVIEW));
				if p^.pagepreview<>nil then
					begin
						new(p^.pagepreview^.st,Init(p^.pagepreview,RTPVPAGE,11,false,BUBBLE_PREVIEW_PAGE));
						if p^.pagepreview^.st<>nil then p^.pagepreview^.st^.Style:=p^.pagepreview^.st^.Style and not(sts_Fill);
						new(p^.pagepreview^.cb,Init(p^.pagepreview,RTPVMARGINS,true,BUBBLE_PREVIEW_MARGINS));
						new(p^.pagepreview^.pb1,Init(p^.pagepreview,RTPVDEC,id_No,true,BUBBLE_PREVIEW_DEC));
						new(p^.pagepreview^.pb2,Init(p^.pagepreview,RTPVINC,id_No,true,BUBBLE_PREVIEW_INC));
						new(pb,Init(p^.pagepreview,RTPVPAPER,id_No,true,BUBBLE_PREVIEW_PAPER));
						if not(TexelApp.ExtPrnSel(p^.wnd_prnt_set,TexelApp.app_prnt_set)) then
							if pb<>nil then pb^.Disable;
						new(PButton,Init(p^.pagepreview,RTPVPRINT,id_No,true,BUBBLE_PREVIEW_PRINT));
						new(PButton,Init(p^.pagepreview,RTPVLAYOUT,id_No,true,BUBBLE_PREVIEW_LAYOUT));
						new(p^.pagepreview^.pb3,Init(p^.pagepreview,RTPVFIT,id_No,true,BUBBLE_PREVIEW_SCALE));
						new(p^.pagepreview^.pb4,Init(p^.pagepreview,RTPV100,id_No,true,BUBBLE_PREVIEW_100));
						new(PButton,Init(p^.pagepreview,RTPVOK,id_OK,true,BUBBLE_PREVIEW_OK));
						new(pb,Init(p^.pagepreview,RTPVHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
					end
			end;
		if p^.pagepreview<>nil then
			begin
				p^.pagepreview^.MakeWindow;
				p^.pagepreview^.Update(false)
			end
	end;


function TInfoDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then PCalcWindow(Parent)^.SetDirty;
		OK:=valid
	end;


function TInfoDialog.ExitDlg(AnIndx: integer): boolean;
	label _pagain;

	var p    : PDialog;
	    pe   : PEdit;
	    pcw  : PCalcWindow;
	    dummy: longint;
	    tb   : record
	    	oldpw,
	    	newpw: string[21]
	    end;

	begin
		ExitDlg:=false;
		if AnIndx=RTIPASSWORD then
			begin
				pcw:=PCalcWindow(Parent);
				TexelApp.ActivateExtResource;
				_pagain:
				new(p,Init(@self,'',RTCHGPASS));
				if p<>nil then
					begin
						new(pe,Init(p,RTCPOLD,21,BUBBLE_CHGPASS_OLD));
						if pcw^.PassWord.Flag=0 then
							if pe<>nil then pe^.Disable;
						new(PEdit,Init(p,RTCPNEW,21,BUBBLE_CHGPASS_NEW));
						new(PButton,Init(p,RTCPABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(p,RTCPOK,id_OK,true,BUBBLE_CHGPASS_OK));
						tb.oldpw:='';
						tb.newpw:='';
						p^.TransferBuffer:=@tb;
						if Application^.ExecDialog(p)=RTCPOK then
							begin
								if pcw^.PassWord.Flag<>0 then
									if not(CheckPassWord(tb.oldpw,pcw^.PassWord.Code,dummy)) then
										begin
											Application^.Alert(@self,1,NOTE,MESSAGE_INFO_PASSWRONG,BUTTON_OK);
											goto _pagain
										end;
								if (length(tb.newpw)>0) and (length(tb.newpw)<6) then
									begin
										Application^.Alert(@self,1,NOTE,MESSAGE_INFO_PASSLEN,BUTTON_OK);
										goto _pagain
									end;
								if length(tb.newpw)>0 then
									begin
										pcw^.PassWord.Flag:=1;
										pcw^.PassWord.Code:=CreatePassCode(tb.newpw,pcw^.PassWord.Mask)
									end
								else
									begin
										pcw^.PassWord.Flag:=0;
										pcw^.PassWord.Code:=0;
										pcw^.PassWord.Mask:=0
									end;
								pcw^.SetDirty
							end
					end;
				TexelApp.DeactivateExtResource
			end
	end;


procedure TInfo.Work;
	var p : PCalcWindow;
	    t : string;
	    pb: PButton;

	begin
		p:=PCalcWindow(Parent);
		if ADialog=nil then
			begin
				ADialog:=new(PInfoDialog,Init(p,TEXELWINDPREFIX+TITLE_INFO,STG_INFO,ICNTITLE_INFO,RTINFO));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTIFILE,GROUP_INFO_FILE,''));
						new(PGroupBox,Init(ADialog,RTIEDIT,'',''));
						new(PGroupBox,Init(ADialog,RTITIME,'',''));
						new(PGroupBox,Init(ADialog,RTIINFO,'',''));
						new(st0,Init(ADialog,RTIFNAME,64,false,BUBBLE_INFO_FILE));
						new(PEdit,Init(ADialog,RTIAUTOR,51,BUBBLE_INFO_AUTHOR));
						new(PEdit,Init(ADialog,RTISTICHWORT,51,BUBBLE_INFO_INDEX));
						new(PEdit,Init(ADialog,RTIREM1,51,BUBBLE_INFO_REM));
						new(PEdit,Init(ADialog,RTIREM2,51,BUBBLE_INFO_REM));
						new(PEdit,Init(ADialog,RTIREM3,51,BUBBLE_INFO_REM));
						new(PEdit,Init(ADialog,RTIREM4,51,BUBBLE_INFO_REM));
						new(PCheckBox,Init(ADialog,RTIENCRYPT,true,BUBBLE_INFO_ENCRYPT));
						new(st1,Init(ADialog,RTICREATE,33,false,BUBBLE_INFO_CREATED));
						new(st2,Init(ADialog,RTILAST,32,false,BUBBLE_INFO_LATEST));
						new(st3,Init(ADialog,RTIUSED,18,false,BUBBLE_INFO_USED));
						new(st4,Init(ADialog,RTIPRINTED,18,false,BUBBLE_INFO_PRINTED));
						new(st6,Init(ADialog,RTITEXEL,31,false,BUBBLE_INFO_VERSION));
						new(pb,Init(ADialog,RTIHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTIOK,id_OK,true,BUBBLE_GENERAL_OK));
						new(PButton,Init(ADialog,RTIPASSWORD,id_No,true,BUBBLE_INFO_PASSWORD));
						new(PButton,Init(ADialog,RTIABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						ADialog^.TransferBuffer:=@p^.infobuf
					end
			end;
		if ADialog<>nil then
			begin
				t:=p^.GetWindowFilename;
				if length(t)=0 then t:=p^.GetRawIconTitle;
				if st0<>nil then st0^.SetText(CompressPath(t,63));
				if st1<>nil then st1^.SetText(STRING_INFO_CREATED+TexelApp.Time2Str(p^.infobuf.Created)+' h');
				if st2<>nil then st2^.SetText(STRING_INFO_LATEST+TexelApp.Time2Str(p^.infobuf.Last)+' h');
				if st3<>nil then st3^.SetText(STRING_INFO_USED+ltoa(p^.infobuf.Used)+' x');
				if st4<>nil then st4^.SetText(STRING_INFO_PRINTED+ltoa(p^.infobuf.Printed)+' x');
				if st6<>nil then
					begin
						if p^.infobuf.Version=0 then st6^.Clear
						else
							if p^.infobuf.Release=0 then st6^.SetText(STRING_INFO_SAVEDWITH+' '+TEXELNAME+' '+VtoS(p^.infobuf.Version))
							else
								st6^.SetText(STRING_INFO_SAVEDWITH+' '+TEXELNAME+' '+VtoS(p^.infobuf.Version)+'r'+ltoa(p^.infobuf.Release))
					end;
				ADialog^.MakeWindow
			end
	end;


procedure TFindNext.Work;

	begin
		with PCalcWindow(Parent)^ do
			if find<>nil then find^.FindNext
	end;


procedure TFind.Work;
	var pb: PButton;

	begin
		if ADialog=nil then
			begin
				ADialog:=new(PFindDialog,Init(PCalcWindow(Parent),TEXELWINDPREFIX+TITLE_FIND,STG_FIND,ICNTITLE_FIND,RTFIND));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTFIDIRECTION,GROUP_FIND_DIRECTION,''));
						new(PGroupBox,Init(ADialog,RTFIOPTIONS,'',''));
						new(PGroupBox,Init(ADialog,RTFIWHAT,GROUP_FIND_SEARCHIN,''));
						new(PGroupBox,Init(ADialog,RTFIINTERPRETE,GROUP_FIND_SEARCHAS,''));
						new(PGroupBox,Init(ADialog,RTFIDIR,GROUP_FIND_FORBACKWARD,''));
						new(PEdit,Init(ADialog,RTFISEARCHEDIT,46,BUBBLE_FIND_SEARCHFOR));
						new(PRadioButton,Init(ADialog,RTFIROWS,true,BUBBLE_FIND_ROWS));
						new(PRadioButton,Init(ADialog,RTFICOLUMNS,true,BUBBLE_FIND_COLUMNS));
						new(PCheckBox,Init(ADialog,RTFICASE,true,BUBBLE_FIND_CASE));
						new(PCheckBox,Init(ADialog,RTFICOMPLETE,true,BUBBLE_FIND_COMPLETE));
						new(PCheckBox,Init(ADialog,RTFIFORMULA,true,BUBBLE_FIND_FORMULA));
						new(PCheckBox,Init(ADialog,RTFIVALUE,true,BUBBLE_FIND_VALUE));
						new(PCheckBox,Init(ADialog,RTFITEXT,true,BUBBLE_FIND_TEXT));
						new(PRadioButton,Init(ADialog,RTFIINTRFORM,true,BUBBLE_FIND_EDIT));
						new(PRadioButton,Init(ADialog,RTFIINTRVAL,true,BUBBLE_FIND_DISPLAY));
						new(rb1,Init(ADialog,RTFIVOR,true,BUBBLE_FIND_TOEND));
						new(rb2,Init(ADialog,RTFIZURUECK,true,BUBBLE_FIND_TOBEGIN));
						new(pb,Init(ADialog,RTFIHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTFICANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTFISEARCH,id_No,true,BUBBLE_FIND_FIND));
						new(PButton,Init(ADialog,RTFIOK,id_OK,true,BUBBLE_FIND_OK));
						ADialog^.TransferBuffer:=@PCalcWindow(Parent)^.findbuf
					end
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


procedure TFind.FindNext;
	label _raus;

	var p    : PCalcWindow;
	    dir,
	    x,y,
	    r,c  : integer;
	    cell : PCell;
	    offs : longint;
	    s,cmp: string;

	function checkcell: boolean;

		function checks: boolean;

			begin
				checks:=false;
				if length(s)=0 then exit;
				if p^.findbuf.cse=bf_Unchecked then s:=StrPUpper(s);
				if p^.findbuf.complete=bf_Checked then checks:=(s=cmp)
				else
					checks:=(pos(cmp,s)>0)
			end;

		begin
			checkcell:=false;
			if cell^.Data.Value=0 then exit;
			case cell^.Typ of
			CTYPE_TEXT:
				if p^.findbuf.txt=bf_Checked then
					begin
						s:=cell^.Data.Txt^;
						checkcell:=checks
					end;
			CTYPE_CONST:
				if p^.findbuf.value=bf_Checked then
					begin
						if p^.findbuf.iform=bf_Checked then
							begin
								if cell^.Data.Konst^.Txt=nil then s:=''
								else
									s:=cell^.Data.Konst^.Txt^
							end
						else
							with cell^.Data.Konst^ do p^.Val2Txt(Value,s,FPts,cell^.Format,nil);
						checkcell:=checks
					end;
			CTYPE_FORMULA:
				if p^.findbuf.formula=bf_Checked then
					begin
						if p^.findbuf.iform=bf_Checked then s:=p^.BuildFunction(cell,true)
						else
							with cell^.Data.Formula^ do
								if Error=FE_OK then p^.Val2Txt(Value,s,FPts,cell^.Format,nil)
								else
									s:=p^.Error2Txt(Error);
						checkcell:=checks
					end
			end
		end;

	begin
		p:=PCalcWindow(Parent);
		if ADialog<>nil then
			if ADialog^.Attr.Status=ws_Open then ADialog^.TransferData(tf_GetData);
		with p^.findbuf do
			begin
				if (length(search)=0) or ((formula=bf_Unchecked) and (value=bf_Unchecked) and (txt=bf_Unchecked)) then
					begin
						Application^.Bing;
						exit
					end;
				cmp:=search;
				if cse=bf_Unchecked then cmp:=StrPUpper(cmp)
			end;
		r:=-1;
		c:=-1;
		y:=p^.Parms.Cursor.Row;
		x:=p^.Parms.Cursor.Col;
		cell:=p^.GetCell(y,x);
		if p^.findbuf.rows=bf_Checked then offs:=CELLSIZE
		else
			offs:=CELLSIZE*longint(p^.Parms.Columns+1);
		if p^.findbuf.vor=bf_Unchecked then
			begin
				offs:=-offs;
				dir:=-1
			end
		else
			dir:=1;
		if p^.findbuf.rows=bf_Checked then
			repeat
				inc(x,dir);
				if x<0 then
					begin
						if y=0 then goto _raus
						else
							begin
								dec(y);
								x:=p^.Parms.Columns;
								cell:=p^.GetCell(y,x)
							end
					end
				else
					if x>p^.Parms.Columns then
						begin
							if y=p^.Parms.Rows then goto _raus
							else
								begin
									inc(y);
									x:=0;
									cell:=p^.GetCell(y,x)
								end
						end
					else
						inc(longint(cell),offs);
				if checkcell then
					begin
						r:=y;
						c:=x;
						goto _raus
					end
			until false
		else
			repeat
				inc(y,dir);
				if y<0 then
					begin
						if x=0 then goto _raus
						else
							begin
								dec(x);
								y:=p^.Parms.Rows;
								cell:=p^.GetCell(y,x)
							end
					end
				else
					if y>p^.Parms.Rows then
						begin
							if x=p^.Parms.Columns then goto _raus
							else
								begin
									inc(x);
									y:=0;
									cell:=p^.GetCell(y,x)
								end
						end
					else
						inc(longint(cell),offs);
				if checkcell then
					begin
						r:=y;
						c:=x;
						goto _raus
					end
			until false;
		_raus:
		if (r>=0) and (c>=0) then p^.SetCursorPos(r,c,true)
		else
			begin
				Application^.Bing;
				with p^.findbuf do
					if vor=bf_Checked then
						begin
							vor:=bf_Unchecked;
							zurueck:=bf_Checked;
							if rb1<>nil then rb1^.Uncheck;
							if rb2<>nil then rb2^.Check
						end
					else
						begin
							vor:=bf_Checked;
							zurueck:=bf_Unchecked;
							if rb1<>nil then rb1^.Check;
							if rb2<>nil then rb2^.Uncheck
						end
			end
	end;


function TFindDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		if AnIndx=RTFISEARCH then
			with PCalcWindow(Parent)^ do
				if find<>nil then find^.FindNext
	end;


function TFindDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTFISEARCH);
		OK:=valid
	end;


procedure TReplaceNext.Work;

	begin
		with PCalcWindow(Parent)^ do
			if replace<>nil then replace^.ReplaceNext(false)
	end;


procedure TReplace.Work;
	var pb: PButton;

	begin
		if ADialog=nil then
			begin
				ADialog:=new(PReplaceDialog,Init(PCalcWindow(Parent),TEXELWINDPREFIX+TITLE_REPLACE,STG_REPLACE,ICNTITLE_REPLACE,RTREPLACE));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTREDIRECTION,GROUP_REPLACE_DIRECTION,''));
						new(PGroupBox,Init(ADialog,RTREOPTIONS,'',''));
						new(PGroupBox,Init(ADialog,RTREWHAT,GROUP_REPLACE_REPLIN,''));
						new(PGroupBox,Init(ADialog,RTREDIR,GROUP_REPLACE_FORBACK,''));
						new(PEdit,Init(ADialog,RTRESEARCH,46,BUBBLE_REPL_SEARCHFOR));
						new(PEdit,Init(ADialog,RTREREPLACEWITH,46,BUBBLE_REPL_REPLWITH));
						new(PRadioButton,Init(ADialog,RTREROWS,true,BUBBLE_REPL_ROWS));
						new(PRadioButton,Init(ADialog,RTRECOLUMNS,true,BUBBLE_REPL_COLUMNS));
						new(PCheckBox,Init(ADialog,RTRECASE,true,BUBBLE_REPL_CASE));
						new(PCheckBox,Init(ADialog,RTRECOMPLETE,true,BUBBLE_REPL_COMPLETE));
						new(PCheckBox,Init(ADialog,RTREFORMULA,true,BUBBLE_REPL_FORMULA));
						new(PCheckBox,Init(ADialog,RTREVALUE,true,BUBBLE_REPL_VALUE));
						new(PCheckBox,Init(ADialog,RTRETEXT,true,BUBBLE_REPL_TEXT));
						new(rb1,Init(ADialog,RTREVOR,true,BUBBLE_REPL_TOEND));
						new(rb2,Init(ADialog,RTREZURUECK,true,BUBBLE_REPL_TOBEGIN));
						new(pb,Init(ADialog,RTREHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTRECANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTREALL,id_No,true,BUBBLE_REPL_ALL));
						new(PButton,Init(ADialog,RTREREPLACE,id_No,true,BUBBLE_REPL_REPLACE));
						new(PButton,Init(ADialog,RTREOK,id_OK,true,BUBBLE_REPL_OK));
						ADialog^.TransferBuffer:=@PCalcWindow(Parent)^.replacebuf
					end
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


procedure TReplace.ReplaceNext(all: boolean);
	label _raus;

	var p    : PCalcWindow;
	    dir,q,
	    x,y,
	    r,c  : integer;
	    cell : PCell;
	    offs : longint;
	    t,
	    s,cmp: string;

	function checkcell: boolean;

		function checks: boolean;

			begin
				checks:=false;
				if length(s)=0 then exit;
				if p^.replacebuf.cse=bf_Unchecked then t:=StrPUpper(s)
				else
					t:=s;
				if p^.replacebuf.complete=bf_Checked then
					begin
						q:=1;
						checks:=(t=cmp)
					end
				else
					begin
						q:=pos(cmp,t);
						checks:=(q>0)
					end
			end;

		begin
			checkcell:=false;
			if cell^.Data.Value=0 then exit;
			case cell^.Typ of
			CTYPE_TEXT:
				if p^.replacebuf.txt=bf_Checked then
					begin
						s:=cell^.Data.Txt^;
						if not(checks) then exit
					end
				else
					exit;
			CTYPE_CONST:
				if p^.replacebuf.value=bf_Checked then
					begin
						if cell^.Data.Konst^.Txt=nil then s:=''
						else
							s:=cell^.Data.Konst^.Txt^;
						if not(checks) then exit
					end
				else
					exit;
			CTYPE_FORMULA:
				if p^.replacebuf.formula=bf_Checked then
					begin
						s:=p^.BuildFunction(cell,true);
						if not(checks) then exit
					end
				else
					exit;
			else
				exit
			end;
			checkcell:=true;
			s:=StrPLeft(s,q-1)+p^.replacebuf.replace+StrPRight(s,length(s)+1-q-length(cmp));
			p^.ChangeCell(cell,s,y,x,false);
			p^.SetInpline(cell)
		end;

	begin
		p:=PCalcWindow(Parent);
		if ADialog<>nil then
			if ADialog^.Attr.Status=ws_Open then ADialog^.TransferData(tf_GetData);
		with p^.replacebuf do
			begin
				if (length(search)=0) or ((formula=bf_Unchecked) and (value=bf_Unchecked) and (txt=bf_Unchecked)) then
					begin
						Application^.Bing;
						exit
					end;
				cmp:=search;
				if cse=bf_Unchecked then cmp:=StrPUpper(cmp)
			end;
		r:=-1;
		c:=-1;
		y:=p^.Parms.Cursor.Row;
		x:=p^.Parms.Cursor.Col;
		cell:=p^.GetCell(y,x);
		if p^.replacebuf.rows=bf_Checked then offs:=CELLSIZE
		else
			offs:=CELLSIZE*longint(p^.Parms.Columns+1);
		if p^.replacebuf.vor=bf_Unchecked then
			begin
				offs:=-offs;
				dir:=-1
			end
		else
			dir:=1;
		if p^.replacebuf.rows=bf_Checked then
			repeat
				inc(x,dir);
				if x<0 then
					begin
						if y=0 then goto _raus
						else
							begin
								dec(y);
								x:=p^.Parms.Columns;
								cell:=p^.GetCell(y,x)
							end
					end
				else
					if x>p^.Parms.Columns then
						begin
							if y=p^.Parms.Rows then goto _raus
							else
								begin
									inc(y);
									x:=0;
									cell:=p^.GetCell(y,x)
								end
						end
					else
						inc(longint(cell),offs);
				if checkcell then
					begin
						r:=y;
						c:=x;
						if not(all) then goto _raus
					end
			until false
		else
			repeat
				inc(y,dir);
				if y<0 then
					begin
						if x=0 then goto _raus
						else
							begin
								dec(x);
								y:=p^.Parms.Rows;
								cell:=p^.GetCell(y,x)
							end
					end
				else
					if y>p^.Parms.Rows then
						begin
							if x=p^.Parms.Columns then goto _raus
							else
								begin
									inc(x);
									y:=0;
									cell:=p^.GetCell(y,x)
								end
						end
					else
						inc(longint(cell),offs);
				if checkcell then
					begin
						r:=y;
						c:=x;
						if not(all) then goto _raus
					end
			until false;
		_raus:
		if (r>=0) and (c>=0) then p^.SetCursorPos(r,c,true)
		else
			begin
				Application^.Bing;
				with p^.replacebuf do
					if vor=bf_Checked then
						begin
							vor:=bf_Unchecked;
							zurueck:=bf_Checked;
							if rb1<>nil then rb1^.Uncheck;
							if rb2<>nil then rb2^.Check
						end
					else
						begin
							vor:=bf_Checked;
							zurueck:=bf_Unchecked;
							if rb1<>nil then rb1^.Check;
							if rb2<>nil then rb2^.Uncheck
						end
			end
	end;


function TReplaceDialog.ExitDlg(AnIndx: integer): boolean;

	begin
		ExitDlg:=false;
		case AnIndx of
		RTREREPLACE:
			with PCalcWindow(Parent)^ do
				if replace<>nil then replace^.ReplaceNext(false);
		RTREALL:
			begin
				with PCalcWindow(Parent)^ do
					if replace<>nil then replace^.ReplaceNext(true);
				ExitDlg:=true
			end
		end
	end;


function TReplaceDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTREREPLACE);
		OK:=valid
	end;


procedure TKonstBox.Work;
	var sel: integer;
	    p  : PKonstDialog;
	    pp : PParameter;

	begin
		if List=nil then exit;
		if List^.Count=0 then exit;
		p:=PKonstDialog(Parent);
		sel:=GetSelection;
		if sel<0 then exit;
		pp:=PParameter(List^.At(sel));
		if pp^.Name=nil then p^.ed1^.Clear
		else
			p^.ed1^.SetText(pp^.Name^);
		if pp^.Txt=nil then p^.ed2^.Clear
		else
			p^.ed2^.SetText(pp^.Txt^);
		if pp^.Descr=nil then p^.ed3^.Clear
		else
			p^.ed3^.SetText(pp^.Descr^);
		if pp^.Predef then
			begin
				p^.pb1^.Disable;
				p^.pb2^.Disable;
				p^.cb^.Disable
			end
		else
			begin
				p^.pb1^.Enable;
				p^.pb2^.Enable;
				p^.cb^.Enable
			end
	end;


procedure TKonst.Work;
	var p : PCalcWindow;
	    pb: PButton;

	begin
		p:=PCalcWindow(Parent);
		if p^.konstanten=nil then
			begin
				new(p^.konstanten,Init(p,TEXELWINDPREFIX+TITLE_CONST,STG_CONST,ICNTITLE_CONST,RTCONST));
				if p^.konstanten<>nil then
					begin
						new(p^.konstanten^.cb,Init(p^.konstanten,RTCNAMEN,true,BUBBLE_CONST_CHGNAME));
						new(p^.konstanten^.pkb,Init(p^.konstanten,RTCLIST,RTCLISTSLID,RTCLISTDEC,RTCLISTINC,PCalcWindow(Parent)^.Parameter,false,BUBBLE_CONST_LIST));
						new(p^.konstanten^.ed1,Init(p^.konstanten,RTCNAME,31,BUBBLE_CONST_NAME));
						new(p^.konstanten^.ed2,Init(p^.konstanten,RTCVALUE,31,BUBBLE_CONST_VALUE));
						new(p^.konstanten^.ed3,Init(p^.konstanten,RTCREM,41,BUBBLE_CONST_DESCR));
						new(pb,Init(p^.konstanten,RTCHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(p^.konstanten,RTCNEU,id_No,true,BUBBLE_CONST_NEW));
						new(p^.konstanten^.pb1,Init(p^.konstanten,RTCCHANGE,id_No,true,BUBBLE_CONST_CHANGE));
						new(p^.konstanten^.pb2,Init(p^.konstanten,RTCDELETE,id_No,true,BUBBLE_CONST_DELETE));
						new(PButton,Init(p^.konstanten,RTCOK,id_OK,true,BUBBLE_GENERAL_OK));
						fillchar(kbuf,sizeof(kbuf),0);
						kbuf.chng:=bf_Checked;
						p^.konstanten^.TransferBuffer:=@kbuf
					end
			end;
		if p^.konstanten<>nil then
			begin
				p^.konstanten^.MakeWindow;
				p^.konstanten^.UpdateList(false)
			end
	end;


procedure TKonstDialog.UpdateList(wrk: boolean);

	begin
		if Attr.Status<>ws_Open then exit;
		pkb^.SetCollection(PCalcWindow(Parent)^.Parameter);
		if wrk then
			begin
				pkb^.SetSelection(pkb^.List^.Count);
				pkb^.ScrollBar^.SetPosition(pkb^.List^.Count)
			end;
		pkb^.Work
	end;


function TKonstDialog.ExitDlg(AnIndx: integer): boolean;
	var nval,
	    oname,
	    nname: string;
	    sel,
	    q    : integer;
	    pp   : PParameter;
	    p    : PCalcWindow;
	    vnum : TNumber;

	procedure changeconst;
		var r,c : integer;
		    cell: PCell;

		procedure change(p: PNode);
			var q: integer;

			begin
				if p=nil then exit;
				if p^.Typ<5000 then
					begin
						if p^.Typ>=10 then
							begin
								change(p^.Right.Node);
								change(p^.Left.Node)
							end
						else
							if p^.Typ=NT_CONST then
								if p^.Left.Txt<>nil then
									if StrPUpper(p^.Left.Txt^)=oname then
										begin
											DisposeStr(p^.Left.Txt);
											p^.Left.Txt:=NewStr(nname);
											p^.Num^:=vnum
										end
					end
				else
					if p^.Left.List<>nil then
						for q:=0 to p^.Count-1 do change(PNode(p^.Left.List^[q]))
			end;

		begin
			cell:=p^.Sheet;
			for r:=0 to p^.Parms.Rows do
				for c:=0 to p^.Parms.Columns do
					begin
						if cell^.Typ=CTYPE_FORMULA then change(cell^.Data.Formula^.Func);
						inc(longint(cell),CELLSIZE)
					end
		end;

	procedure const2zero;
		var r,c : integer;
		    cell: PCell;

		procedure zero(p: PNode);
			var q: integer;

			begin
				if p=nil then exit;
				if p^.Typ<5000 then
					begin
						if p^.Typ>=10 then
							begin
								zero(p^.Right.Node);
								zero(p^.Left.Node)
							end
						else
							if p^.Typ=NT_CONST then
								if p^.Left.Txt<>nil then
									if StrPUpper(p^.Left.Txt^)=oname then p^.Num^:=0.0
					end
				else
					if p^.Left.List<>nil then
						for q:=0 to p^.Count-1 do zero(PNode(p^.Left.List^[q]))
			end;

		begin
			cell:=p^.Sheet;
			for r:=0 to p^.Parms.Rows do
				for c:=0 to p^.Parms.Columns do
					begin
						if cell^.Typ=CTYPE_FORMULA then zero(cell^.Data.Formula^.Func);
						inc(longint(cell),CELLSIZE)
					end
		end;

	function checkinp(nr: integer): boolean;
		var q: integer;

		function zahl(s: string): boolean;
			label _ok,_again;

			var q,stat,old: integer;

			begin
				zahl:=false;
				if s[1] in ['+','-'] then s:=StrPRight(s,length(s)-1);
				if s[1]='.' then
					begin
						stat:=1;
						q:=2
					end
				else
					begin
						stat:=0;
						q:=1
					end;
				_again:
				if stat=2 then
					if s[q] in ['-','+'] then inc(q);
				old:=q;
				while (q<=length(s)) and (s[q] in ['0'..'9']) do inc(q);
				if old=q then exit;
				if q>length(s) then goto _ok;
				if stat=0 then
					begin
						if s[q]='.' then
							begin
								inc(q);
								stat:=1;
								goto _again
							end
						else
							if s[q]='E' then
								begin
									inc(q);
									stat:=2;
									goto _again
								end
					end
				else
					if stat=1 then
						if s[q]='E' then
							begin
								inc(q);
								stat:=2;
								goto _again
							end;
				_ok:
				if q>length(s) then zahl:=true
			end;

		begin
			checkinp:=false;
			if length(nname)=0 then
				begin
					Application^.Alert(@self,1,NOTE,MESSAGE_CONST_EMPTY,BUTTON_OK);
					exit
				end;
			if nname[1] in ['0'..'9'] then
				begin
					Application^.Alert(@self,1,NOTE,MESSAGE_CONST_NAME,BUTTON_OK);
					exit
				end;
			for q:=1 to length(nname) do if not(nname[q] in VarNameSet) then
				begin
					Application^.Alert(@self,1,NOTE,MESSAGE_CONST_NAME,BUTTON_OK);
					exit
				end;
			if pkb^.List^.Count>0 then
				for q:=0 to pkb^.List^.Count-1 do
					if q<>nr then
						if StrPUpper(nname)=StrPUpper(PParameter(pkb^.List^.At(q))^.Name^) then
							begin
								Application^.Alert(@self,1,NOTE,MESSAGE_CONST_USED1+StrPUpper(nname)+MESSAGE_CONST_USED2,BUTTON_OK);
								exit
							end;
			if length(nval)=0 then
				begin
					Application^.Alert(@self,1,NOTE,MESSAGE_CONST_VALEMPTY,BUTTON_OK);
					exit
				end;
			if not(zahl(nval)) then
				begin
					Application^.Alert(@self,1,NOTE,MESSAGE_CONST_VALUE,BUTTON_OK);
					exit
				end;
			checkinp:=true
		end;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		nname:=StrPTrimF(ed1^.GetText);
		nval:=StrPTrimF(ed2^.GetText);
		sel:=pkb^.GetSelection;
		case AnIndx of
		RTCNEU:
			begin
				if not(checkinp(-1)) then exit;
				new(pp);
				if pp<>nil then
					begin
						pp^.Value:=atof(nval);
						pp^.Name:=NewStr(nname);
						pp^.ListName:=NewStr('  '+nname+' '#0);
						pp^.Txt:=NewStr(nval);
						pp^.Descr:=NewStr(StrPTrimF(ed3^.GetText));
						pp^.Predef:=false;
						if (pp^.Name=nil) or (pp^.Txt=nil) then
							begin
								DisposeStr(pp^.Name);
								DisposeStr(pp^.ListName);
								DisposeStr(pp^.Txt);
								DisposeStr(pp^.Descr);
								dispose(pp)
							end
						else
							begin
								p^.Parameter^.Insert(pp);
								UpdateList(true);
								p^.SetDirty
							end
					end
			end;
		RTCCHANGE:
			begin
				if not(checkinp(sel)) then exit;
				pp:=PParameter(pkb^.List^.At(sel));
				oname:=StrPUpper(pp^.Name^);
				DisposeStr(pp^.Name);
				DisposeStr(pp^.ListName);
				DisposeStr(pp^.Txt);
				DisposeStr(pp^.Descr);
				vnum:=atof(nval);
				pp^.Value:=vnum;
				pp^.Name:=NewStr(nname);
				pp^.ListName:=NewStr('  '+nname+' '#0);
				pp^.Txt:=NewStr(nval);
				pp^.Descr:=NewStr(StrPTrimF(ed3^.GetText));
				if cb^.GetCheck=bf_Checked then changeconst
				else
					const2zero;
				q:=pkb^.GetSelection;
				UpdateList(false);
				pkb^.SetSelection(q);
				p^.SetDirty;
				p^.AutoCalculate(true)
			end;
		RTCDELETE:
			begin
				oname:=StrPUpper(PParameter(pkb^.List^.At(sel))^.Name^);
				if Application^.Alert(@self,1,WAIT,MESSAGE_CONST_DELETE1+oname+MESSAGE_CONST_DELETE2,BUTTON_YESNO)=1 then
					begin
						pkb^.List^.AtFree(sel);
						UpdateList(false);
						const2zero;
						p^.SetDirty;
						p^.AutoCalculate(true)
					end
			end
		end
	end;


procedure TCalculate.Work;

	begin
		PCalcWindow(Parent)^.Calculate(true)
	end;


procedure TGoto.Work;

	begin
		PCalcWindow(Parent)^.ExitDlg(RTWDBLOCK)
	end;


procedure TZielwertDialog.BlockChanged(blk: string);

	begin
		if pos(':',blk)>0 then exit;
		if GetFocus=RTZWZZELLE then ed1^.SetText(blk)
		else
			if GetFocus=RTZWVZELLE then ed2^.SetText(blk)
	end;


function TZielwertDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTZWSUCHEN);
		OK:=valid
	end;


function TZielwertDialog.ExitDlg(AnIndx: integer): boolean;
	label _nochmal,_fehler;

	var p              : PCalcWindow;
	    zrs,zcs,zre,zce,
	    vrs,vcs,vre,vce,
	    kstat,key,
	    dummy,ret      : integer;
	    itanz,itmax    : longint;
	    v1,v2,valid    : boolean;
	    x0,x1,x2,
	    f0,f1,nenner,
	    zwert          : TNumber;
	    zcell,vcell    : PCell;
	    pc             : PConst;
	    err            : string;
	    pipe           : Pipearray;

	function f(x: TNumber): TNumber;

		begin
			vcell^.Data.Konst^.Value:=x;
			f:=p^.GetCellValue(zcell,true)-zwert
		end;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTZWSUCHEN:
			begin
				TransferData(tf_GetData);
				v1:=p^.GetBlock(p^.zwbuf.zzelle,false,zrs,zcs,zre,zce,dummy,dummy);
				v2:=p^.GetBlock(p^.zwbuf.vzelle,false,vrs,vcs,vre,vce,dummy,dummy);
				if not(v1) or not(v2) or (zrs<>zre) or (zcs<>zce) or (vrs<>vre) or (vcs<>vce) then
					begin
						Application^.Alert(p,1,NOTE,MESSAGE_FINDVAL_CELLREF,BUTTON_OK);
						exit
					end;
				zwert:=atof(p^.zwbuf.wert);
				itmax:=atol(p^.zwbuf.iterationen);
				zcell:=p^.GetCell(zrs,zcs);
				if zcell^.Typ<>CTYPE_FORMULA then
					begin
						Application^.Alert(p,1,NOTE,MESSAGE_FINDVAL_FORMULA,BUTTON_OK);
						exit
					end;
				vcell:=p^.GetCell(vrs,vcs);
				if (vcell^.Typ=CTYPE_TEXT) or (vcell^.Typ=CTYPE_FORMULA) then
					begin
						Application^.Alert(p,1,NOTE,MESSAGE_FINDVAL_NUMBER,BUTTON_OK);
						exit
					end;
				if vcell^.Typ=CTYPE_CONST then DisposeStr(vcell^.Data.Konst^.Txt)
				else
					begin
						new(pc);
						if pc=nil then exit;
						pc^.Value:=0.0;
						pc^.FPts:=atol(TexelApp.setupbuffer.floatpoint);
						pc^.Txt:=nil;
						with vcell^.TxtVal do
							begin
								Font:=p^.GetFontIndex;
								Size:=p^.GetFontSize;
								Align:=(Align and $f0) or TA_RIGHT;
								Flags:=0
							end;
						vcell^.Data.Konst:=pc;
						vcell^.Typ:=CTYPE_CONST
					end;
				BusyMouse;
				err:='';
				if st<>nil then st^.SetText(STRING_FINDVAL_STATUS+': '+STRING_FINDVAL_SEARCH);
				x0:=-1.0;
				x1:=2.0;
				valid:=false;
				_nochmal:
				f0:=f(x0);
				f1:=f(x1);
				if abs(f1-f0)<1e-11 then
					begin
						if abs(x1-x0)>0.1 then
							begin
								x0:=x0/2.0;
								x1:=x1/1.8;
								goto _nochmal
							end
						else
							begin
								err:='('+STRING_FINDVAL_INTERVAL+')';
								goto _fehler
							end
					end;
				valid:=true;
				itanz:=0;
				repeat
					if (itanz mod 10)=0 then
						begin
							ret:=evnt_multi(MU_TIMER or MU_KEYBD,0,0,0,0,0,0,0,0,0,0,0,0,0,pipe,1,0,dummy,dummy,dummy,kstat,key,dummy);
							if bTst(ret,MU_KEYBD) then
								if kstat=K_NORMAL then
									if key=S_Esc then
										begin
											err:='('+STRING_FINDVAL_CANCEL+')';
											valid:=false;
											break
										end
						end;
					inc(itanz);
					if itanz>itmax then
						begin
							err:='('+STRING_FINDVAL_ITERAT+')';
							valid:=false;
							break
						end;
					nenner:=f1-f0;
					if abs(nenner)<1e-11 then
						begin
							err:='('+STRING_FINDVAL_NOSOLUTN+')';
							valid:=false;
							break
						end;
					x2:=x1-(x1-x0)*f1/nenner;
					x0:=x1;
					x1:=x2;
					f0:=f1;
					f1:=f(x2)
				until abs(x1-x0)<1e-11;
				_fehler:
				vcell^.Data.Konst^.Value:=x1;
				vcell^.Data.Konst^.Txt:=NewStr(ftoa(x1));
				p^.AutoCalculate(true);
				p^.DrawCells(vrs,vcs,vre,vce);
				ArrowMouse;
				if not(valid) then
					begin
						if st<>nil then st^.SetText(STRING_FINDVAL_STATUS+': '+STRING_FINDVAL_ERROR+' '+err);
						Application^.Alert(p,1,NOTE,MESSAGE_FINDVAL_ERROR,BUTTON_OK)
					end
				else
					if abs(f1)>1e-9 then
						begin
							if st<>nil then st^.SetText(STRING_FINDVAL_STATUS+': '+STRING_FINDVAL_ERROR);
							Application^.Alert(p,1,NOTE,MESSAGE_FINDVAL_ERROR,BUTTON_OK)
						end
					else
						if st<>nil then st^.SetText(STRING_FINDVAL_STATUS+': '+STRING_FINDVAL_OK)
			end
		end
	end;


procedure TZielwert.Work;
	var pb: PButton;

	begin
		if ADialog=nil then
			begin
				TexelApp.ActivateExtResource;
				ADialog:=new(PZielwertDialog,Init(PCalcWindow(Parent),TEXELWINDPREFIX+TITLE_FINDVAL,STG_FINDVAL,ICNTITLE_FINDVAL,RTZIELWERT));
				if ADialog<>nil then
					begin
						new(PZielwertDialog(ADialog)^.ed1,Init(ADialog,RTZWZZELLE,8,BUBBLE_FINDVAL_CTARGET));
						new(PZielwertDialog(ADialog)^.ed2,Init(ADialog,RTZWVZELLE,8,BUBBLE_FINDVAL_CVALUE));
						new(PEdit,Init(ADialog,RTZWWERT,16,BUBBLE_FINDVAL_TVALUE));
						new(PEdit,Init(ADialog,RTZWITERATIONEN,7,BUBBLE_FINDVAL_ITERAT));
						new(PZielwertDialog(ADialog)^.st,Init(ADialog,RTZWSTATUS,41,false,BUBBLE_FINDVAL_STATUS));
						new(pb,Init(ADialog,RTZWHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTZWABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTZWSUCHEN,id_No,true,BUBBLE_FINDVAL_FIND));
						new(PButton,Init(ADialog,RTZWOK,id_OK,true,BUBBLE_FINDVAL_OK));
						ADialog^.TransferBuffer:=@PCalcWindow(Parent)^.zwbuf
					end;
				TexelApp.DeactivateExtResource
			end;
		if ADialog<>nil then
			begin
				if PZielwertDialog(ADialog)^.st<>nil then PZielwertDialog(ADialog)^.st^.SetText(STRING_FINDVAL_STATUS+':');
				ADialog^.MakeWindow
			end
	end;


procedure TSortBox.SetText(ATextString: string);
	var q: integer;

	begin
		q:=pos(',',ATextString);
		if q>0 then ATextString:=StrPRight(ATextString,length(ATextString)-q-1);
		inherited SetText(StrPLeft(StrPTrimF(ATextString),15))
	end;


procedure TSortButton.Changed(AnIndx: integer; DblClick: boolean);

	begin
		inherited Changed(AnIndx,DblClick);
		PSortDialog(Parent)^.ScanValues
	end;


procedure TSort.Work;
	var psc: PStringCollection;
	    pb : PButton;

	begin
		if ADialog=nil then
			begin
				ADialog:=new(PSortDialog,Init(PCalcWindow(Parent),TEXELWINDPREFIX+TITLE_SORT,STG_SORT,ICNTITLE_SORT,RTSORT));
				if ADialog<>nil then
					begin
						new(PGroupBox,Init(ADialog,RTSRSORT1,GROUP_SORT_SORT1,''));
						new(PGroupBox,Init(ADialog,RTSRSORT2,GROUP_SORT_SORT2,''));
						new(PGroupBox,Init(ADialog,RTSRSORT3,GROUP_SORT_SORT3,''));
						new(PGroupBox,Init(ADialog,RTSRBEREICH,GROUP_GENERAL_RANGE,BUBBLE_GENERAL_RANGE));
						new(PGroupBox,Init(ADialog,RTSRDIRECTION,GROUP_SORT_WHAT,''));
						new(PGroupBox,Init(ADialog,RTSRNUMBERS,GROUP_SORT_NUMBERS,''));
						new(PGroupBox,Init(ADialog,RTSREMPTY,GROUP_SORT_SPACES,''));
						psc:=new(PStringCollection,Init(20,10)); 
						new(PSortDialog(ADialog)^.pcb1,InitCollection(ADialog,RTSR1POPUP,RTSR1CYC,id_No,15,psc,true,false,false,BUBBLE_SORT_SORT1));
						new(PRadioButton,Init(ADialog,RTSR1UP,true,BUBBLE_SORT_1UP));
						new(PRadioButton,Init(ADialog,RTSR1DOWN,true,BUBBLE_SORT_1DOWN));
						new(PSortDialog(ADialog)^.pcb2,InitCollection(ADialog,RTSR2POPUP,RTSR2CYC,id_No,15,psc,false,false,false,BUBBLE_SORT_SORT2));
						new(PRadioButton,Init(ADialog,RTSR2UP,true,BUBBLE_SORT_2UP));
						new(PRadioButton,Init(ADialog,RTSR2DOWN,true,BUBBLE_SORT_2DOWN));
						new(PSortDialog(ADialog)^.pcb3,InitCollection(ADialog,RTSR3POPUP,RTSR3CYC,id_No,15,psc,false,false,false,BUBBLE_SORT_SORT3));
						new(PRadioButton,Init(ADialog,RTSR3UP,true,BUBBLE_SORT_3UP));
						new(PRadioButton,Init(ADialog,RTSR3DOWN,true,BUBBLE_SORT_3DOWN));
						new(PSortDialog(ADialog)^.rb1,Init(ADialog,RTSRCOLUMNS,true,BUBBLE_SORT_COLUMNS));
						new(PSortButton,Init(ADialog,RTSRROWS,true,BUBBLE_SORT_ROWS));
						new(PRadioButton,Init(ADialog,RTSRINSERT,true,BUBBLE_SORT_NUMINS));
						new(PRadioButton,Init(ADialog,RTSRPRE,true,BUBBLE_SORT_NUMPRE));
						new(PRadioButton,Init(ADialog,RTSRPOST,true,BUBBLE_SORT_NUMPOST));
						new(PCheckBox,Init(ADialog,RTSRCASE,true,BUBBLE_SORT_CASE));
						new(PRadioButton,Init(ADialog,RTSRBEGINNING,true,BUBBLE_SORT_BEGINNING));
						new(PRadioButton,Init(ADialog,RTSREND,true,BUBBLE_SORT_END));
						new(PCheckBox,Init(ADialog,RTSRUMLAUTE,true,BUBBLE_SORT_UMLAUTE));
						new(PCheckBox,Init(ADialog,RTSRABS,true,BUBBLE_SORT_ABS));
						new(PCheckBox,Init(ADialog,RTSRATTRIBUTE,true,BUBBLE_SORT_ATTR));
						new(PSortDialog(ADialog)^.bedt,Init(ADialog,RTSRBEDIT,16,false,BUBBLE_GENERAL_RANGE));
						new(pb,Init(ADialog,RTSRHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTSRABBRUCH,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTSRSORT,id_No,true,BUBBLE_SORT_SORT));
						new(PButton,Init(ADialog,RTSROK,id_OK,true,BUBBLE_SORT_OK));
						ADialog^.TransferBuffer:=@PCalcWindow(Parent)^.sortbuf
					end
			end;
		if ADialog<>nil then
			begin
				PSortDialog(ADialog)^.bedt^.SetText(StrPTrimF(PCalcWindow(Parent)^.dblock^.GetText));
				ADialog^.MakeWindow;
				PSortDialog(ADialog)^.ScanValues
			end
	end;


procedure TSortDialog.ScanValues;
	var p    : PCalcWindow;
	    rs,cs,
	    re,ce,
	    q,
	    dummy: integer;

	begin
		p:=PCalcWindow(Parent);
		if (pcb1=nil) or (pcb2=nil) or (pcb3=nil) then exit;
		if (pcb1^.Popup=nil) or (pcb2^.Popup=nil) or (pcb3^.Popup=nil) then exit;
		if pcb1^.Popup^.List=nil then exit;
		pcb1^.Popup^.List^.FreeAll;
		pcb1^.Popup^.List^.Sort:=false;
		pcb1^.Popup^.List^.Insert(NewStr('  ('+STRING_NOTHING+') '#0));
		pcb1^.ChangeAlways:=true;
		pcb2^.ChangeAlways:=true;
		pcb3^.ChangeAlways:=true;
		p^.GetBlock(bedt^.GetText,false,rs,cs,re,ce,dummy,dummy);
		if rb1^.GetCheck=bf_Checked then
			for q:=cs to ce do
				if p^.pcolnames^[q]=nil then pcb1^.Popup^.List^.Insert(NewStr('  '+STRING_COL+' '+p^.GetColumnName(q)+' '#0))
				else
					pcb1^.Popup^.List^.Insert(NewStr('  '+STRING_COL+' '+p^.GetColumnIndex(q)+', "'+p^.GetColumnName(q)+'" '#0))
		else
			for q:=rs to re do
				pcb1^.Popup^.List^.Insert(NewStr('  '+STRING_ROW+' '+p^.GetRowIndex(q)+' '#0));
		pcb1^.Popup^.SetCollection(pcb1^.Popup^.List);
		pcb2^.Popup^.SetCollection(pcb1^.Popup^.List);
		pcb3^.Popup^.SetCollection(pcb1^.Popup^.List);
		pcb1^.SetSelection(pcb1^.GetSelection,true);
		pcb2^.SetSelection(pcb2^.GetSelection,true);
		pcb3^.SetSelection(pcb3^.GetSelection,true)
	end;


function TSortDialog.ExitDlg(AnIndx: integer): boolean;
	var p       : PCalcWindow;
	    nrs,
	    n1,n2,n3,
	    offs    : integer;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTSRBEDIT:
			WMKeyDown(K_CTRL,Ctrl_B);
		RTSRSORT:
			begin
				TransferData(tf_GetData);
				with p^ do
					with sortbuf do
						begin
							if Ins=bf_Checked then nrs:=0
							else
								if Pre=bf_Checked then nrs:=1
								else
									nrs:=2;
							if Rows=bf_Checked then
								begin
									if Parms.Cursor.Block then offs:=Parms.Cursor.RowStart
									else
										offs:=Parms.Cursor.Row
								end
							else
								begin
									if Parms.Cursor.Block then offs:=Parms.Cursor.ColStart
									else
										offs:=Parms.Cursor.Col
								end;
							if Pop1=0 then n1:=-1
							else
								n1:=Pop1+offs-1;
							if Pop2=0 then n2:=-1
							else
								n2:=Pop2+offs-1;
							if Pop3=0 then n3:=-1
							else
								n3:=Pop3+offs-1;
							Sort(n1,n2,n3,nrs,Up1=bf_Checked,Up2=bf_Checked,Up3=bf_Checked,Rows=bf_Checked,
							     Chars=bf_Checked,EmptyPre=bf_Checked,Lexikal=bf_Checked,Absolut=bf_Checked,
							     Attribute=bf_Checked)
						end
			end
		end
	end;


procedure TSortDialog.BlockChanged(blk: string);

	begin
		if bedt<>nil then bedt^.SetText(blk);
		ScanValues
	end;


function TSortDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then ExitDlg(RTSRSORT);
		OK:=valid
	end;


function TSheetDialog.ExitDlg(AnIndx: integer): boolean;
	var cell: PCell;
	    p   : PCalcWindow;
	    q,w,
	    rmax,
	    cmax: integer;

	begin
		ExitDlg:=false;
		p:=PCalcWindow(Parent);
		case AnIndx of
		RTFSMINIMAL:
			begin
				cell:=p^.Sheet;
				rmax:=1;
				cmax:=1;
				for q:=0 to p^.Parms.Rows do
					for w:=0 to p^.Parms.Columns do
						begin
							if cell^.Data.Value<>0 then
								begin
									if q>rmax then rmax:=q;
									if w>cmax then cmax:=w
								end;
							inc(longint(cell),CELLSIZE)
						end;
				ed1^.SetText(ltoa(rmax+1));
				ed2^.SetText(ltoa(cmax+1))
			end;
		RTFSCURRENT:
			begin
				ed1^.SetText(ltoa(p^.Parms.Rows+1));
				ed2^.SetText(ltoa(p^.Parms.Columns+1))
			end
		end
	end;


function TSheetDialog.OK: boolean;
	label _raus,_weiter;

	var nsheet,cell,
	    ocell      : PCell;
	    osb        : TSheetBuffer;
	    nprowflags,
	    npcolflags : PByteArray;
			nprow,
			npcol      : PWordArray;
			npcolnames : PItemList;
			r,c,ro,co,
			dummy,x,y,
			lcopy,loffs,
			oloffs     : longint;
			lossy      : boolean;
			i,ww,q     : integer;

	begin
		osb:=PCalcWindow(Parent)^.sheetbuffer;
		if inherited OK then
			begin
				with PCalcWindow(Parent)^ do
					begin
						r:=atol(sheetbuffer.rows);
						c:=atol(sheetbuffer.columns);
						ro:=atol(osb.rows);
						co:=atol(osb.columns);
						if (ro<>r) or (co<>c) then
							begin
								lossy:=false;
								if r<ro then
									for y:=r to ro-1 do
										begin
											cell:=GetCell(y,0);
											for x:=0 to co-1 do
												begin
													if cell^.Data.Value<>0 then
														begin
															lossy:=true;
															goto _weiter
														end;
													inc(longint(cell),CELLSIZE)
												end
										end;
								if c<co then
									for y:=0 to ro-1 do
										begin
											cell:=GetCell(y,c);
											for x:=c to co-1 do
												begin
													if cell^.Data.Value<>0 then
														begin
															lossy:=true;
															goto _weiter
														end;
													inc(longint(cell),CELLSIZE)
												end
										end;
								_weiter:
								if lossy then
									if Application^.Alert(@self,1,NOTE,MESSAGE_WINDOW_SIZE,BUTTON_GOCANCEL)<>1 then
										begin
											sheetbuffer:=osb;
											goto _raus
										end;
								getmem(nprow,r shl 1);
								getmem(npcol,c shl 1);
								getmem(npcolnames,c shl 2);
								getmem(nprowflags,r);
								getmem(npcolflags,c);
								dummy:=r*c*CELLSIZE;
								getmem(nsheet,dummy);
								if (nprow=nil) or (npcol=nil) or (nsheet=nil) or (npcolnames=nil)  or (nprowflags=nil) or (npcolflags=nil) then
									begin
										if nprow<>nil then freemem(nprow,r shl 1);
										if npcol<>nil then freemem(npcol,c shl 1);
										if nprowflags<>nil then freemem(nprowflags,r);
										if npcolflags<>nil then freemem(npcolflags,c);
										if npcolnames<>nil then freemem(npcolnames,c shl 2);
										if nsheet<>nil then freemem(nsheet,dummy);
										sheetbuffer:=osb;
										Application^.Alert(@self,1,STOP,MESSAGE_WINDOW_SIZEERR,BUTTON_OK);
										goto _raus
									end;
								SetCursorPos(0,0,true);
								RowsClearOverflow(0,Parms.Rows,q,q);
								{ Pos/Block beibehalten ... }
								fillchar(npcolnames^,c shl 2,0);
								fillchar(npcolflags^,c,0);
								fillchar(nprowflags^,r,0);
								fillchar(nsheet^,dummy,0);
								TexelApp.InitCells(nsheet,r,c);
								if r<ro then
									begin
										system.move(PRow^,nprow^,r shl 1);
										system.move(PRowFlags^,nprowflags^,r)
									end
								else
									begin
										system.move(PRow^,nprow^,ro shl 1);
										system.move(PRowFlags^,nprowflags^,ro)
									end;
								freemem(PRow,ro shl 1);
								freemem(PRowFlags,ro);
								PRow:=nprow;
								PRowFlags:=nprowflags;
								loffs:=c*CELLSIZE;
								oloffs:=co*CELLSIZE;
								if c<co then
									begin
										system.move(PCol^,npcol^,c shl 1);
										system.move(PColNames^,npcolnames^,c shl 2);
										system.move(PColFlags^,npcolflags^,c);
										for y:=c to co-1 do DisposeStr(PString(PColNames^[y]));
										lcopy:=loffs
									end
								else
									begin
										system.move(PCol^,npcol^,co shl 1);
										system.move(PColNames^,npcolnames^,co shl 2);
										system.move(PColFlags^,npcolflags^,co);
										lcopy:=oloffs
									end;
								freemem(PColNames,co shl 2);
								freemem(PCol,co shl 1);
								freemem(PColFlags,co);
								PColNames:=npcolnames;
								PColFlags:=npcolflags;
								PCol:=npcol;
								cell:=nsheet;
								ocell:=Sheet;
								x:=Min(r,ro)-1;
								for y:=0 to x do
									begin
										system.move(ocell^,cell^,lcopy);
										inc(longint(cell),loffs);
										inc(longint(ocell),oloffs)
									end;
								if (r<ro) and (c<co) then
									begin
										FreeBlock(0,c,r-1,co-1,false);
										FreeBlock(r,0,ro-1,co-1,false)
									end
								else
									if r<ro then FreeBlock(r,0,ro-1,co-1,false)
									else
										if c<co then FreeBlock(0,c,ro-1,co-1,false);
								freemem(Sheet,ro*co*CELLSIZE);
								Sheet:=nsheet;
								Parms.Rows:=r-1;
								Parms.Columns:=c-1;
								vst_font(vdiHandle,GetStdFontIndex);
								if Speedo then vst_arbpt(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight)
								else
									vst_point(vdiHandle,GetStdFontSize,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight);
								if vqt_width(vdiHandle,ord('W'),ww,i,i)<>ord('W') then ww:=Attr.charWidth;
								if r>ro then
									begin
										y:=round(longint(Attr.boxHeight)*longint(Application^.Attr.PixH)/10.0);
										for x:=ro to r-1 do SetRowHeight_mm100(x,y,false)
									end;
								if c>co then
									begin
										y:=round(longint(ww)*atol(TexelApp.setupbuffer.stdcolwidth)*longint(Application^.Attr.PixW)/10.0);
										for x:=co to c-1 do SetColWidth_mm100(x,y,false)
									end;
								SetSystemFont(vdiHandle,Attr.charWidth,Attr.charHeight,Attr.boxWidth,Attr.boxHeight);
								SheetCheckOverflow;
								AutoCalculate(true)
							end;
						SetFont(GetStdFontIndex,GetStdFontSize);
						SetBorderSize;
						ForceVRedraw;
						SetDirty
					end;
				OK:=true
			end
		else
			_raus:
			OK:=false
	end;


procedure TSaveAs.Work;
	var fname: string;

	begin
		fname:='';
		if XFileSelect(PCalcWindow(Parent),FSELTITLE_SAVEAS,'*.'+TEXELEXTENSION,TexelApp.LastPath[0],fname,1,FSEL_SAVE,false,PCalcWindow(Parent)^.closing) then
			begin
				TexelApp.LastFile[0]:=fname;
				SaveAs(TexelApp.LastPath[0]+TexelApp.LastFile[0],0)
			end
	end;


procedure TSaveAs.SaveAs(const fname: string; flag: integer);
	var p      : PCalcWindow;
	    oldname: string;

	begin
		if length(fname)=0 then exit;
		p:=PCalcWindow(Parent);
		if Exist(fname) then
			begin
				if p^.closing then
					begin
						p^.alertret:=Application^.Alert(p,1,WAIT,MESSAGE_SAVEAS_EXIST1+CompressPath(fname,78)+MESSAGE_SAVEAS_EXIST2,BUTTON_YESNOCANCEL);
						if p^.alertret<>1 then exit
					end
				else
					if Application^.Alert(p,1,WAIT,MESSAGE_SAVEAS_EXIST1+CompressPath(fname,78)+MESSAGE_SAVEAS_EXIST2,BUTTON_YESNO)<>1 then exit
			end;
		if not(KeyCorrect(regname,regkey)) then
			begin
				DemoAlert(p);
				exit
			end;
		oldname:=p^.GetWindowFilename;
		if flag=1 then
			begin
				p^.sheetbuffer.vorlage:=bf_Unchecked;
				if p^.save^.Save(fname) then
					begin
						if Application^.Alert(p,1,WAIT,MESSAGE_SAVEAS_NEW1+CompressPath(fname,78)+MESSAGE_SAVEAS_NEW2,BUTTON_YESNO)=1 then p^.SetWindowFileName(fname)
						else
							p^.sheetbuffer.vorlage:=bf_Checked
					end
				else
					p^.sheetbuffer.vorlage:=bf_Checked;
			end
		else
			if p^.sheetbuffer.vorlage=bf_Checked then
				begin
					if length(oldname)=0 then
						begin
							if p^.save^.Save(fname) then p^.SetWindowFileName(fname)
						end
					else
						begin
							if Application^.Alert(p,2,WAIT,MESSAGE_SAVE_FORMDOC,BUTTON_FORMDOC)=2 then p^.sheetbuffer.vorlage:=bf_Unchecked;
							if p^.save^.Save(fname) then
								begin
									if Application^.Alert(p,1,WAIT,MESSAGE_SAVEAS_NEW1+CompressPath(fname,78)+MESSAGE_SAVEAS_NEW2,BUTTON_YESNO)=1 then p^.SetWindowFileName(fname)
									else
										p^.sheetbuffer.vorlage:=bf_Checked
								end
							else
								p^.sheetbuffer.vorlage:=bf_Checked;
						end
				end
			else
				if p^.save^.Save(fname) then
					begin
						if length(oldname)=0 then p^.SetWindowFileName(fname)
						else
							if Application^.Alert(p,1,WAIT,MESSAGE_SAVEAS_NEW1+CompressPath(fname,78)+MESSAGE_SAVEAS_NEW2,BUTTON_YESNO)=1 then p^.SetWindowFileName(fname)
					end
	end;


procedure TAbandon.Work;
	var pipe: ARRAY_8;
	    p   : PCalcWindow;

	begin
		p:=PCalcWindow(Parent);
		pipe[0]:=GO_PRIVATE;
		pipe[1]:=Application^.apID;
		pipe[2]:=0;
		pipe[3]:=GOP_ABANDON;
		pipe[4]:=integer(HiWord(p));
		pipe[5]:=integer(LoWord(p));
		appl_write(Application^.apID,16,@pipe)
	end;


procedure TOptions.Work;
	var pe    : PEdit;
	    pb    : PButton;
	    fsizes: PStringCollection;
	    pfsb  : PFontSizeBox;
	    pfb   : PFontBox;

	begin
		if ADialog=nil then
			begin
				ADialog:=new(POptionsDialog,Init(nil,TEXELWINDPREFIX+TITLE_SETUP,STG_SETUP,ICNTITLE_SETUP,RTSETUP));
				if ADialog<>nil then
					begin
						POptionsDialog(ADialog)^.prnt:=nil;
						POptionsDialog(ADialog)^.spage:=nil;
						new(PCard,Init(ADialog,RTSSTANDARD,RTSTSTANDARD,0,crd_First,BUBBLE_SETUP_DEFDOC));
						new(PCard,Init(ADialog,RTSWINDOW,RTSTWINDOW,0,crd_Normal,BUBBLE_SETUP_WINDOW));
						new(PCard,Init(ADialog,RTSGENERAL,RTSTGENERAL,0,crd_Normal,BUBBLE_SETUP_GENERAL));
						new(PCard,Init(ADialog,RTSSTART,RTSTSTART,0,crd_Last,BUBBLE_SETUP_STARTUP));
						new(pe,Init(ADialog,RTSSTDROWS,6,BUBBLE_SETUP_ROWS));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(2,16384)));
						new(pe,Init(ADialog,RTSSTDCOLUMNS,4,BUBBLE_SETUP_COLUMNS));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(2,702)));
						new(pe,Init(ADialog,RTSSTDCOLWIDTH,3,BUBBLE_SETUP_COLWIDTH));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(1,25)));
						new(PCheckBox,Init(ADialog,RTSAUTOCALC,true,BUBBLE_SETUP_AUTOCALC));
						new(pfb,InitCollection(ADialog,RTSFONTPOP,RTSFONTCYC,RTSFONTTITLE,26,TexelApp.Fonts,false,false,false,BUBBLE_SETUP_FONTID));
						if pfb<>nil then
							begin
								pfb^.newsize:=-1;
								new(fsizes,Init(130,20));
								new(pfsb,InitCollection(ADialog,RTSSIZEPOP,RTSSIZECYC,RTSSIZETITLE,6,fsizes,true,false,false,BUBBLE_SETUP_FONTSIZE));
								pfsb^.setsize:=true;
								pfb^.fsizebox:=pfsb;
								pfb^.Work
							end;
						new(pe,Init(ADialog,RTSSIZERRANGE,2,BUBBLE_SETUP_SIZERRANGE));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(0,5)));
						new(pe,Init(ADialog,RTSFLOATPOINT,3,BUBBLE_SETUP_FPOINT));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(0,MAXCIPHERS)));
						new(pe,Init(ADialog,RTSHISTORY,3,BUBBLE_SETUP_HISTORY));
						if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(0,99)));
						new(PCheckBox,Init(ADialog,RTSCURSORWRAP,true,BUBBLE_SETUP_CRSWRAP));
						new(PCheckBox,Init(ADialog,RTSXINPUT,true,BUBBLE_SETUP_XINPUT));
						new(PCheckBox,Init(ADialog,RTSCLOSERCANCEL,true,BUBBLE_SETUP_CLOSER));
						new(PRadioButton,Init(ADialog,RTSOPENNEW,true,BUBBLE_SETUP_NEW));
						new(PRadioButton,Init(ADialog,RTSLOADDOC,true,BUBBLE_SETUP_OPEN));
						new(PRadioButton,Init(ADialog,RTSNOTHING,true,BUBBLE_SETUP_NOTHING));
						new(PCheckBox,Init(ADialog,RTSFULLSIZE,true,BUBBLE_SETUP_FULLSIZE));
						new(PCheckBox,Init(ADialog,RTSBLOCK,true,BUBBLE_SETUP_BLOCK));
						new(PCheckBox,Init(ADialog,RTSRECALC,true,BUBBLE_SETUP_RECALC));
						new(PCheckBox,Init(ADialog,RTSONLINE,true,BUBBLE_SETUP_RTBLOCK));
						new(PCheckBox,Init(ADialog,RTSBACKUP,true,BUBBLE_SETUP_BACKUP));
						new(PCheckBox,Init(ADialog,RTSTOOLBAR,true,BUBBLE_SETUP_TOOLBAR));
						new(PComboBox,Init(ADialog,RTSCURRENCY,RTSCURRCYC,RTSCURRTITLE,RTPOPUPS,RTPCURRENCY,id_No,true,false,BUBBLE_SETUP_CURRENCY));
						new(PCheckBox,Init(ADialog,RTSOVERFLOW,true,BUBBLE_SETUP_OVERFLOW));
						new(PCheckBox,Init(ADialog,RTSBOTTOMLINE,true,BUBBLE_SETUP_BOTTOMLINE));
						new(pb,Init(ADialog,RTSHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(pb,Init(ADialog,RTSPRINTER,id_No,true,BUBBLE_SETUP_PRINTER));
						if Application^.GDOSActive then pb^.Enable
						else
							pb^.Disable;
						new(PButton,Init(ADialog,RTSOK,id_OK,true,BUBBLE_GENERAL_OK2));
						new(PButton,Init(ADialog,RTSCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						ADialog^.TransferBuffer:=@TexelApp.setupbuffer
					end
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


function TOptionsDialog.OK: boolean;
	var valid: boolean;
	    oldof: integer;
	    pw   : PWindow;

	begin
		oldof:=TexelApp.setupbuffer.overflow;
		valid:=inherited OK;
		if valid then
			with TexelApp do
				begin
					if setupbuffer.xinputmode=bf_Checked then Attr.Style:=Attr.Style or as_XInputMode
					else
						Attr.Style:=Attr.Style and not(as_XInputMode);
					if oldof<>setupbuffer.overflow then
						begin
							pw:=Application^.MainWindow;
							while pw<>nil do
								begin
									if pw^.GetClassName=TEXELWINDCLASS then pw^.ForceRedraw;
									pw:=pw^.Next
								end
						end
				end;
		OK:=valid
	end;


function TOptionsDialog.ExitDlg(AnIndx: integer): boolean;
	var st         : PStatic;
	    pe         : PEdit;
	    pb         : PButton;
	    drivers    : PStringCollection;
	    pc         : PCheckBox;
	    pcb        : PPrintPercBox;
	    docname    : string;
	    sub_dialogs: PPDLG_SUB;
	    pt         : PTree;

	begin
		ExitDlg:=false;
		if AnIndx=RTSPRINTER then
			begin
				if TexelApp.ExtPrnSel(TexelApp.app_prnt_set,nil) then
					begin
						getmem(sub_dialogs,sizeof(PDLG_SUB));
						if sub_dialogs<>nil then
							begin
								pt:=Application^.GetAddr(RTICONS);
								with sub_dialogs^ do
									begin
										next:=nil;
										option_flags:=0;
										sub_id:=-1;
										sub_icon:=@pt^[RTIPRINTRANGE];
										sub_tree:=Application^.GetAddr(RTPRINTSUBDIAL);
										dialog:=nil;
										tree:=nil;
										index_offset:=0;
										reserved1:=0;
										reserved2:=0;
										init_dlg:=pinit_texel;
										do_dlg:=nil;
										reset_dlg:=preset_texel;
										reserved3:=0;
										private1:=0;
										private2:=0;
										private3:=0;
										private4:=0
									end;
								with AES_pb do
									begin
										control^[0]:=205;
										control^[1]:=1;
										control^[2]:=1;
										control^[3]:=2;
										control^[4]:=0;
										intin^[0]:=3;
										addrin^[0]:=TexelApp.prnt_dialog;
										addrin^[1]:=sub_dialogs;
										_crystal(@AES_pb)
									end
							end;
						docname:=TEXELWINDPREFIX+TITLE_SETUP+#0;
						with AES_pb do
							begin
								control^[0]:=207;
								control^[1]:=1;
								control^[2]:=1;
								control^[3]:=3;
								control^[4]:=0;
								intin^[0]:=PDLG_PREFS or PDLG_ALWAYS_COPIES or PDLG_ALWAYS_SCALE;
								addrin^[0]:=TexelApp.prnt_dialog;
								addrin^[1]:=TexelApp.app_prnt_set;
								addrin^[2]:=@docname[1];
								_crystal(@AES_pb)
							end;
						if sub_dialogs<>nil then
							begin
								with AES_pb do
									begin
										control^[0]:=205;
										control^[1]:=1;
										control^[2]:=1;
										control^[3]:=1;
										control^[4]:=0;
										intin^[0]:=4;
										addrin^[0]:=TexelApp.prnt_dialog;
										_crystal(@AES_pb)
									end;
								free_sub_dialogs(sub_dialogs)
							end;
						exit
					end;
				if prnt=nil then
					begin
						new(prnt,Init(@self,TEXELWINDPREFIX+TITLE_SETUP,STG_PRINT,ICNTITLE_SETUPPRINTER,RTPRINT));
						if prnt<>nil then
							begin
								prnt^.drvinfo:=nil;
								new(PGroupBox,Init(prnt,RTPBEREICH,GROUP_GENERAL_RANGE,''));
								new(st,Init(prnt,RTPSUPTITLE,13,false,''));
								if st<>nil then st^.Hide(true);
								new(st,Init(prnt,RTPTITLE,43,true,''));
								if st<>nil then st^.SetText(STRING_DEFAULTPRINTER);
								new(PCheckBox,Init(prnt,RTPSHEET,true,BUBBLE_PRINT_SHEET));
								new(PCheckBox,Init(prnt,RTPFEED,true,BUBBLE_PRINT_FEED));
								new(pe,Init(prnt,RTPCOPIES,4,BUBBLE_PRINT_COPIES));
								if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(1,99)));
								new(pcb,Init(prnt,RTPPERCSIZE,RTPPSCYC,RTPPSTITLE,RTPOPUPS,RTPPRINTPERC,id_no,false,true,BUBBLE_PRINT_SCALE));
								if pcb<>nil then
									begin
										if pcb^.Popup<>nil then pcb^.Popup^.AutoCheck:=false;
										if pcb^.Edit<>nil then pcb^.Edit^.SetValidator(new(PRangeValidator,Init(MINPERCENT,MAXPERCENT)))
									end;
								new(drivers,Init(10,5));
								new(prnt^.drvbox,InitCollection(prnt,RTPDRIVER,RTPDRIVERCYC,RTPDRIVERTITLE,30,drivers,true,true,false,BUBBLE_PRINT_DRIVER));
								new(prnt^.inf,Init(prnt,RTPINFO,id_No,true,BUBBLE_PRINT_INFO));
								new(prnt^.druck,Init(prnt,RTPPRINT,id_No,true,BUBBLE_PRINT_PRINT));
								new(prnt^.devbox,Init(prnt,RTPDEVICE,RTPDEVCYC,RTPDEVTITLE,RTPOPUPS,RTPDEVICES,id_No,false,false,BUBBLE_PRINT_DEVICE));
								new(pc,Init(prnt,RTPSW,true,BUBBLE_PRINT_BW));
								if pc<>nil then pc^.Disable; { ... }
								new(PRadioButton,Init(prnt,RTPPBLOCK,true,BUBBLE_PRINT_RANGE));
								new(PRadioButton,Init(prnt,RTPALL,true,BUBBLE_PRINT_ALL));
								new(PRadioButton,Init(prnt,RTPBLOCK,true,BUBBLE_PRINT_SELECTION));
								new(prnt^.paper,Init(prnt,RTPPSIZE,RTPPCYC,RTPPTITLE,RTPOPUPS,RTPPAPER,id_No,false,false,BUBBLE_PRINT_PAPER));
								new(pe,Init(prnt,RTPVON,4,BUBBLE_PRINT_PAGEFROM));
								if pe<>nil then pe^.SetValidator(new(PRangeValidator,Init(MINPAGES,MAXPAGESOLD)));
								new(PEdit,Init(prnt,RTPBIS,4,BUBBLE_PRINT_PAGETO));
								new(pb,Init(prnt,RTPHELP,id_Help,false,BUBBLE_GENERAL_HELP));
								if pb<>nil then
									if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
								new(pb,Init(prnt,RTPPREVIEW,id_No,true,''));
								if pb<>nil then pb^.Hide(false);
								new(PButton,Init(prnt,RTPPAGESETUP,id_No,true,BUBBLE_PRINT_LAYOUT));
								new(PButton,Init(prnt,RTPOK,id_OK,true,BUBBLE_GENERAL_OK));
								new(PButton,Init(prnt,RTPCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
								prnt^.SetDefaultButton(RTPOK);
								if prnt^.druck<>nil then prnt^.druck^.Hide(true);
								prnt^.TransferBuffer:=@TexelApp.stdprnbuffer
							end
					end;
				if prnt<>nil then prnt^.MakeWindow
			end
	end;


procedure TOptionsDialog.PageSetup;
	var pe: PEdit;
	    pc: PCheckBox;
	    pb: PButton;

	begin
		if spage=nil then
			begin
				new(spage,Init(@self,TEXELWINDPREFIX+TITLE_SETUP,STG_LAYOUT,ICNTITLE_SETUPLAYOUT,RTPAGESETUP));
				if spage<>nil then
					begin
						new(PGroupBox,Init(spage,RTPSMARGINS,GROUP_LAYOUT_MARGINS,''));
						new(PGroupBox,Init(spage,RTPSCENTER,GROUP_LAYOUT_CENTER,''));
						new(PGroupBox,Init(spage,RTPSPRINT,GROUP_LAYOUT_PRINTWITH,''));
						new(PGroupBox,Init(spage,RTPSBEREICH,GROUP_LAYOUT_PRINTRANGE,''));
						new(PGroupBox,Init(spage,RTPSHEAD,GROUP_LAYOUT_HEAD,''));
						new(PGroupBox,Init(spage,RTPSFOOT,GROUP_LAYOUT_FOOT,''));
						new(PGroupBox,Init(spage,RTPSNUM,GROUP_LAYOUT_NUM,''));
						new(pe,Init(spage,RTPSTOP,9,BUBBLE_LAYOUT_TMARGIN));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(pe,Init(spage,RTPSBOTTOM,9,BUBBLE_LAYOUT_BMARGIN));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(pe,Init(spage,RTPSLEFT,9,BUBBLE_LAYOUT_LMARGIN));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(pe,Init(spage,RTPSRIGHT,9,BUBBLE_LAYOUT_RMARGIN));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(PCheckBox,Init(spage,RTPSHCENTER,true,BUBBLE_LAYOUT_HCENTER));
						new(PCheckBox,Init(spage,RTPSVCENTER,true,BUBBLE_LAYOUT_VCENTER));
						new(PCheckBox,Init(spage,RTPSGITTER,true,BUBBLE_LAYOUT_GRID));
						new(PCheckBox,Init(spage,RTPSROWS,true,BUBBLE_LAYOUT_NUMBERS));
						new(PCheckBox,Init(spage,RTPSCOLUMNS,true,BUBBLE_LAYOUT_NAMES));
						new(pe,Init(spage,RTPSBEDIT,16,BUBBLE_LAYOUT_PRNTRANGE));
						new(pe,Init(spage,RTPSHLEFT,42,BUBBLE_LAYOUT_LHEAD));
						new(pe,Init(spage,RTPSHMID,42,BUBBLE_LAYOUT_CHEAD));
						new(pe,Init(spage,RTPSHRIGHT,42,BUBBLE_LAYOUT_RHEAD));
						new(pe,Init(spage,RTPSFLEFT,42,BUBBLE_LAYOUT_LFOOT));
						new(pe,Init(spage,RTPSFMID,42,BUBBLE_LAYOUT_CFOOT));
						new(pe,Init(spage,RTPSFRIGHT,42,BUBBLE_LAYOUT_RFOOT));
						new(PRadioButton,Init(spage,RTPSNUM1,false,BUBBLE_LAYOUT_NUMHOR));
						new(PRadioButton,Init(spage,RTPSNUM2,false,BUBBLE_LAYOUT_NUMVERT));
						new(pc,Init(spage,RTPSHLEFTON,true,BUBBLE_LAYOUT_PLHEAD));
						new(pc,Init(spage,RTPSHCENTERON,true,BUBBLE_LAYOUT_PCHEAD));
						new(pc,Init(spage,RTPSHRIGHTON,true,BUBBLE_LAYOUT_PRHEAD));
						new(pc,Init(spage,RTPSFLEFTON,true,BUBBLE_LAYOUT_PLFOOT));
						new(pc,Init(spage,RTPSFCENTERON,true,BUBBLE_LAYOUT_PCFOOT));
						new(pc,Init(spage,RTPSFRIGHTON,true,BUBBLE_LAYOUT_PRFOOT));
						new(PCheckBox,Init(spage,RTPSOBJECTS,true,BUBBLE_LAYOUT_POBJECTS));
						new(pe,Init(spage,RTPSKOPF,9,BUBBLE_LAYOUT_MHEAD));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(pe,Init(spage,RTPSFUSS,9,BUBBLE_LAYOUT_MFOOT));
						if pe<>nil then pe^.SetValidator(new(PPosRealValidator,Init));
						new(pb,Init(spage,RTPSHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(pb,Init(spage,RTPSMINIMAL,id_No,true,''));
						if pb<>nil then pb^.Hide(false);
						new(PButton,Init(spage,RTPSCANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(pb,Init(spage,RTPSSET,id_No,true,''));
						if pb<>nil then pb^.Hide(false);
						new(PButton,Init(spage,RTPSOK,id_OK,true,BUBBLE_GENERAL_OK));
						spage^.TransferBuffer:=@TexelApp.stdpsbuffer
					end
			end;
		if spage<>nil then spage^.MakeWindow
	end;


procedure TDeviceBox.Work;
	label _fehler,_weiter;

	var unten,oben,
	    q,hndl,
	    sel,hdl   : integer;
	    bufsize,
	    res,w     : longint;
	    buf       : PByteArray;
	    pcb       : PDriverBox;
	    cb        : PComboBox;
	    wrkin     : workin_ARRAY;
	    wrkout    : workout_ARRAY;
	    names     : array [0..24] of string[80];
	    devfound  : array [0..24] of boolean;
	    txt,txt2  : string;
	    ok        : boolean;

	begin
		pcb:=PPrintDialog(Parent)^.drvbox;
		if pcb=nil then exit;
		SliceMouse;
		sel:=GetSelection;
		if pcb^.List=nil then exit;
		pcb^.List^.FreeAll;
		pcb^.List^.Sort:=false;
		if Sel<DEV_FAX then unten:=Sel*10+11
		else
			unten:=Sel*10+21;
		if Sel=DEV_MEMORY then oben:=80
		else
			if Sel=DEV_IMG then oben:=99
			else
				oben:=unten+9;
		pcb^.drvcnt:=0;
		if TexelApp.NVDIVersion>=$0300 then
			for q:=unten to oben do
				begin
					SliceMouseNext;
					if vqtExtDevinfo(Application^.aesHandle,q,txt2,txt) then
						begin
							pcb^.drivers[pcb^.drvcnt]:=q;
							if (length(txt2)>0) or (length(txt)>0) then
								begin
									if length(txt)>0 then names[pcb^.drvcnt]:='  '+StrPLeft(txt,75)+' '#0
									else
										names[pcb^.drvcnt]:='  '+StrPLeft(ltoa(q)+' '+txt2,75)+' '#0;
									pcb^.shortnames[pcb^.drvcnt]:=StrPLeft(txt2,12);
									pcb^.longnames[pcb^.drvcnt]:=StrPLeft(txt,42);
									devfound[pcb^.drvcnt]:=true
								end
							else
								begin
									names[pcb^.drvcnt]:='  '+ltoa(q);
									pcb^.shortnames[pcb^.drvcnt]:='';
									pcb^.longnames[pcb^.drvcnt]:='';
									devfound[pcb^.drvcnt]:=false
								end;
							inc(pcb^.drvcnt)
						end
				end
		else
			begin
		   	for q:=1 to 9 do wrkin[q]:=1;
		 		wrkin[10]:=RC;
				for q:=unten to oben do
					begin
						SliceMouseNext;
						wrkin[0]:=q;
						v_opnwk(wrkin,hndl,wrkout);
						if hndl<>0 then
							begin
								pcb^.drivers[pcb^.drvcnt]:=q;
								if vqtDevinfo(hndl,q,txt2,txt) then
									if (length(txt2)>0) or (length(txt)>0) then
										begin
											if length(txt)>0 then names[pcb^.drvcnt]:='  '+StrPLeft(txt,75)+' '#0
											else
												names[pcb^.drvcnt]:='  '+StrPLeft(ltoa(q)+' '+txt2,75)+' '#0;
											pcb^.shortnames[pcb^.drvcnt]:=StrPLeft(txt2,12);
											pcb^.longnames[pcb^.drvcnt]:=StrPLeft(txt,42);
											devfound[pcb^.drvcnt]:=true;
											goto _weiter
										end;
								names[pcb^.drvcnt]:='  '+ltoa(q);
								pcb^.shortnames[pcb^.drvcnt]:='';
								pcb^.longnames[pcb^.drvcnt]:='';
								devfound[pcb^.drvcnt]:=false;
								_weiter:
								v_clswk(hndl);
								inc(pcb^.drvcnt)
							end
					end
			end;
		_fehler:
		if pcb^.drvcnt=0 then
			begin
				pcb^.SetText(STRING_NODRIVER2);
				pcb^.Disable;
				with PPrintDialog(Parent)^ do
					begin
						if inf<>nil then inf^.Disable;
						if druck<>nil then druck^.Disable
					end
			end
		else
			begin
				BusyMouse;
				ok:=true;
				for q:=0 to pcb^.drvcnt-1 do
					if not(devfound[q]) then
						begin
							ok:=false;
							break
						end;
				if not(ok) then
					begin
						txt:=BootDevice+':\assign.sys';
						if not(Exist(txt)) then
							begin
								txt:='assign.sys';
								if shel_find(txt)=0 then
									begin
										pcb^.drvcnt:=0;
										ArrowMouse;
										goto _fehler
									end
							end;
						buf:=GetMemBuffer(16384,128,bufsize);
						if buf=nil then
							begin
								pcb^.drvcnt:=0;
								ArrowMouse;
								goto _fehler
							end;
						res:=fopen(txt,FO_READ);
						if res<0 then
							begin
								pcb^.drvcnt:=0;
								freemem(buf,bufsize);
								ArrowMouse;
								goto _fehler
							end;
						hdl:=integer(res);
						txt:='';
						repeat
							res:=fread(hdl,bufsize,buf);
							if res>0 then
								for w:=0 to res-1 do
									if buf^[w]=CR then
										begin
											StrPTrim(txt);
											hndl:=atol(StrPLeft(txt,2));
											if (hndl>=11) and (hndl<=99) then
												begin
													txt:=StrPTrimF(StrPRight(txt,length(txt)-3));
													for q:=0 to pcb^.drvcnt-1 do
														if hndl=pcb^.drivers[q] then
															if not(devfound[q]) then
																begin
																	names[q]:=StrPLeft(names[q]+' '+txt,75)+' '#0;
																	pcb^.shortnames[q]:=StrPLeft(txt,12)
																end
												end;
											txt:=''
										end
									else
										if buf^[w]>=32 then txt:=txt+chr(buf^[w])
						until res<>bufsize;
						fclose(hdl);
						freemem(buf,bufsize)
					end;
				for q:=0 to pcb^.drvcnt-1 do pcb^.List^.Insert(NewStr(names[q]));
				ArrowMouse
			end;
		with pcb^ do
			begin
				if Popup<>nil then Popup^.SetCollection(List);
				if drvcnt=0 then
					begin
						ClearSelection(true);
						SetText(STRING_NODRIVER2);
						Disable;
						with PPrintDialog(Parent)^ do
							begin
								if inf<>nil then inf^.Disable;
								if druck<>nil then druck^.Disable
							end
					end
				else
					begin
						SetSelection(0,true);
						SetText(Popup^.GetText(0));
						Enable;
						with PPrintDialog(Parent)^ do
							begin
								if inf<>nil then inf^.Enable;
								if druck<>nil then druck^.Enable
							end
					end
			end;
		cb:=PPrintDialog(Parent)^.paper;
		if cb<>nil then
			begin
				if TexelApp.NVDIVersion<$0300 then cb^.Disable
				else
					if (Sel=DEV_IMG) or (Sel=DEV_PRINTER) then cb^.Enable
					else
						cb^.Disable
			end;
		ArrowMouse
	end;


procedure TPrintPercBox.SetValue(Sel: integer);
	var dummy: string;

	begin
		if Popup=nil then exit;
		dummy:=StrPTrimF(Popup^.GetText(Sel));
		SetText(StrPLeft(dummy,length(dummy)-1))
	end;


function TPrintDialog.OK: boolean;
	var valid: boolean;

	begin
		valid:=inherited OK;
		if valid then
			if Parent^.GetClassName=TEXELWINDCLASS then
				with PCalcWindow(Parent)^ do
					if pagepreview<>nil then pagepreview^.Update(true);
		OK:=valid
	end;


function TPrintDialog.ExitDlg(AnIndx: integer): boolean;
	var num: integer;

	begin
		ExitDlg:=false;
		if not(OK) then exit;
		case AnIndx of
		RTPPRINT:
			if drvbox=nil then Application^.Alert(@self,1,NOTE,MESSAGE_PRINT_PRINTER,BUTTON_OK)
			else
				begin
					num:=drvbox^.drivers[drvbox^.GetSelection];
					if num<11 then Application^.Alert(@self,1,NOTE,MESSAGE_PRINT_DRIVER,BUTTON_OK)
					else
						if PCalcWindow(Parent)^.prnt^.PrintSheet(num) then
							begin
								with PCalcWindow(Parent)^ do
									if pagepreview<>nil then pagepreview^.Update(true);
								ExitDlg:=true
							end
				end;
		RTPPREVIEW:
			with PCalcWindow(Parent)^ do
				if preview<>nil then preview^.Work;
		RTPPAGESETUP:
			if Parent^.GetClassName=TEXELWINDCLASS then
				begin
					with PCalcWindow(Parent)^ do
						if pagesetup<>nil then pagesetup^.Work
				end
			else
				POptionsDialog(Parent)^.PageSetup;
		RTPINFO:
			ShowInfo
		end
	end;


procedure TPrintDialog.ShowInfo;
	var dummy,txt,
	    colr,fonts,
	    res,psize,
	    rsize,bez,
	    defcol,ea : string;
	    dpix,dpiy,
	    num,q,hndl: integer;
	    ewrkout,
	    wrkout    : workout_ARRAY;
	    pw,ph,
	    rw,rh,
	    xfak,yfak : real;
	    pb        : PButton;

	begin
		if drvinfo=nil then
			begin
				new(drvinfo,Init(@self,TEXELNAME,STG_PRINTERINFO,ICNTITLE_PRINTERINFO,RTPRINTINFO));
				if drvinfo<>nil then
					begin
						new(st1,Init(drvinfo,RTPITITLE,33,true,BUBBLE_PRNINFO_DEVICE));
						new(st2,Init(drvinfo,RTPINAME,27,false,BUBBLE_PRNINFO_FILE));
						new(st3,Init(drvinfo,RTPIGDOS,17,false,BUBBLE_PRNINFO_NUMBER));
						new(st4,Init(drvinfo,RTPIINFO,43,false,BUBBLE_PRNINFO_DESCR));
						new(st5,Init(drvinfo,RTPIIOTYPE,36,false,BUBBLE_PRNINFO_IO));
						new(st6,Init(drvinfo,RTPICOLORS,41,false,BUBBLE_PRNINFO_COLORS));
						new(st7,Init(drvinfo,RTPIDEFCOLORS,20,false,BUBBLE_PRNINFO_MAXCOLOR));
						new(st8,Init(drvinfo,RTPIFONTS,20,false,BUBBLE_PRNINFO_FONTS));
						new(st9,Init(drvinfo,RTPIDPI,33,false,BUBBLE_PRNINFO_DPI));
						new(st10,Init(drvinfo,RTPISIZE,42,false,BUBBLE_PRNINFO_PAPRSIZE));
						new(st11,Init(drvinfo,RTPIPRINTSIZE,42,false,BUBBLE_PRNINFO_PRNTSIZE));
						new(st12,Init(drvinfo,RTPIBEZIER,19,false,BUBBLE_PRNINFO_BEZIER));
						new(pb,Init(drvinfo,RTPIHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(drvinfo,RTPIOK,id_OK,true,BUBBLE_GENERAL_CLOSE))
					end
			end;
		if drvinfo<>nil then
			begin
				BusyMouse;
				if devbox<>nil then dummy:=devbox^.GetText
				else
					dummy:='???';
				if st1<>nil then st1^.SetText(STRING_PRNINFO_INFOON+' '+dummy);
				if drvbox<>nil then
					begin
						num:=drvbox^.drivers[drvbox^.GetSelection];
						dummy:=drvbox^.shortnames[drvbox^.GetSelection];
						txt:=drvbox^.longnames[drvbox^.GetSelection]
					end
				else
					begin
						dummy:='???';
						txt:='';
						num:=-1
					end;
				if st2<>nil then st2^.SetText(STRING_PRNINFO_NAME+dummy);
				if st3<>nil then st3^.SetText(STRING_PRNINFO_NUMBER+ltoa(num));
				colr:='';
				ea:='';
				defcol:='';
				fonts:='';
				res:='';
				psize:='';
				rsize:='';
				bez:='';
				if (num>=11) and (num<=99) then
					begin
						vOpnwk(num,hndl,wrkout,paper^.GetSelection,'',PCalcWindow(Parent)^.wnd_prnt_set);
						if hndl<>0 then
							begin
								inc(wrkout[10],vst_load_fonts(hndl,0));
								vq_extnd(hndl,1,ewrkout);
								vst_unload_fonts(hndl,0);
								v_clswk(hndl);
								case wrkout[44] of
								0: ea:=STRING_PRNINFO_OUT;
								1: ea:=STRING_PRNINFO_IN;
								2: ea:=STRING_PRNINFO_IO;
								4: ea:=STRING_PRNINFO_META
								else
									ea:=STRING_PRNINFO_UNKNOWN
								end;
								if wrkout[35]=0 then colr:=STRING_PRNINFO_COLOR1
								else
									if wrkout[39]=0 then colr:=STRING_PRNINFO_COLOR2
									else
										colr:=ltoa(wrkout[39]);
								if (wrkout[13]=0) or (wrkout[35]=0) then defcol:=STRING_NONE
								else
									defcol:=ltoa(wrkout[13]);
								if wrkout[10]=0 then fonts:=STRING_NONE
								else
									fonts:=ltoa(wrkout[10]);
								pw:=longint(wrkout[0])+1.0;
								ph:=longint(wrkout[1])+1.0;
								xfak:=longint(wrkout[3])/longint(10000);
								yfak:=longint(wrkout[4])/longint(10000);
								rw:=pw;
								rh:=ph;
								if ewrkout[20]=0 then
									begin
										dpix:=mm2dpi(wrkout[3]);
										dpiy:=mm2dpi(wrkout[4])
									end
								else
									begin
										dpix:=ewrkout[23];
										dpiy:=ewrkout[24];
										rw:=rw+ewrkout[40]+ewrkout[42];
										rh:=rh+ewrkout[41]+ewrkout[43];
										case ewrkout[20] of
										1:
											begin
												xfak:=longint(ewrkout[21])/100000;
												yfak:=longint(ewrkout[22])/100000
											end;
										2:
											begin
												xfak:=longint(ewrkout[21])/1000000;
												yfak:=longint(ewrkout[22])/1000000
											end;
										3:
											begin
												xfak:=longint(ewrkout[21])/10000000;
												yfak:=longint(ewrkout[22])/10000000
											end
										end
									end;
								pw:=pw*xfak;
								ph:=ph*yfak;
								rw:=rw*xfak;
								rh:=rh*yfak;
								res:=ltoa(dpix)+' x '+ltoa(dpiy)+' dpi'#253;
								str(pw:0:2,psize);
								str(ph:0:2,dummy);
								psize:=psize+' x '+dummy+' cm'#253;
								str(rw:0:2,rsize);
								str(rh:0:2,dummy);
								rsize:=rsize+' x '+dummy+' cm'#253;
								if bTst(ewrkout[28],2) then bez:=STRING_YES
								else
									bez:=STRING_NO
							end
					end;
				if st4<>nil then st4^.SetText(txt);
				if st5<>nil then st5^.SetText(STRING_PRNINFO_TXT1+ea);
				if st6<>nil then st6^.SetText(STRING_PRNINFO_TXT2+colr);
				if st7<>nil then st7^.SetText(STRING_PRNINFO_TXT3+defcol);
				if st8<>nil then st8^.SetText(STRING_PRNINFO_TXT4+fonts);
				if st9<>nil then st9^.SetText(STRING_PRNINFO_TXT5+res);
				if st10<>nil then st10^.SetText(STRING_PRNINFO_TXT6+rsize);
				if st11<>nil then st11^.SetText(STRING_PRNINFO_TXT7+psize);
				if st12<>nil then st12^.SetText(STRING_PRNINFO_TXT8+bez);
				drvinfo^.MakeWindow;
				ArrowMouse
			end
	end;


procedure TSaveOpt.Work;
	var q,hdl: integer;
	    ret  : longint;

	begin
		SliceMouse;
		if WritePrivateProfileString('CalcWindowDefaults','Rows',TexelApp.setupbuffer.stdrows,TEXELINF) then
			begin
				SliceMouseNext;
				WritePrivateProfileString('CalcWindowDefaults','Columns',TexelApp.setupbuffer.stdcolumns,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('CalcWindowDefaults','StdColWidth',TexelApp.setupbuffer.stdcolwidth,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('CalcWindowDefaults','StdFont',TexelApp.GetStdFontIndex,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('CalcWindowDefaults','StdFontSize',TexelApp.GetStdFontSize,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('CalcWindowDefaults','AutoCalc',TexelApp.setupbuffer.autocalc,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','OpenNew',TexelApp.setupbuffer.opennew,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','LoadDoc',TexelApp.setupbuffer.loaddoc,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','Nothing',TexelApp.setupbuffer.nothing,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','FullSize',TexelApp.setupbuffer.fullsize,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','WYSIWYG',TexelApp.setupbuffer.wysiwyg,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','WYSIWYG.PixW',TexelApp.setupbuffer.pixw,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','WYSIWYG.PixH',TexelApp.setupbuffer.pixh,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','Recalc',TexelApp.setupbuffer.recalc,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','Online',TexelApp.setupbuffer.online,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','Backup',TexelApp.setupbuffer.bak,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','Toolbar',TexelApp.setupbuffer.toolbar,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','Currency',TexelApp.setupbuffer.currency,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','Overflow',TexelApp.setupbuffer.overflow,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','BottomLine',TexelApp.setupbuffer.bottomline,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','XInputMode',TexelApp.setupbuffer.xinputmode,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','CursorWrap',TexelApp.setupbuffer.cursorwrap,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Setup','CancelOnClose',TexelApp.setupbuffer.closercancel,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Setup','SizerRange',TexelApp.setupbuffer.sizerrange,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Setup','FloatingPoint',TexelApp.setupbuffer.floatpoint,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Setup','History',TexelApp.setupbuffer.history,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Printer','Sheet',TexelApp.stdprnbuffer.sheet,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Printer','BlackWhite',TexelApp.stdprnbuffer.sw,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Printer','Feed',TexelApp.stdprnbuffer.feed,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Printer','Driver',TexelApp.stdprnbuffer.driver,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Printer','Device',TexelApp.stdprnbuffer.device,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Printer','Copies',TexelApp.stdprnbuffer.copies,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Printer','Percent',TexelApp.stdprnbuffer.percent,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Printer','Von',TexelApp.stdprnbuffer.von,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Printer','Bis',TexelApp.stdprnbuffer.bis,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Printer','PBlock',TexelApp.stdprnbuffer.pblock,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Printer','Alles',TexelApp.stdprnbuffer.alles,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Printer','Block',TexelApp.stdprnbuffer.block,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Printer','Papier',TexelApp.stdprnbuffer.papier,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Import','Hor',TexelApp.ascbuf.hor,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Import','Vert',TexelApp.ascbuf.vert,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Import','rcTxt','"'+TexelApp.ascbuf.rcTxt+'"',TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Import','rcVal',TexelApp.ascbuf.rcval,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Import','cellTxt','"'+TexelApp.ascbuf.cellTxt+'"',TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Import','cellVal',TexelApp.ascbuf.cellval,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Import','textTxt','"'+TexelApp.ascbuf.textTxt+'"',TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Import','textVal',TexelApp.ascbuf.textval,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Import','Quote',TexelApp.ascbuf.quote,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Import','Numbers',TexelApp.ascbuf.numbers,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Import','Filter',TexelApp.ascbuf.filter,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','Oben',TexelApp.stdpsbuffer.oben,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','Unten',TexelApp.stdpsbuffer.unten,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','Links',TexelApp.stdpsbuffer.links,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','Rechts',TexelApp.stdpsbuffer.rechts,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','Kopf',TexelApp.stdpsbuffer.kopf,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','Fuss',TexelApp.stdpsbuffer.fuss,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','Bereich',TexelApp.stdpsbuffer.bereich,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','hLeft','"'+TexelApp.stdpsbuffer.hleft+'"',TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','hMid','"'+TexelApp.stdpsbuffer.hmid+'"',TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','hRight','"'+TexelApp.stdpsbuffer.hright+'"',TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','fLeft','"'+TexelApp.stdpsbuffer.fleft+'"',TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','fMid','"'+TexelApp.stdpsbuffer.fmid+'"',TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Page Setup','fRight','"'+TexelApp.stdpsbuffer.fright+'"',TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','hCenter',TexelApp.stdpsbuffer.hcenter,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','vCenter',TexelApp.stdpsbuffer.vcenter,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','Gitter',TexelApp.stdpsbuffer.gitter,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','Rows',TexelApp.stdpsbuffer.rows,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','Columns',TexelApp.stdpsbuffer.columns,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','Num1',TexelApp.stdpsbuffer.num1,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','Num2',TexelApp.stdpsbuffer.num2,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','hLeftOn',TexelApp.stdpsbuffer.hlefton,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','hCenterOn',TexelApp.stdpsbuffer.hcenteron,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','hRightOn',TexelApp.stdpsbuffer.hrighton,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','fLeftOn',TexelApp.stdpsbuffer.flefton,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','fCenterOn',TexelApp.stdpsbuffer.fcenteron,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','fRightOn',TexelApp.stdpsbuffer.frighton,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Page Setup','Images',TexelApp.stdpsbuffer.images,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Web','ASH',TexelApp.WebASH,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Web','Support',TexelApp.WebMail,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Texel','Version',VtoS(TEXELVER),TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Texel','Release',ltoa(RELEASE),TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Texel','Date',TEXELDATE,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileInt('Texel','Level',TEXELCOMPAT,TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Texel','OGEMVersion',VtoS(GOVersion),TEXELINF);
				SliceMouseNext;
				WritePrivateProfileString('Texel','OGEMDate',DtoS(GODate),TEXELINF);
				SliceMouseNext;
				SavePrivateProfile
			end;
		ArrowMouse;
		BusyMouse;
		ret:=fcreate(GetHomeDir(false)+'defaults\'+TEXELPATHS,0);
		if ret<0 then ret:=fcreate(GetHomeDir(false)+TEXELPATHS,0);
		if ret>=0 then
			begin
				hdl:=integer(ret);
				q:=PFMAX;
				fwrite(hdl,2,@q);
				for q:=0 to PFMAX do
					begin
						fwrite(hdl,length(TexelApp.LastPath[q])+1,@TexelApp.LastPath[q]);
						fwrite(hdl,length(TexelApp.LastFile[q])+1,@TexelApp.LastFile[q])
					end;
				fclose(hdl)
			end;
		if TexelApp.app_prnt_set<>nil then
			if TexelApp.app_prnt_set^.magic='pset' then
				begin
					ret:=fcreate(GetHomeDir(false)+'defaults\'+TEXELPRNSET,0);
					if ret<0 then ret:=fcreate(GetHomeDir(false)+TEXELPRNSET,0);
					if ret>=0 then
						begin
							hdl:=integer(ret);
							fwrite(hdl,TexelApp.app_prnt_set^.len,TexelApp.app_prnt_set);
							fclose(hdl)
						end
				end;
		ArrowMouse
	end;


procedure TSaveWork.Work;
	var p  : PWindow;
	    ret: longint;
	    hdl,
	    anz: integer;
	    s  : string;

	begin
		BusyMouse;
		p:=Application^.MainWindow;
		anz:=0;
		while p<>nil do
			begin
				if p^.GetClassName=TEXELWINDCLASS then
					if length(PCalcWindow(p)^.GetWindowFilename)>0 then inc(anz);
				p:=p^.Next
			end;
		ret:=fcreate(GetHomeDir(false)+'defaults\'+TEXELWORK,0);
		if ret<0 then ret:=fcreate(GetHomeDir(false)+TEXELWORK,0);
		if ret>=0 then
			begin
				hdl:=integer(ret);
				fwrite(hdl,2,@anz);
				p:=Application^.MainWindow;
				while p<>nil do
					begin
						if p^.GetClassName=TEXELWINDCLASS then
							begin
								s:=PCalcWindow(p)^.GetWindowFilename;
								if length(s)>0 then fwrite(hdl,256,@s[0])
							end;
						p:=p^.Next
					end;
				fclose(hdl)
			end;
		ArrowMouse
	end;


procedure TSpecialChars.Work;

	begin
		if TexelApp.specialchars=nil then
			begin
				new(TexelApp.specialchars,Init(nil,TEXELWINDPREFIX+TITLE_SPECIALCHARS));
				if TexelApp.specialchars<>nil then TexelApp.specialchars^.LoadIcon(new(PIcon,Init(TexelApp.specialchars,RTICONS,RTICALC,0,0,false,false,'','')))
			end;
		if TexelApp.specialchars<>nil then TexelApp.specialchars^.MakeWindow
	end;


procedure TWeb.Work;
	var pipe : Pipearray;
	    txt,
	    fname: string;
	    ret  : longint;
	    hdl  : integer;

	begin
		if (TexelApp.WebID<0) or (helpbuf=nil) or (GetState<>bf_Enabled) then exit;
		case VMNum of
		RTMHELPASH:
			begin
				StrPCopy(helpbuf,TexelApp.WebASH);
				pipe[0]:=CAB_VIEW;
				pipe[1]:=Application^.apID;
				pipe[2]:=0;
				pipe[3]:=integer(HiWord(helpbuf));
				pipe[4]:=integer(LoWord(helpbuf));
				pipe[5]:=1;
				pipe[6]:=0;
				pipe[7]:=0
			end;
		RTMHELPSUPPORT:
			begin
				fname:=CreateUniqueTempFilename(GetTexelTempDir);
				ret:=fcreate(fname,0);
				if ret<0 then exit;
				hdl:=integer(ret);
				txt:=STRING_WEB_MAILDEF1+#13#10#13#10+STRING_WEB_MAILDEF2+' '+TEXELNAME+' '+VtoS(TEXELVER)+'r'+ltoa(RELEASE)+' '+STRING_WEB_MAILDATEOF+' '+TEXELDATE+':'#13#10#13#10#13#10#13#10+STRING_WEB_MAILDEF3+' ';
				{$IFDEF DEMO}
				txt:=txt+'('+STRING_DEMOVERSION+')';
				{$ELSE}
				{$IFDEF BETA}
				if length(regname)=0 then txt:=txt+'(unregistrierte Version)'
				else
					txt:=txt+regname;
				{$ELSE}
				txt:=txt+decode_name(ash_name);
				{$ENDIF}
				{$ENDIF}
				txt:=txt+#13#10;
				fwrite(hdl,length(txt),@txt[1]);
				fclose(hdl);
				StrPCopy(helpbuf,TexelApp.WebMail+'?'+STRING_WEB_MAILSUBJECT+' '+TEXELNAME+' '+VtoS(TEXELVER));
				StrPCopy(mailbuf,fname);
				pipe[0]:=CAB_MAIL;
				pipe[1]:=Application^.apID;
				pipe[2]:=0;
				pipe[3]:=integer(HiWord(helpbuf));
				pipe[4]:=integer(LoWord(helpbuf));
				pipe[5]:=integer(HiWord(mailbuf));
				pipe[6]:=integer(LoWord(mailbuf));
				pipe[7]:=3
			end
		end;
		appl_write(TexelApp.WebID,16,@pipe)
	end;


procedure THelp.Work;
	label _aufruf;

	var pipe: Pipearray;
	    p   : PWindow;

	begin
		if not(TexelApp.HelpAvailable(true)) then exit;
		case VMNum of
		RTMHELPCONTEXT:
			begin
				p:=Application^.GetPTopWindow;
				if p<>nil then
					begin
						if p^.IsDialog then
							begin
								PDialog(p)^.Help;
								exit
							end
						else
							if p^.GetClassName='SpecialCharactersWindow' then
								begin
									if Exist(TexelApp.DataPath+TEXELHELP) then StrPCopy(helpbuf,TexelApp.DataPath+TEXELHELP+' '+STG_SPECIALCHARS)
									else
										StrPCopy(helpbuf,GUIDES+TEXELHELP+' '+STG_SPECIALCHARS);
									goto _aufruf
								end
					end;
				if Exist(TexelApp.DataPath+TEXELHELP) then StrPCopy(helpbuf,TexelApp.DataPath+TEXELHELP)
				else
					StrPCopy(helpbuf,GUIDES+TEXELHELP)
			end;
		RTMHELPONHELP:
			StrPCopy(helpbuf,'*:\st-guide.hyp');
		RTMHELPCONTENTS:
			begin
				if Exist(TexelApp.DataPath+TEXELHELP) then StrPCopy(helpbuf,TexelApp.DataPath+TEXELHELP)
				else
					StrPCopy(helpbuf,GUIDES+TEXELHELP)
			end;
		RTMHELPINDEX:
			begin
				if Exist(TexelApp.DataPath+TEXELHELP) then StrPCopy(helpbuf,TexelApp.DataPath+TEXELHELP+' Index')
				else
					StrPCopy(helpbuf,GUIDES+TEXELHELP+' Index')
			end
		end;
		_aufruf:
		pipe[0]:=VA_START;
		pipe[1]:=Application^.apID;
		pipe[2]:=0;
		pipe[3]:=integer(HiWord(helpbuf));
		pipe[4]:=integer(LoWord(helpbuf));
		pipe[5]:=0;
		pipe[6]:=0;
		pipe[7]:=0;
		appl_write(TexelApp.HelpID,16,@pipe)
	end;


procedure THelpItem.Work;
	var pb: PButton;

	begin
		if ADialog=nil then
			begin
				ADialog:=new(PHelpItemDialog,Init(nil,TEXELWINDPREFIX+TITLE_HELP,STG_HELP,ICNTITLE_HELP,RTHELPITEM));
				if ADialog<>nil then
					begin
						new(PEdit,Init(ADialog,RTHIITEM,41,BUBBLE_HELP_ITEM));
						new(pb,Init(ADialog,RTHIHELP,id_Help,false,BUBBLE_GENERAL_HELP));
						if pb<>nil then
							if not(TexelApp.HelpAvailable(false)) then pb^.Disable;
						new(PButton,Init(ADialog,RTHICANCEL,id_Cancel,true,BUBBLE_GENERAL_CANCEL));
						new(PButton,Init(ADialog,RTHISEARCH,id_No,true,BUBBLE_HELP_SEARCH));
						new(PButton,Init(ADialog,RTHIOK,id_OK,true,BUBBLE_HELP_OK));
						TexelApp.HelpItem:='';
						ADialog^.TransferBuffer:=@TexelApp.HelpItem
					end
			end;
		if ADialog<>nil then ADialog^.MakeWindow
	end;


function THelpItemDialog.OK: boolean;
	var valid: boolean;
	    pipe : Pipearray;
	    dummy: string;

	begin
		valid:=inherited OK;
		OK:=valid;
		if valid then
			begin
				dummy:=StrPTrimF(TexelApp.HelpItem);
				if (length(dummy)=0) or not(TexelApp.HelpAvailable(true)) then exit;
				if Exist(TexelApp.DataPath+TEXELHELPREF) then StrPCopy(helpbuf,TexelApp.DataPath+TEXELHELPREF+' '+dummy)
				else
					StrPCopy(helpbuf,GUIDES+TEXELHELPREF+' '+dummy);
				pipe[0]:=VA_START;
				pipe[1]:=Application^.apID;
				pipe[2]:=0;
				pipe[3]:=integer(HiWord(helpbuf));
				pipe[4]:=integer(LoWord(helpbuf));
				pipe[5]:=0;
				pipe[6]:=0;
				pipe[7]:=0;
				appl_write(TexelApp.HelpID,16,@pipe);
				TexelApp.HelpItem:=''
			end
	end;


function THelpItemDialog.ExitDlg(AnIndx: integer): boolean;
	var pipe : Pipearray;
	    dummy: string;

	begin
		ExitDlg:=false;
		if AnIndx<>RTHISEARCH then exit;
		TransferData(tf_GetData);
		dummy:=StrPTrimF(TexelApp.HelpItem);
		if (length(dummy)=0) or not(TexelApp.HelpAvailable(true)) then exit;
		if Exist(TexelApp.DataPath+TEXELHELPREF) then StrPCopy(helpbuf,TexelApp.DataPath+TEXELHELPREF+' '+dummy)
		else
			StrPCopy(helpbuf,GUIDES+TEXELHELPREF+' '+dummy);
		pipe[0]:=VA_START;
		pipe[1]:=Application^.apID;
		pipe[2]:=0;
		pipe[3]:=integer(HiWord(helpbuf));
		pipe[4]:=integer(LoWord(helpbuf));
		pipe[5]:=0;
		pipe[6]:=0;
		pipe[7]:=0;
		appl_write(TexelApp.HelpID,16,@pipe)
	end;


procedure TBlock.Work;

	begin
		with PCalcWindow(Parent)^ do
			begin
				with dblock^ do
					begin
						ObjAddr^.ob_state:=ObjAddr^.ob_state or SELECTED;
						Paint
					end;
				ExitDlg(RTWDBLOCK);
				with dblock^ do
					begin
						ObjAddr^.ob_state:=ObjAddr^.ob_state and not(SELECTED);
						Paint
					end
			end
	end;


constructor TColorToolbar.Init(AParent: PWindow; AnIndx,AColIndx: integer; Switch: boolean; Hlp: string);
	var pt: PTree;

	begin
		if not(inherited Init(AParent,RTWTOOLBAR,AnIndx,id_No,id_No,nil,false,Switch,Hlp)) then fail;
		used:=false;
		if Application^.HasColorIcons and (AColIndx>=0) and
		   (Application^.Attr.Colors>=15) and TexelApp.UseNewToolbar then
			begin
				TexelApp.ActivateExtResource;
				pt:=Application^.GetAddr(RTWCOLORTB);
				if pt<>nil then
					begin
						oldobtype:=ObjAddr^.ob_type;
						oldobspec:=ObjAddr^.ob_spec.index;
						ObjAddr^.ob_type:=(oldobtype and $ff00) or G_CICON;
						ObjAddr^.ob_spec.index:=pt^[AColIndx].ob_spec.index;
						used:=true
					end;
				TexelApp.DeactivateExtResource
			end
	end;


destructor TColorToolbar.Done;

	begin
		if used then
			begin
				ObjAddr^.ob_type:=oldobtype;
				ObjAddr^.ob_spec.index:=oldobspec
			end;
		inherited Done
	end;


procedure TTCut.Work;

	begin
		PCalcWindow(Parent)^.Cut
	end;


procedure TTCopy.Work;

	begin
		PCalcWindow(Parent)^.Copy
	end;


procedure TTPaste.Work;

	begin
		PCalcWindow(Parent)^.Paste
	end;


procedure TTFunction.Work;

	begin
		with PCalcWindow(Parent)^ do if insfunc<>nil then insfunc^.Work
	end;


procedure TTSumme.Work;
	var txt,blk: string;
	    ne,
	    r,rvon : integer;
	    loffs  : longint;
	    cell   : PCell;

	begin
		with PCalcWindow(Parent)^ do
			begin
				if inpline=nil then exit;
				with Parms.Cursor do
					if Block then blk:=StrPTrimF(dblock^.GetText)
					else
						begin
							blk:='';
							if Parms.Cursor.Row>0 then
								begin
									r:=Parms.Cursor.Row;
									repeat
										dec(r);
										if r>=0 then cell:=GetCell(r,Parms.Cursor.Col)
									until (cell^.Typ=CTYPE_TEXT) or (cell^.Typ=CTYPE_EMPTY) or (r<0);
									if r<Parms.Cursor.Row-1 then blk:=GetColumnIndex(Parms.Cursor.Col)+GetRowIndex(r+1)+':'+GetColumnIndex(Parms.Cursor.Col)+GetRowIndex(Parms.Cursor.Row-1)
								end
						end;
				if inpstat then
					begin
						txt:=inpline^.GetText;
						if (length(txt)>0) and (StrPTrimF(txt)<>'=') then Application^.Bing
						else
							begin
								inpline^.SetText('='+TexelApp.SumName+'('+blk+')');
								inpline^.SetCursor(length(inpline^.GetText)-1)
							end
					end
				else
					begin
						with Parms.Cursor do if Block then SetCursorPos(Row,Col,true);
						inpline^.SetText('='+TexelApp.SumName+'('+blk+')');
						inpline^.SetCursor(length(inpline^.GetText)-1);
						EnableInpline
					end
			end
	end;


procedure TTFett.Work;
	var x,y,rs,re,
	    cmin,cmax,
	    cs,ce    : integer;
	    cell     : PCell;

	begin
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				cmin:=cs;
				cmax:=ce;
				RowsClearOverflow(rs,re,cmin,cmax);
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								with cell^.TxtVal do
									if GetCheck=bf_Checked then Effects:=Effects or TF_THICKENED
									else
										Effects:=Effects and not(TF_THICKENED);
								inc(longint(cell),CELLSIZE)
							end
					end;
				RowsCheckOverflow(rs,re,cmin,cmax);
				SetDirty;
				DrawCells(rs,cmin,re,cmax)
			end
	end;


procedure TTKursiv.Work;
	var x,y,rs,re,
	    cmin,cmax,
	    cs,ce    : integer;
	    cell     : PCell;

	begin
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				cmin:=cs;
				cmax:=ce;
				RowsClearOverflow(rs,re,cmin,cmax);
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								with cell^.TxtVal do
									if GetCheck=bf_Checked then Effects:=Effects or TF_SLANTED
									else
										Effects:=Effects and not(TF_SLANTED);
								inc(longint(cell),CELLSIZE)
							end
					end;
				RowsCheckOverflow(rs,re,cmin,cmax);
				SetDirty;
				DrawCells(rs,cmin,re,cmax)
			end
	end;


procedure TTUnter.Work;
	var x,y,rs,re,
	    cmin,cmax,
	    cs,ce    : integer;
	    cell     : PCell;

	begin
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				cmin:=cs;
				cmax:=ce;
				RowsClearOverflow(rs,re,cmin,cmax);
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								with cell^.TxtVal do
									if GetCheck=bf_Checked then Effects:=Effects or TF_UNDERLINED
									else
										Effects:=Effects and not(TF_UNDERLINED);
								inc(longint(cell),CELLSIZE)
							end
					end;
				RowsCheckOverflow(rs,re,cmin,cmax);
				SetDirty;
				DrawCells(rs,cmin,re,cmax)
			end
	end;


procedure TTAlignLeft.Work;
	var x,y,rs,re,
	    cmin,cmax,
	    cs,ce     : integer;
	    cell,cell2: PCell;

	begin
		with PCalcWindow(Parent)^ do
			begin
				if palignleft<>nil then palignleft^.Check;
				if paligncenter<>nil then paligncenter^.Uncheck;
				if palignright<>nil then palignright^.Uncheck;
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd;
							cell2:=nil
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col;
							cell2:=GetCell(rs,cs)
						end;
				cmin:=cs;
				cmax:=ce;
				RowsClearOverflow(rs,re,cmin,cmax);
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								cell^.TxtVal.Align:=(cell^.TxtVal.Align and $f0) or TA_LEFT;
								inc(longint(cell),CELLSIZE)
							end
					end;
				RowsCheckOverflow(rs,re,cmin,cmax);
				SetDirty;
				DrawCells(rs,cmin,re,cmax);
				SetInpline(cell2)
			end
	end;


procedure TTAlignCenter.Work;
	var x,y,rs,re,
	    cmin,cmax,
	    cs,ce     : integer;
	    cell,cell2: PCell;

	begin
		with PCalcWindow(Parent)^ do
			begin
				if paligncenter<>nil then paligncenter^.Check;
				if palignleft<>nil then palignleft^.Uncheck;
				if palignright<>nil then palignright^.Uncheck;
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd;
							cell2:=nil
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col;
							cell2:=GetCell(rs,cs)
						end;
				cmin:=cs;
				cmax:=ce;
				RowsClearOverflow(rs,re,cmin,cmax);
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								cell^.TxtVal.Align:=(cell^.TxtVal.Align and $f0) or TA_CENTER;
								inc(longint(cell),CELLSIZE)
							end
					end;
				RowsCheckOverflow(rs,re,cmin,cmax);
				SetDirty;
				DrawCells(rs,cmin,re,cmax);
				SetInpline(cell2)
			end
	end;


procedure TTAlignRight.Work;
	var x,y,rs,re,
	    cmin,cmax,
	    cs,ce     : integer;
	    cell,cell2: PCell;

	begin
		with PCalcWindow(Parent)^ do
			begin
				if palignright<>nil then palignright^.Check;
				if palignleft<>nil then palignleft^.Uncheck;
				if paligncenter<>nil then paligncenter^.Uncheck;
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd;
							cell2:=nil
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col;
							cell2:=GetCell(rs,cs)
						end;
				cmin:=cs;
				cmax:=ce;
				RowsClearOverflow(rs,re,cmin,cmax);
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								cell^.TxtVal.Align:=(cell^.TxtVal.Align and $f0) or TA_RIGHT;
								inc(longint(cell),CELLSIZE)
							end
					end;
				RowsCheckOverflow(rs,re,cmin,cmax);
				SetDirty;
				DrawCells(rs,cmin,re,cmax);
				SetInpline(cell2)
			end
	end;


procedure TTNumber.Work;
	var cell : PCell;
	    x,y,
	    nform,
	    rs,cs,
	    re,ce: integer;
	    vrnd : boolean;

	begin
		vrnd:=false;
		{$IFDEF ENGLISH}
		nform:=60;
		{$ELSE}
		nform:=TexelApp.FormStart[2];
		{$ENDIF}
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								if cell^.Typ<>CTYPE_TEXT then
									if cell^.Format<>nform then
										begin
											cell^.Format:=nform;
											vrnd:=true
										end;
								inc(longint(cell),CELLSIZE)
							end
					end;
				if vrnd then
					begin
						SetDirty;
						DrawCells(rs,cs,re,ce)
					end
				else
					Application^.Bing
			end
	end;


procedure TTDate.Work;
	var cell : PCell;
	    x,y,
	    nform,
	    rs,cs,
	    re,ce: integer;
	    vrnd : boolean;

	begin
		vrnd:=false;
		{$IFDEF FRENCH}
		nform:=72;
		{$ELSE}
		{$IFDEF ENGLISH}
		nform:=73;
		{$ELSE}
		nform:=TexelApp.FormStart[3];
		{$ENDIF}
		{$ENDIF}
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								if cell^.Typ<>CTYPE_TEXT then
									if cell^.Format<>nform then
										begin
											cell^.Format:=nform;
											vrnd:=true
										end;
								inc(longint(cell),CELLSIZE)
							end
					end;
				if vrnd then
					begin
						SetDirty;
						DrawCells(rs,cs,re,ce)
					end
				else
					Application^.Bing
			end
	end;


procedure TTMoney.Work;
	var cell : PCell;
	    x,y,
	    nform,
	    rs,cs,
	    re,ce: integer;
	    vrnd : boolean;

	begin
		vrnd:=false;
		case TexelApp.setupbuffer.currency of
		1:
			nform:=52;
		2:
			nform:=48;
		3: 
			nform:=68;
		4:
			nform:=64;
		5:
			nform:=75;
		6:
			nform:=79;
		7:
			nform:=83;
		else
			nform:=TexelApp.FormStart[7]
		end;
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								if cell^.Typ<>CTYPE_TEXT then
									if cell^.Format<>nform then
										begin
											cell^.Format:=nform;
											vrnd:=true
										end;
								inc(longint(cell),CELLSIZE)
							end
					end;
				if vrnd then
					begin
						SetDirty;
						DrawCells(rs,cs,re,ce)
					end
				else
					Application^.Bing
			end
	end;


procedure TTPercent.Work;
	var cell : PCell;
	    x,y,
	    nform,
	    rs,cs,
	    re,ce: integer;
	    vrnd : boolean;

	begin
		vrnd:=false;
		nform:=TexelApp.FormStart[5];
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								if cell^.Typ<>CTYPE_TEXT then
									if cell^.Format<>nform then
										begin
											cell^.Format:=nform;
											vrnd:=true
										end;
								inc(longint(cell),CELLSIZE)
							end
					end;
				if vrnd then
					begin
						SetDirty;
						DrawCells(rs,cs,re,ce)
					end
				else
					Application^.Bing
			end
	end;


procedure TTDiagram.Work;
	var p    : PCalcWindow;
	    old  : TDiagrammBuf;
	    cell : PCell;
	    lofs : longint;
	    q,
	    rs,cs,
	    re,ce,
	    dummy: integer;

	begin
		p:=PCalcWindow(Parent);
		if Application^.Multitasking then
			if p^.Parms.Cursor.Block then
				if p^.GetBlock(p^.dblock^.GetText,false,rs,cs,re,ce,dummy,dummy) then
					if p^.diagramm<>nil then
						begin
							if p^.diagramm^.ADialog=nil then
								begin
									p^.diagramm^.Work;
									if p^.diagramm^.ADialog<>nil then p^.diagramm^.ADialog^.WMClosed
								end;
							if p^.diagramm^.ADialog<>nil then
								with PDiagrammDialog(p^.diagramm^.ADialog)^ do
									begin
										old:=p^.diagrammbuf;
										with p^.diagrammbuf do
											begin
												typLinie:=bf_Unchecked;
												typBalken:=bf_Checked;
												typKreis:=bf_Unchecked;
												Stapeln:=bf_Unchecked;
												DreiD:=bf_Unchecked;
												Neben:=bf_Checked;
												Absolut:=bf_Checked;
												if Application^.Attr.MaxColors=2 then Farbe:=bf_Unchecked
												else
													Farbe:=bf_Checked;
												Titel:=p^.GetRawIconTitle;
												Border:=bf_Checked;
												Size:=TexelApp.setupbuffer.stdfsize;
												Font:=TexelApp.setupbuffer.stdfont;
												alName:='';
												alMin:='';
												alMax:='';
												auName:='';
												auMin:='';
												auMax:='';
												szWidth:='50.0';
												szHeight:='50.0';
												objFilename:='';
												Ticks:=bf_Checked;
												numTicks:='4';
												alTicks:=bf_Checked;
												alNum:='3';
												auTicks:=bf_Checked;
												auNum:='3';
												nRow:=bf_Unchecked;
												nColumn:=bf_Unchecked;
												dRows:=bf_Unchecked;
												dColumns:=bf_Unchecked;
												if cs=ce then
													begin
														dColumns:=bf_Checked;
														cell:=p^.GetCell(rs,cs);
														if cell^.Typ=CTYPE_TEXT then nRow:=bf_Checked
													end
												else
													if rs=re then
														begin
															dRows:=bf_Checked;
															cell:=p^.GetCell(rs,cs);
															if cell^.Typ=CTYPE_TEXT then nColumn:=bf_Checked
														end
													else
														begin
															lofs:=longint(p^.Parms.Columns+1)*CELLSIZE;
															cell:=p^.GetCell(rs,cs+1);
															for q:=cs+1 to ce do
																begin
																	if cell^.Typ=CTYPE_TEXT then
																		begin
																			nRow:=bf_Checked;
																			break
																		end;
																	inc(longint(cell),CELLSIZE)
																end;
															cell:=p^.GetCell(rs+1,cs);
															for q:=rs+1 to re do
																begin
																	if cell^.Typ=CTYPE_TEXT then
																		begin
																			nColumn:=bf_Checked;
																			break
																		end;
																	inc(longint(cell),lofs)
																end;
															cell:=p^.GetCell(rs,cs);
															if cell^.Typ=CTYPE_TEXT then
																if (nRow=bf_Unchecked) and (nColumn=bf_Unchecked) then
																	begin
																		if (ce-cs)<(re-rs) then nRow:=bf_Checked
																		else
																			nColumn:=bf_Checked
																	end;
															if (nRow=bf_Checked) and (nColumn=bf_Unchecked) then dColumns:=bf_Checked
															else
																dRows:=bf_Checked
														end;
												if (nRow=bf_Checked) or (nColumn=bf_Checked) then Legende:=bf_Checked
												else
													Legende:=bf_Unchecked;
												if (Kbshift(-1) and K_SHIFT)>0 then
													begin
														if dRows=bf_Checked then
															begin
																dRows:=bf_Unchecked;
																dColumns:=bf_Checked
															end
														else
															begin
																dRows:=bf_Checked;
																dColumns:=bf_Unchecked
															end
													end
											end;
										CreateDiagram('',true);
										p^.diagrammbuf:=old;
										exit
									end
						end;
		Application^.Bing
	end;


procedure TTHome.Work;

	begin
		PCalcWindow(Parent)^.SetCursorPos(0,0,true)
	end;


procedure TTSortAuf.Work;
	var cs,ce,
	    c2,c3,
	    dummy: integer;

	begin
		with PCalcWindow(Parent)^ do
			begin
				GetBlock(dblock^.GetText,false,dummy,cs,dummy,ce,dummy,dummy);
				if ce>cs then c2:=cs+1
				else
					c2:=-1;
				if ce>cs+1 then c3:=cs+2
				else
					c3:=-1;
				Sort(cs,c2,c3,0,true,true,true,false,false,false,true,false,false)
			end
	end;


procedure TTSortAb.Work;
	var cs,ce,
	    c2,c3,
	    dummy: integer;

	begin
		with PCalcWindow(Parent)^ do
			begin
				GetBlock(dblock^.GetText,false,dummy,cs,dummy,ce,dummy,dummy);
				if ce>cs then c2:=cs+1
				else
					c2:=-1;
				if ce>cs+1 then c3:=cs+2
				else
					c3:=-1;
				Sort(cs,c2,c3,0,false,false,false,false,false,false,true,false,false)
			end
	end;


procedure TTDezPlus.Work;
	var cell : PCell;
	    x,y,
	    nnr,
	    rs,cs,
	    re,ce: integer;
	    chg,
	    vrnd : boolean;
	    p    : PCalcWindow;
	    pfm  : PFormat;
	    s,ret: string;

	procedure ChangeFormat(frm: integer);
		var q: integer;

		function DezPlus(t: string): string;
			var q,flg: integer;

			begin
				DezPlus:=t;
				if length(t)=0 then exit;
				flg:=0;
				q:=1;
				while q<=length(t) do
					begin
						if t[q]='{' then flg:=1
						else
							if ((t[q]='}') or (t[q]='E')) and (flg>0) then
								begin
									if flg=2 then
										begin
											if t[q-1]='|' then
												begin
													{$IFDEF ENGLISH}
													t:=StrPLeft(t,q-1)+'.0'+StrPRight(t,length(t)+1-q);
													{$ELSE}
													t:=StrPLeft(t,q-1)+',0'+StrPRight(t,length(t)+1-q);
													{$ENDIF}
													inc(q,2)
												end
											else
												begin
													t:=StrPLeft(t,q-1)+'0'+StrPRight(t,length(t)+1-q);
													inc(q)
												end
										end
									else
										begin
											{$IFDEF ENGLISH}
											t:=StrPLeft(t,q-1)+'|.0'+StrPRight(t,length(t)+1-q);
											{$ELSE}
											t:=StrPLeft(t,q-1)+'|,0'+StrPRight(t,length(t)+1-q);
											{$ENDIF}
											inc(q,3)
										end;
									DezPlus:=t;
									chg:=true;
									flg:=0
								end
							else
								if t[q]='|' then
									if flg=1 then flg:=2;
						inc(q)
					end
			end;

		begin
			if frm<=0 then exit;
			if frm>=1000 then pfm:=PFormat(p^.UsrFormats^.At(frm-1000))
			else
				pfm:=PFormat(TexelApp.Formats^.At(frm));
			s:=pfm^.Name^;
			ret:='';
			chg:=false;
			q:=pos(';',s);
			while q>0 do
				begin
					ret:=ret+DezPlus(StrPLeft(s,q-1))+';';
					s:=StrPRight(s,length(s)-q);
					q:=pos(';',s);
				end;
			ret:=ret+DezPlus(s);
			if chg then
				begin
					nnr:=0;
					if p^.UsrFormats^.Count>0 then
						for q:=0 to p^.UsrFormats^.Count-1 do
							if PFormat(p^.UsrFormats^.At(q))^.Name^=ret then
								begin
									nnr:=PFormat(p^.UsrFormats^.At(q))^.Index;
									break
								end;
					if nnr=0 then
						if TexelApp.Formats^.Count>0 then
							for q:=0 to TexelApp.Formats^.Count-1 do
								if PFormat(TexelApp.Formats^.At(q))^.Name^=ret then
									begin
										nnr:=PFormat(TexelApp.Formats^.At(q))^.Index;
										break
									end;
					if nnr=0 then nnr:=p^.NewNumFormat(ret);
					cell^.Format:=nnr;
					vrnd:=true
				end
		end;

	begin
		p:=PCalcWindow(Parent);
		vrnd:=false;
		with p^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								if cell^.Typ=CTYPE_FORMULA then
									with cell^.Data.Formula^ do
										begin
											if FPts<MAXCIPHERS then
												begin
													inc(Fpts);
													vrnd:=true
												end
										end
								else
									if cell^.Typ=CTYPE_CONST then
										with cell^.Data.Konst^ do
											if FPts<MAXCIPHERS then
												begin
													inc(Fpts);
													vrnd:=true
												end;
								ChangeFormat(cell^.Format);
								inc(longint(cell),CELLSIZE)
							end
					end;
				if vrnd then
					begin
						SetDirty;
						DrawCells(rs,cs,re,ce)
					end
				else
					Application^.Bing
			end
	end;


procedure TTDezMinus.Work;
	var cell : PCell;
	    x,y,
	    nnr,
	    rs,cs,
	    re,ce: integer;
	    vrnd,
	    eflg,
	    chg  : boolean;
	    s,ret: string;
	    pfm  : PFormat;
	    p    : PCalcWindow;

	procedure ChangeFormat(frm: integer);
		var q: integer;

		function DezMinus(t: string): string;
			var q,w,flg,nk,nk1: integer;

			begin
				DezMinus:=t;
				if length(t)=0 then exit;
				flg:=0;
				q:=1;
				while q<=length(t) do
					begin
						if t[q]='{' then flg:=1
						else
							if t[q]='}' then flg:=0
							else
								if t[q]='|' then
									if flg=1 then
										begin
											w:=q+1;
											nk:=0;
											nk1:=0;
											eflg:=false;
											while w<=length(t) do
												begin
													if t[w]='0' then
														begin
															nk:=w;
															if nk1=0 then nk1:=nk
														end
													else
														if (t[w]='}') then break
														else
															if t[w]='E' then
																begin
																	eflg:=true;
																	break
																end;
													inc(w)
												end;
											if nk>0 then
												begin
													if nk1=nk then
														begin
															if eflg then t:=StrPLeft(t,q)+StrPRight(t,length(t)-nk)
															else
																begin
																	t:=StrPLeft(t,q-1)+StrPRight(t,length(t)-nk);
																	dec(q)
																end
														end
													else
														t:=StrPLeft(t,nk-1)+StrPRight(t,length(t)-nk);
													DezMinus:=t;
													chg:=true
												end
										end;
						inc(q)
					end
			end;

		begin
			if frm<=0 then exit;
			if frm>=1000 then pfm:=PFormat(p^.UsrFormats^.At(frm-1000))
			else
				pfm:=PFormat(TexelApp.Formats^.At(frm));
			s:=pfm^.Name^;
			ret:='';
			chg:=false;
			q:=pos(';',s);
			while q>0 do
				begin
					ret:=ret+DezMinus(StrPLeft(s,q-1))+';';
					s:=StrPRight(s,length(s)-q);
					q:=pos(';',s);
				end;
			ret:=ret+DezMinus(s);
			if chg then
				begin
					nnr:=0;
					if p^.UsrFormats^.Count>0 then
						for q:=0 to p^.UsrFormats^.Count-1 do
							if PFormat(p^.UsrFormats^.At(q))^.Name^=ret then
								begin
									nnr:=PFormat(p^.UsrFormats^.At(q))^.Index;
									break
								end;
					if nnr=0 then
						if TexelApp.Formats^.Count>0 then
							for q:=0 to TexelApp.Formats^.Count-1 do
								if PFormat(TexelApp.Formats^.At(q))^.Name^=ret then
									begin
										nnr:=PFormat(TexelApp.Formats^.At(q))^.Index;
										break
									end;
					if nnr=0 then nnr:=p^.NewNumFormat(ret);
					cell^.Format:=nnr;
					vrnd:=true
				end
		end;

	begin
		vrnd:=false;
		p:=PCalcWindow(Parent);
		with p^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							rs:=RowStart;
							re:=RowEnd;
							cs:=ColStart;
							ce:=ColEnd
						end
					else
						begin
							rs:=Row;
							re:=Row;
							cs:=Col;
							ce:=Col
						end;
				for y:=rs to re do
					begin
						cell:=GetCell(y,cs);
						for x:=cs to ce do
							begin
								if cell^.Typ=CTYPE_FORMULA then
									with cell^.Data.Formula^ do
										begin
											if FPts>0 then
												begin
													dec(Fpts);
													vrnd:=true
												end
										end
								else
									if cell^.Typ=CTYPE_CONST then
										with cell^.Data.Konst^ do
											if FPts>0 then
												begin
													dec(Fpts);
													vrnd:=true
												end;
								ChangeFormat(cell^.Format);
								inc(longint(cell),CELLSIZE)
							end
					end;
				if vrnd then
					begin
						SetDirty;
						DrawCells(rs,cs,re,ce)
					end
				else
					Application^.Bing
			end
	end;


function TBorderBox.TestIndex(AnIndx: integer): boolean;

	begin
		if AnIndx=ObjAddr^.ob_head then
			begin
				TestIndex:=true;
				exit
			end;
		TestIndex:=inherited TestIndex(AnIndx)
	end;


procedure TBorderBox.Changed(AnIndx: integer; DblClick: boolean);

	begin
		if AnIndx=ObjAddr^.ob_head then AnIndx:=ObjIndx;
		inherited Changed(AnIndx,DblClick)
	end;


procedure TBorderBox.SetValue(Sel: integer);
	var p: PTree;

	begin
		p:=Application^.GetAddr(RTICONS);
		PCalcWindow(Parent)^.DlgTree^[ObjAddr^.ob_head].ob_spec.bit_blk^.bi_pdata:=p^[p^[RTIRAHMEN].ob_head+Sel].ob_spec.bit_blk^.bi_pdata;
		Paint
	end;


procedure TBorderBox.Work;

	begin
		with PCalcWindow(Parent)^ do
			begin
				if Attr.Status<>ws_Open then exit;
				case GetSelection of
				0:
					SetBorder(0,White,0,White,0,White,0,White,0,White,0,White,-1,0);
				1:
					SetBorder(-1,0,-1,0,-1,0,2,Black,-1,0,-1,0,-1,0);
				2:
					SetBorder(2,Black,-1,0,-1,0,-1,0,-1,0,-1,0,-1,0);
				3:
					SetBorder(-1,0,2,Black,-1,0,-1,0,-1,0,-1,0,-1,0);
				4:
					SetBorder(-1,0,-1,0,-1,0,5,Black,-1,0,-1,0,-1,0);
				5:
					SetBorder(-1,0,-1,0,-1,0,3,Black,-1,0,-1,0,-1,0);
				6:
					SetBorder(-1,0,-1,0,2,Black,2,Black,-1,0,-1,0,-1,0);
				7:
					SetBorder(-1,0,-1,0,2,Black,5,Black,-1,0,-1,0,-1,0);
				8:
					SetBorder(-1,0,-1,0,2,Black,3,Black,-1,0,-1,0,-1,0);
				9:
					SetBorder(2,Black,2,Black,2,Black,2,Black,-1,0,-1,0,-1,0);
				10:
					SetBorder(-1,0,-1,0,-1,0,-1,0,-1,0,-1,0,2,Black);
				11:
					SetBorder(-1,0,-1,0,-1,0,-1,0,-1,0,-1,0,3,Black)
				end
			end
	end;


function TColorBox.TestIndex(AnIndx: integer): boolean;

	begin
		if ObjAddr^.ob_head>0 then
			if AnIndx=ObjAddr^.ob_head then
				begin
					TestIndex:=true;
					exit
				end;
		TestIndex:=inherited TestIndex(AnIndx)
	end;


procedure TColorBox.Changed(AnIndx: integer; DblClick: boolean);

	begin
		if ObjAddr^.ob_head>0 then
			if AnIndx=ObjAddr^.ob_head then AnIndx:=ObjIndx;
		inherited Changed(AnIndx,DblClick)
	end;


procedure TColorBox.SetValue(Sel: integer);

	begin
		with ObjAddr^ do
			if (ob_spec.index and $0f)<>Sel then
				begin
					ob_spec.index:=(ob_spec.index and $fffffff0) or Sel;
					Paint
				end
	end;


procedure TColorBox.Work;

	begin
		if PWindow(Parent)^.GetClassName<>TEXELWINDCLASS then exit;
		PCalcWindow(Parent)^.SetCellColor(GetSelection)
	end;


procedure TTextColorBox.Work;

	begin
		PCalcWindow(Parent)^.SetTextColor(GetSelection)
	end;


procedure TDirectionBox.SetValue(Sel: integer);
	var ch: longint;

	begin
		case Sel of
		0,8:
			ch:=47;
		1:
			ch:=1;
		2,6:
			ch:=92;
		3:
			ch:=4;
		5:
			ch:=3;
		7:
			ch:=2
		else
			ch:=45
		end;
		with ObjAddr^ do
			begin
				ob_spec.index:=(ob_spec.index and $00ffffff) or (ch shl 24);
				Paint
			end
	end;


function TPatternBox.TestIndex(AnIndx: integer): boolean;

	begin
		if AnIndx=ObjAddr^.ob_head then TestIndex:=true
		else
			TestIndex:=inherited TestIndex(AnIndx)
	end;


procedure TPatternBox.Changed(AnIndx: integer; DblClick: boolean);

	begin
		if AnIndx=ObjAddr^.ob_head then AnIndx:=ObjIndx;
		inherited Changed(AnIndx,DblClick)
	end;


procedure TPatternBox.SetValue(Sel: integer);

	begin
		with ObjAddr^ do
			if ((ob_spec.index shr 4) and $07)<>Sel then
				begin
					ob_spec.index:=(ob_spec.index and $ffffff8f) or (Sel shl 4);
					Paint
				end
	end;


procedure TPatternBox.Work;
	var x,y,st,
	    oldint,
	    inter : integer;
	    cell  : PCell;

	begin
		if Parent^.Attr.Status<>ws_Open then exit;
		st:=GetSelection;
		if st=0 then
			begin
				st:=8;
				inter:=FIS_HOLLOW
			end
		else
			begin
				if st=7 then st:=8;
				inter:=FIS_PATTERN
			end;
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							for y:=RowStart to RowEnd do
								begin
									cell:=GetCell(y,ColStart);
									for x:=ColStart to ColEnd do
										begin
											cell^.Interior:=inter;
											cell^.Style:=st;
											if inter=FIS_HOLLOW then cell^.Color:=Black;
											inc(longint(cell),CELLSIZE)
										end
								end;
							DrawCells(RowStart,ColStart,RowEnd,ColEnd)
						end
					else
						begin
							cell:=GetCell(Row,Col);
							oldint:=cell^.Interior;
							cell^.Interior:=inter;
							cell^.Style:=st;
							if inter=FIS_HOLLOW then cell^.Color:=Black;
							DrawCells(Row,Col,Row,Col);
							if pcbox<>nil then
								begin
									if inter=FIS_HOLLOW then pcbox^.SetSelection(0,false)
									else
										if oldint=FIS_HOLLOW then pcbox^.SetSelection(1,false)
								end
						end;
				SetDirty
			end
	end;


procedure TCellProtect.Work;
	var x,y : integer;
	    cell: PCell;

	begin
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							for y:=RowStart to RowEnd do
								begin
									cell:=GetCell(y,ColStart);
									for x:=ColStart to ColEnd do
										begin
											cell^.Flags:=cell^.Flags or CELL_PROTECTED;
											inc(longint(cell),CELLSIZE)
										end
								end;
							DrawCells(RowStart,ColStart,RowEnd,ColEnd)
						end
					else
						begin
							cell:=GetCell(Row,Col);
							cell^.Flags:=cell^.Flags or CELL_PROTECTED;
							DrawCells(Row,Col,Row,Col)
						end;
				SetDirty
			end
	end;


procedure TCellUnprotect.Work;
	var x,y : integer;
	    cell: PCell;

	begin
		with PCalcWindow(Parent)^ do
			begin
				with Parms.Cursor do
					if Block then
						begin
							for y:=RowStart to RowEnd do
								begin
									cell:=GetCell(y,ColStart);
									for x:=ColStart to ColEnd do
										begin
											cell^.Flags:=cell^.Flags and not(CELL_PROTECTED);
											inc(longint(cell),CELLSIZE)
										end
								end;
							DrawCells(RowStart,ColStart,RowEnd,ColEnd)
						end
					else
						begin
							cell:=GetCell(Row,Col);
							cell^.Flags:=cell^.Flags and not(CELL_PROTECTED);
							DrawCells(Row,Col,Row,Col)
						end;
				SetDirty
			end
	end;


procedure TPercentBox.Work;
	var prc: integer;
	    txt: string;
	    p  : PCalcWindow;
	    x,y: longint;
	    fak: real;

	begin
		p:=PCalcWindow(Parent);
		x:=p^.Scroller^.XPos;
		y:=p^.Scroller^.YPos;
		fak:=1.0/p^.PercentSize;
		txt:=StrPTrimF(GetText);
		prc:=atol(StrPLeft(txt,length(txt)-1));
		p^.SetPercentSize(prc);
		fak:=fak*p^.PercentSize;
		p^.Scroller^.TrackMode:=false;
		p^.Scroller^.ScrollTo(round(x*fak),round(y*fak));
		p^.Scroller^.TrackMode:=true
	end;


begin
	TexelApp.Init(TEXELNAME);
	TexelApp.Run;
	TexelApp.Done
end.